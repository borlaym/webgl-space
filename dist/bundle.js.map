{"version":3,"sources":["webpack:///bundle.js","webpack:///webpack/bootstrap e62b9b5a1e2a90d7a848","webpack:///./scripts/index.js","webpack:///./~/three/build/three.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","init","relativeX","relativeY","scene","_three2","Scene","camera","PerspectiveCamera","window","innerWidth","innerHeight","spaceTexture","ImageUtils","loadTexture","redMaterial","MeshLambertMaterial","color","side","DoubleSide","transparent","spaceMaterial","MeshBasicMaterial","map","loader","load","geometry","mat","scale","x","y","z","rotateY","Math","PI","mesh","Mesh","add","sphere","SphereGeometry","background","ambient","AmbientLight","light","SpotLight","position","set","renderer","WebGLRenderer","setSize","document","body","appendChild","domElement","addEventListener","e","screenWidth","screenHeight","offsetX","offsetY","clientX","clientY","animate","now","Date","d","timestamp","requestAnimationFrame","rotation","TURN_SPEED","render","_three","JSONLoader","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","THREE","REVISION","undefined","Number","EPSILON","pow","sign","Function","prototype","name","Object","defineProperty","get","this","toString","match","assign","target","TypeError","output","index","arguments","length","source","nextKey","hasOwnProperty","MOUSE","LEFT","MIDDLE","RIGHT","CullFaceNone","CullFaceBack","CullFaceFront","CullFaceFrontBack","FrontFaceDirectionCW","FrontFaceDirectionCCW","BasicShadowMap","PCFShadowMap","PCFSoftShadowMap","FrontSide","BackSide","FlatShading","SmoothShading","NoColors","FaceColors","VertexColors","NoBlending","NormalBlending","AdditiveBlending","SubtractiveBlending","MultiplyBlending","CustomBlending","AddEquation","SubtractEquation","ReverseSubtractEquation","MinEquation","MaxEquation","ZeroFactor","OneFactor","SrcColorFactor","OneMinusSrcColorFactor","SrcAlphaFactor","OneMinusSrcAlphaFactor","DstAlphaFactor","OneMinusDstAlphaFactor","DstColorFactor","OneMinusDstColorFactor","SrcAlphaSaturateFactor","NeverDepth","AlwaysDepth","LessDepth","LessEqualDepth","EqualDepth","GreaterEqualDepth","GreaterDepth","NotEqualDepth","MultiplyOperation","MixOperation","AddOperation","NoToneMapping","LinearToneMapping","ReinhardToneMapping","Uncharted2ToneMapping","CineonToneMapping","UVMapping","CubeReflectionMapping","CubeRefractionMapping","EquirectangularReflectionMapping","EquirectangularRefractionMapping","SphericalReflectionMapping","CubeUVReflectionMapping","CubeUVRefractionMapping","RepeatWrapping","ClampToEdgeWrapping","MirroredRepeatWrapping","NearestFilter","NearestMipMapNearestFilter","NearestMipMapLinearFilter","LinearFilter","LinearMipMapNearestFilter","LinearMipMapLinearFilter","UnsignedByteType","ByteType","ShortType","UnsignedShortType","IntType","UnsignedIntType","FloatType","HalfFloatType","UnsignedShort4444Type","UnsignedShort5551Type","UnsignedShort565Type","AlphaFormat","RGBFormat","RGBAFormat","LuminanceFormat","LuminanceAlphaFormat","RGBEFormat","DepthFormat","RGB_S3TC_DXT1_Format","RGBA_S3TC_DXT1_Format","RGBA_S3TC_DXT3_Format","RGBA_S3TC_DXT5_Format","RGB_PVRTC_4BPPV1_Format","RGB_PVRTC_2BPPV1_Format","RGBA_PVRTC_4BPPV1_Format","RGBA_PVRTC_2BPPV1_Format","RGB_ETC1_Format","LoopOnce","LoopRepeat","LoopPingPong","InterpolateDiscrete","InterpolateLinear","InterpolateSmooth","ZeroCurvatureEnding","ZeroSlopeEnding","WrapAroundEnding","TrianglesDrawMode","TriangleStripDrawMode","TriangleFanDrawMode","LinearEncoding","sRGBEncoding","GammaEncoding","RGBEEncoding","LogLuvEncoding","RGBM7Encoding","RGBM16Encoding","RGBDEncoding","BasicDepthPacking","RGBADepthPacking","Color","r","g","b","setRGB","constructor","value","copy","setHex","setStyle","setScalar","scalar","hex","floor","setHSL","hue2rgb","q","t","h","s","l","euclideanModulo","clamp","style","handleAlpha","string","parseFloat","console","warn","exec","components","min","parseInt","size","charAt","ColorKeywords","clone","copyGammaToLinear","gammaFactor","copyLinearToGamma","safeInverse","convertGammaToLinear","convertLinearToGamma","sqrt","getHex","getHexString","slice","getHSL","optionalTarget","hue","saturation","hsl","max","lightness","delta","getStyle","offsetHSL","addColors","color1","color2","addScalar","multiply","multiplyScalar","lerp","alpha","equals","fromArray","array","offset","toArray","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","Quaternion","w","_x","_y","_z","_w","onChangeCallback","quaternion","setFromEuler","euler","update","Euler","Error","c1","cos","c2","c3","s1","sin","s2","s3","order","setFromAxisAngle","axis","angle","halfAngle","setFromRotationMatrix","te","elements","m11","m12","m13","m21","m22","m23","m31","m32","m33","trace","setFromUnitVectors","v1","EPS","vFrom","vTo","Vector3","dot","abs","crossVectors","normalize","inverse","conjugate","v","lengthSq","multiplyQuaternions","premultiply","a","qax","qay","qaz","qaw","qbx","qby","qbz","qbw","slerp","qb","cosHalfTheta","sinHalfTheta","halfTheta","atan2","ratioA","ratioB","onChange","callback","qa","qm","slerpFlat","dst","dstOffset","src0","srcOffset0","src1","srcOffset1","x0","y0","z0","w0","x1","y1","z1","w1","dir","sqrSin","len","tDir","f","Vector2","width","height","setX","setY","setComponent","getComponent","addVectors","addScaledVector","sub","subVectors","subScalar","isFinite","divide","divideScalar","clampScalar","minVal","maxVal","clampLength","ceil","round","roundToZero","negate","lengthManhattan","distanceTo","distanceToSquared","dx","dy","setLength","lerpVectors","v2","fromAttribute","attribute","itemSize","rotateAround","center","setZ","multiplyVectors","applyEuler","error","applyQuaternion","applyAxisAngle","applyMatrix3","applyMatrix4","applyProjection","qx","qy","qz","qw","ix","iy","iz","iw","project","matrix","Matrix4","multiplyMatrices","projectionMatrix","getInverse","matrixWorld","unproject","transformDirection","cross","ax","ay","az","bx","by","bz","projectOnVector","vector","projectOnPlane","planeNormal","reflect","normal","angleTo","theta","acos","dz","setFromSpherical","sinPhiRadius","phi","radius","setFromMatrixPosition","setFromMatrixColumn","setFromMatrixScale","sx","sy","sz","temp","Vector4","setW","setAxisAngleFromQuaternion","setAxisAngleFromRotationMatrix","epsilon","epsilon2","xx","yy","zz","xy","xz","yz","_order","DefaultOrder","RotationOrders","asin","setFromQuaternion","makeRotationFromQuaternion","setFromVector3","reorder","newOrder","toVector3","optionalResult","Line3","start","end","line","result","distanceSq","distance","at","closestPointToPointParameter","startP","startEnd","point","clampToLine","startEnd2","startEnd_startP","closestPointToPoint","Box2","Infinity","setFromPoints","points","makeEmpty","i","il","expandByPoint","setFromCenterAndSize","halfSize","box","isEmpty","expandByVector","expandByScalar","containsPoint","containsBox","getParameter","intersectsBox","clampPoint","distanceToPoint","clampedPoint","intersect","union","translate","Box3","setFromArray","minX","minY","minZ","maxX","maxY","maxZ","setFromObject","object","scope","updateMatrixWorld","traverse","node","Geometry","vertices","BufferGeometry","attributes","positions","intersectsSphere","closestPoint","intersectsPlane","plane","constant","getBoundingSphere","Sphere","Matrix3","Float32Array","n11","n12","n13","n21","n22","n23","n31","n32","n33","identity","me","setFromMatrix4","applyToVector3Array","j","applyToBuffer","buffer","getX","getY","getZ","setXYZ","determinant","throwOnDegenerate","t11","t12","t13","det","msg","detInv","transpose","tmp","flattenToArrayOffset","getNormalMatrix","matrix4","transposeIntoArray","n14","n24","n34","n41","n42","n43","n44","copyPosition","extractBasis","xAxis","yAxis","zAxis","makeBasis","extractRotation","scaleX","scaleY","scaleZ","makeRotationFromEuler","ae","af","be","bf","ce","cf","de","df","ac","ad","bc","bd","x2","y2","z2","wx","wy","wz","lookAt","eye","up","n","a11","a12","a13","a14","a21","a22","a23","a24","a31","a32","a33","a34","a41","a42","a43","a44","b11","b12","b13","b14","b21","b22","b23","b24","b31","b32","b33","b34","b41","b42","b43","b44","multiplyToArray","getPosition","setPosition","t14","getMaxScaleOnAxis","scaleXSq","scaleYSq","scaleZSq","makeTranslation","makeRotationX","makeRotationY","makeRotationZ","makeRotationAxis","tx","ty","makeScale","compose","decompose","invSX","invSY","invSZ","makeFrustum","left","right","bottom","top","near","far","makePerspective","fov","aspect","ymax","DEG2RAD","ymin","xmin","xmax","makeOrthographic","Ray","origin","direction","ray","recast","directionDistance","distanceSqToPoint","distanceSqToSegment","segCenter","segDir","diff","v0","optionalPointOnRay","optionalPointOnSegment","s0","sqrDist","extDet","segExtent","a01","b0","b1","invDet","intersectSphere","tca","d2","radius2","thc","t0","t1","distanceToPlane","denominator","intersectPlane","distToPoint","intersectBox","tmin","tmax","tymin","tymax","tzmin","tzmax","invdirx","invdiry","invdirz","intersectTriangle","edge1","edge2","backfaceCulling","DdN","DdQxE2","DdE1xQ","QdN","optionalCenter","maxRadiusSq","empty","radiusSum","deltaLengthSq","getBoundingBox","Frustum","p0","p1","p2","p3","p4","p5","planes","Plane","frustum","setFromMatrix","me0","me1","me2","me3","me4","me5","me6","me7","me8","me9","me10","me11","me12","me13","me14","me15","setComponents","intersectsObject","boundingSphere","computeBoundingSphere","intersectsSprite","sprite","negRadius","d1","setFromNormalAndCoplanarPoint","setFromCoplanarPoints","inverseNormalLength","distanceToSphere","projectPoint","orthoPoint","perpendicularMagnitude","intersectLine","intersectsLine","startSign","endSign","coplanarPoint","m1","optionalNormalMatrix","referencePoint","normalMatrix","Spherical","other","makeSafe","vec3","RAD2DEG","generateUUID","chars","split","uuid","Array","rnd","random","join","mapLinear","a1","a2","b2","smoothstep","smootherstep","random16","randInt","low","high","randFloat","randFloatSpread","range","degToRad","degrees","radToDeg","radians","isPowerOfTwo","nearestPowerOfTwo","log","LN2","nextPowerOfTwo","Spline","interpolate","t2","t3","intPoint","weight","w2","w3","pa","pb","pc","pd","v3","initFromArray","getPoint","k","getControlPointsArray","coords","getLength","nSubDivisions","nSamples","oldIntPoint","oldPosition","tmpVec","chunkLengths","totalLength","chunks","total","reparametrizeByArcLength","samplingCoef","indexCurrent","indexNext","realDistance","sampling","newpoints","sl","push","Triangle","resultLengthSq","barycoordFromPoint","dot00","dot01","dot02","dot11","dot12","denom","invDenom","u","setFromPointsAndIndices","i0","i1","i2","triangle","area","midpoint","edgeList","projectedPoint","minDistance","Interpolant","parameterPositions","sampleValues","sampleSize","resultBuffer","_cachedIndex","valueSize","evaluate","pp","validate_interval","seek","linear_scan","forward_scan","giveUpAt","afterEnd_","t1global","beforeStart_","mid","intervalChanged_","interpolate_","settings","DefaultSettings_","getSettings_","copySampleValue_","values","stride","CubicInterpolant","_weightPrev","_offsetPrev","_weightNext","_offsetNext","create","endingStart","endingEnd","iPrev","iNext","tPrev","tNext","halfDt","o1","o0","oP","oN","wP","wN","ppp","sP","sN","DiscreteInterpolant","LinearInterpolant","offset1","offset0","weight1","weight0","QuaternionLinearInterpolant","Clock","autoStart","startTime","oldTime","elapsedTime","running","performance","stop","getElapsedTime","getDelta","newTime","EventDispatcher","type","listener","_listeners","listeners","indexOf","hasEventListener","removeEventListener","listenerArray","splice","dispatchEvent","event","Layers","mask","channel","enable","toggle","disable","test","layers","ascSort","intersectObject","raycaster","intersects","recursive","visible","raycast","children","Raycaster","params","Line","LOD","Points","threshold","Sprite","defineProperties","PointCloud","linePrecision","setFromCamera","OrthographicCamera","sort","intersectObjects","objects","isArray","Object3D","onRotationChange","onQuaternionChange","Object3DIdCount","parent","DefaultUp","enumerable","modelViewMatrix","matrixAutoUpdate","DefaultMatrixAutoUpdate","matrixWorldNeedsUpdate","castShadow","receiveShadow","frustumCulled","renderOrder","userData","applyMatrix","setRotationFromAxisAngle","setRotationFromEuler","setRotationFromMatrix","setRotationFromQuaternion","rotateOnAxis","q1","rotateX","rotateZ","translateOnAxis","translateX","translateY","translateZ","localToWorld","worldToLocal","remove","getObjectById","getObjectByProperty","getObjectByName","child","getWorldPosition","getWorldQuaternion","getWorldRotation","getWorldScale","getWorldDirection","traverseVisible","traverseAncestors","updateMatrix","force","toJSON","meta","extractFromCache","cache","key","data","metadata","isRootObject","geometries","materials","textures","images","version","generator","JSON","stringify","material","parse","Face3","materialIndex","vertexNormals","vertexColors","BufferAttribute","normalized","dynamic","updateRange","count","needsUpdate","setDynamic","copyAt","index1","index2","copyArray","copyColorsArray","colors","copyIndicesArray","indices","copyVector2sArray","vectors","copyVector3sArray","copyVector4sArray","getW","setXY","setXYZW","Int8Attribute","Int8Array","Uint8Attribute","Uint8Array","Uint8ClampedAttribute","Uint8ClampedArray","Int16Attribute","Int16Array","Uint16Attribute","Uint16Array","Int32Attribute","Int32Array","Uint32Attribute","Uint32Array","Float32Attribute","Float64Attribute","Float64Array","DynamicBufferAttribute","InstancedBufferAttribute","meshPerAttribute","InterleavedBuffer","InstancedInterleavedBuffer","InterleavedBufferAttribute","interleavedBuffer","GeometryIdCount","faces","faceVertexUvs","morphTargets","morphNormals","skinWeights","skinIndices","lineDistances","boundingBox","verticesNeedUpdate","elementsNeedUpdate","uvsNeedUpdate","normalsNeedUpdate","colorsNeedUpdate","lineDistancesNeedUpdate","groupsNeedUpdate","vertex","face","jl","computeBoundingBox","fromBufferGeometry","addFace","normals","tempNormals","uvs","tempUVs","uvs2","tempUVs2","uv","uv2","groups","group","computeFaceNormals","cb","ab","fl","vA","vB","vC","computeVertexNormals","areaWeighted","vl","computeMorphNormals","__originalFaceNormal","__originalVertexNormals","tmpGeo","faceNormals","faceNormal","dstNormalsFace","dstNormalsVertex","computeTangents","computeLineDistances","merge","materialIndexOffset","vertexOffset","vertices1","vertices2","faces1","faces2","uvs1","vertexCopy","faceCopy","faceVertexNormals","faceVertexColors","uvCopy","mergeMesh","mergeVertices","verticesMap","unique","changes","precisionPoints","precision","faceIndicesToRemove","dupIndex","idx","sortFacesByMaterialIndex","materialIndexSort","_id","newUvs1","newUvs2","setBit","enabled","getNormalIndex","hash","normalsHash","getColorIndex","colorsHash","getUvIndex","uvsHash","parameters","hasMaterial","hasFaceUv","hasFaceVertexUv","hasFaceNormal","hasFaceVertexNormal","hasFaceColor","hasFaceVertexColor","faceType","uvsCopy","kl","dispose","DirectGeometry","computeGroups","fromGeometry","morphTargetsPosition","hasFaceVertexUv2","morphTargetsLength","morphTargetsNormal","morphNormalsLength","hasSkinIndices","hasSkinWeights","vertexUvs","morphTarget","morphNormal","morphAttributes","drawRange","getIndex","setIndex","addAttribute","getAttribute","removeAttribute","addGroup","clearGroups","setDrawRange","updateFromObject","direct","__directGeometry","lineDistance","fromDirectGeometry","TypeArray","isNaN","pA","pB","pC","normalizeNormals","attribute1","attributeArray1","attribute2","attributeArray2","attributeSize","toNonIndexed","geometry2","array2","MaxIndex","InstancedBufferGeometry","maxInstancedCount","instances","Uniform","onUpdate","onUpdateCallback","AnimationAction","_new","mixer","clip","localRoot","_mixer","_clip","_localRoot","tracks","nTracks","interpolants","interpolantSettings","interpolant","createInterpolant","_interpolantSettings","_interpolants","_propertyBindings","_cacheIndex","_byClipCacheIndex","_timeScaleInterpolant","_weightInterpolant","loop","_loopCount","_startTime","time","timeScale","_effectiveTimeScale","_effectiveWeight","repetitions","paused","clampWhenFinished","zeroSlopeAtStart","zeroSlopeAtEnd","play","_activateAction","_deactivateAction","reset","stopFading","stopWarping","isRunning","_isActiveAction","isScheduled","startAt","setLoop","mode","setEffectiveWeight","getEffectiveWeight","fadeIn","duration","_scheduleFading","fadeOut","crossFadeFrom","fadeOutAction","warp","fadeInDuration","fadeOutDuration","startEndRatio","endStartRatio","crossFadeTo","fadeInAction","weightInterpolant","_takeBackControlInterpolant","setEffectiveTimeScale","getEffectiveTimeScale","setDuration","syncWith","action","halt","startTimeScale","endTimeScale","_lendControlInterpolant","times","timeScaleInterpolant","getMixer","getClip","getRoot","_root","_update","deltaTime","timeDirection","accuIndex","timeRunning","_updateTimeScale","clipTime","_updateTime","_updateWeight","propertyMixers","accumulate","interpolantValue","loopCount","_setEndings","handle_stop","pingPong","loopDelta","pending","atStart","atEnd","weightNow","weightThen","AnimationClip","resetDuration","trim","optimize","track","json","jsonTracks","frameTime","fps","KeyframeTrack","clipTracks","CreateFromMorphTargetSequence","morphTargetSequence","noLoop","numMorphTargets","AnimationUtils","getKeyframeOrder","sortedArray","NumberKeyframeTrack","findByName","objectOrClipArray","clipArray","o","animations","CreateClipsFromMorphTargetSequences","animationToMorphTargets","pattern","parts","animationMorphTargets","clips","parseAnimation","animation","bones","nodeName","addNonemptyTrack","trackType","trackName","animationKeys","propertyName","destTracks","flattenJSON","clipName","hierarchyTracks","hierarchy","keys","morphTargetNames","morphTargetName","animationKey","boneName","VectorKeyframeTrack","QuaternionKeyframeTrack","AnimationMixer","root","_initMemoryManager","_accuIndex","clipAction","optionalRoot","rootUuid","clipObject","clipUuid","actionsForClip","_actionsByClip","prototypeAction","existingAction","actionByRoot","knownActions","newAction","_Action","_bindAction","_addInactiveAction","stopAllAction","actions","_actions","nActions","_nActiveActions","bindings","_bindings","nBindings","_nActiveBindings","useCount","apply","uncacheClip","actionsByClip","actionsToRemove","cacheIndex","lastInactiveAction","pop","_removeInactiveBindingsForAction","uncacheRoot","_removeInactiveAction","bindingsByRoot","_bindingsByRootAndName","bindingByName","binding","restoreOriginalState","_removeInactiveBinding","uncacheAction","bindingsByName","referenceCount","_addInactiveBinding","path","parsedPath","PropertyMixer","PropertyBinding","ValueTypeName","getValueSize","_lendBinding","saveOriginalState","_lendAction","_takeBackBinding","_takeBackAction","_controlInterpolants","_nActiveControlInterpolants","stats","inUse","controlInterpolants","knownActionsForClip","lastKnownAction","byClipCacheIndex","prevIndex","lastActiveIndex","firstInactiveAction","firstInactiveIndex","lastActiveAction","propBinding","rootNode","lastInactiveBinding","remove_empty_map","_","firstInactiveBinding","lastActiveBinding","_controlInterpolantsResultBuffer","__cacheIndex","lastActiveInterpolant","AnimationObjectGroup","var_args","_objects","nCachedObjects_","_indicesByUUID","_paths","_parsedPaths","_bindingsIndicesByPath","bindingsPerObject","nObjects","nCachedObjects","indicesByUUID","paths","parsedPaths","knownObject","firstActiveIndex","lastCachedObject","bindingsForPath","lastCached","lastCachedIndex","firstActiveObject","firstActive","uncache","lastIndex","lastObject","last","subscribe_","indicesByPath","unsubscribe_","lastBindingsIndex","lastBindings","lastBindingsPath","arraySlice","from","to","isTypedArray","subarray","convertArray","forceClone","BYTES_PER_ELEMENT","ArrayBuffer","isView","DataView","compareTime","nValues","srcOffset","jsonKeys","valuePropertyName","interpolation","TimeBufferType","ValueBufferType","setInterpolation","DefaultInterpolation","validate","InterpolantFactoryMethodDiscrete","InterpolantFactoryMethodLinear","InterpolantFactoryMethodSmooth","factoryMethod","message","getInterpolation","shift","timeOffset","endTime","nKeys","valid","prevTime","currTime","writeIndex","keep","timeNext","offsetP","offsetN","readOffset","writeOffset","_getTrackTypeForValueTypeName","typeName","toLowerCase","ColorKeyframeTrack","BooleanKeyframeTrack","StringKeyframeTrack","parseTrackName","findNode","getValue","targetArray","bind","setValue","sourceArray","targetObject","objectName","propertyIndex","_getValue_unavailable","_setValue_unavailable","objectIndex","skeleton","nodeProperty","versioning","Versioning","None","NeedsUpdate","MatrixWorldNeedsUpdate","bindingType","BindingType","Direct","ArrayElement","resolvedProperty","HasFromToArray","EntireArray","GetterByBindingType","SetterByBindingTypeAndVersioning","unbind","_getValue_unbound","_setValue_unbound","dest","Composite","targetGroup","optionalParsedPath","_targetGroup","firstValidIndex","re","matches","results","searchSkeleton","bone","searchNodeSubtree","childNode","subTreeNode","mixFunction","bufferType","_slerp","_select","_lerp","_mixBufferRegion","cumulativeWeight","currentWeight","mix","originalValueOffset","Audio","context","createBufferSource","onended","onEnded","gain","createGain","connect","getInput","autoplay","playbackRate","isPlaying","hasPlaybackControl","sourceType","filters","getOutput","setNodeSource","audioNode","setBuffer","audioBuffer","pause","currentTime","disconnect","getFilters","setFilters","getFilter","setFilter","filter","setPlaybackRate","getPlaybackRate","getLoop","getVolume","setVolume","AudioAnalyser","audio","fftSize","analyser","createAnalyser","frequencyBinCount","getFrequencyData","getByteFrequencyData","getAverageFrequency","AudioContext","webkitAudioContext","PositionalAudio","panner","createPanner","getRefDistance","refDistance","setRefDistance","getRolloffFactor","rolloffFactor","setRolloffFactor","getDistanceModel","distanceModel","setDistanceModel","getMaxDistance","maxDistance","setMaxDistance","AudioListener","destination","removeFilter","getMasterVolume","setMasterVolume","orientation","setOrientation","Camera","matrixWorldInverse","CubeCamera","cubeResolution","cameraPX","cameraNX","cameraPY","cameraNY","cameraPZ","cameraNZ","options","format","magFilter","minFilter","renderTarget","WebGLRenderTargetCube","updateCubeMap","generateMipmaps","texture","activeCubeFace","setRenderTarget","zoom","updateProjectionMatrix","cx","cy","focus","view","filmGauge","filmOffset","setFocalLength","focalLength","vExtentSlope","getFilmHeight","atan","getFocalLength","getEffectiveFOV","getFilmWidth","setViewOffset","fullWidth","fullHeight","clearViewOffset","skew","StereoCamera","cameraL","cameraR","eyeRight","eyeLeft","eyeSep","eyeSepOnProjection","Light","intensity","groundColor","decay","penumbra","LightShadow","bias","mapSize","DirectionalLight","shadow","DirectionalLightShadow","HemisphereLight","skyColor","PointLight","power","SpotLightShadow","AudioLoader","manager","DefaultLoadingManager","url","onLoad","onProgress","onError","XHRLoader","setResponseType","decodeAudioData","Cache","files","file","clear","Loader","onLoadStart","onLoadProgress","onLoadComplete","crossOrigin","extractUrlBase","initMaterials","texturePath","createMaterial","textureLoader","materialLoader","repeat","wrap","anisotropy","fullPath","Handlers","setCrossOrigin","wrapS","wrapT","TextureLoader","MaterialLoader","blending","specular","emissive","shininess","mapDiffuseRepeat","mapDiffuseOffset","mapDiffuseWrap","mapDiffuseAnisotropy","lightMap","mapLightRepeat","mapLightOffset","mapLightWrap","mapLightAnisotropy","aoMap","mapAORepeat","mapAOOffset","mapAOWrap","mapAOAnisotropy","bumpMap","mapBumpRepeat","mapBumpOffset","mapBumpWrap","mapBumpAnisotropy","bumpScale","normalMap","mapNormalRepeat","mapNormalOffset","mapNormalWrap","mapNormalAnisotropy","normalScale","specularMap","mapSpecularRepeat","mapSpecularOffset","mapSpecularWrap","mapSpecularAnisotropy","alphaMap","mapAlphaRepeat","mapAlphaOffset","mapAlphaWrap","mapAlphaAnisotropy","opacity","setTextures","handlers","regex","cached","setTimeout","request","XMLHttpRequest","overrideMimeType","open","response","status","itemEnd","itemError","responseType","withCredentials","send","itemStart","setPath","setWithCredentials","FontLoader","text","substring","font","Font","ImageLoader","image","createElement","src","statusDomElement","_statusDomElement","setTexturePath","parseModel","isBitSet","fi","zLength","colorIndex","normalIndex","uvIndex","isQuad","faceA","faceB","uvLayer","nUvLayers","parseSkin","influencesPerVertex","parseMorphing","dstVertices","srcVertices","morphColors","parseAnimations","outputAnimations","concat","morphAnimationClips","LoadingManager","isLoading","itemsLoaded","itemsTotal","onStart","BufferGeometryLoader","TYPED_ARRAYS","typedArray","drawcalls","offsets","getTexture","roughness","metalness","uniforms","vertexShader","fragmentShader","shading","alphaTest","depthTest","depthWrite","colorWrite","wireframe","wireframeLinewidth","sizeAttenuation","displacementMap","displacementScale","displacementBias","roughnessMap","metalnessMap","emissiveMap","emissiveIntensity","envMap","combine","reflectivity","lightMapIntensity","aoMapIntensity","ObjectLoader","lastIndexOf","parseGeometries","parseImages","parseTextures","parseMaterials","parseObject","geometryLoader","bufferGeometryLoader","widthSegments","heightSegments","depth","depthSegments","segments","thetaStart","thetaLength","radiusTop","radiusBottom","radialSegments","openEnded","phiStart","phiLength","detail","innerRadius","outerRadius","thetaSegments","phiSegments","tube","tubularSegments","arc","loadImage","parseConstant","Texture","mapping","getGeometry","getMaterial","SkinnedMesh","Group","levels","level","addLevel","CubeTextureLoader","urls","CubeTexture","DataTextureLoader","BinaryTextureLoader","_parser","DataTexture","texData","mipmaps","mipmapCount","CompressedTextureLoader","texDatas","CompressedTexture","isCubemap","Material","MaterialIdCount","fog","lights","blendSrc","blendDst","blendEquation","blendSrcAlpha","blendDstAlpha","blendEquationAlpha","depthFunc","clippingPlanes","clipShadows","polygonOffset","polygonOffsetFactor","polygonOffsetUnits","premultipliedAlpha","overdraw","_needsUpdate","setValues","newValue","currentValue","isRoot","srcPlanes","dstPlanes","LineBasicMaterial","linewidth","linecap","linejoin","LineDashedMaterial","dashSize","gapSize","refractionRatio","wireframeLinecap","wireframeLinejoin","skinning","MeshDepthMaterial","depthPacking","MeshNormalMaterial","MeshPhongMaterial","MeshStandardMaterial","defines","STANDARD","envMapIntensity","MeshPhysicalMaterial","PHYSICAL","MultiMaterial","PointsMaterial","ShaderMaterial","clipping","extensions","derivatives","fragDepth","drawBuffers","shaderTextureLOD","defaultAttributeValues","index0AttributeName","UniformsUtils","RawShaderMaterial","SpriteMaterial","ShadowMaterial","UniformsLib","ShaderChunk","encoding","TextureIdCount","sourceFile","DEFAULT_IMAGE","DEFAULT_MAPPING","premultiplyAlpha","flipY","unpackAlignment","getDataURL","canvas","toDataURL","getContext","drawImage","transformUv","DepthTexture","CanvasTexture","VideoTexture","video","readyState","HAVE_CURRENT_DATA","inverseMatrix","testPoint","rayPointDistanceSq","localThresholdSq","intersectPoint","distanceToRay","localThreshold","LineSegments","precisionSq","vStart","vEnd","interSegment","interRay","step","distSq","faceIndex","nbVertices","drawMode","updateMorphTargets","setDrawMode","morphTargetBase","morphTargetInfluences","morphTargetDictionary","ml","getMorphTargetIndexByName","uvIntersection","uv1","uv3","barycoord","checkIntersection","intersectionPointWorld","checkBufferGeometryIntersection","intersection","intersectionPoint","uvA","uvB","uvC","tempA","tempB","tempC","fvA","fvB","fvC","isFaceMaterial","faceMaterial","morphInfluences","tl","influence","targets","uvs_f","Bone","skin","Skeleton","boneInverses","useVertexTexture","identityMatrix","boneTextureWidth","boneTextureHeight","boneMatrices","boneTexture","calculateInverses","bl","pose","offsetMatrix","bindMode","bindMatrix","bindMatrixInverse","gbone","pos","rotq","scl","normalizeSkinWeights","sw","vec","skinWeight","getObjectForDistance","matrixPosition","guessSizeSq","LensFlare","lensFlares","positionScreen","customUpdateCallback","updateLensFlares","flare","vecX","vecY","wantedRotation","overrideMaterial","autoUpdate","Fog","FogExp2","density","merged","uniforms_src","uniforms_dst","parameter_src","common","diffuse","offsetRepeat","flipEnvMap","aomap","lightmap","emissivemap","bumpmap","normalmap","displacementmap","roughnessmap","metalnessmap","fogDensity","fogNear","fogFar","fogColor","ambientLightColor","directionalLights","properties","shadowBias","shadowRadius","shadowMapSize","directionalShadowMap","directionalShadowMatrix","spotLights","coneCos","penumbraCos","spotShadowMap","spotShadowMatrix","pointLights","pointShadowMap","pointShadowMatrix","hemisphereLights","ShaderLib","basic","lambert","phong","standard","dashed","totalSize","cube","tCube","tFlip","equirect","tEquirect","distanceRGBA","lightPos","getTargetPixelRatio","_currentRenderTarget","_pixelRatio","glClearColor","_premultipliedAlpha","state","clearColor","setDefaultGLState","scissor","_currentScissor","_scissor","viewport","_currentViewport","_viewport","_clearColor","_clearAlpha","resetGLState","_currentProgram","_currentCamera","_currentGeometryProgram","_currentMaterialId","onContextLost","preventDefault","onTextureDispose","deallocateTexture","_infoMemory","onRenderTargetDispose","deallocateRenderTarget","onMaterialDispose","deallocateMaterial","textureProperties","__image__webglTextureCube","_gl","deleteTexture","__webglInit","__webglTexture","renderTargetProperties","depthTexture","deleteFramebuffer","__webglFramebuffer","__webglDepthbuffer","deleteRenderbuffer","releaseMaterialProgramReference","programInfo","program","programCache","releaseProgram","setupVertexAttributes","startIndex","extension","initAttributes","geometryAttributes","programAttributes","getAttributes","materialDefaultAttributeValues","programAttribute","geometryAttribute","FLOAT","UNSIGNED_SHORT","SHORT","UNSIGNED_INT","INT","BYTE","UNSIGNED_BYTE","getAttributeBuffer","enableAttributeAndDivisor","enableAttribute","bindBuffer","ARRAY_BUFFER","vertexAttribPointer","vertexAttrib2fv","vertexAttrib3fv","vertexAttrib4fv","vertexAttrib1fv","disableUnusedAttributes","absNumericalSort","painterSortStable","reversePainterSortStable","pushRenderItem","transparentObjects","transparentObjectsLastIndex","opaqueObjects","opaqueObjectsLastIndex","renderItem","_vector3","isObjectViewable","_sphere","isSphereViewable","isSpriteViewable","_frustum","numPlanes","_clipping","_this","negRad","projectObject","sprites","ImmediateRenderObject","sortObjects","_projScreenMatrix","groupMaterial","renderObjects","renderList","setMaterial","setProgram","renderBufferImmediate","renderBufferDirect","initMaterial","materialProperties","getParameters","_lights","code","getProgramCode","programChange","shaderID","shader","__webglShader","acquireProgram","numSupportedMorphTargets","maxMorphTargets","numSupportedMorphNormals","maxMorphNormals","numClippingPlanes","uniform","lightsHash","directional","spot","hemi","progUniforms","getUniforms","uniformsList","WebGLUniforms","seqWithValue","seq","dynamicUniforms","splitDynamic","CULL_FACE","setFlipSided","setBlending","setDepthFunc","setDepthTest","setDepthWrite","setColorWrite","setPolygonOffset","_usedTextureUnits","_clippingEnabled","_localClippingEnabled","useCache","setState","refreshProgram","refreshMaterial","refreshLights","p_uniforms","m_uniforms","useProgram","capabilities","logarithmicDepthBuffer","uCamPos","cameraPosition","setOptional","floatVertexTextures","markUniformsLightsNeedsUpdate","refreshUniformsFog","refreshUniformsCommon","refreshUniformsLine","refreshUniformsDash","refreshUniformsPoints","refreshUniformsLambert","refreshUniformsPhong","refreshUniformsPhysical","refreshUniformsStandard","upload","dynUniforms","evalDynamic","uvScaleMap","WebGLRenderTarget","_canvas","clientHeight","setupShadows","lightShadowsLength","shadows","setupLights","ll","shadowMap","viewMatrix","directionalLength","pointLength","spotLength","hemiLength","lightCache","allocTextureUnit","textureUnit","maxTextures","setTextureParameters","textureType","isPowerOfTwoImage","texParameteri","TEXTURE_WRAP_S","paramThreeToGL","TEXTURE_WRAP_T","TEXTURE_MAG_FILTER","TEXTURE_MIN_FILTER","CLAMP_TO_EDGE","filterFallback","__currentAnisotropy","texParameterf","TEXTURE_MAX_ANISOTROPY_EXT","getMaxAnisotropy","uploadTexture","slot","createTexture","activeTexture","TEXTURE0","bindTexture","TEXTURE_2D","pixelStorei","UNPACK_FLIP_Y_WEBGL","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_ALIGNMENT","clampToMaxSize","maxTextureSize","textureNeedsPowerOfTwo","makePowerOfTwo","glFormat","glType","mipmap","internalFormat","DEPTH_COMPONENT","_isWebGL2","DEPTH_COMPONENT32F","DEPTH_COMPONENT16","texImage2D","getCompressedTextureFormats","compressedTexImage2D","generateMipmap","__version","setTexture2D","complete","maxSize","HTMLImageElement","HTMLCanvasElement","setTextureCube","TEXTURE_CUBE_MAP","isCompressed","isDataTexture","cubeImage","autoScaleCubemaps","maxCubemapSize","TEXTURE_CUBE_MAP_POSITIVE_X","setTextureCubeDynamic","setupFrameBufferTexture","framebuffer","attachment","textureTarget","bindFramebuffer","FRAMEBUFFER","framebufferTexture2D","setupRenderBufferStorage","renderbuffer","bindRenderbuffer","RENDERBUFFER","depthBuffer","stencilBuffer","renderbufferStorage","framebufferRenderbuffer","DEPTH_ATTACHMENT","DEPTH_STENCIL","DEPTH_STENCIL_ATTACHMENT","RGBA4","setupDepthTexture","isCube","webglDepthTexture","setupDepthRenderbuffer","createRenderbuffer","setupRenderTarget","isTargetPowerOfTwo","createFramebuffer","COLOR_ATTACHMENT0","updateRenderTargetMipmap","NEAREST","LINEAR","REPEAT","MIRRORED_REPEAT","NEAREST_MIPMAP_NEAREST","NEAREST_MIPMAP_LINEAR","LINEAR_MIPMAP_NEAREST","LINEAR_MIPMAP_LINEAR","UNSIGNED_SHORT_4_4_4_4","UNSIGNED_SHORT_5_5_5_1","UNSIGNED_SHORT_5_6_5","HALF_FLOAT_OES","ALPHA","RGB","RGBA","LUMINANCE","LUMINANCE_ALPHA","FUNC_ADD","FUNC_SUBTRACT","FUNC_REVERSE_SUBTRACT","ZERO","ONE","SRC_COLOR","ONE_MINUS_SRC_COLOR","SRC_ALPHA","ONE_MINUS_SRC_ALPHA","DST_ALPHA","ONE_MINUS_DST_ALPHA","DST_COLOR","ONE_MINUS_DST_COLOR","SRC_ALPHA_SATURATE","COMPRESSED_RGB_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT1_EXT","COMPRESSED_RGBA_S3TC_DXT3_EXT","COMPRESSED_RGBA_S3TC_DXT5_EXT","COMPRESSED_RGB_PVRTC_4BPPV1_IMG","COMPRESSED_RGB_PVRTC_2BPPV1_IMG","COMPRESSED_RGBA_PVRTC_4BPPV1_IMG","COMPRESSED_RGBA_PVRTC_2BPPV1_IMG","COMPRESSED_RGB_ETC1_WEBGL","MIN_EXT","MAX_EXT","_context","_alpha","_depth","_stencil","stencil","_antialias","antialias","_preserveDrawingBuffer","preserveDrawingBuffer","autoClear","autoClearColor","autoClearDepth","autoClearStencil","localClippingEnabled","gammaInput","gammaOutput","physicallyCorrectLights","toneMapping","toneMappingExposure","toneMappingWhitePoint","_currentFramebuffer","_currentScissorTest","_width","_height","_scissorTest","WebGLClipping","_infoRender","calls","info","memory","programs","getShaderPrecisionFormat","rangeMin","rangeMax","WebGL2RenderingContext","WebGLExtensions","WebGLCapabilities","WebGLState","WebGLProperties","WebGLObjects","WebGLPrograms","WebGLLights","bufferRenderer","WebGLBufferRenderer","indexedBufferRenderer","WebGLIndexedBufferRenderer","WebGLShadowMap","spritePlugin","SpritePlugin","lensFlarePlugin","LensFlarePlugin","getContextAttributes","forceContextLoss","loseContext","MAX_TEXTURE_MAX_ANISOTROPY_EXT","getPrecision","getPixelRatio","setPixelRatio","getSize","updateStyle","setViewport","setScissor","setScissorTest","boolean","getClearColor","setClearColor","getClearAlpha","setClearAlpha","bits","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","STENCIL_BUFFER_BIT","clearDepth","clearStencil","clearTarget","buffers","hasPositions","createBuffer","hasNormals","hasUvs","hasColors","bufferData","positionArray","DYNAMIC_DRAW","normalArray","nx","ny","nz","uvArray","colorArray","drawArrays","TRIANGLES","updateBuffers","geometryProgram","activeInfluences","getWireframeAttribute","ELEMENT_ARRAY_BUFFER","dataStart","dataCount","rangeStart","rangeCount","groupStart","groupCount","drawStart","drawEnd","drawCount","setLineWidth","setMode","LINES","TRIANGLE_STRIP","TRIANGLE_FAN","lineWidth","LINE_STRIP","POINTS","renderInstances","forceClear","beginShadows","endShadows","setFaceCulling","cullFace","frontFaceDirection","setCullFace","warned","setTexture","getCurrentRenderTarget","scissorTest","activeMipMapLevel","readRenderTargetPixels","restore","IMPLEMENTATION_COLOR_READ_FORMAT","IMPLEMENTATION_COLOR_READ_TYPE","checkFramebufferStatus","FRAMEBUFFER_COMPLETE","readPixels","drawArraysInstancedANGLE","resetGlobalState","globalState","numGlobalPlanes","projectPlanes","skipTransform","nPlanes","dstArray","flatSize","viewNormalMatrix","i4","renderingShadows","enableLocalClipping","fromCache","nGlobal","lGlobal","clippingState","drawElements","drawElementsInstancedANGLE","gl","getExtension","getMaxPrecision","VERTEX_SHADER","HIGH_FLOAT","FRAGMENT_SHADER","MEDIUM_FLOAT","MAX_TEXTURE_IMAGE_UNITS","maxVertexTextures","MAX_VERTEX_TEXTURE_IMAGE_UNITS","MAX_TEXTURE_SIZE","MAX_CUBE_MAP_TEXTURE_SIZE","maxAttributes","MAX_VERTEX_ATTRIBS","maxVertexUniforms","MAX_VERTEX_UNIFORM_VECTORS","maxVaryings","MAX_VARYING_VECTORS","maxFragmentUniforms","MAX_FRAGMENT_UNIFORM_VECTORS","vertexTextures","floatFragmentTextures","_maxPrecision","WebGLGeometries","onGeometryDispose","buffergeometry","_bufferGeometry","deleteAttribute","deleteAttributes","property","bufferproperty","__webglBuffer","deleteBuffer","removeAttributeBuffer","updateAttribute","attributeProperties","updateBuffer","usage","STATIC_DRAW","bufferSubData","edges","checkEdge","list","WebGLProgram","getEncodingComponents","getTexelDecodingFunction","functionName","getTexelEncodingFunction","getToneMappingFunction","toneMappingName","generateExtensions","rendererExtensions","envMapCubeUV","flatShading","filterEmptyLine","generateDefines","fetchAttributeLocations","identifiers","getProgramParameter","ACTIVE_ATTRIBUTES","getActiveAttrib","getAttribLocation","replaceLightNums","replace","numDirLights","numSpotLights","numPointLights","numHemiLights","parseIncludes","include","unrollLoops","snippet","unroll","programIdCount","shadowMapTypeDefine","shadowMapType","envMapTypeDefine","envMapModeDefine","envMapBlendingDefine","prefixVertex","prefixFragment","gammaFactorDefine","customExtensions","customDefines","createProgram","supportsVertexTextures","maxBones","doubleSided","flipSided","shadowMapEnabled","useFog","fogExp","outputEncoding","mapEncoding","envMapEncoding","emissiveMapEncoding","vertexGlsl","fragmentGlsl","glVertexShader","WebGLShader","glFragmentShader","attachShader","bindAttribLocation","linkProgram","programLog","getProgramInfoLog","vertexLog","getShaderInfoLog","fragmentLog","runnable","haveDiagnostics","LINK_STATUS","getError","VALIDATE_STATUS","diagnostics","prefix","deleteShader","cachedUniforms","cachedAttributes","destroy","deleteProgram","usedTimes","allocateBones","nVertexUniforms","nVertexMatrices","getTextureEncodingFromMap","gammaOverrideLinear","shaderIDs","parameterNames","nClipPlanes","currentRenderTarget","envMapMode","pl","addLineNumbers","lines","createShader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","_renderer","getDepthMaterial","isPointLight","lightPositionWorld","materialVariants","_depthMaterials","customMaterial","customDepthMaterial","_distanceMaterials","customDistanceMaterial","useMorphing","useSkinning","variantIndex","_MorphingFlag","_SkinningFlag","keyA","keyB","materialsForVariant","_materialCache","cachedMaterial","renderSingleSided","renderReverseSided","shadowCamera","_renderList","_state","_lightShadows","_shadowMapSize","_lookTarget","_lightPositionWorld","_NumberOfMaterialVariants","cubeDirections","cubeUps","cube2DViewPorts","depthMaterialTemplate","distanceShader","distanceUniforms","depthMaterial","distanceMaterial","USE_SHADOWMAP","BLEND","faceCount","vpWidth","vpHeight","pars","shadowMatrix","vpDimensions","clearAlpha","WebGLColorBuffer","WebGLDepthBuffer","WebGLStencilBuffer","maxVertexAttributes","newAttributes","enabledAttributes","attributeDivisors","compressedTextureFormats","currentBlending","currentBlendEquation","currentBlendSrc","currentBlendDst","currentBlendEquationAlpha","currentBlendSrcAlpha","currentBlendDstAlpha","currentPremultipledAlpha","currentFlipSided","currentCullFace","currentLineWidth","currentPolygonOffsetFactor","currentPolygonOffsetUnits","currentScissorTest","currentTextureSlot","currentBoundTextures","currentScissor","currentViewport","emptyTextures","DEPTH_TEST","enableVertexAttribArray","vertexAttribDivisorANGLE","disableVertexAttribArray","formats","COMPRESSED_TEXTURE_FORMATS","blendEquationSeparate","blendFuncSeparate","blendFunc","setMask","setTest","setFunc","setStencilTest","stencilTest","setStencilWrite","stencilWrite","setStencilFunc","stencilFunc","stencilRef","stencilMask","setStencilOp","stencilFail","stencilZFail","stencilZPass","setOp","frontFace","CW","CCW","BACK","FRONT","FRONT_AND_BACK","factor","units","POLYGON_OFFSET_FILL","getScissorTest","SCISSOR_TEST","webglSlot","webglType","webglTexture","boundTexture","setClear","locked","currentColorMask","currentColorClear","colorMask","setLocked","lock","currentDepthMask","currentDepthFunc","currentDepthClear","depthMask","NEVER","ALWAYS","LESS","LEQUAL","EQUAL","GEQUAL","GREATER","NOTEQUAL","currentStencilMask","currentStencilFunc","currentStencilRef","currentStencilFuncMask","currentStencilFail","currentStencilZFail","currentStencilZPass","currentStencilClear","STENCIL_TEST","stencilOp","UniformContainer","arrayCacheF32","arrayCacheI32","flatten","nBlocks","blockSize","firstElem","allocTexUnits","setValue1f","uniform1f","addr","setValue1i","uniform1i","setValue2fv","uniform2fv","uniform2f","setValue3fv","uniform3f","uniform3fv","setValue4fv","uniform4fv","uniform4f","setValue2fm","uniformMatrix2fv","setValue3fm","uniformMatrix3fv","setValue4fm","uniformMatrix4fv","setValueT1","unit","setValueT6","setValue2iv","uniform2iv","setValue3iv","uniform3iv","setValue4iv","uniform4iv","getSingularSetter","setValue1fv","uniform1fv","setValue1iv","uniform1iv","setValueV2a","setValueV3a","setValueV4a","setValueM2a","setValueM3a","setValueM4a","setValueT1a","tex","setValueT6a","getPureArraySetter","SingleUniform","activeInfo","PureArrayUniform","StructuredUniform","RePathPart","addUniform","container","uniformObject","parseUniform","pathLength","matchEnd","idIsIndex","subscript","next","ACTIVE_UNIFORMS","getActiveUniform","getUniformLocation","flares","vertexBuffer","elementBuffer","tempTexture","occlusionTexture","renderType","occlusionMap","screenPosition","tempPosition","invAspect","halfViewportWidth","halfViewportHeight","screenPositionPixels","validArea","TEXTURE1","copyTexImage2D","uvOffset","uvScale","fogType","fillStyle","fillRect","spritePosition","spriteRotation","spriteScale","oldFogType","sceneFogType","Face4","LineStrip","LinePieces","MeshFaceMaterial","Particle","ParticleSystem","PointCloudMaterial","ParticleBasicMaterial","ParticleSystemMaterial","Vertex","isIntersectionBox","isIntersectionSphere","multiplyVector3","multiplyVector3Array","extractPosition","multiplyVector4","rotateAxis","crossVector","rotateByAxis","isIntersectionLine","isIntersectionPlane","setEulerFromRotationMatrix","setEulerFromQuaternion","getPositionFromMatrix","getScaleFromMatrix","getColumnFromMatrix","getChildByName","renderDepth","eulerOrder","useQuaternion","setLens","onlyShadow","shadowCameraFov","shadowCameraLeft","shadowCameraRight","shadowCameraTop","shadowCameraBottom","shadowCameraNear","shadowCameraFar","shadowCameraVisible","shadowDarkness","shadowMapWidth","shadowMapHeight","addIndex","addDrawCall","indexOffset","clearDrawCalls","computeOffsets","wrapAround","wrapRGB","metal","supportsFloatTextures","supportsHalfFloatTextures","supportsStandardDerivatives","supportsCompressedTextureS3TC","supportsCompressedTexturePVRTC","supportsBlendMinMax","supportsInstancedArrays","enableScissorTest","addPrePlugin","addPostPlugin","updateShadowMap","shadowMapCullFace","audioLoader","getData","GeometryUtils","geometry1","loadTextureCube","loadCompressedTexture","loadCompressedTextureCube","Projector","projectVector","unprojectVector","pickingRay","CanvasRenderer","CurveUtils","tangentQuadraticBezier","tangentCubicBezier","tangentSpline","h00","h10","h01","h11","SceneUtils","createMultiMaterialObject","detach","attach","ShapeUtils","contour","triangulate","snip","verts","px","py","aX","aY","bX","bY","cX","cY","apx","apy","bpx","bpy","cpx","cpy","cCROSSap","bCROSScp","aCROSSbp","vertIndices","nv","triangulateShape","holes","point_in_segment_2D_colin","inSegPt1","inSegPt2","inOtherPt","intersect_segments_2D","inSeg1Pt1","inSeg1Pt2","inSeg2Pt1","inSeg2Pt2","inExcludeAdjacentSegs","seg1dx","seg1dy","seg2dx","seg2dy","seg1seg2dx","seg1seg2dy","limit","perpSeg1","perpSeg2","factorSeg1","seg1Pt","seg2Pt","seg1min","seg1max","seg1minVal","seg1maxVal","seg2min","seg2max","seg2minVal","seg2maxVal","isPointInsideAngle","inVertex","inLegFromPt","inLegToPt","legFromPtX","legFromPtY","legToPtX","legToPtY","otherPtX","otherPtY","from2toAngle","from2otherAngle","other2toAngle","removeHoles","isCutLineInsideAngles","inShapeIdx","inHoleIdx","lastShapeIdx","shape","prevShapeIdx","nextShapeIdx","insideAngle","hole","lastHoleIdx","prevHoleIdx","nextHoleIdx","intersectsShapeEdge","inShapePt","inHolePt","sIdx","nextIdx","intersectsHoleEdge","ihIdx","chkHole","hIdx","indepHoles","holeIndex","shapeIndex","shapePt","holePt","holeIdx","cutKey","tmpShape1","tmpShape2","tmpHole1","tmpHole2","failedCuts","hl","minShapeIndex","counter","h2","allPointsMap","allpoints","shapeWithoutHoles","triangles","isClockWise","pts","b2p0","b2p1","b2p2","b3","b3p0","b3p1","b3p2","b3p3","Curve","getPointAt","getUtoTmapping","getPoints","divisions","getSpacedPoints","lengths","getLengths","cacheArcLengths","current","sum","updateArcLengths","targetArcLength","arcLengths","comparison","lengthBefore","lengthAfter","segmentLength","segmentFraction","getTangent","pt1","pt2","getTangentAt","getPointFunc","CurvePath","curves","autoClose","curve","closePath","startPoint","endPoint","LineCurve","curveLengths","getCurveLengths","lens","cacheLengths","sums","createPointsGeometry","createGeometry","createSpacedPointsGeometry","generateShapes","createPaths","String","resolution","ret","createPath","glyph","glyphs","cpx0","cpy0","cpx1","cpy1","cpx2","cpy2","laste","Path","outline","_cachedOutline","moveTo","lineTo","quadraticCurveTo","bezierCurveTo","ha","shapes","toShapes","fromPoints","args","lastargs","aCPx","aCPy","QuadraticBezierCurve","aCP1x","aCP1y","aCP2x","aCP2y","CubicBezierCurve","splineThru","npts","SplineCurve","aRadius","aStartAngle","aEndAngle","aClockwise","absarc","absellipse","ellipse","xRadius","yRadius","aRotation","EllipseCurve","lastPoint","item","spts","spline","deltaAngle","tdivisions","isCCW","noHoles","extractSubpaths","inActions","subPaths","lastPath","toShapesNoHoles","inSubpaths","tmpPath","tmpShape","Shape","isPointInsidePolygon","inPt","inPolygon","polyLen","inside","edgeLowPt","edgeHighPt","edgeDx","edgeDy","perpEdge","solid","holesFirst","tmpPoints","betterShapeHoles","newShapes","newShapeHoles","mainIdx","ambiguous","toChange","sLen","sho","ho","hole_unassigned","s2Idx","froms","tos","tmpHoles","extrude","ExtrudeGeometry","makeGeometry","ShapeGeometry","getPointsHoles","holesPts","extractAllPoints","extractPoints","tangent","point0","point1","point2","point3","ArcCurve","LineCurve3","QuadraticBezierCurve3","CubicBezierCurve3","SplineCurve3","CatmullRomCurve3","CubicPoly","pz","c0","initNonuniformCatmullRom","x3","dt0","dt1","dt2","initCatmullRom","tension","calc","closed","ClosedSplineCurve3","BoxGeometry","BoxBufferGeometry","CubeGeometry","calculateVertexCount","calculateIndexCount","buildPlane","udir","vdir","gridX","gridY","segmentWidth","segmentHeight","widthHalf","heightHalf","depthHalf","gridX1","gridY1","vertexCounter","vertexBufferOffset","uvBufferOffset","numberOfVertices","indexBufferOffset","vertexCount","indexCount","CircleGeometry","CircleBufferGeometry","ii","segment","CylinderBufferGeometry","nbCap","generateTorso","tanTheta","indexRow","halfHeight","indexArray","i3","generateCap","centerIndexStart","centerIndexEnd","cosTheta","sinTheta","CylinderGeometry","ConeBufferGeometry","ConeGeometry","EdgesGeometry","thresholdAngle","sortFunction","thresholdDot","edge","vert1","vert2","face1","face2","addShapeList","addShape","scalePt2","pt","getBevelVec","inPrev","inNext","v_trans_x","v_trans_y","shrink_by","v_prev_x","v_prev_y","v_next_x","v_next_y","v_prev_lensq","collinear0","v_prev_len","v_next_len","ptPrevShift_x","ptPrevShift_y","ptNextShift_x","ptNextShift_y","sf","v_trans_lensq","direction_eq","buildLidFaces","bevelEnabled","layer","vlen","flen","f3","steps","bevelSegments","buildSideFaces","layeroffset","sidewalls","ahole","slen1","slen2","f4","shapesOffset","uvgen","generateTopUV","wallContour","stepIndex","stepsLength","contourIndex1","contourIndex2","generateSideWallUV","extrudePts","splineTube","binormal","position2","amount","bevelThickness","bevelSize","curveSegments","extrudePath","extrudeByPath","UVGenerator","WorldUVGenerator","frames","TubeGeometry","FrenetFrames","shapePoints","reverse","bs","vert","contourMovements","oneHoleMovements","holesMovements","verticesMovements","binormals","indexA","indexB","indexC","indexD","LatheBufferGeometry","base","inverseSegments","n1","n2","LatheGeometry","PlaneGeometry","PlaneBufferGeometry","width_half","height_half","segment_width","segment_height","offset2","RingBufferGeometry","radiusStep","thetaSegmentLevel","RingGeometry","SphereBufferGeometry","thetaEnd","verticesRow","v4","TextGeometry","TorusBufferGeometry","TorusGeometry","TorusKnotBufferGeometry","calculatePositionOnCurve","cu","su","quOverP","cs","P1","P2","B","T","N","TorusKnotGeometry","heightScale","taper","NoTaper","ip","jp","uva","uvb","uvc","uvd","grid","numpoints","pos2","tangents","SinusoidalTaper","initialNormal3","smallest","MAX_VALUE","tz","PolyhedronGeometry","prepare","that","azimuth","inclination","make","centroid","azi","correctUV","subdivide","cols","aj","bj","rows","DodecahedronGeometry","IcosahedronGeometry","OctahedronGeometry","TetrahedronGeometry","ParametricGeometry","func","slices","stacks","sliceCount","WireframeGeometry","numEdges","ol","numTris","AxisHelper","ArrowHelper","lineGeometry","coneGeometry","headLength","headWidth","cone","setDirection","setColor","BoxHelper","BoundingBoxHelper","CameraHelper","addLine","addPoint","pointMap","hexFrustum","hexCone","hexUp","hexTarget","hexCross","setPoint","DirectionalLightHelper","lightPlane","targetLine","EdgesHelper","FaceNormalsHelper","nNormals","objGeometry","GridHelper","setColors","HemisphereLightHelper","sphereSize","lightSphere","PointLightHelper","SkeletonHelper","getBoneList","boneList","matrixWorldInv","boneMatrix","SpotLightHelper","vector2","coneLength","coneWidth","VertexNormalsHelper","objPos","objNorm","WireframeHelper","renderCallback","MorphBlendMesh","animationsMap","animationsList","numFrames","startFrame","endFrame","createAnimation","setAnimationWeight","lastFrame","currentFrame","active","directionBackwards","mirroredLoop","autoCreateAnimations","firstAnimation","frameRanges","morph","setAnimationDirectionForward","setAnimationDirectionBackward","setAnimationFPS","setAnimationDuration","setAnimationTime","getAnimationTime","getAnimationDuration","playAnimation","stopAnimation","keyframe"],"mappings":"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","file":"bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _three = __webpack_require__(1);\n\t\n\tvar _three2 = _interopRequireDefault(_three);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tvar TURN_SPEED = Math.PI / 8;\n\tvar scene, camera, renderer, spaceTexture;\n\tvar geometry, redMaterial, spaceMaterial, mesh, light, ambient, sphere, background;\n\tvar relativeX, relativeY;\n\tvar timestamp = new Date();\n\tvar loader = new _three2.default.JSONLoader();\n\t\n\tinit();\n\tanimate();\n\t\n\tfunction init() {\n\t\trelativeX = 0;\n\t\trelativeY = 0;\n\t\tscene = new _three2.default.Scene();\n\t\n\t\tcamera = new _three2.default.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.01, 10000);\n\t\tspaceTexture = _three2.default.ImageUtils.loadTexture('../textures/dark-space-texture.png');\n\t\tredMaterial = new _three2.default.MeshLambertMaterial({ color: 0x3f3f3f });\n\t\tredMaterial.side = _three2.default.DoubleSide;\n\t\tredMaterial.transparent = true;\n\t\n\t\tspaceMaterial = new _three2.default.MeshBasicMaterial();\n\t\tspaceMaterial.map = spaceTexture;\n\t\tspaceMaterial.side = _three2.default.DoubleSide;\n\t\n\t\tloader.load('../models/cockpit.js', function (geometry, mat) {\n\t\t\tgeometry.scale.x = 15;\n\t\t\tgeometry.scale.y = 15;\n\t\t\tgeometry.scale.z = 15;\n\t\t\tgeometry.rotateY(Math.PI / 2);\n\t\t\tmesh = new _three2.default.Mesh(geometry, redMaterial);\n\t\t\tscene.add(mesh);\n\t\t});\n\t\n\t\tsphere = new _three2.default.SphereGeometry(2000, 100, 100);\n\t\tbackground = new _three2.default.Mesh(sphere, spaceMaterial);\n\t\tscene.add(background);\n\t\n\t\tambient = new _three2.default.AmbientLight(0x404040);\n\t\tscene.add(ambient);\n\t\n\t\tlight = new _three2.default.SpotLight(0xffffff);\n\t\tlight.position.set(-20, 5, 5);\n\t\tscene.add(light);\n\t\n\t\trenderer = new _three2.default.WebGLRenderer();\n\t\trenderer.setSize(window.innerWidth, window.innerHeight);\n\t\n\t\tdocument.body.appendChild(renderer.domElement);\n\t\n\t\tdocument.body.addEventListener('mousemove', function (e) {\n\t\t\tvar x, y, screenWidth, screenHeight, offsetX, offsetY;\n\t\t\tx = e.clientX;\n\t\t\ty = e.clientY;\n\t\t\tscreenWidth = window.innerWidth;\n\t\t\tscreenHeight = window.innerHeight;\n\t\t\toffsetX = x - screenWidth / 2;\n\t\t\toffsetY = y - screenHeight / 2;\n\t\t\trelativeX = offsetX / (screenWidth / 2);\n\t\t\trelativeY = offsetY / (screenHeight / 2);\n\t\t});\n\t}\n\t\n\tfunction animate() {\n\t\tvar now = new Date();\n\t\tvar d = now - timestamp;\n\t\ttimestamp = now;\n\t\trequestAnimationFrame(animate);\n\t\tcamera.rotation.x -= relativeY * TURN_SPEED * d / 1000;\n\t\tcamera.rotation.y -= relativeX * TURN_SPEED * d / 1000;\n\t\tif (mesh) mesh.rotation.x = camera.rotation.x;\n\t\tif (mesh) mesh.rotation.y = camera.rotation.y;\n\t\trenderer.render(scene, camera);\n\t}\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;// File:src/Three.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tvar THREE = { REVISION: '77' };\r\n\t\r\n\t//\r\n\t\r\n\tif ( true ) {\r\n\t\r\n\t\t!(__WEBPACK_AMD_DEFINE_FACTORY__ = (THREE), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t\r\n\t} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {\r\n\t\r\n\t\tmodule.exports = THREE;\r\n\t\r\n\t}\r\n\t\r\n\t// Polyfills\r\n\t\r\n\tif ( Number.EPSILON === undefined ) {\r\n\t\r\n\t\tNumber.EPSILON = Math.pow( 2, - 52 );\r\n\t\r\n\t}\r\n\t\r\n\t//\r\n\t\r\n\tif ( Math.sign === undefined ) {\r\n\t\r\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\r\n\t\r\n\t\tMath.sign = function ( x ) {\r\n\t\r\n\t\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\r\n\t\r\n\t\t};\r\n\t\r\n\t}\r\n\t\r\n\tif ( Function.prototype.name === undefined ) {\r\n\t\r\n\t\t// Missing in IE9-11.\r\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\r\n\t\r\n\t\tObject.defineProperty( Function.prototype, 'name', {\r\n\t\r\n\t\t\tget: function () {\r\n\t\r\n\t\t\t\treturn this.toString().match( /^\\s*function\\s*(\\S*)\\s*\\(/ )[ 1 ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t} );\r\n\t\r\n\t}\r\n\t\r\n\tif ( Object.assign === undefined ) {\r\n\t\r\n\t\t// Missing in IE.\r\n\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\r\n\t\r\n\t\t( function () {\r\n\t\r\n\t\t\tObject.assign = function ( target ) {\r\n\t\r\n\t\t\t\t'use strict';\r\n\t\r\n\t\t\t\tif ( target === undefined || target === null ) {\r\n\t\r\n\t\t\t\t\tthrow new TypeError( 'Cannot convert undefined or null to object' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar output = Object( target );\r\n\t\r\n\t\t\t\tfor ( var index = 1; index < arguments.length; index ++ ) {\r\n\t\r\n\t\t\t\t\tvar source = arguments[ index ];\r\n\t\r\n\t\t\t\t\tif ( source !== undefined && source !== null ) {\r\n\t\r\n\t\t\t\t\t\tfor ( var nextKey in source ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {\r\n\t\r\n\t\t\t\t\t\t\t\toutput[ nextKey ] = source[ nextKey ];\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn output;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )();\r\n\t\r\n\t}\r\n\t\r\n\t//\r\n\t\r\n\tObject.assign( THREE, {\r\n\t\r\n\t\t// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button\r\n\t\r\n\t\tMOUSE: { LEFT: 0, MIDDLE: 1, RIGHT: 2 },\r\n\t\r\n\t\t// GL STATE CONSTANTS\r\n\t\r\n\t\tCullFaceNone: 0,\r\n\t\tCullFaceBack: 1,\r\n\t\tCullFaceFront: 2,\r\n\t\tCullFaceFrontBack: 3,\r\n\t\r\n\t\tFrontFaceDirectionCW: 0,\r\n\t\tFrontFaceDirectionCCW: 1,\r\n\t\r\n\t\t// SHADOWING TYPES\r\n\t\r\n\t\tBasicShadowMap: 0,\r\n\t\tPCFShadowMap: 1,\r\n\t\tPCFSoftShadowMap: 2,\r\n\t\r\n\t\t// MATERIAL CONSTANTS\r\n\t\r\n\t\t// side\r\n\t\r\n\t\tFrontSide: 0,\r\n\t\tBackSide: 1,\r\n\t\tDoubleSide: 2,\r\n\t\r\n\t\t// shading\r\n\t\r\n\t\tFlatShading: 1,\r\n\t\tSmoothShading: 2,\r\n\t\r\n\t\t// colors\r\n\t\r\n\t\tNoColors: 0,\r\n\t\tFaceColors: 1,\r\n\t\tVertexColors: 2,\r\n\t\r\n\t\t// blending modes\r\n\t\r\n\t\tNoBlending: 0,\r\n\t\tNormalBlending: 1,\r\n\t\tAdditiveBlending: 2,\r\n\t\tSubtractiveBlending: 3,\r\n\t\tMultiplyBlending: 4,\r\n\t\tCustomBlending: 5,\r\n\t\r\n\t\t// custom blending equations\r\n\t\t// (numbers start from 100 not to clash with other\r\n\t\t// mappings to OpenGL constants defined in Texture.js)\r\n\t\r\n\t\tAddEquation: 100,\r\n\t\tSubtractEquation: 101,\r\n\t\tReverseSubtractEquation: 102,\r\n\t\tMinEquation: 103,\r\n\t\tMaxEquation: 104,\r\n\t\r\n\t\t// custom blending destination factors\r\n\t\r\n\t\tZeroFactor: 200,\r\n\t\tOneFactor: 201,\r\n\t\tSrcColorFactor: 202,\r\n\t\tOneMinusSrcColorFactor: 203,\r\n\t\tSrcAlphaFactor: 204,\r\n\t\tOneMinusSrcAlphaFactor: 205,\r\n\t\tDstAlphaFactor: 206,\r\n\t\tOneMinusDstAlphaFactor: 207,\r\n\t\r\n\t\t// custom blending source factors\r\n\t\r\n\t\t//ZeroFactor: 200,\r\n\t\t//OneFactor: 201,\r\n\t\t//SrcAlphaFactor: 204,\r\n\t\t//OneMinusSrcAlphaFactor: 205,\r\n\t\t//DstAlphaFactor: 206,\r\n\t\t//OneMinusDstAlphaFactor: 207,\r\n\t\tDstColorFactor: 208,\r\n\t\tOneMinusDstColorFactor: 209,\r\n\t\tSrcAlphaSaturateFactor: 210,\r\n\t\r\n\t\t// depth modes\r\n\t\r\n\t\tNeverDepth: 0,\r\n\t\tAlwaysDepth: 1,\r\n\t\tLessDepth: 2,\r\n\t\tLessEqualDepth: 3,\r\n\t\tEqualDepth: 4,\r\n\t\tGreaterEqualDepth: 5,\r\n\t\tGreaterDepth: 6,\r\n\t\tNotEqualDepth: 7,\r\n\t\r\n\t\r\n\t\t// TEXTURE CONSTANTS\r\n\t\r\n\t\tMultiplyOperation: 0,\r\n\t\tMixOperation: 1,\r\n\t\tAddOperation: 2,\r\n\t\r\n\t\t// Tone Mapping modes\r\n\t\r\n\t\tNoToneMapping: 0, // do not do any tone mapping, not even exposure (required for special purpose passes.)\r\n\t\tLinearToneMapping: 1, // only apply exposure.\r\n\t\tReinhardToneMapping: 2,\r\n\t\tUncharted2ToneMapping: 3, // John Hable\r\n\t\tCineonToneMapping: 4, // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\r\n\t\r\n\t\t// Mapping modes\r\n\t\r\n\t\tUVMapping: 300,\r\n\t\r\n\t\tCubeReflectionMapping: 301,\r\n\t\tCubeRefractionMapping: 302,\r\n\t\r\n\t\tEquirectangularReflectionMapping: 303,\r\n\t\tEquirectangularRefractionMapping: 304,\r\n\t\r\n\t\tSphericalReflectionMapping: 305,\r\n\t\tCubeUVReflectionMapping: 306,\r\n\t\tCubeUVRefractionMapping: 307,\r\n\t\r\n\t\t// Wrapping modes\r\n\t\r\n\t\tRepeatWrapping: 1000,\r\n\t\tClampToEdgeWrapping: 1001,\r\n\t\tMirroredRepeatWrapping: 1002,\r\n\t\r\n\t\t// Filters\r\n\t\r\n\t\tNearestFilter: 1003,\r\n\t\tNearestMipMapNearestFilter: 1004,\r\n\t\tNearestMipMapLinearFilter: 1005,\r\n\t\tLinearFilter: 1006,\r\n\t\tLinearMipMapNearestFilter: 1007,\r\n\t\tLinearMipMapLinearFilter: 1008,\r\n\t\r\n\t\t// Data types\r\n\t\r\n\t\tUnsignedByteType: 1009,\r\n\t\tByteType: 1010,\r\n\t\tShortType: 1011,\r\n\t\tUnsignedShortType: 1012,\r\n\t\tIntType: 1013,\r\n\t\tUnsignedIntType: 1014,\r\n\t\tFloatType: 1015,\r\n\t\tHalfFloatType: 1025,\r\n\t\r\n\t\t// Pixel types\r\n\t\r\n\t\t//UnsignedByteType: 1009,\r\n\t\tUnsignedShort4444Type: 1016,\r\n\t\tUnsignedShort5551Type: 1017,\r\n\t\tUnsignedShort565Type: 1018,\r\n\t\r\n\t\t// Pixel formats\r\n\t\r\n\t\tAlphaFormat: 1019,\r\n\t\tRGBFormat: 1020,\r\n\t\tRGBAFormat: 1021,\r\n\t\tLuminanceFormat: 1022,\r\n\t\tLuminanceAlphaFormat: 1023,\r\n\t\t// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders\r\n\t\tRGBEFormat: THREE.RGBAFormat, //1024;\r\n\t\tDepthFormat: 1026,\r\n\t\r\n\t\t// DDS / ST3C Compressed texture formats\r\n\t\r\n\t\tRGB_S3TC_DXT1_Format: 2001,\r\n\t\tRGBA_S3TC_DXT1_Format: 2002,\r\n\t\tRGBA_S3TC_DXT3_Format: 2003,\r\n\t\tRGBA_S3TC_DXT5_Format: 2004,\r\n\t\r\n\t\t// PVRTC compressed texture formats\r\n\t\r\n\t\tRGB_PVRTC_4BPPV1_Format: 2100,\r\n\t\tRGB_PVRTC_2BPPV1_Format: 2101,\r\n\t\tRGBA_PVRTC_4BPPV1_Format: 2102,\r\n\t\tRGBA_PVRTC_2BPPV1_Format: 2103,\r\n\t\r\n\t\t// ETC compressed texture formats\r\n\t\r\n\t\tRGB_ETC1_Format: 2151,\r\n\t\r\n\t\t// Loop styles for AnimationAction\r\n\t\r\n\t\tLoopOnce: 2200,\r\n\t\tLoopRepeat: 2201,\r\n\t\tLoopPingPong: 2202,\r\n\t\r\n\t\t// Interpolation\r\n\t\r\n\t\tInterpolateDiscrete: 2300,\r\n\t\tInterpolateLinear: 2301,\r\n\t\tInterpolateSmooth: 2302,\r\n\t\r\n\t\t// Interpolant ending modes\r\n\t\r\n\t\tZeroCurvatureEnding: 2400,\r\n\t\tZeroSlopeEnding: 2401,\r\n\t\tWrapAroundEnding: 2402,\r\n\t\r\n\t\t// Triangle Draw modes\r\n\t\r\n\t\tTrianglesDrawMode: 0,\r\n\t\tTriangleStripDrawMode: 1,\r\n\t\tTriangleFanDrawMode: 2,\r\n\t\r\n\t\t// Texture Encodings\r\n\t\r\n\t\tLinearEncoding: 3000, // No encoding at all.\r\n\t\tsRGBEncoding: 3001,\r\n\t\tGammaEncoding: 3007, // uses GAMMA_FACTOR, for backwards compatibility with WebGLRenderer.gammaInput/gammaOutput\r\n\t\r\n\t\t// The following Texture Encodings are for RGB-only (no alpha) HDR light emission sources.\r\n\t\t// These encodings should not specified as output encodings except in rare situations.\r\n\t\tRGBEEncoding: 3002, // AKA Radiance.\r\n\t\tLogLuvEncoding: 3003,\r\n\t\tRGBM7Encoding: 3004,\r\n\t\tRGBM16Encoding: 3005,\r\n\t\tRGBDEncoding: 3006, // MaxRange is 256.\r\n\t\r\n\t\t// Depth packing strategies\r\n\t\r\n\t\tBasicDepthPacking: 3200, // for writing to float textures for high precision or for visualizing results in RGB buffers\r\n\t\tRGBADepthPacking: 3201 // for packing into RGBA buffers.\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/math/Color.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Color = function ( r, g, b ) {\r\n\t\r\n\t\tif ( g === undefined && b === undefined ) {\r\n\t\r\n\t\t\t// r is THREE.Color, hex or string\r\n\t\t\treturn this.set( r );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn this.setRGB( r, g, b );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Color.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Color,\r\n\t\r\n\t\tr: 1, g: 1, b: 1,\r\n\t\r\n\t\tset: function ( value ) {\r\n\t\r\n\t\t\tif ( value instanceof THREE.Color ) {\r\n\t\r\n\t\t\t\tthis.copy( value );\r\n\t\r\n\t\t\t} else if ( typeof value === 'number' ) {\r\n\t\r\n\t\t\t\tthis.setHex( value );\r\n\t\r\n\t\t\t} else if ( typeof value === 'string' ) {\r\n\t\r\n\t\t\t\tthis.setStyle( value );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetScalar: function ( scalar ) {\r\n\t\r\n\t\t\tthis.r = scalar;\r\n\t\t\tthis.g = scalar;\r\n\t\t\tthis.b = scalar;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetHex: function ( hex ) {\r\n\t\r\n\t\t\thex = Math.floor( hex );\r\n\t\r\n\t\t\tthis.r = ( hex >> 16 & 255 ) / 255;\r\n\t\t\tthis.g = ( hex >> 8 & 255 ) / 255;\r\n\t\t\tthis.b = ( hex & 255 ) / 255;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetRGB: function ( r, g, b ) {\r\n\t\r\n\t\t\tthis.r = r;\r\n\t\t\tthis.g = g;\r\n\t\t\tthis.b = b;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetHSL: function () {\r\n\t\r\n\t\t\tfunction hue2rgb( p, q, t ) {\r\n\t\r\n\t\t\t\tif ( t < 0 ) t += 1;\r\n\t\t\t\tif ( t > 1 ) t -= 1;\r\n\t\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\r\n\t\t\t\tif ( t < 1 / 2 ) return q;\r\n\t\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\r\n\t\t\t\treturn p;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn function ( h, s, l ) {\r\n\t\r\n\t\t\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\t\t\t\th = THREE.Math.euclideanModulo( h, 1 );\r\n\t\t\t\ts = THREE.Math.clamp( s, 0, 1 );\r\n\t\t\t\tl = THREE.Math.clamp( l, 0, 1 );\r\n\t\r\n\t\t\t\tif ( s === 0 ) {\r\n\t\r\n\t\t\t\t\tthis.r = this.g = this.b = l;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\r\n\t\t\t\t\tvar q = ( 2 * l ) - p;\r\n\t\r\n\t\t\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\r\n\t\t\t\t\tthis.g = hue2rgb( q, p, h );\r\n\t\t\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tsetStyle: function ( style ) {\r\n\t\r\n\t\t\tfunction handleAlpha( string ) {\r\n\t\r\n\t\t\t\tif ( string === undefined ) return;\r\n\t\r\n\t\t\t\tif ( parseFloat( string ) < 1 ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\tvar m;\r\n\t\r\n\t\t\tif ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\r\n\t\r\n\t\t\t\t// rgb / hsl\r\n\t\r\n\t\t\t\tvar color;\r\n\t\t\t\tvar name = m[ 1 ];\r\n\t\t\t\tvar components = m[ 2 ];\r\n\t\r\n\t\t\t\tswitch ( name ) {\r\n\t\r\n\t\t\t\t\tcase 'rgb':\r\n\t\t\t\t\tcase 'rgba':\r\n\t\r\n\t\t\t\t\t\tif ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\r\n\t\r\n\t\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\r\n\t\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\r\n\t\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\r\n\t\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\r\n\t\r\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\r\n\t\r\n\t\t\t\t\t\t\treturn this;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\r\n\t\r\n\t\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\r\n\t\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\r\n\t\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\r\n\t\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\r\n\t\r\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\r\n\t\r\n\t\t\t\t\t\t\treturn this;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'hsl':\r\n\t\t\t\t\tcase 'hsla':\r\n\t\r\n\t\t\t\t\t\tif ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\r\n\t\r\n\t\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\r\n\t\t\t\t\t\t\tvar h = parseFloat( color[ 1 ] ) / 360;\r\n\t\t\t\t\t\t\tvar s = parseInt( color[ 2 ], 10 ) / 100;\r\n\t\t\t\t\t\t\tvar l = parseInt( color[ 3 ], 10 ) / 100;\r\n\t\r\n\t\t\t\t\t\t\thandleAlpha( color[ 5 ] );\r\n\t\r\n\t\t\t\t\t\t\treturn this.setHSL( h, s, l );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\r\n\t\r\n\t\t\t\t// hex color\r\n\t\r\n\t\t\t\tvar hex = m[ 1 ];\r\n\t\t\t\tvar size = hex.length;\r\n\t\r\n\t\t\t\tif ( size === 3 ) {\r\n\t\r\n\t\t\t\t\t// #ff0\r\n\t\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\r\n\t\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\r\n\t\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\r\n\t\r\n\t\t\t\t\treturn this;\r\n\t\r\n\t\t\t\t} else if ( size === 6 ) {\r\n\t\r\n\t\t\t\t\t// #ff0000\r\n\t\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\r\n\t\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\r\n\t\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\r\n\t\r\n\t\t\t\t\treturn this;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( style && style.length > 0 ) {\r\n\t\r\n\t\t\t\t// color keywords\r\n\t\t\t\tvar hex = THREE.ColorKeywords[ style ];\r\n\t\r\n\t\t\t\tif ( hex !== undefined ) {\r\n\t\r\n\t\t\t\t\t// red\r\n\t\t\t\t\tthis.setHex( hex );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// unknown color\r\n\t\t\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor( this.r, this.g, this.b );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( color ) {\r\n\t\r\n\t\t\tthis.r = color.r;\r\n\t\t\tthis.g = color.g;\r\n\t\t\tthis.b = color.b;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyGammaToLinear: function ( color, gammaFactor ) {\r\n\t\r\n\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\r\n\t\r\n\t\t\tthis.r = Math.pow( color.r, gammaFactor );\r\n\t\t\tthis.g = Math.pow( color.g, gammaFactor );\r\n\t\t\tthis.b = Math.pow( color.b, gammaFactor );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyLinearToGamma: function ( color, gammaFactor ) {\r\n\t\r\n\t\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\r\n\t\r\n\t\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\r\n\t\r\n\t\t\tthis.r = Math.pow( color.r, safeInverse );\r\n\t\t\tthis.g = Math.pow( color.g, safeInverse );\r\n\t\t\tthis.b = Math.pow( color.b, safeInverse );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tconvertGammaToLinear: function () {\r\n\t\r\n\t\t\tvar r = this.r, g = this.g, b = this.b;\r\n\t\r\n\t\t\tthis.r = r * r;\r\n\t\t\tthis.g = g * g;\r\n\t\t\tthis.b = b * b;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tconvertLinearToGamma: function () {\r\n\t\r\n\t\t\tthis.r = Math.sqrt( this.r );\r\n\t\t\tthis.g = Math.sqrt( this.g );\r\n\t\t\tthis.b = Math.sqrt( this.b );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetHex: function () {\r\n\t\r\n\t\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetHexString: function () {\r\n\t\r\n\t\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetHSL: function ( optionalTarget ) {\r\n\t\r\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\t\r\n\t\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\r\n\t\r\n\t\t\tvar r = this.r, g = this.g, b = this.b;\r\n\t\r\n\t\t\tvar max = Math.max( r, g, b );\r\n\t\t\tvar min = Math.min( r, g, b );\r\n\t\r\n\t\t\tvar hue, saturation;\r\n\t\t\tvar lightness = ( min + max ) / 2.0;\r\n\t\r\n\t\t\tif ( min === max ) {\r\n\t\r\n\t\t\t\thue = 0;\r\n\t\t\t\tsaturation = 0;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tvar delta = max - min;\r\n\t\r\n\t\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\r\n\t\r\n\t\t\t\tswitch ( max ) {\r\n\t\r\n\t\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\r\n\t\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\r\n\t\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\thue /= 6;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\thsl.h = hue;\r\n\t\t\thsl.s = saturation;\r\n\t\t\thsl.l = lightness;\r\n\t\r\n\t\t\treturn hsl;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetStyle: function () {\r\n\t\r\n\t\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\r\n\t\r\n\t\t},\r\n\t\r\n\t\toffsetHSL: function ( h, s, l ) {\r\n\t\r\n\t\t\tvar hsl = this.getHSL();\r\n\t\r\n\t\t\thsl.h += h; hsl.s += s; hsl.l += l;\r\n\t\r\n\t\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tadd: function ( color ) {\r\n\t\r\n\t\t\tthis.r += color.r;\r\n\t\t\tthis.g += color.g;\r\n\t\t\tthis.b += color.b;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddColors: function ( color1, color2 ) {\r\n\t\r\n\t\t\tthis.r = color1.r + color2.r;\r\n\t\t\tthis.g = color1.g + color2.g;\r\n\t\t\tthis.b = color1.b + color2.b;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.r += s;\r\n\t\t\tthis.g += s;\r\n\t\t\tthis.b += s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiply: function ( color ) {\r\n\t\r\n\t\t\tthis.r *= color.r;\r\n\t\t\tthis.g *= color.g;\r\n\t\t\tthis.b *= color.b;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.r *= s;\r\n\t\t\tthis.g *= s;\r\n\t\t\tthis.b *= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerp: function ( color, alpha ) {\r\n\t\r\n\t\t\tthis.r += ( color.r - this.r ) * alpha;\r\n\t\t\tthis.g += ( color.g - this.g ) * alpha;\r\n\t\t\tthis.b += ( color.b - this.b ) * alpha;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( c ) {\r\n\t\r\n\t\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis.r = array[ offset ];\r\n\t\t\tthis.g = array[ offset + 1 ];\r\n\t\t\tthis.b = array[ offset + 2 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tarray[ offset ] = this.r;\r\n\t\t\tarray[ offset + 1 ] = this.g;\r\n\t\t\tarray[ offset + 2 ] = this.b;\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\r\n\t'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\r\n\t'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\r\n\t'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\r\n\t'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\r\n\t'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\r\n\t'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\r\n\t'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\r\n\t'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\r\n\t'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\r\n\t'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\r\n\t'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\r\n\t'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\r\n\t'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\r\n\t'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\r\n\t'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\r\n\t'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\r\n\t'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\r\n\t'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\r\n\t'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\r\n\t'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\r\n\t'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\r\n\t'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\r\n\t'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\r\n\t\r\n\t// File:src/math/Quaternion.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t * @author bhouston / http://clara.io\r\n\t */\r\n\t\r\n\tTHREE.Quaternion = function ( x, y, z, w ) {\r\n\t\r\n\t\tthis._x = x || 0;\r\n\t\tthis._y = y || 0;\r\n\t\tthis._z = z || 0;\r\n\t\tthis._w = ( w !== undefined ) ? w : 1;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Quaternion.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Quaternion,\r\n\t\r\n\t\tget x () {\r\n\t\r\n\t\t\treturn this._x;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset x ( value ) {\r\n\t\r\n\t\t\tthis._x = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget y () {\r\n\t\r\n\t\t\treturn this._y;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset y ( value ) {\r\n\t\r\n\t\t\tthis._y = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget z () {\r\n\t\r\n\t\t\treturn this._z;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset z ( value ) {\r\n\t\r\n\t\t\tthis._z = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget w () {\r\n\t\r\n\t\t\treturn this._w;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset w ( value ) {\r\n\t\r\n\t\t\tthis._w = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset: function ( x, y, z, w ) {\r\n\t\r\n\t\t\tthis._x = x;\r\n\t\t\tthis._y = y;\r\n\t\t\tthis._z = z;\r\n\t\t\tthis._w = w;\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( quaternion ) {\r\n\t\r\n\t\t\tthis._x = quaternion.x;\r\n\t\t\tthis._y = quaternion.y;\r\n\t\t\tthis._z = quaternion.z;\r\n\t\t\tthis._w = quaternion.w;\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromEuler: function ( euler, update ) {\r\n\t\r\n\t\t\tif ( euler instanceof THREE.Euler === false ) {\r\n\t\r\n\t\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\r\n\t\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\r\n\t\t\t//\tcontent/SpinCalc.m\r\n\t\r\n\t\t\tvar c1 = Math.cos( euler._x / 2 );\r\n\t\t\tvar c2 = Math.cos( euler._y / 2 );\r\n\t\t\tvar c3 = Math.cos( euler._z / 2 );\r\n\t\t\tvar s1 = Math.sin( euler._x / 2 );\r\n\t\t\tvar s2 = Math.sin( euler._y / 2 );\r\n\t\t\tvar s3 = Math.sin( euler._z / 2 );\r\n\t\r\n\t\t\tvar order = euler.order;\r\n\t\r\n\t\t\tif ( order === 'XYZ' ) {\r\n\t\r\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\t\r\n\t\t\t} else if ( order === 'YXZ' ) {\r\n\t\r\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\t\r\n\t\t\t} else if ( order === 'ZXY' ) {\r\n\t\r\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\t\r\n\t\t\t} else if ( order === 'ZYX' ) {\r\n\t\r\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\t\r\n\t\t\t} else if ( order === 'YZX' ) {\r\n\t\r\n\t\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\t\r\n\t\t\t} else if ( order === 'XZY' ) {\r\n\t\r\n\t\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( update !== false ) this.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromAxisAngle: function ( axis, angle ) {\r\n\t\r\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\r\n\t\r\n\t\t\t// assumes axis is normalized\r\n\t\r\n\t\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\r\n\t\r\n\t\t\tthis._x = axis.x * s;\r\n\t\t\tthis._y = axis.y * s;\r\n\t\t\tthis._z = axis.z * s;\r\n\t\t\tthis._w = Math.cos( halfAngle );\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromRotationMatrix: function ( m ) {\r\n\t\r\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n\t\r\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\t\r\n\t\t\tvar te = m.elements,\r\n\t\r\n\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\r\n\t\r\n\t\t\t\ttrace = m11 + m22 + m33,\r\n\t\t\t\ts;\r\n\t\r\n\t\t\tif ( trace > 0 ) {\r\n\t\r\n\t\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\r\n\t\r\n\t\t\t\tthis._w = 0.25 / s;\r\n\t\t\t\tthis._x = ( m32 - m23 ) * s;\r\n\t\t\t\tthis._y = ( m13 - m31 ) * s;\r\n\t\t\t\tthis._z = ( m21 - m12 ) * s;\r\n\t\r\n\t\t\t} else if ( m11 > m22 && m11 > m33 ) {\r\n\t\r\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\r\n\t\r\n\t\t\t\tthis._w = ( m32 - m23 ) / s;\r\n\t\t\t\tthis._x = 0.25 * s;\r\n\t\t\t\tthis._y = ( m12 + m21 ) / s;\r\n\t\t\t\tthis._z = ( m13 + m31 ) / s;\r\n\t\r\n\t\t\t} else if ( m22 > m33 ) {\r\n\t\r\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\r\n\t\r\n\t\t\t\tthis._w = ( m13 - m31 ) / s;\r\n\t\t\t\tthis._x = ( m12 + m21 ) / s;\r\n\t\t\t\tthis._y = 0.25 * s;\r\n\t\t\t\tthis._z = ( m23 + m32 ) / s;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\r\n\t\r\n\t\t\t\tthis._w = ( m21 - m12 ) / s;\r\n\t\t\t\tthis._x = ( m13 + m31 ) / s;\r\n\t\t\t\tthis._y = ( m23 + m32 ) / s;\r\n\t\t\t\tthis._z = 0.25 * s;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromUnitVectors: function () {\r\n\t\r\n\t\t\t// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\r\n\t\r\n\t\t\t// assumes direction vectors vFrom and vTo are normalized\r\n\t\r\n\t\t\tvar v1, r;\r\n\t\r\n\t\t\tvar EPS = 0.000001;\r\n\t\r\n\t\t\treturn function ( vFrom, vTo ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\r\n\t\t\t\tr = vFrom.dot( vTo ) + 1;\r\n\t\r\n\t\t\t\tif ( r < EPS ) {\r\n\t\r\n\t\t\t\t\tr = 0;\r\n\t\r\n\t\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\r\n\t\r\n\t\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tv1.crossVectors( vFrom, vTo );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis._x = v1.x;\r\n\t\t\t\tthis._y = v1.y;\r\n\t\t\t\tthis._z = v1.z;\r\n\t\t\t\tthis._w = r;\r\n\t\r\n\t\t\t\treturn this.normalize();\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tinverse: function () {\r\n\t\r\n\t\t\treturn this.conjugate().normalize();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tconjugate: function () {\r\n\t\r\n\t\t\tthis._x *= - 1;\r\n\t\t\tthis._y *= - 1;\r\n\t\t\tthis._z *= - 1;\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdot: function ( v ) {\r\n\t\r\n\t\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthSq: function () {\r\n\t\r\n\t\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlength: function () {\r\n\t\r\n\t\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalize: function () {\r\n\t\r\n\t\t\tvar l = this.length();\r\n\t\r\n\t\t\tif ( l === 0 ) {\r\n\t\r\n\t\t\t\tthis._x = 0;\r\n\t\t\t\tthis._y = 0;\r\n\t\t\t\tthis._z = 0;\r\n\t\t\t\tthis._w = 1;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tl = 1 / l;\r\n\t\r\n\t\t\t\tthis._x = this._x * l;\r\n\t\t\t\tthis._y = this._y * l;\r\n\t\t\t\tthis._z = this._z * l;\r\n\t\t\t\tthis._w = this._w * l;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiply: function ( q, p ) {\r\n\t\r\n\t\t\tif ( p !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\r\n\t\t\t\treturn this.multiplyQuaternions( q, p );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this.multiplyQuaternions( this, q );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tpremultiply: function ( q ) {\r\n\t\r\n\t\t\treturn this.multiplyQuaternions( q, this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyQuaternions: function ( a, b ) {\r\n\t\r\n\t\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\r\n\t\r\n\t\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\r\n\t\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\r\n\t\r\n\t\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\r\n\t\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\r\n\t\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\r\n\t\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tslerp: function ( qb, t ) {\r\n\t\r\n\t\t\tif ( t === 0 ) return this;\r\n\t\t\tif ( t === 1 ) return this.copy( qb );\r\n\t\r\n\t\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\r\n\t\r\n\t\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\r\n\t\r\n\t\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\r\n\t\r\n\t\t\tif ( cosHalfTheta < 0 ) {\r\n\t\r\n\t\t\t\tthis._w = - qb._w;\r\n\t\t\t\tthis._x = - qb._x;\r\n\t\t\t\tthis._y = - qb._y;\r\n\t\t\t\tthis._z = - qb._z;\r\n\t\r\n\t\t\t\tcosHalfTheta = - cosHalfTheta;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.copy( qb );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( cosHalfTheta >= 1.0 ) {\r\n\t\r\n\t\t\t\tthis._w = w;\r\n\t\t\t\tthis._x = x;\r\n\t\t\t\tthis._y = y;\r\n\t\t\t\tthis._z = z;\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\r\n\t\r\n\t\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\r\n\t\r\n\t\t\t\tthis._w = 0.5 * ( w + this._w );\r\n\t\t\t\tthis._x = 0.5 * ( x + this._x );\r\n\t\t\t\tthis._y = 0.5 * ( y + this._y );\r\n\t\t\t\tthis._z = 0.5 * ( z + this._z );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\r\n\t\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\r\n\t\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\r\n\t\r\n\t\t\tthis._w = ( w * ratioA + this._w * ratioB );\r\n\t\t\tthis._x = ( x * ratioA + this._x * ratioB );\r\n\t\t\tthis._y = ( y * ratioA + this._y * ratioB );\r\n\t\t\tthis._z = ( z * ratioA + this._z * ratioB );\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( quaternion ) {\r\n\t\r\n\t\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis._x = array[ offset ];\r\n\t\t\tthis._y = array[ offset + 1 ];\r\n\t\t\tthis._z = array[ offset + 2 ];\r\n\t\t\tthis._w = array[ offset + 3 ];\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tarray[ offset ] = this._x;\r\n\t\t\tarray[ offset + 1 ] = this._y;\r\n\t\t\tarray[ offset + 2 ] = this._z;\r\n\t\t\tarray[ offset + 3 ] = this._w;\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tonChange: function ( callback ) {\r\n\t\r\n\t\t\tthis.onChangeCallback = callback;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tonChangeCallback: function () {}\r\n\t\r\n\t};\r\n\t\r\n\tObject.assign( THREE.Quaternion, {\r\n\t\r\n\t\tslerp: function( qa, qb, qm, t ) {\r\n\t\r\n\t\t\treturn qm.copy( qa ).slerp( qb, t );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tslerpFlat: function(\r\n\t\t\t\tdst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\r\n\t\r\n\t\t\t// fuzz-free, array-based Quaternion SLERP operation\r\n\t\r\n\t\t\tvar x0 = src0[ srcOffset0 + 0 ],\r\n\t\t\t\ty0 = src0[ srcOffset0 + 1 ],\r\n\t\t\t\tz0 = src0[ srcOffset0 + 2 ],\r\n\t\t\t\tw0 = src0[ srcOffset0 + 3 ],\r\n\t\r\n\t\t\t\tx1 = src1[ srcOffset1 + 0 ],\r\n\t\t\t\ty1 = src1[ srcOffset1 + 1 ],\r\n\t\t\t\tz1 = src1[ srcOffset1 + 2 ],\r\n\t\t\t\tw1 = src1[ srcOffset1 + 3 ];\r\n\t\r\n\t\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\r\n\t\r\n\t\t\t\tvar s = 1 - t,\r\n\t\r\n\t\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\r\n\t\r\n\t\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\r\n\t\t\t\t\tsqrSin = 1 - cos * cos;\r\n\t\r\n\t\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\r\n\t\t\t\tif ( sqrSin > Number.EPSILON ) {\r\n\t\r\n\t\t\t\t\tvar sin = Math.sqrt( sqrSin ),\r\n\t\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\r\n\t\r\n\t\t\t\t\ts = Math.sin( s * len ) / sin;\r\n\t\t\t\t\tt = Math.sin( t * len ) / sin;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar tDir = t * dir;\r\n\t\r\n\t\t\t\tx0 = x0 * s + x1 * tDir;\r\n\t\t\t\ty0 = y0 * s + y1 * tDir;\r\n\t\t\t\tz0 = z0 * s + z1 * tDir;\r\n\t\t\t\tw0 = w0 * s + w1 * tDir;\r\n\t\r\n\t\t\t\t// Normalize in case we just did a lerp:\r\n\t\t\t\tif ( s === 1 - t ) {\r\n\t\r\n\t\t\t\t\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\r\n\t\r\n\t\t\t\t\tx0 *= f;\r\n\t\t\t\t\ty0 *= f;\r\n\t\t\t\t\tz0 *= f;\r\n\t\t\t\t\tw0 *= f;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tdst[ dstOffset ] = x0;\r\n\t\t\tdst[ dstOffset + 1 ] = y0;\r\n\t\t\tdst[ dstOffset + 2 ] = z0;\r\n\t\t\tdst[ dstOffset + 3 ] = w0;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/math/Vector2.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author philogb / http://blog.thejit.org/\r\n\t * @author egraether / http://egraether.com/\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t */\r\n\t\r\n\tTHREE.Vector2 = function ( x, y ) {\r\n\t\r\n\t\tthis.x = x || 0;\r\n\t\tthis.y = y || 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Vector2.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Vector2,\r\n\t\r\n\t\tget width() {\r\n\t\r\n\t\t\treturn this.x;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset width( value ) {\r\n\t\r\n\t\t\tthis.x = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget height() {\r\n\t\r\n\t\t\treturn this.y;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset height( value ) {\r\n\t\r\n\t\t\tthis.y = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t//\r\n\t\r\n\t\tset: function ( x, y ) {\r\n\t\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetScalar: function ( scalar ) {\r\n\t\r\n\t\t\tthis.x = scalar;\r\n\t\t\tthis.y = scalar;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetX: function ( x ) {\r\n\t\r\n\t\t\tthis.x = x;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetY: function ( y ) {\r\n\t\r\n\t\t\tthis.y = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetComponent: function ( index, value ) {\r\n\t\r\n\t\t\tswitch ( index ) {\r\n\t\r\n\t\t\t\tcase 0: this.x = value; break;\r\n\t\t\t\tcase 1: this.y = value; break;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetComponent: function ( index ) {\r\n\t\r\n\t\t\tswitch ( index ) {\r\n\t\r\n\t\t\t\tcase 0: return this.x;\r\n\t\t\t\tcase 1: return this.y;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor( this.x, this.y );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( v ) {\r\n\t\r\n\t\t\tthis.x = v.x;\r\n\t\t\tthis.y = v.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tadd: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.addVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x += v.x;\r\n\t\t\tthis.y += v.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x += s;\r\n\t\t\tthis.y += s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x + b.x;\r\n\t\t\tthis.y = a.y + b.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddScaledVector: function ( v, s ) {\r\n\t\r\n\t\t\tthis.x += v.x * s;\r\n\t\t\tthis.y += v.y * s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsub: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.subVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x -= v.x;\r\n\t\t\tthis.y -= v.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsubScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x -= s;\r\n\t\t\tthis.y -= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsubVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x - b.x;\r\n\t\t\tthis.y = a.y - b.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiply: function ( v ) {\r\n\t\r\n\t\t\tthis.x *= v.x;\r\n\t\t\tthis.y *= v.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyScalar: function ( scalar ) {\r\n\t\r\n\t\t\tif ( isFinite( scalar ) ) {\r\n\t\r\n\t\t\t\tthis.x *= scalar;\r\n\t\t\t\tthis.y *= scalar;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.x = 0;\r\n\t\t\t\tthis.y = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdivide: function ( v ) {\r\n\t\r\n\t\t\tthis.x /= v.x;\r\n\t\t\tthis.y /= v.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdivideScalar: function ( scalar ) {\r\n\t\r\n\t\t\treturn this.multiplyScalar( 1 / scalar );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmin: function ( v ) {\r\n\t\r\n\t\t\tthis.x = Math.min( this.x, v.x );\r\n\t\t\tthis.y = Math.min( this.y, v.y );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmax: function ( v ) {\r\n\t\r\n\t\t\tthis.x = Math.max( this.x, v.x );\r\n\t\t\tthis.y = Math.max( this.y, v.y );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclamp: function ( min, max ) {\r\n\t\r\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\t\r\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclampScalar: function () {\r\n\t\r\n\t\t\tvar min, max;\r\n\t\r\n\t\t\treturn function clampScalar( minVal, maxVal ) {\r\n\t\r\n\t\t\t\tif ( min === undefined ) {\r\n\t\r\n\t\t\t\t\tmin = new THREE.Vector2();\r\n\t\t\t\t\tmax = new THREE.Vector2();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tmin.set( minVal, minVal );\r\n\t\t\t\tmax.set( maxVal, maxVal );\r\n\t\r\n\t\t\t\treturn this.clamp( min, max );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclampLength: function ( min, max ) {\r\n\t\r\n\t\t\tvar length = this.length();\r\n\t\r\n\t\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfloor: function () {\r\n\t\r\n\t\t\tthis.x = Math.floor( this.x );\r\n\t\t\tthis.y = Math.floor( this.y );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tceil: function () {\r\n\t\r\n\t\t\tthis.x = Math.ceil( this.x );\r\n\t\t\tthis.y = Math.ceil( this.y );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tround: function () {\r\n\t\r\n\t\t\tthis.x = Math.round( this.x );\r\n\t\t\tthis.y = Math.round( this.y );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\troundToZero: function () {\r\n\t\r\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnegate: function () {\r\n\t\r\n\t\t\tthis.x = - this.x;\r\n\t\t\tthis.y = - this.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdot: function ( v ) {\r\n\t\r\n\t\t\treturn this.x * v.x + this.y * v.y;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthSq: function () {\r\n\t\r\n\t\t\treturn this.x * this.x + this.y * this.y;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlength: function () {\r\n\t\r\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthManhattan: function() {\r\n\t\r\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalize: function () {\r\n\t\r\n\t\t\treturn this.divideScalar( this.length() );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tangle: function () {\r\n\t\r\n\t\t\t// computes the angle in radians with respect to the positive x-axis\r\n\t\r\n\t\t\tvar angle = Math.atan2( this.y, this.x );\r\n\t\r\n\t\t\tif ( angle < 0 ) angle += 2 * Math.PI;\r\n\t\r\n\t\t\treturn angle;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceTo: function ( v ) {\r\n\t\r\n\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToSquared: function ( v ) {\r\n\t\r\n\t\t\tvar dx = this.x - v.x, dy = this.y - v.y;\r\n\t\t\treturn dx * dx + dy * dy;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetLength: function ( length ) {\r\n\t\r\n\t\t\treturn this.multiplyScalar( length / this.length() );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerp: function ( v, alpha ) {\r\n\t\r\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerpVectors: function ( v1, v2, alpha ) {\r\n\t\r\n\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( v ) {\r\n\t\r\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis.x = array[ offset ];\r\n\t\t\tthis.y = array[ offset + 1 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tarray[ offset ] = this.x;\r\n\t\t\tarray[ offset + 1 ] = this.y;\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromAttribute: function ( attribute, index, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tindex = index * attribute.itemSize + offset;\r\n\t\r\n\t\t\tthis.x = attribute.array[ index ];\r\n\t\t\tthis.y = attribute.array[ index + 1 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\trotateAround: function ( center, angle ) {\r\n\t\r\n\t\t\tvar c = Math.cos( angle ), s = Math.sin( angle );\r\n\t\r\n\t\t\tvar x = this.x - center.x;\r\n\t\t\tvar y = this.y - center.y;\r\n\t\r\n\t\t\tthis.x = x * c - y * s + center.x;\r\n\t\t\tthis.y = x * s + y * c + center.y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Vector3.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author *kile / http://kile.stravaganza.org/\r\n\t * @author philogb / http://blog.thejit.org/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author egraether / http://egraether.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\tTHREE.Vector3 = function ( x, y, z ) {\r\n\t\r\n\t\tthis.x = x || 0;\r\n\t\tthis.y = y || 0;\r\n\t\tthis.z = z || 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Vector3.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Vector3,\r\n\t\r\n\t\tset: function ( x, y, z ) {\r\n\t\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t\tthis.z = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetScalar: function ( scalar ) {\r\n\t\r\n\t\t\tthis.x = scalar;\r\n\t\t\tthis.y = scalar;\r\n\t\t\tthis.z = scalar;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetX: function ( x ) {\r\n\t\r\n\t\t\tthis.x = x;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetY: function ( y ) {\r\n\t\r\n\t\t\tthis.y = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetZ: function ( z ) {\r\n\t\r\n\t\t\tthis.z = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetComponent: function ( index, value ) {\r\n\t\r\n\t\t\tswitch ( index ) {\r\n\t\r\n\t\t\t\tcase 0: this.x = value; break;\r\n\t\t\t\tcase 1: this.y = value; break;\r\n\t\t\t\tcase 2: this.z = value; break;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetComponent: function ( index ) {\r\n\t\r\n\t\t\tswitch ( index ) {\r\n\t\r\n\t\t\t\tcase 0: return this.x;\r\n\t\t\t\tcase 1: return this.y;\r\n\t\t\t\tcase 2: return this.z;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor( this.x, this.y, this.z );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( v ) {\r\n\t\r\n\t\t\tthis.x = v.x;\r\n\t\t\tthis.y = v.y;\r\n\t\t\tthis.z = v.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tadd: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.addVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x += v.x;\r\n\t\t\tthis.y += v.y;\r\n\t\t\tthis.z += v.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x += s;\r\n\t\t\tthis.y += s;\r\n\t\t\tthis.z += s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x + b.x;\r\n\t\t\tthis.y = a.y + b.y;\r\n\t\t\tthis.z = a.z + b.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddScaledVector: function ( v, s ) {\r\n\t\r\n\t\t\tthis.x += v.x * s;\r\n\t\t\tthis.y += v.y * s;\r\n\t\t\tthis.z += v.z * s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsub: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.subVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x -= v.x;\r\n\t\t\tthis.y -= v.y;\r\n\t\t\tthis.z -= v.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsubScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x -= s;\r\n\t\t\tthis.y -= s;\r\n\t\t\tthis.z -= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsubVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x - b.x;\r\n\t\t\tthis.y = a.y - b.y;\r\n\t\t\tthis.z = a.z - b.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiply: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.multiplyVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x *= v.x;\r\n\t\t\tthis.y *= v.y;\r\n\t\t\tthis.z *= v.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyScalar: function ( scalar ) {\r\n\t\r\n\t\t\tif ( isFinite( scalar ) ) {\r\n\t\r\n\t\t\t\tthis.x *= scalar;\r\n\t\t\t\tthis.y *= scalar;\r\n\t\t\t\tthis.z *= scalar;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.x = 0;\r\n\t\t\t\tthis.y = 0;\r\n\t\t\t\tthis.z = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x * b.x;\r\n\t\t\tthis.y = a.y * b.y;\r\n\t\t\tthis.z = a.z * b.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyEuler: function () {\r\n\t\r\n\t\t\tvar quaternion;\r\n\t\r\n\t\t\treturn function applyEuler( euler ) {\r\n\t\r\n\t\t\t\tif ( euler instanceof THREE.Euler === false ) {\r\n\t\r\n\t\t\t\t\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\r\n\t\r\n\t\t\t\treturn this.applyQuaternion( quaternion.setFromEuler( euler ) );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tapplyAxisAngle: function () {\r\n\t\r\n\t\t\tvar quaternion;\r\n\t\r\n\t\t\treturn function applyAxisAngle( axis, angle ) {\r\n\t\r\n\t\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\r\n\t\r\n\t\t\t\treturn this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tapplyMatrix3: function ( m ) {\r\n\t\r\n\t\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\t\tvar e = m.elements;\r\n\t\r\n\t\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\r\n\t\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\r\n\t\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix4: function ( m ) {\r\n\t\r\n\t\t\t// input: THREE.Matrix4 affine matrix\r\n\t\r\n\t\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\t\tvar e = m.elements;\r\n\t\r\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];\r\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];\r\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyProjection: function ( m ) {\r\n\t\r\n\t\t\t// input: THREE.Matrix4 projection matrix\r\n\t\r\n\t\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\t\tvar e = m.elements;\r\n\t\t\tvar d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide\r\n\t\r\n\t\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;\r\n\t\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;\r\n\t\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyQuaternion: function ( q ) {\r\n\t\r\n\t\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\t\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\r\n\t\r\n\t\t\t// calculate quat * vector\r\n\t\r\n\t\t\tvar ix =  qw * x + qy * z - qz * y;\r\n\t\t\tvar iy =  qw * y + qz * x - qx * z;\r\n\t\t\tvar iz =  qw * z + qx * y - qy * x;\r\n\t\t\tvar iw = - qx * x - qy * y - qz * z;\r\n\t\r\n\t\t\t// calculate result * inverse quat\r\n\t\r\n\t\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\r\n\t\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\r\n\t\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tproject: function () {\r\n\t\r\n\t\t\tvar matrix;\r\n\t\r\n\t\t\treturn function project( camera ) {\r\n\t\r\n\t\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\r\n\t\t\t\treturn this.applyProjection( matrix );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tunproject: function () {\r\n\t\r\n\t\t\tvar matrix;\r\n\t\r\n\t\t\treturn function unproject( camera ) {\r\n\t\r\n\t\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\r\n\t\t\t\treturn this.applyProjection( matrix );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttransformDirection: function ( m ) {\r\n\t\r\n\t\t\t// input: THREE.Matrix4 affine matrix\r\n\t\t\t// vector interpreted as a direction\r\n\t\r\n\t\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\t\tvar e = m.elements;\r\n\t\r\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;\r\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;\r\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\r\n\t\r\n\t\t\treturn this.normalize();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdivide: function ( v ) {\r\n\t\r\n\t\t\tthis.x /= v.x;\r\n\t\t\tthis.y /= v.y;\r\n\t\t\tthis.z /= v.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdivideScalar: function ( scalar ) {\r\n\t\r\n\t\t\treturn this.multiplyScalar( 1 / scalar );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmin: function ( v ) {\r\n\t\r\n\t\t\tthis.x = Math.min( this.x, v.x );\r\n\t\t\tthis.y = Math.min( this.y, v.y );\r\n\t\t\tthis.z = Math.min( this.z, v.z );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmax: function ( v ) {\r\n\t\r\n\t\t\tthis.x = Math.max( this.x, v.x );\r\n\t\t\tthis.y = Math.max( this.y, v.y );\r\n\t\t\tthis.z = Math.max( this.z, v.z );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclamp: function ( min, max ) {\r\n\t\r\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\t\r\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclampScalar: function () {\r\n\t\r\n\t\t\tvar min, max;\r\n\t\r\n\t\t\treturn function clampScalar( minVal, maxVal ) {\r\n\t\r\n\t\t\t\tif ( min === undefined ) {\r\n\t\r\n\t\t\t\t\tmin = new THREE.Vector3();\r\n\t\t\t\t\tmax = new THREE.Vector3();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tmin.set( minVal, minVal, minVal );\r\n\t\t\t\tmax.set( maxVal, maxVal, maxVal );\r\n\t\r\n\t\t\t\treturn this.clamp( min, max );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclampLength: function ( min, max ) {\r\n\t\r\n\t\t\tvar length = this.length();\r\n\t\r\n\t\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfloor: function () {\r\n\t\r\n\t\t\tthis.x = Math.floor( this.x );\r\n\t\t\tthis.y = Math.floor( this.y );\r\n\t\t\tthis.z = Math.floor( this.z );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tceil: function () {\r\n\t\r\n\t\t\tthis.x = Math.ceil( this.x );\r\n\t\t\tthis.y = Math.ceil( this.y );\r\n\t\t\tthis.z = Math.ceil( this.z );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tround: function () {\r\n\t\r\n\t\t\tthis.x = Math.round( this.x );\r\n\t\t\tthis.y = Math.round( this.y );\r\n\t\t\tthis.z = Math.round( this.z );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\troundToZero: function () {\r\n\t\r\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnegate: function () {\r\n\t\r\n\t\t\tthis.x = - this.x;\r\n\t\t\tthis.y = - this.y;\r\n\t\t\tthis.z = - this.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdot: function ( v ) {\r\n\t\r\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthSq: function () {\r\n\t\r\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlength: function () {\r\n\t\r\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthManhattan: function () {\r\n\t\r\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalize: function () {\r\n\t\r\n\t\t\treturn this.divideScalar( this.length() );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetLength: function ( length ) {\r\n\t\r\n\t\t\treturn this.multiplyScalar( length / this.length() );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerp: function ( v, alpha ) {\r\n\t\r\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerpVectors: function ( v1, v2, alpha ) {\r\n\t\r\n\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcross: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.crossVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\r\n\t\t\tthis.x = y * v.z - z * v.y;\r\n\t\t\tthis.y = z * v.x - x * v.z;\r\n\t\t\tthis.z = x * v.y - y * v.x;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcrossVectors: function ( a, b ) {\r\n\t\r\n\t\t\tvar ax = a.x, ay = a.y, az = a.z;\r\n\t\t\tvar bx = b.x, by = b.y, bz = b.z;\r\n\t\r\n\t\t\tthis.x = ay * bz - az * by;\r\n\t\t\tthis.y = az * bx - ax * bz;\r\n\t\t\tthis.z = ax * by - ay * bx;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tprojectOnVector: function () {\r\n\t\r\n\t\t\tvar v1, dot;\r\n\t\r\n\t\t\treturn function projectOnVector( vector ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\r\n\t\t\t\tv1.copy( vector ).normalize();\r\n\t\r\n\t\t\t\tdot = this.dot( v1 );\r\n\t\r\n\t\t\t\treturn this.copy( v1 ).multiplyScalar( dot );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tprojectOnPlane: function () {\r\n\t\r\n\t\t\tvar v1;\r\n\t\r\n\t\t\treturn function projectOnPlane( planeNormal ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\r\n\t\t\t\tv1.copy( this ).projectOnVector( planeNormal );\r\n\t\r\n\t\t\t\treturn this.sub( v1 );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\treflect: function () {\r\n\t\r\n\t\t\t// reflect incident vector off plane orthogonal to normal\r\n\t\t\t// normal is assumed to have unit length\r\n\t\r\n\t\t\tvar v1;\r\n\t\r\n\t\t\treturn function reflect( normal ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\r\n\t\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tangleTo: function ( v ) {\r\n\t\r\n\t\t\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\r\n\t\r\n\t\t\t// clamp, to handle numerical problems\r\n\t\r\n\t\t\treturn Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceTo: function ( v ) {\r\n\t\r\n\t\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToSquared: function ( v ) {\r\n\t\r\n\t\t\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\r\n\t\r\n\t\t\treturn dx * dx + dy * dy + dz * dz;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromSpherical: function( s ) {\r\n\t\r\n\t\t\tvar sinPhiRadius = Math.sin( s.phi ) * s.radius;\r\n\t\r\n\t\t\tthis.x = sinPhiRadius * Math.sin( s.theta );\r\n\t\t\tthis.y = Math.cos( s.phi ) * s.radius;\r\n\t\t\tthis.z = sinPhiRadius * Math.cos( s.theta );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromMatrixPosition: function ( m ) {\r\n\t\r\n\t\t\treturn this.setFromMatrixColumn( m, 3 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromMatrixScale: function ( m ) {\r\n\t\r\n\t\t\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\r\n\t\t\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\r\n\t\t\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\r\n\t\r\n\t\t\tthis.x = sx;\r\n\t\t\tthis.y = sy;\r\n\t\t\tthis.z = sz;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromMatrixColumn: function ( m, index ) {\r\n\t\r\n\t\t\tif ( typeof m === 'number' ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );\r\n\t\t\t\tvar temp = m\r\n\t\t\t\tm = index;\r\n\t\t\t\tindex = temp;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this.fromArray( m.elements, index * 4 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( v ) {\r\n\t\r\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis.x = array[ offset ];\r\n\t\t\tthis.y = array[ offset + 1 ];\r\n\t\t\tthis.z = array[ offset + 2 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tarray[ offset ] = this.x;\r\n\t\t\tarray[ offset + 1 ] = this.y;\r\n\t\t\tarray[ offset + 2 ] = this.z;\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromAttribute: function ( attribute, index, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tindex = index * attribute.itemSize + offset;\r\n\t\r\n\t\t\tthis.x = attribute.array[ index ];\r\n\t\t\tthis.y = attribute.array[ index + 1 ];\r\n\t\t\tthis.z = attribute.array[ index + 2 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Vector4.js\r\n\t\r\n\t/**\r\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\r\n\t * @author philogb / http://blog.thejit.org/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author egraether / http://egraether.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\tTHREE.Vector4 = function ( x, y, z, w ) {\r\n\t\r\n\t\tthis.x = x || 0;\r\n\t\tthis.y = y || 0;\r\n\t\tthis.z = z || 0;\r\n\t\tthis.w = ( w !== undefined ) ? w : 1;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Vector4.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Vector4,\r\n\t\r\n\t\tset: function ( x, y, z, w ) {\r\n\t\r\n\t\t\tthis.x = x;\r\n\t\t\tthis.y = y;\r\n\t\t\tthis.z = z;\r\n\t\t\tthis.w = w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetScalar: function ( scalar ) {\r\n\t\r\n\t\t\tthis.x = scalar;\r\n\t\t\tthis.y = scalar;\r\n\t\t\tthis.z = scalar;\r\n\t\t\tthis.w = scalar;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetX: function ( x ) {\r\n\t\r\n\t\t\tthis.x = x;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetY: function ( y ) {\r\n\t\r\n\t\t\tthis.y = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetZ: function ( z ) {\r\n\t\r\n\t\t\tthis.z = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetW: function ( w ) {\r\n\t\r\n\t\t\tthis.w = w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetComponent: function ( index, value ) {\r\n\t\r\n\t\t\tswitch ( index ) {\r\n\t\r\n\t\t\t\tcase 0: this.x = value; break;\r\n\t\t\t\tcase 1: this.y = value; break;\r\n\t\t\t\tcase 2: this.z = value; break;\r\n\t\t\t\tcase 3: this.w = value; break;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetComponent: function ( index ) {\r\n\t\r\n\t\t\tswitch ( index ) {\r\n\t\r\n\t\t\t\tcase 0: return this.x;\r\n\t\t\t\tcase 1: return this.y;\r\n\t\t\t\tcase 2: return this.z;\r\n\t\t\t\tcase 3: return this.w;\r\n\t\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( v ) {\r\n\t\r\n\t\t\tthis.x = v.x;\r\n\t\t\tthis.y = v.y;\r\n\t\t\tthis.z = v.z;\r\n\t\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tadd: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.addVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x += v.x;\r\n\t\t\tthis.y += v.y;\r\n\t\t\tthis.z += v.z;\r\n\t\t\tthis.w += v.w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x += s;\r\n\t\t\tthis.y += s;\r\n\t\t\tthis.z += s;\r\n\t\t\tthis.w += s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x + b.x;\r\n\t\t\tthis.y = a.y + b.y;\r\n\t\t\tthis.z = a.z + b.z;\r\n\t\t\tthis.w = a.w + b.w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddScaledVector: function ( v, s ) {\r\n\t\r\n\t\t\tthis.x += v.x * s;\r\n\t\t\tthis.y += v.y * s;\r\n\t\t\tthis.z += v.z * s;\r\n\t\t\tthis.w += v.w * s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsub: function ( v, w ) {\r\n\t\r\n\t\t\tif ( w !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\t\treturn this.subVectors( v, w );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.x -= v.x;\r\n\t\t\tthis.y -= v.y;\r\n\t\t\tthis.z -= v.z;\r\n\t\t\tthis.w -= v.w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsubScalar: function ( s ) {\r\n\t\r\n\t\t\tthis.x -= s;\r\n\t\t\tthis.y -= s;\r\n\t\t\tthis.z -= s;\r\n\t\t\tthis.w -= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsubVectors: function ( a, b ) {\r\n\t\r\n\t\t\tthis.x = a.x - b.x;\r\n\t\t\tthis.y = a.y - b.y;\r\n\t\t\tthis.z = a.z - b.z;\r\n\t\t\tthis.w = a.w - b.w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyScalar: function ( scalar ) {\r\n\t\r\n\t\t\tif ( isFinite( scalar ) ) {\r\n\t\r\n\t\t\t\tthis.x *= scalar;\r\n\t\t\t\tthis.y *= scalar;\r\n\t\t\t\tthis.z *= scalar;\r\n\t\t\t\tthis.w *= scalar;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.x = 0;\r\n\t\t\t\tthis.y = 0;\r\n\t\t\t\tthis.z = 0;\r\n\t\t\t\tthis.w = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix4: function ( m ) {\r\n\t\r\n\t\t\tvar x = this.x, y = this.y, z = this.z, w = this.w;\r\n\t\t\tvar e = m.elements;\r\n\t\r\n\t\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\r\n\t\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\r\n\t\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\r\n\t\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdivideScalar: function ( scalar ) {\r\n\t\r\n\t\t\treturn this.multiplyScalar( 1 / scalar );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetAxisAngleFromQuaternion: function ( q ) {\r\n\t\r\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\r\n\t\r\n\t\t\t// q is assumed to be normalized\r\n\t\r\n\t\t\tthis.w = 2 * Math.acos( q.w );\r\n\t\r\n\t\t\tvar s = Math.sqrt( 1 - q.w * q.w );\r\n\t\r\n\t\t\tif ( s < 0.0001 ) {\r\n\t\r\n\t\t\t\t this.x = 1;\r\n\t\t\t\t this.y = 0;\r\n\t\t\t\t this.z = 0;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t this.x = q.x / s;\r\n\t\t\t\t this.y = q.y / s;\r\n\t\t\t\t this.z = q.z / s;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetAxisAngleFromRotationMatrix: function ( m ) {\r\n\t\r\n\t\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\r\n\t\r\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\t\r\n\t\t\tvar angle, x, y, z,\t\t// variables for result\r\n\t\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\r\n\t\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\r\n\t\r\n\t\t\t\tte = m.elements,\r\n\t\r\n\t\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n\t\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n\t\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\t\r\n\t\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\r\n\t\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\r\n\t\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\r\n\t\r\n\t\t\t\t// singularity found\r\n\t\t\t\t// first check for identity matrix which must have +1 for all terms\r\n\t\t\t\t// in leading diagonal and zero in other terms\r\n\t\r\n\t\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\r\n\t\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\r\n\t\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\r\n\t\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\r\n\t\r\n\t\t\t\t\t// this singularity is identity matrix so angle = 0\r\n\t\r\n\t\t\t\t\tthis.set( 1, 0, 0, 0 );\r\n\t\r\n\t\t\t\t\treturn this; // zero angle, arbitrary axis\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// otherwise this singularity is angle = 180\r\n\t\r\n\t\t\t\tangle = Math.PI;\r\n\t\r\n\t\t\t\tvar xx = ( m11 + 1 ) / 2;\r\n\t\t\t\tvar yy = ( m22 + 1 ) / 2;\r\n\t\t\t\tvar zz = ( m33 + 1 ) / 2;\r\n\t\t\t\tvar xy = ( m12 + m21 ) / 4;\r\n\t\t\t\tvar xz = ( m13 + m31 ) / 4;\r\n\t\t\t\tvar yz = ( m23 + m32 ) / 4;\r\n\t\r\n\t\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\r\n\t\r\n\t\t\t\t\t// m11 is the largest diagonal term\r\n\t\r\n\t\t\t\t\tif ( xx < epsilon ) {\r\n\t\r\n\t\t\t\t\t\tx = 0;\r\n\t\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\t\tz = 0.707106781;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tx = Math.sqrt( xx );\r\n\t\t\t\t\t\ty = xy / x;\r\n\t\t\t\t\t\tz = xz / x;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( yy > zz ) {\r\n\t\r\n\t\t\t\t\t// m22 is the largest diagonal term\r\n\t\r\n\t\t\t\t\tif ( yy < epsilon ) {\r\n\t\r\n\t\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\t\ty = 0;\r\n\t\t\t\t\t\tz = 0.707106781;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\ty = Math.sqrt( yy );\r\n\t\t\t\t\t\tx = xy / y;\r\n\t\t\t\t\t\tz = yz / y;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// m33 is the largest diagonal term so base result on this\r\n\t\r\n\t\t\t\t\tif ( zz < epsilon ) {\r\n\t\r\n\t\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\t\tz = 0;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tz = Math.sqrt( zz );\r\n\t\t\t\t\t\tx = xz / z;\r\n\t\t\t\t\t\ty = yz / z;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.set( x, y, z, angle );\r\n\t\r\n\t\t\t\treturn this; // return 180 deg rotation\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// as we have reached here there are no singularities so we can handle normally\r\n\t\r\n\t\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\r\n\t\t\t                   ( m13 - m31 ) * ( m13 - m31 ) +\r\n\t\t\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\r\n\t\r\n\t\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\r\n\t\r\n\t\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\r\n\t\t\t// caught by singularity test above, but I've left it in just in case\r\n\t\r\n\t\t\tthis.x = ( m32 - m23 ) / s;\r\n\t\t\tthis.y = ( m13 - m31 ) / s;\r\n\t\t\tthis.z = ( m21 - m12 ) / s;\r\n\t\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmin: function ( v ) {\r\n\t\r\n\t\t\tthis.x = Math.min( this.x, v.x );\r\n\t\t\tthis.y = Math.min( this.y, v.y );\r\n\t\t\tthis.z = Math.min( this.z, v.z );\r\n\t\t\tthis.w = Math.min( this.w, v.w );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmax: function ( v ) {\r\n\t\r\n\t\t\tthis.x = Math.max( this.x, v.x );\r\n\t\t\tthis.y = Math.max( this.y, v.y );\r\n\t\t\tthis.z = Math.max( this.z, v.z );\r\n\t\t\tthis.w = Math.max( this.w, v.w );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclamp: function ( min, max ) {\r\n\t\r\n\t\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\t\r\n\t\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\t\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\r\n\t\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclampScalar: function () {\r\n\t\r\n\t\t\tvar min, max;\r\n\t\r\n\t\t\treturn function clampScalar( minVal, maxVal ) {\r\n\t\r\n\t\t\t\tif ( min === undefined ) {\r\n\t\r\n\t\t\t\t\tmin = new THREE.Vector4();\r\n\t\t\t\t\tmax = new THREE.Vector4();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tmin.set( minVal, minVal, minVal, minVal );\r\n\t\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\r\n\t\r\n\t\t\t\treturn this.clamp( min, max );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tfloor: function () {\r\n\t\r\n\t\t\tthis.x = Math.floor( this.x );\r\n\t\t\tthis.y = Math.floor( this.y );\r\n\t\t\tthis.z = Math.floor( this.z );\r\n\t\t\tthis.w = Math.floor( this.w );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tceil: function () {\r\n\t\r\n\t\t\tthis.x = Math.ceil( this.x );\r\n\t\t\tthis.y = Math.ceil( this.y );\r\n\t\t\tthis.z = Math.ceil( this.z );\r\n\t\t\tthis.w = Math.ceil( this.w );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tround: function () {\r\n\t\r\n\t\t\tthis.x = Math.round( this.x );\r\n\t\t\tthis.y = Math.round( this.y );\r\n\t\t\tthis.z = Math.round( this.z );\r\n\t\t\tthis.w = Math.round( this.w );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\troundToZero: function () {\r\n\t\r\n\t\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\t\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnegate: function () {\r\n\t\r\n\t\t\tthis.x = - this.x;\r\n\t\t\tthis.y = - this.y;\r\n\t\t\tthis.z = - this.z;\r\n\t\t\tthis.w = - this.w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdot: function ( v ) {\r\n\t\r\n\t\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthSq: function () {\r\n\t\r\n\t\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlength: function () {\r\n\t\r\n\t\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlengthManhattan: function () {\r\n\t\r\n\t\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalize: function () {\r\n\t\r\n\t\t\treturn this.divideScalar( this.length() );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetLength: function ( length ) {\r\n\t\r\n\t\t\treturn this.multiplyScalar( length / this.length() );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerp: function ( v, alpha ) {\r\n\t\r\n\t\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\t\t\tthis.w += ( v.w - this.w ) * alpha;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlerpVectors: function ( v1, v2, alpha ) {\r\n\t\r\n\t\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( v ) {\r\n\t\r\n\t\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis.x = array[ offset ];\r\n\t\t\tthis.y = array[ offset + 1 ];\r\n\t\t\tthis.z = array[ offset + 2 ];\r\n\t\t\tthis.w = array[ offset + 3 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tarray[ offset ] = this.x;\r\n\t\t\tarray[ offset + 1 ] = this.y;\r\n\t\t\tarray[ offset + 2 ] = this.z;\r\n\t\t\tarray[ offset + 3 ] = this.w;\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromAttribute: function ( attribute, index, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tindex = index * attribute.itemSize + offset;\r\n\t\r\n\t\t\tthis.x = attribute.array[ index ];\r\n\t\t\tthis.y = attribute.array[ index + 1 ];\r\n\t\t\tthis.z = attribute.array[ index + 2 ];\r\n\t\t\tthis.w = attribute.array[ index + 3 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Euler.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t * @author bhouston / http://clara.io\r\n\t */\r\n\t\r\n\tTHREE.Euler = function ( x, y, z, order ) {\r\n\t\r\n\t\tthis._x = x || 0;\r\n\t\tthis._y = y || 0;\r\n\t\tthis._z = z || 0;\r\n\t\tthis._order = order || THREE.Euler.DefaultOrder;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\r\n\t\r\n\tTHREE.Euler.DefaultOrder = 'XYZ';\r\n\t\r\n\tTHREE.Euler.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Euler,\r\n\t\r\n\t\tget x () {\r\n\t\r\n\t\t\treturn this._x;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset x ( value ) {\r\n\t\r\n\t\t\tthis._x = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget y () {\r\n\t\r\n\t\t\treturn this._y;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset y ( value ) {\r\n\t\r\n\t\t\tthis._y = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget z () {\r\n\t\r\n\t\t\treturn this._z;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset z ( value ) {\r\n\t\r\n\t\t\tthis._z = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget order () {\r\n\t\r\n\t\t\treturn this._order;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset order ( value ) {\r\n\t\r\n\t\t\tthis._order = value;\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset: function ( x, y, z, order ) {\r\n\t\r\n\t\t\tthis._x = x;\r\n\t\t\tthis._y = y;\r\n\t\t\tthis._z = z;\r\n\t\t\tthis._order = order || this._order;\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( euler ) {\r\n\t\r\n\t\t\tthis._x = euler._x;\r\n\t\t\tthis._y = euler._y;\r\n\t\t\tthis._z = euler._z;\r\n\t\t\tthis._order = euler._order;\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromRotationMatrix: function ( m, order, update ) {\r\n\t\r\n\t\t\tvar clamp = THREE.Math.clamp;\r\n\t\r\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\t\r\n\t\t\tvar te = m.elements;\r\n\t\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\r\n\t\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\r\n\t\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\t\r\n\t\t\torder = order || this._order;\r\n\t\r\n\t\t\tif ( order === 'XYZ' ) {\r\n\t\r\n\t\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\r\n\t\r\n\t\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\r\n\t\r\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\r\n\t\t\t\t\tthis._z = Math.atan2( - m12, m11 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\r\n\t\t\t\t\tthis._z = 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( order === 'YXZ' ) {\r\n\t\r\n\t\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\r\n\t\r\n\t\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\r\n\t\r\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\r\n\t\t\t\t\tthis._z = Math.atan2( m21, m22 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\r\n\t\t\t\t\tthis._z = 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( order === 'ZXY' ) {\r\n\t\r\n\t\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\r\n\t\r\n\t\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\r\n\t\r\n\t\t\t\t\tthis._y = Math.atan2( - m31, m33 );\r\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis._y = 0;\r\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( order === 'ZYX' ) {\r\n\t\r\n\t\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\r\n\t\r\n\t\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\r\n\t\r\n\t\t\t\t\tthis._x = Math.atan2( m32, m33 );\r\n\t\t\t\t\tthis._z = Math.atan2( m21, m11 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis._x = 0;\r\n\t\t\t\t\tthis._z = Math.atan2( - m12, m22 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( order === 'YZX' ) {\r\n\t\r\n\t\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\r\n\t\r\n\t\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\r\n\t\r\n\t\t\t\t\tthis._x = Math.atan2( - m23, m22 );\r\n\t\t\t\t\tthis._y = Math.atan2( - m31, m11 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis._x = 0;\r\n\t\t\t\t\tthis._y = Math.atan2( m13, m33 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( order === 'XZY' ) {\r\n\t\r\n\t\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\r\n\t\r\n\t\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\r\n\t\r\n\t\t\t\t\tthis._x = Math.atan2( m32, m22 );\r\n\t\t\t\t\tthis._y = Math.atan2( m13, m11 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis._x = Math.atan2( - m23, m33 );\r\n\t\t\t\t\tthis._y = 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._order = order;\r\n\t\r\n\t\t\tif ( update !== false ) this.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromQuaternion: function () {\r\n\t\r\n\t\t\tvar matrix;\r\n\t\r\n\t\t\treturn function ( q, order, update ) {\r\n\t\r\n\t\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tmatrix.makeRotationFromQuaternion( q );\r\n\t\r\n\t\t\t\treturn this.setFromRotationMatrix( matrix, order, update );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tsetFromVector3: function ( v, order ) {\r\n\t\r\n\t\t\treturn this.set( v.x, v.y, v.z, order || this._order );\r\n\t\r\n\t\t},\r\n\t\r\n\t\treorder: function () {\r\n\t\r\n\t\t\t// WARNING: this discards revolution information -bhouston\r\n\t\r\n\t\t\tvar q = new THREE.Quaternion();\r\n\t\r\n\t\t\treturn function ( newOrder ) {\r\n\t\r\n\t\t\t\tq.setFromEuler( this );\r\n\t\t\t\t\r\n\t\t\t\treturn this.setFromQuaternion( q, newOrder );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tequals: function ( euler ) {\r\n\t\r\n\t\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array ) {\r\n\t\r\n\t\t\tthis._x = array[ 0 ];\r\n\t\t\tthis._y = array[ 1 ];\r\n\t\t\tthis._z = array[ 2 ];\r\n\t\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\r\n\t\r\n\t\t\tthis.onChangeCallback();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tarray[ offset ] = this._x;\r\n\t\t\tarray[ offset + 1 ] = this._y;\r\n\t\t\tarray[ offset + 2 ] = this._z;\r\n\t\t\tarray[ offset + 3 ] = this._order;\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoVector3: function ( optionalResult ) {\r\n\t\r\n\t\t\tif ( optionalResult ) {\r\n\t\r\n\t\t\t\treturn optionalResult.set( this._x, this._y, this._z );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\treturn new THREE.Vector3( this._x, this._y, this._z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tonChange: function ( callback ) {\r\n\t\r\n\t\t\tthis.onChangeCallback = callback;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tonChangeCallback: function () {}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Line3.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://clara.io\r\n\t */\r\n\t\r\n\tTHREE.Line3 = function ( start, end ) {\r\n\t\r\n\t\tthis.start = ( start !== undefined ) ? start : new THREE.Vector3();\r\n\t\tthis.end = ( end !== undefined ) ? end : new THREE.Vector3();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Line3.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Line3,\r\n\t\r\n\t\tset: function ( start, end ) {\r\n\t\r\n\t\t\tthis.start.copy( start );\r\n\t\t\tthis.end.copy( end );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( line ) {\r\n\t\r\n\t\t\tthis.start.copy( line.start );\r\n\t\t\tthis.end.copy( line.end );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcenter: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdelta: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.subVectors( this.end, this.start );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceSq: function () {\r\n\t\r\n\t\t\treturn this.start.distanceToSquared( this.end );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistance: function () {\r\n\t\r\n\t\t\treturn this.start.distanceTo( this.end );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tat: function ( t, optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclosestPointToPointParameter: function () {\r\n\t\r\n\t\t\tvar startP = new THREE.Vector3();\r\n\t\t\tvar startEnd = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( point, clampToLine ) {\r\n\t\r\n\t\t\t\tstartP.subVectors( point, this.start );\r\n\t\t\t\tstartEnd.subVectors( this.end, this.start );\r\n\t\r\n\t\t\t\tvar startEnd2 = startEnd.dot( startEnd );\r\n\t\t\t\tvar startEnd_startP = startEnd.dot( startP );\r\n\t\r\n\t\t\t\tvar t = startEnd_startP / startEnd2;\r\n\t\r\n\t\t\t\tif ( clampToLine ) {\r\n\t\r\n\t\t\t\t\tt = THREE.Math.clamp( t, 0, 1 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn t;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\r\n\t\r\n\t\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix4: function ( matrix ) {\r\n\t\r\n\t\t\tthis.start.applyMatrix4( matrix );\r\n\t\t\tthis.end.applyMatrix4( matrix );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( line ) {\r\n\t\r\n\t\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Box2.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://clara.io\r\n\t */\r\n\t\r\n\tTHREE.Box2 = function ( min, max ) {\r\n\t\r\n\t\tthis.min = ( min !== undefined ) ? min : new THREE.Vector2( + Infinity, + Infinity );\r\n\t\tthis.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Box2.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Box2,\r\n\t\r\n\t\tset: function ( min, max ) {\r\n\t\r\n\t\t\tthis.min.copy( min );\r\n\t\t\tthis.max.copy( max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromPoints: function ( points ) {\r\n\t\r\n\t\t\tthis.makeEmpty();\r\n\t\r\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tthis.expandByPoint( points[ i ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromCenterAndSize: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector2();\r\n\t\r\n\t\t\treturn function ( center, size ) {\r\n\t\r\n\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\t\t\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\t\t\tthis.max.copy( center ).add( halfSize );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( box ) {\r\n\t\r\n\t\t\tthis.min.copy( box.min );\r\n\t\t\tthis.max.copy( box.max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeEmpty: function () {\r\n\t\r\n\t\t\tthis.min.x = this.min.y = + Infinity;\r\n\t\t\tthis.max.x = this.max.y = - Infinity;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tisEmpty: function () {\r\n\t\r\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\t\r\n\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcenter: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsize: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\t\treturn result.subVectors( this.max, this.min );\r\n\t\r\n\t\t},\r\n\t\r\n\t\texpandByPoint: function ( point ) {\r\n\t\r\n\t\t\tthis.min.min( point );\r\n\t\t\tthis.max.max( point );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\texpandByVector: function ( vector ) {\r\n\t\r\n\t\t\tthis.min.sub( vector );\r\n\t\t\tthis.max.add( vector );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\texpandByScalar: function ( scalar ) {\r\n\t\r\n\t\t\tthis.min.addScalar( - scalar );\r\n\t\t\tthis.max.addScalar( scalar );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcontainsPoint: function ( point ) {\r\n\t\r\n\t\t\tif ( point.x < this.min.x || point.x > this.max.x ||\r\n\t\t\t     point.y < this.min.y || point.y > this.max.y ) {\r\n\t\r\n\t\t\t\treturn false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcontainsBox: function ( box ) {\r\n\t\r\n\t\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n\t\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn false;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetParameter: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\t// This can potentially have a divide by zero if the box\r\n\t\t\t// has a size dimension of 0.\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\r\n\t\t\treturn result.set(\r\n\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\r\n\t\t\t);\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsBox: function ( box ) {\r\n\t\r\n\t\t\t// using 6 splitting planes to rule out intersections.\r\n\t\r\n\t\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\r\n\t\r\n\t\t\t\treturn false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclampPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\t\treturn result.copy( point ).clamp( this.min, this.max );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToPoint: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector2();\r\n\t\r\n\t\t\treturn function ( point ) {\r\n\t\r\n\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n\t\t\t\treturn clampedPoint.sub( point ).length();\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tintersect: function ( box ) {\r\n\t\r\n\t\t\tthis.min.max( box.min );\r\n\t\t\tthis.max.min( box.max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tunion: function ( box ) {\r\n\t\r\n\t\t\tthis.min.min( box.min );\r\n\t\t\tthis.max.max( box.max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttranslate: function ( offset ) {\r\n\t\r\n\t\t\tthis.min.add( offset );\r\n\t\t\tthis.max.add( offset );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( box ) {\r\n\t\r\n\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Box3.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://clara.io\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\tTHREE.Box3 = function ( min, max ) {\r\n\t\r\n\t\tthis.min = ( min !== undefined ) ? min : new THREE.Vector3( + Infinity, + Infinity, + Infinity );\r\n\t\tthis.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Box3.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Box3,\r\n\t\r\n\t\tset: function ( min, max ) {\r\n\t\r\n\t\t\tthis.min.copy( min );\r\n\t\t\tthis.max.copy( max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromArray: function ( array ) {\r\n\t\r\n\t\t\tvar minX = + Infinity;\r\n\t\t\tvar minY = + Infinity;\r\n\t\t\tvar minZ = + Infinity;\r\n\t\r\n\t\t\tvar maxX = - Infinity;\r\n\t\t\tvar maxY = - Infinity;\r\n\t\t\tvar maxZ = - Infinity;\r\n\t\r\n\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\r\n\t\r\n\t\t\t\tvar x = array[ i ];\r\n\t\t\t\tvar y = array[ i + 1 ];\r\n\t\t\t\tvar z = array[ i + 2 ];\r\n\t\r\n\t\t\t\tif ( x < minX ) minX = x;\r\n\t\t\t\tif ( y < minY ) minY = y;\r\n\t\t\t\tif ( z < minZ ) minZ = z;\r\n\t\r\n\t\t\t\tif ( x > maxX ) maxX = x;\r\n\t\t\t\tif ( y > maxY ) maxY = y;\r\n\t\t\t\tif ( z > maxZ ) maxZ = z;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.min.set( minX, minY, minZ );\r\n\t\t\tthis.max.set( maxX, maxY, maxZ );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromPoints: function ( points ) {\r\n\t\r\n\t\t\tthis.makeEmpty();\r\n\t\r\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tthis.expandByPoint( points[ i ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromCenterAndSize: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( center, size ) {\r\n\t\r\n\t\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\t\r\n\t\t\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\t\t\tthis.max.copy( center ).add( halfSize );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tsetFromObject: function () {\r\n\t\r\n\t\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\r\n\t\t\t// accounting for both the object's, and children's, world transforms\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( object ) {\r\n\t\r\n\t\t\t\tvar scope = this;\r\n\t\r\n\t\t\t\tobject.updateMatrixWorld( true );\r\n\t\r\n\t\t\t\tthis.makeEmpty();\r\n\t\r\n\t\t\t\tobject.traverse( function ( node ) {\r\n\t\r\n\t\t\t\t\tvar geometry = node.geometry;\r\n\t\r\n\t\t\t\t\tif ( geometry !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\t\t\t\t\tvar vertices = geometry.vertices;\r\n\t\r\n\t\t\t\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tv1.copy( vertices[ i ] );\r\n\t\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\r\n\t\r\n\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tvar positions = geometry.attributes[ 'position' ].array;\r\n\t\r\n\t\t\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\t\t\tv1.fromArray( positions, i );\r\n\t\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\r\n\t\r\n\t\t\t\t\t\t\t\tscope.expandByPoint( v1 );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( box ) {\r\n\t\r\n\t\t\tthis.min.copy( box.min );\r\n\t\t\tthis.max.copy( box.max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeEmpty: function () {\r\n\t\r\n\t\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\r\n\t\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tisEmpty: function () {\r\n\t\r\n\t\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\t\r\n\t\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcenter: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsize: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.subVectors( this.max, this.min );\r\n\t\r\n\t\t},\r\n\t\r\n\t\texpandByPoint: function ( point ) {\r\n\t\r\n\t\t\tthis.min.min( point );\r\n\t\t\tthis.max.max( point );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\texpandByVector: function ( vector ) {\r\n\t\r\n\t\t\tthis.min.sub( vector );\r\n\t\t\tthis.max.add( vector );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\texpandByScalar: function ( scalar ) {\r\n\t\r\n\t\t\tthis.min.addScalar( - scalar );\r\n\t\t\tthis.max.addScalar( scalar );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcontainsPoint: function ( point ) {\r\n\t\r\n\t\t\tif ( point.x < this.min.x || point.x > this.max.x ||\r\n\t\t\t\t\t point.y < this.min.y || point.y > this.max.y ||\r\n\t\t\t\t\t point.z < this.min.z || point.z > this.max.z ) {\r\n\t\r\n\t\t\t\treturn false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcontainsBox: function ( box ) {\r\n\t\r\n\t\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n\t\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\r\n\t\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn false;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetParameter: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\t// This can potentially have a divide by zero if the box\r\n\t\t\t// has a size dimension of 0.\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\treturn result.set(\r\n\t\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\r\n\t\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\r\n\t\t\t);\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsBox: function ( box ) {\r\n\t\r\n\t\t\t// using 6 splitting planes to rule out intersections.\r\n\t\r\n\t\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t\t\t\t box.max.y < this.min.y || box.min.y > this.max.y ||\r\n\t\t\t\t\t box.max.z < this.min.z || box.min.z > this.max.z ) {\r\n\t\r\n\t\t\t\treturn false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsSphere: ( function () {\r\n\t\r\n\t\t\tvar closestPoint;\r\n\t\r\n\t\t\treturn function intersectsSphere( sphere ) {\r\n\t\r\n\t\t\t\tif ( closestPoint === undefined ) closestPoint = new THREE.Vector3();\r\n\t\r\n\t\t\t\t// Find the point on the AABB closest to the sphere center.\r\n\t\t\t\tthis.clampPoint( sphere.center, closestPoint );\r\n\t\r\n\t\t\t\t// If that point is inside the sphere, the AABB and sphere intersect.\r\n\t\t\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )(),\r\n\t\r\n\t\tintersectsPlane: function ( plane ) {\r\n\t\r\n\t\t\t// We compute the minimum and maximum dot product values. If those values\r\n\t\t\t// are on the same side (back or front) of the plane, then there is no intersection.\r\n\t\r\n\t\t\tvar min, max;\r\n\t\r\n\t\t\tif ( plane.normal.x > 0 ) {\r\n\t\r\n\t\t\t\tmin = plane.normal.x * this.min.x;\r\n\t\t\t\tmax = plane.normal.x * this.max.x;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tmin = plane.normal.x * this.max.x;\r\n\t\t\t\tmax = plane.normal.x * this.min.x;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( plane.normal.y > 0 ) {\r\n\t\r\n\t\t\t\tmin += plane.normal.y * this.min.y;\r\n\t\t\t\tmax += plane.normal.y * this.max.y;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tmin += plane.normal.y * this.max.y;\r\n\t\t\t\tmax += plane.normal.y * this.min.y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( plane.normal.z > 0 ) {\r\n\t\r\n\t\t\t\tmin += plane.normal.z * this.min.z;\r\n\t\t\t\tmax += plane.normal.z * this.max.z;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tmin += plane.normal.z * this.max.z;\r\n\t\t\t\tmax += plane.normal.z * this.min.z;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn ( min <= plane.constant && max >= plane.constant );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclampPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.copy( point ).clamp( this.min, this.max );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToPoint: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( point ) {\r\n\t\r\n\t\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n\t\t\t\treturn clampedPoint.sub( point ).length();\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tgetBoundingSphere: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( optionalTarget ) {\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Sphere();\r\n\t\r\n\t\t\t\tresult.center = this.center();\r\n\t\t\t\tresult.radius = this.size( v1 ).length() * 0.5;\r\n\t\r\n\t\t\t\treturn result;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tintersect: function ( box ) {\r\n\t\r\n\t\t\tthis.min.max( box.min );\r\n\t\t\tthis.max.min( box.max );\r\n\t\r\n\t\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\r\n\t\t\tif( this.isEmpty() ) this.makeEmpty();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tunion: function ( box ) {\r\n\t\r\n\t\t\tthis.min.min( box.min );\r\n\t\t\tthis.max.max( box.max );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix4: function () {\r\n\t\r\n\t\t\tvar points = [\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3(),\r\n\t\t\t\tnew THREE.Vector3()\r\n\t\t\t];\r\n\t\r\n\t\t\treturn function ( matrix ) {\r\n\t\r\n\t\t\t\t// transform of empty box is an empty box.\r\n\t\t\t\tif( this.isEmpty() ) return this;\r\n\t\r\n\t\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\r\n\t\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\r\n\t\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\r\n\t\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\r\n\t\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\r\n\t\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\r\n\t\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\r\n\t\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\r\n\t\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );\t// 111\r\n\t\r\n\t\t\t\tthis.setFromPoints( points );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslate: function ( offset ) {\r\n\t\r\n\t\t\tthis.min.add( offset );\r\n\t\t\tthis.max.add( offset );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( box ) {\r\n\t\r\n\t\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Matrix3.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t * @author bhouston / http://clara.io\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.Matrix3 = function () {\r\n\t\r\n\t\tthis.elements = new Float32Array( [\r\n\t\r\n\t\t\t1, 0, 0,\r\n\t\t\t0, 1, 0,\r\n\t\t\t0, 0, 1\r\n\t\r\n\t\t] );\r\n\t\r\n\t\tif ( arguments.length > 0 ) {\r\n\t\r\n\t\t\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Matrix3.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Matrix3,\r\n\t\r\n\t\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\r\n\t\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\r\n\t\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tidentity: function () {\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\t1, 0, 0,\r\n\t\t\t\t0, 1, 0,\r\n\t\t\t\t0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().fromArray( this.elements );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( m ) {\r\n\t\r\n\t\t\tvar me = m.elements;\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\tme[ 0 ], me[ 3 ], me[ 6 ],\r\n\t\t\t\tme[ 1 ], me[ 4 ], me[ 7 ],\r\n\t\t\t\tme[ 2 ], me[ 5 ], me[ 8 ]\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromMatrix4: function( m ) {\r\n\t\r\n\t\t\tvar me = m.elements;\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\tme[ 0 ], me[ 4 ], me[  8 ],\r\n\t\t\t\tme[ 1 ], me[ 5 ], me[  9 ],\r\n\t\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyToVector3Array: function () {\r\n\t\r\n\t\t\tvar v1;\r\n\t\r\n\t\t\treturn function ( array, offset, length ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\t\tif ( length === undefined ) length = array.length;\r\n\t\r\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\r\n\t\r\n\t\t\t\t\tv1.fromArray( array, j );\r\n\t\t\t\t\tv1.applyMatrix3( this );\r\n\t\t\t\t\tv1.toArray( array, j );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn array;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tapplyToBuffer: function () {\r\n\t\r\n\t\t\tvar v1;\r\n\t\r\n\t\t\treturn function applyToBuffer( buffer, offset, length ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\r\n\t\r\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\r\n\t\r\n\t\t\t\t\tv1.x = buffer.getX( j );\r\n\t\t\t\t\tv1.y = buffer.getY( j );\r\n\t\t\t\t\tv1.z = buffer.getZ( j );\r\n\t\r\n\t\t\t\t\tv1.applyMatrix3( this );\r\n\t\r\n\t\t\t\t\tbuffer.setXYZ( v1.x, v1.y, v1.z );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn buffer;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tmultiplyScalar: function ( s ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\r\n\t\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\r\n\t\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdeterminant: function () {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\r\n\t\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\r\n\t\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\r\n\t\r\n\t\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetInverse: function ( matrix, throwOnDegenerate ) {\r\n\t\r\n\t\t\tif ( matrix instanceof THREE.Matrix4 ) {\r\n\t\r\n\t\t\t\tconsole.error( \"THREE.Matrix3.getInverse no longer takes a Matrix4 argument.\" );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar me = matrix.elements,\r\n\t\t\t\tte = this.elements,\r\n\t\r\n\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\r\n\t\t\t\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\r\n\t\t\t\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\r\n\t\r\n\t\t\t\tt11 = n33 * n22 - n32 * n23,\r\n\t\t\t\tt12 = n32 * n13 - n33 * n12,\r\n\t\t\t\tt13 = n23 * n12 - n22 * n13,\r\n\t\r\n\t\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\r\n\t\r\n\t\t\tif ( det === 0 ) {\r\n\t\r\n\t\t\t\tvar msg = \"THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0\";\r\n\t\r\n\t\t\t\tif ( throwOnDegenerate || false ) {\r\n\t\r\n\t\t\t\t\tthrow new Error( msg );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tconsole.warn( msg );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn this.identity();\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar detInv = 1 / det;\r\n\t\r\n\t\t\tte[ 0 ] = t11 * detInv;\r\n\t\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\r\n\t\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\r\n\t\r\n\t\t\tte[ 3 ] = t12 * detInv;\r\n\t\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\r\n\t\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\r\n\t\r\n\t\t\tte[ 6 ] = t13 * detInv;\r\n\t\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\r\n\t\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttranspose: function () {\r\n\t\r\n\t\t\tvar tmp, m = this.elements;\r\n\t\r\n\t\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\r\n\t\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\r\n\t\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tflattenToArrayOffset: function ( array, offset ) {\r\n\t\r\n\t\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\r\n\t\t\t\t\t\"- just use .toArray instead.\" );\r\n\t\r\n\t\t\treturn this.toArray( array, offset );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetNormalMatrix: function ( matrix4 ) {\r\n\t\r\n\t\t\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttransposeIntoArray: function ( r ) {\r\n\t\r\n\t\t\tvar m = this.elements;\r\n\t\r\n\t\t\tr[ 0 ] = m[ 0 ];\r\n\t\t\tr[ 1 ] = m[ 3 ];\r\n\t\t\tr[ 2 ] = m[ 6 ];\r\n\t\t\tr[ 3 ] = m[ 1 ];\r\n\t\t\tr[ 4 ] = m[ 4 ];\r\n\t\t\tr[ 5 ] = m[ 7 ];\r\n\t\t\tr[ 6 ] = m[ 2 ];\r\n\t\t\tr[ 7 ] = m[ 5 ];\r\n\t\t\tr[ 8 ] = m[ 8 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array ) {\r\n\t\r\n\t\t\tthis.elements.set( array );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tarray[ offset ] = te[ 0 ];\r\n\t\t\tarray[ offset + 1 ] = te[ 1 ];\r\n\t\t\tarray[ offset + 2 ] = te[ 2 ];\r\n\t\r\n\t\t\tarray[ offset + 3 ] = te[ 3 ];\r\n\t\t\tarray[ offset + 4 ] = te[ 4 ];\r\n\t\t\tarray[ offset + 5 ] = te[ 5 ];\r\n\t\r\n\t\t\tarray[ offset + 6 ] = te[ 6 ];\r\n\t\t\tarray[ offset + 7 ] = te[ 7 ];\r\n\t\t\tarray[ offset + 8 ]  = te[ 8 ];\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Matrix4.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\r\n\t * @author philogb / http://blog.thejit.org/\r\n\t * @author jordi_ros / http://plattsoft.com\r\n\t * @author D1plo1d / http://github.com/D1plo1d\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author timknip / http://www.floorplanner.com/\r\n\t * @author bhouston / http://clara.io\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\tTHREE.Matrix4 = function () {\r\n\t\r\n\t\tthis.elements = new Float32Array( [\r\n\t\r\n\t\t\t1, 0, 0, 0,\r\n\t\t\t0, 1, 0, 0,\r\n\t\t\t0, 0, 1, 0,\r\n\t\t\t0, 0, 0, 1\r\n\t\r\n\t\t] );\r\n\t\r\n\t\tif ( arguments.length > 0 ) {\r\n\t\r\n\t\t\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Matrix4.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Matrix4,\r\n\t\r\n\t\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\r\n\t\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\r\n\t\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\r\n\t\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tidentity: function () {\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\t1, 0, 0, 0,\r\n\t\t\t\t0, 1, 0, 0,\r\n\t\t\t\t0, 0, 1, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Matrix4().fromArray( this.elements );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( m ) {\r\n\t\r\n\t\t\tthis.elements.set( m.elements );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyPosition: function ( m ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar me = m.elements;\r\n\t\r\n\t\t\tte[ 12 ] = me[ 12 ];\r\n\t\t\tte[ 13 ] = me[ 13 ];\r\n\t\t\tte[ 14 ] = me[ 14 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\textractBasis: function ( xAxis, yAxis, zAxis ) {\r\n\t\r\n\t\t\txAxis.setFromMatrixColumn( this, 0 );\r\n\t\t\tyAxis.setFromMatrixColumn( this, 1 );\r\n\t\t\tzAxis.setFromMatrixColumn( this, 2 );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\r\n\t\r\n\t\t\tthis.set(\r\n\t\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\r\n\t\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\r\n\t\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\r\n\t\t\t\t0,       0,       0,       1\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\textractRotation: function () {\r\n\t\r\n\t\t\tvar v1;\r\n\t\r\n\t\t\treturn function ( m ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\r\n\t\t\t\tvar te = this.elements;\r\n\t\t\t\tvar me = m.elements;\r\n\t\r\n\t\t\t\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\r\n\t\t\t\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\r\n\t\t\t\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\r\n\t\r\n\t\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\r\n\t\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\r\n\t\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\r\n\t\r\n\t\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\r\n\t\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\r\n\t\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\r\n\t\r\n\t\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\r\n\t\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\r\n\t\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tmakeRotationFromEuler: function ( euler ) {\r\n\t\r\n\t\t\tif ( euler instanceof THREE.Euler === false ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tvar x = euler.x, y = euler.y, z = euler.z;\r\n\t\t\tvar a = Math.cos( x ), b = Math.sin( x );\r\n\t\t\tvar c = Math.cos( y ), d = Math.sin( y );\r\n\t\t\tvar e = Math.cos( z ), f = Math.sin( z );\r\n\t\r\n\t\t\tif ( euler.order === 'XYZ' ) {\r\n\t\r\n\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\t\r\n\t\t\t\tte[ 0 ] = c * e;\r\n\t\t\t\tte[ 4 ] = - c * f;\r\n\t\t\t\tte[ 8 ] = d;\r\n\t\r\n\t\t\t\tte[ 1 ] = af + be * d;\r\n\t\t\t\tte[ 5 ] = ae - bf * d;\r\n\t\t\t\tte[ 9 ] = - b * c;\r\n\t\r\n\t\t\t\tte[ 2 ] = bf - ae * d;\r\n\t\t\t\tte[ 6 ] = be + af * d;\r\n\t\t\t\tte[ 10 ] = a * c;\r\n\t\r\n\t\t\t} else if ( euler.order === 'YXZ' ) {\r\n\t\r\n\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\t\r\n\t\t\t\tte[ 0 ] = ce + df * b;\r\n\t\t\t\tte[ 4 ] = de * b - cf;\r\n\t\t\t\tte[ 8 ] = a * d;\r\n\t\r\n\t\t\t\tte[ 1 ] = a * f;\r\n\t\t\t\tte[ 5 ] = a * e;\r\n\t\t\t\tte[ 9 ] = - b;\r\n\t\r\n\t\t\t\tte[ 2 ] = cf * b - de;\r\n\t\t\t\tte[ 6 ] = df + ce * b;\r\n\t\t\t\tte[ 10 ] = a * c;\r\n\t\r\n\t\t\t} else if ( euler.order === 'ZXY' ) {\r\n\t\r\n\t\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\t\r\n\t\t\t\tte[ 0 ] = ce - df * b;\r\n\t\t\t\tte[ 4 ] = - a * f;\r\n\t\t\t\tte[ 8 ] = de + cf * b;\r\n\t\r\n\t\t\t\tte[ 1 ] = cf + de * b;\r\n\t\t\t\tte[ 5 ] = a * e;\r\n\t\t\t\tte[ 9 ] = df - ce * b;\r\n\t\r\n\t\t\t\tte[ 2 ] = - a * d;\r\n\t\t\t\tte[ 6 ] = b;\r\n\t\t\t\tte[ 10 ] = a * c;\r\n\t\r\n\t\t\t} else if ( euler.order === 'ZYX' ) {\r\n\t\r\n\t\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\t\r\n\t\t\t\tte[ 0 ] = c * e;\r\n\t\t\t\tte[ 4 ] = be * d - af;\r\n\t\t\t\tte[ 8 ] = ae * d + bf;\r\n\t\r\n\t\t\t\tte[ 1 ] = c * f;\r\n\t\t\t\tte[ 5 ] = bf * d + ae;\r\n\t\t\t\tte[ 9 ] = af * d - be;\r\n\t\r\n\t\t\t\tte[ 2 ] = - d;\r\n\t\t\t\tte[ 6 ] = b * c;\r\n\t\t\t\tte[ 10 ] = a * c;\r\n\t\r\n\t\t\t} else if ( euler.order === 'YZX' ) {\r\n\t\r\n\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\t\r\n\t\t\t\tte[ 0 ] = c * e;\r\n\t\t\t\tte[ 4 ] = bd - ac * f;\r\n\t\t\t\tte[ 8 ] = bc * f + ad;\r\n\t\r\n\t\t\t\tte[ 1 ] = f;\r\n\t\t\t\tte[ 5 ] = a * e;\r\n\t\t\t\tte[ 9 ] = - b * e;\r\n\t\r\n\t\t\t\tte[ 2 ] = - d * e;\r\n\t\t\t\tte[ 6 ] = ad * f + bc;\r\n\t\t\t\tte[ 10 ] = ac - bd * f;\r\n\t\r\n\t\t\t} else if ( euler.order === 'XZY' ) {\r\n\t\r\n\t\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\t\r\n\t\t\t\tte[ 0 ] = c * e;\r\n\t\t\t\tte[ 4 ] = - f;\r\n\t\t\t\tte[ 8 ] = d * e;\r\n\t\r\n\t\t\t\tte[ 1 ] = ac * f + bd;\r\n\t\t\t\tte[ 5 ] = a * e;\r\n\t\t\t\tte[ 9 ] = ad * f - bc;\r\n\t\r\n\t\t\t\tte[ 2 ] = bc * f - ad;\r\n\t\t\t\tte[ 6 ] = b * e;\r\n\t\t\t\tte[ 10 ] = bd * f + ac;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// last column\r\n\t\t\tte[ 3 ] = 0;\r\n\t\t\tte[ 7 ] = 0;\r\n\t\t\tte[ 11 ] = 0;\r\n\t\r\n\t\t\t// bottom row\r\n\t\t\tte[ 12 ] = 0;\r\n\t\t\tte[ 13 ] = 0;\r\n\t\t\tte[ 14 ] = 0;\r\n\t\t\tte[ 15 ] = 1;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeRotationFromQuaternion: function ( q ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\r\n\t\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\r\n\t\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\r\n\t\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\r\n\t\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\r\n\t\r\n\t\t\tte[ 0 ] = 1 - ( yy + zz );\r\n\t\t\tte[ 4 ] = xy - wz;\r\n\t\t\tte[ 8 ] = xz + wy;\r\n\t\r\n\t\t\tte[ 1 ] = xy + wz;\r\n\t\t\tte[ 5 ] = 1 - ( xx + zz );\r\n\t\t\tte[ 9 ] = yz - wx;\r\n\t\r\n\t\t\tte[ 2 ] = xz - wy;\r\n\t\t\tte[ 6 ] = yz + wx;\r\n\t\t\tte[ 10 ] = 1 - ( xx + yy );\r\n\t\r\n\t\t\t// last column\r\n\t\t\tte[ 3 ] = 0;\r\n\t\t\tte[ 7 ] = 0;\r\n\t\t\tte[ 11 ] = 0;\r\n\t\r\n\t\t\t// bottom row\r\n\t\t\tte[ 12 ] = 0;\r\n\t\t\tte[ 13 ] = 0;\r\n\t\t\tte[ 14 ] = 0;\r\n\t\t\tte[ 15 ] = 1;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlookAt: function () {\r\n\t\r\n\t\t\tvar x, y, z;\r\n\t\r\n\t\t\treturn function ( eye, target, up ) {\r\n\t\r\n\t\t\t\tif ( x === undefined ) {\r\n\t\r\n\t\t\t\t\tx = new THREE.Vector3();\r\n\t\t\t\t\ty = new THREE.Vector3();\r\n\t\t\t\t\tz = new THREE.Vector3();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\t\tz.subVectors( eye, target ).normalize();\r\n\t\r\n\t\t\t\tif ( z.lengthSq() === 0 ) {\r\n\t\r\n\t\t\t\t\tz.z = 1;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tx.crossVectors( up, z ).normalize();\r\n\t\r\n\t\t\t\tif ( x.lengthSq() === 0 ) {\r\n\t\r\n\t\t\t\t\tz.z += 0.0001;\r\n\t\t\t\t\tx.crossVectors( up, z ).normalize();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\ty.crossVectors( z, x );\r\n\t\r\n\t\r\n\t\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\r\n\t\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\r\n\t\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tmultiply: function ( m, n ) {\r\n\t\r\n\t\t\tif ( n !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\r\n\t\t\t\treturn this.multiplyMatrices( m, n );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this.multiplyMatrices( this, m );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tpremultiply: function ( m ) {\r\n\t\r\n\t\t\treturn this.multiplyMatrices( m, this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyMatrices: function ( a, b ) {\r\n\t\r\n\t\t\tvar ae = a.elements;\r\n\t\t\tvar be = b.elements;\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\r\n\t\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\r\n\t\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\r\n\t\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\r\n\t\r\n\t\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\r\n\t\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\r\n\t\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\r\n\t\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\r\n\t\r\n\t\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\r\n\t\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\r\n\t\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\r\n\t\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\r\n\t\r\n\t\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\r\n\t\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\r\n\t\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\r\n\t\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\r\n\t\r\n\t\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\r\n\t\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\r\n\t\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\r\n\t\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\r\n\t\r\n\t\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\r\n\t\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\r\n\t\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\r\n\t\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyToArray: function ( a, b, r ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tthis.multiplyMatrices( a, b );\r\n\t\r\n\t\t\tr[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];\r\n\t\t\tr[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];\r\n\t\t\tr[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];\r\n\t\t\tr[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmultiplyScalar: function ( s ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\r\n\t\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\r\n\t\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\r\n\t\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyToVector3Array: function () {\r\n\t\r\n\t\t\tvar v1;\r\n\t\r\n\t\t\treturn function ( array, offset, length ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\t\tif ( length === undefined ) length = array.length;\r\n\t\r\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\r\n\t\r\n\t\t\t\t\tv1.fromArray( array, j );\r\n\t\t\t\t\tv1.applyMatrix4( this );\r\n\t\t\t\t\tv1.toArray( array, j );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn array;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tapplyToBuffer: function () {\r\n\t\r\n\t\t\tvar v1;\r\n\t\r\n\t\t\treturn function applyToBuffer( buffer, offset, length ) {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\r\n\t\r\n\t\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\r\n\t\r\n\t\t\t\t\tv1.x = buffer.getX( j );\r\n\t\t\t\t\tv1.y = buffer.getY( j );\r\n\t\t\t\t\tv1.z = buffer.getZ( j );\r\n\t\r\n\t\t\t\t\tv1.applyMatrix4( this );\r\n\t\r\n\t\t\t\t\tbuffer.setXYZ( v1.x, v1.y, v1.z );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn buffer;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tdeterminant: function () {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\r\n\t\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\r\n\t\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\r\n\t\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\r\n\t\r\n\t\t\t//TODO: make this more efficient\r\n\t\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\r\n\t\r\n\t\t\treturn (\r\n\t\t\t\tn41 * (\r\n\t\t\t\t\t+ n14 * n23 * n32\r\n\t\t\t\t\t - n13 * n24 * n32\r\n\t\t\t\t\t - n14 * n22 * n33\r\n\t\t\t\t\t + n12 * n24 * n33\r\n\t\t\t\t\t + n13 * n22 * n34\r\n\t\t\t\t\t - n12 * n23 * n34\r\n\t\t\t\t) +\r\n\t\t\t\tn42 * (\r\n\t\t\t\t\t+ n11 * n23 * n34\r\n\t\t\t\t\t - n11 * n24 * n33\r\n\t\t\t\t\t + n14 * n21 * n33\r\n\t\t\t\t\t - n13 * n21 * n34\r\n\t\t\t\t\t + n13 * n24 * n31\r\n\t\t\t\t\t - n14 * n23 * n31\r\n\t\t\t\t) +\r\n\t\t\t\tn43 * (\r\n\t\t\t\t\t+ n11 * n24 * n32\r\n\t\t\t\t\t - n11 * n22 * n34\r\n\t\t\t\t\t - n14 * n21 * n32\r\n\t\t\t\t\t + n12 * n21 * n34\r\n\t\t\t\t\t + n14 * n22 * n31\r\n\t\t\t\t\t - n12 * n24 * n31\r\n\t\t\t\t) +\r\n\t\t\t\tn44 * (\r\n\t\t\t\t\t- n13 * n22 * n31\r\n\t\t\t\t\t - n11 * n23 * n32\r\n\t\t\t\t\t + n11 * n22 * n33\r\n\t\t\t\t\t + n13 * n21 * n32\r\n\t\t\t\t\t - n12 * n21 * n33\r\n\t\t\t\t\t + n12 * n23 * n31\r\n\t\t\t\t)\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttranspose: function () {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar tmp;\r\n\t\r\n\t\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\r\n\t\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\r\n\t\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\r\n\t\r\n\t\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\r\n\t\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\r\n\t\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tflattenToArrayOffset: function ( array, offset ) {\r\n\t\r\n\t\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\r\n\t\t\t\t\t\"- just use .toArray instead.\" );\r\n\t\r\n\t\t\treturn this.toArray( array, offset );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetPosition: function () {\r\n\t\r\n\t\t\tvar v1;\r\n\t\r\n\t\t\treturn function () {\r\n\t\r\n\t\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\t\t\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\r\n\t\r\n\t\t\t\treturn v1.setFromMatrixColumn( this, 3 );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tsetPosition: function ( v ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tte[ 12 ] = v.x;\r\n\t\t\tte[ 13 ] = v.y;\r\n\t\t\tte[ 14 ] = v.z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetInverse: function ( m, throwOnDegenerate ) {\r\n\t\r\n\t\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\r\n\t\t\tvar te = this.elements,\r\n\t\t\t\tme = m.elements,\r\n\t\r\n\t\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\r\n\t\t\t\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\r\n\t\t\t\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\r\n\t\t\t\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\r\n\t\r\n\t\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\r\n\t\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\r\n\t\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\r\n\t\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\r\n\t\r\n\t\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\r\n\t\r\n\t\t\tif ( det === 0 ) {\r\n\t\r\n\t\t\t\tvar msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\r\n\t\r\n\t\t\t\tif ( throwOnDegenerate || false ) {\r\n\t\r\n\t\t\t\t\tthrow new Error( msg );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tconsole.warn( msg );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn this.identity();\r\n\t\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tvar detInv = 1 / det;\r\n\t\r\n\t\t\tte[ 0 ] = t11 * detInv;\r\n\t\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\r\n\t\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\r\n\t\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\r\n\t\r\n\t\t\tte[ 4 ] = t12 * detInv;\r\n\t\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\r\n\t\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\r\n\t\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\r\n\t\r\n\t\t\tte[ 8 ] = t13 * detInv;\r\n\t\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\r\n\t\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\r\n\t\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\r\n\t\r\n\t\t\tte[ 12 ] = t14 * detInv;\r\n\t\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\r\n\t\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\r\n\t\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tscale: function ( v ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar x = v.x, y = v.y, z = v.z;\r\n\t\r\n\t\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\r\n\t\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\r\n\t\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\r\n\t\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetMaxScaleOnAxis: function () {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\r\n\t\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\r\n\t\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\r\n\t\r\n\t\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeTranslation: function ( x, y, z ) {\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\t1, 0, 0, x,\r\n\t\t\t\t0, 1, 0, y,\r\n\t\t\t\t0, 0, 1, z,\r\n\t\t\t\t0, 0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeRotationX: function ( theta ) {\r\n\t\r\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\t1, 0,  0, 0,\r\n\t\t\t\t0, c, - s, 0,\r\n\t\t\t\t0, s,  c, 0,\r\n\t\t\t\t0, 0,  0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeRotationY: function ( theta ) {\r\n\t\r\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\t c, 0, s, 0,\r\n\t\t\t\t 0, 1, 0, 0,\r\n\t\t\t\t- s, 0, c, 0,\r\n\t\t\t\t 0, 0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeRotationZ: function ( theta ) {\r\n\t\r\n\t\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\tc, - s, 0, 0,\r\n\t\t\t\ts,  c, 0, 0,\r\n\t\t\t\t0,  0, 1, 0,\r\n\t\t\t\t0,  0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeRotationAxis: function ( axis, angle ) {\r\n\t\r\n\t\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\r\n\t\r\n\t\t\tvar c = Math.cos( angle );\r\n\t\t\tvar s = Math.sin( angle );\r\n\t\t\tvar t = 1 - c;\r\n\t\t\tvar x = axis.x, y = axis.y, z = axis.z;\r\n\t\t\tvar tx = t * x, ty = t * y;\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\r\n\t\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\r\n\t\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\t return this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeScale: function ( x, y, z ) {\r\n\t\r\n\t\t\tthis.set(\r\n\t\r\n\t\t\t\tx, 0, 0, 0,\r\n\t\t\t\t0, y, 0, 0,\r\n\t\t\t\t0, 0, z, 0,\r\n\t\t\t\t0, 0, 0, 1\r\n\t\r\n\t\t\t);\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcompose: function ( position, quaternion, scale ) {\r\n\t\r\n\t\t\tthis.makeRotationFromQuaternion( quaternion );\r\n\t\t\tthis.scale( scale );\r\n\t\t\tthis.setPosition( position );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdecompose: function () {\r\n\t\r\n\t\t\tvar vector, matrix;\r\n\t\r\n\t\t\treturn function ( position, quaternion, scale ) {\r\n\t\r\n\t\t\t\tif ( vector === undefined ) {\r\n\t\r\n\t\t\t\t\tvector = new THREE.Vector3();\r\n\t\t\t\t\tmatrix = new THREE.Matrix4();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\r\n\t\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\r\n\t\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\r\n\t\r\n\t\t\t\t// if determine is negative, we need to invert one scale\r\n\t\t\t\tvar det = this.determinant();\r\n\t\t\t\tif ( det < 0 ) {\r\n\t\r\n\t\t\t\t\tsx = - sx;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tposition.x = te[ 12 ];\r\n\t\t\t\tposition.y = te[ 13 ];\r\n\t\t\t\tposition.z = te[ 14 ];\r\n\t\r\n\t\t\t\t// scale the rotation part\r\n\t\r\n\t\t\t\tmatrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\r\n\t\r\n\t\t\t\tvar invSX = 1 / sx;\r\n\t\t\t\tvar invSY = 1 / sy;\r\n\t\t\t\tvar invSZ = 1 / sz;\r\n\t\r\n\t\t\t\tmatrix.elements[ 0 ] *= invSX;\r\n\t\t\t\tmatrix.elements[ 1 ] *= invSX;\r\n\t\t\t\tmatrix.elements[ 2 ] *= invSX;\r\n\t\r\n\t\t\t\tmatrix.elements[ 4 ] *= invSY;\r\n\t\t\t\tmatrix.elements[ 5 ] *= invSY;\r\n\t\t\t\tmatrix.elements[ 6 ] *= invSY;\r\n\t\r\n\t\t\t\tmatrix.elements[ 8 ] *= invSZ;\r\n\t\t\t\tmatrix.elements[ 9 ] *= invSZ;\r\n\t\t\t\tmatrix.elements[ 10 ] *= invSZ;\r\n\t\r\n\t\t\t\tquaternion.setFromRotationMatrix( matrix );\r\n\t\r\n\t\t\t\tscale.x = sx;\r\n\t\t\t\tscale.y = sy;\r\n\t\t\t\tscale.z = sz;\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar x = 2 * near / ( right - left );\r\n\t\t\tvar y = 2 * near / ( top - bottom );\r\n\t\r\n\t\t\tvar a = ( right + left ) / ( right - left );\r\n\t\t\tvar b = ( top + bottom ) / ( top - bottom );\r\n\t\t\tvar c = - ( far + near ) / ( far - near );\r\n\t\t\tvar d = - 2 * far * near / ( far - near );\r\n\t\r\n\t\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\r\n\t\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\r\n\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\r\n\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakePerspective: function ( fov, aspect, near, far ) {\r\n\t\r\n\t\t\tvar ymax = near * Math.tan( THREE.Math.DEG2RAD * fov * 0.5 );\r\n\t\t\tvar ymin = - ymax;\r\n\t\t\tvar xmin = ymin * aspect;\r\n\t\t\tvar xmax = ymax * aspect;\r\n\t\r\n\t\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar w = 1.0 / ( right - left );\r\n\t\t\tvar h = 1.0 / ( top - bottom );\r\n\t\t\tvar p = 1.0 / ( far - near );\r\n\t\r\n\t\t\tvar x = ( right + left ) * w;\r\n\t\t\tvar y = ( top + bottom ) * h;\r\n\t\t\tvar z = ( far + near ) * p;\r\n\t\r\n\t\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\r\n\t\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\r\n\t\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\r\n\t\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( matrix ) {\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar me = matrix.elements;\r\n\t\r\n\t\t\tfor ( var i = 0; i < 16; i ++ ) {\r\n\t\r\n\t\t\t\tif ( te[ i ] !== me[ i ] ) return false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromArray: function ( array ) {\r\n\t\r\n\t\t\tthis.elements.set( array );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoArray: function ( array, offset ) {\r\n\t\r\n\t\t\tif ( array === undefined ) array = [];\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tvar te = this.elements;\r\n\t\r\n\t\t\tarray[ offset ] = te[ 0 ];\r\n\t\t\tarray[ offset + 1 ] = te[ 1 ];\r\n\t\t\tarray[ offset + 2 ] = te[ 2 ];\r\n\t\t\tarray[ offset + 3 ] = te[ 3 ];\r\n\t\r\n\t\t\tarray[ offset + 4 ] = te[ 4 ];\r\n\t\t\tarray[ offset + 5 ] = te[ 5 ];\r\n\t\t\tarray[ offset + 6 ] = te[ 6 ];\r\n\t\t\tarray[ offset + 7 ] = te[ 7 ];\r\n\t\r\n\t\t\tarray[ offset + 8 ]  = te[ 8 ];\r\n\t\t\tarray[ offset + 9 ]  = te[ 9 ];\r\n\t\t\tarray[ offset + 10 ] = te[ 10 ];\r\n\t\t\tarray[ offset + 11 ] = te[ 11 ];\r\n\t\r\n\t\t\tarray[ offset + 12 ] = te[ 12 ];\r\n\t\t\tarray[ offset + 13 ] = te[ 13 ];\r\n\t\t\tarray[ offset + 14 ] = te[ 14 ];\r\n\t\t\tarray[ offset + 15 ] = te[ 15 ];\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Ray.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://clara.io\r\n\t */\r\n\t\r\n\tTHREE.Ray = function ( origin, direction ) {\r\n\t\r\n\t\tthis.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();\r\n\t\tthis.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Ray.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Ray,\r\n\t\r\n\t\tset: function ( origin, direction ) {\r\n\t\r\n\t\t\tthis.origin.copy( origin );\r\n\t\t\tthis.direction.copy( direction );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( ray ) {\r\n\t\r\n\t\t\tthis.origin.copy( ray.origin );\r\n\t\t\tthis.direction.copy( ray.direction );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tat: function ( t, optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlookAt: function ( v ) {\r\n\t\r\n\t\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\trecast: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( t ) {\r\n\t\r\n\t\t\t\tthis.origin.copy( this.at( t, v1 ) );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclosestPointToPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\tresult.subVectors( point, this.origin );\r\n\t\t\tvar directionDistance = result.dot( this.direction );\r\n\t\r\n\t\t\tif ( directionDistance < 0 ) {\r\n\t\r\n\t\t\t\treturn result.copy( this.origin );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToPoint: function ( point ) {\r\n\t\r\n\t\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceSqToPoint: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( point ) {\r\n\t\r\n\t\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\r\n\t\r\n\t\t\t\t// point behind the ray\r\n\t\r\n\t\t\t\tif ( directionDistance < 0 ) {\r\n\t\r\n\t\t\t\t\treturn this.origin.distanceToSquared( point );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\t\r\n\t\t\t\treturn v1.distanceToSquared( point );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tdistanceSqToSegment: function () {\r\n\t\r\n\t\t\tvar segCenter = new THREE.Vector3();\r\n\t\t\tvar segDir = new THREE.Vector3();\r\n\t\t\tvar diff = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\r\n\t\r\n\t\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\r\n\t\t\t\t// It returns the min distance between the ray and the segment\r\n\t\t\t\t// defined by v0 and v1\r\n\t\t\t\t// It can also set two optional targets :\r\n\t\t\t\t// - The closest point on the ray\r\n\t\t\t\t// - The closest point on the segment\r\n\t\r\n\t\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\r\n\t\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\r\n\t\t\t\tdiff.copy( this.origin ).sub( segCenter );\r\n\t\r\n\t\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\r\n\t\t\t\tvar a01 = - this.direction.dot( segDir );\r\n\t\t\t\tvar b0 = diff.dot( this.direction );\r\n\t\t\t\tvar b1 = - diff.dot( segDir );\r\n\t\t\t\tvar c = diff.lengthSq();\r\n\t\t\t\tvar det = Math.abs( 1 - a01 * a01 );\r\n\t\t\t\tvar s0, s1, sqrDist, extDet;\r\n\t\r\n\t\t\t\tif ( det > 0 ) {\r\n\t\r\n\t\t\t\t\t// The ray and segment are not parallel.\r\n\t\r\n\t\t\t\t\ts0 = a01 * b1 - b0;\r\n\t\t\t\t\ts1 = a01 * b0 - b1;\r\n\t\t\t\t\textDet = segExtent * det;\r\n\t\r\n\t\t\t\t\tif ( s0 >= 0 ) {\r\n\t\r\n\t\t\t\t\t\tif ( s1 >= - extDet ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( s1 <= extDet ) {\r\n\t\r\n\t\t\t\t\t\t\t\t// region 0\r\n\t\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\r\n\t\r\n\t\t\t\t\t\t\t\tvar invDet = 1 / det;\r\n\t\t\t\t\t\t\t\ts0 *= invDet;\r\n\t\t\t\t\t\t\t\ts1 *= invDet;\r\n\t\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\t// region 1\r\n\t\r\n\t\t\t\t\t\t\t\ts1 = segExtent;\r\n\t\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t// region 5\r\n\t\r\n\t\t\t\t\t\t\ts1 = - segExtent;\r\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tif ( s1 <= - extDet ) {\r\n\t\r\n\t\t\t\t\t\t\t// region 4\r\n\t\r\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\r\n\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t\t\t} else if ( s1 <= extDet ) {\r\n\t\r\n\t\t\t\t\t\t\t// region 3\r\n\t\r\n\t\t\t\t\t\t\ts0 = 0;\r\n\t\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t// region 2\r\n\t\r\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\r\n\t\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// Ray and segment are parallel.\r\n\t\r\n\t\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\r\n\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( optionalPointOnRay ) {\r\n\t\r\n\t\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( optionalPointOnSegment ) {\r\n\t\r\n\t\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn sqrDist;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tintersectSphere: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( sphere, optionalTarget ) {\r\n\t\r\n\t\t\t\tv1.subVectors( sphere.center, this.origin );\r\n\t\t\t\tvar tca = v1.dot( this.direction );\r\n\t\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\r\n\t\t\t\tvar radius2 = sphere.radius * sphere.radius;\r\n\t\r\n\t\t\t\tif ( d2 > radius2 ) return null;\r\n\t\r\n\t\t\t\tvar thc = Math.sqrt( radius2 - d2 );\r\n\t\r\n\t\t\t\t// t0 = first intersect point - entrance on front of sphere\r\n\t\t\t\tvar t0 = tca - thc;\r\n\t\r\n\t\t\t\t// t1 = second intersect point - exit point on back of sphere\r\n\t\t\t\tvar t1 = tca + thc;\r\n\t\r\n\t\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\r\n\t\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\r\n\t\r\n\t\t\t\t// test to see if t0 is behind the ray:\r\n\t\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\r\n\t\t\t\t// in order to always return an intersect point that is in front of the ray.\r\n\t\t\t\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\r\n\t\r\n\t\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\r\n\t\t\t\treturn this.at( t0, optionalTarget );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tintersectsSphere: function ( sphere ) {\r\n\t\r\n\t\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToPlane: function ( plane ) {\r\n\t\r\n\t\t\tvar denominator = plane.normal.dot( this.direction );\r\n\t\r\n\t\t\tif ( denominator === 0 ) {\r\n\t\r\n\t\t\t\t// line is coplanar, return origin\r\n\t\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\r\n\t\r\n\t\t\t\t\treturn 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\r\n\t\r\n\t\t\t\treturn null;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\r\n\t\r\n\t\t\t// Return if the ray never intersects the plane\r\n\t\r\n\t\t\treturn t >= 0 ? t :  null;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectPlane: function ( plane, optionalTarget ) {\r\n\t\r\n\t\t\tvar t = this.distanceToPlane( plane );\r\n\t\r\n\t\t\tif ( t === null ) {\r\n\t\r\n\t\t\t\treturn null;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this.at( t, optionalTarget );\r\n\t\r\n\t\t},\r\n\t\r\n\t\r\n\t\r\n\t\tintersectsPlane: function ( plane ) {\r\n\t\r\n\t\t\t// check if the ray lies on the plane first\r\n\t\r\n\t\t\tvar distToPoint = plane.distanceToPoint( this.origin );\r\n\t\r\n\t\t\tif ( distToPoint === 0 ) {\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar denominator = plane.normal.dot( this.direction );\r\n\t\r\n\t\t\tif ( denominator * distToPoint < 0 ) {\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// ray origin is behind the plane (and is pointing behind it)\r\n\t\r\n\t\t\treturn false;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectBox: function ( box, optionalTarget ) {\r\n\t\r\n\t\t\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\r\n\t\r\n\t\t\tvar invdirx = 1 / this.direction.x,\r\n\t\t\t\tinvdiry = 1 / this.direction.y,\r\n\t\t\t\tinvdirz = 1 / this.direction.z;\r\n\t\r\n\t\t\tvar origin = this.origin;\r\n\t\r\n\t\t\tif ( invdirx >= 0 ) {\r\n\t\r\n\t\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\r\n\t\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\r\n\t\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( invdiry >= 0 ) {\r\n\t\r\n\t\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\r\n\t\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\r\n\t\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\r\n\t\r\n\t\t\t// These lines also handle the case where tmin or tmax is NaN\r\n\t\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\r\n\t\r\n\t\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\r\n\t\r\n\t\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\r\n\t\r\n\t\t\tif ( invdirz >= 0 ) {\r\n\t\r\n\t\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\r\n\t\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\r\n\t\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\r\n\t\r\n\t\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\r\n\t\r\n\t\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\r\n\t\r\n\t\t\t//return point closest to the ray (positive side)\r\n\t\r\n\t\t\tif ( tmax < 0 ) return null;\r\n\t\r\n\t\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsBox: ( function () {\r\n\t\r\n\t\t\tvar v = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( box ) {\r\n\t\r\n\t\t\t\treturn this.intersectBox( box, v ) !== null;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )(),\r\n\t\r\n\t\tintersectTriangle: function () {\r\n\t\r\n\t\t\t// Compute the offset origin, edges, and normal.\r\n\t\t\tvar diff = new THREE.Vector3();\r\n\t\t\tvar edge1 = new THREE.Vector3();\r\n\t\t\tvar edge2 = new THREE.Vector3();\r\n\t\t\tvar normal = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( a, b, c, backfaceCulling, optionalTarget ) {\r\n\t\r\n\t\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\r\n\t\r\n\t\t\t\tedge1.subVectors( b, a );\r\n\t\t\t\tedge2.subVectors( c, a );\r\n\t\t\t\tnormal.crossVectors( edge1, edge2 );\r\n\t\r\n\t\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\r\n\t\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\r\n\t\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\r\n\t\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\r\n\t\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\r\n\t\t\t\tvar DdN = this.direction.dot( normal );\r\n\t\t\t\tvar sign;\r\n\t\r\n\t\t\t\tif ( DdN > 0 ) {\r\n\t\r\n\t\t\t\t\tif ( backfaceCulling ) return null;\r\n\t\t\t\t\tsign = 1;\r\n\t\r\n\t\t\t\t} else if ( DdN < 0 ) {\r\n\t\r\n\t\t\t\t\tsign = - 1;\r\n\t\t\t\t\tDdN = - DdN;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\treturn null;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tdiff.subVectors( this.origin, a );\r\n\t\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\r\n\t\r\n\t\t\t\t// b1 < 0, no intersection\r\n\t\t\t\tif ( DdQxE2 < 0 ) {\r\n\t\r\n\t\t\t\t\treturn null;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\r\n\t\r\n\t\t\t\t// b2 < 0, no intersection\r\n\t\t\t\tif ( DdE1xQ < 0 ) {\r\n\t\r\n\t\t\t\t\treturn null;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// b1+b2 > 1, no intersection\r\n\t\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\r\n\t\r\n\t\t\t\t\treturn null;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// Line intersects triangle, check if ray does.\r\n\t\t\t\tvar QdN = - sign * diff.dot( normal );\r\n\t\r\n\t\t\t\t// t < 0, no intersection\r\n\t\t\t\tif ( QdN < 0 ) {\r\n\t\r\n\t\t\t\t\treturn null;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// Ray intersects triangle.\r\n\t\t\t\treturn this.at( QdN / DdN, optionalTarget );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tapplyMatrix4: function ( matrix4 ) {\r\n\t\r\n\t\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\r\n\t\t\tthis.origin.applyMatrix4( matrix4 );\r\n\t\t\tthis.direction.sub( this.origin );\r\n\t\t\tthis.direction.normalize();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( ray ) {\r\n\t\r\n\t\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Sphere.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://clara.io\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Sphere = function ( center, radius ) {\r\n\t\r\n\t\tthis.center = ( center !== undefined ) ? center : new THREE.Vector3();\r\n\t\tthis.radius = ( radius !== undefined ) ? radius : 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Sphere.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Sphere,\r\n\t\r\n\t\tset: function ( center, radius ) {\r\n\t\r\n\t\t\tthis.center.copy( center );\r\n\t\t\tthis.radius = radius;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromPoints: function () {\r\n\t\r\n\t\t\tvar box = new THREE.Box3();\r\n\t\r\n\t\t\treturn function ( points, optionalCenter ) {\r\n\t\r\n\t\t\t\tvar center = this.center;\r\n\t\r\n\t\t\t\tif ( optionalCenter !== undefined ) {\r\n\t\r\n\t\t\t\t\tcenter.copy( optionalCenter );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tbox.setFromPoints( points ).center( center );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar maxRadiusSq = 0;\r\n\t\r\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( sphere ) {\r\n\t\r\n\t\t\tthis.center.copy( sphere.center );\r\n\t\t\tthis.radius = sphere.radius;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tempty: function () {\r\n\t\r\n\t\t\treturn ( this.radius <= 0 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcontainsPoint: function ( point ) {\r\n\t\r\n\t\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToPoint: function ( point ) {\r\n\t\r\n\t\t\treturn ( point.distanceTo( this.center ) - this.radius );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsSphere: function ( sphere ) {\r\n\t\r\n\t\t\tvar radiusSum = this.radius + sphere.radius;\r\n\t\r\n\t\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsBox: function ( box ) {\r\n\t\r\n\t\t\treturn box.intersectsSphere( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsPlane: function ( plane ) {\r\n\t\r\n\t\t\t// We use the following equation to compute the signed distance from\r\n\t\t\t// the center of the sphere to the plane.\r\n\t\t\t//\r\n\t\t\t// distance = q * n - d\r\n\t\t\t//\r\n\t\t\t// If this distance is greater than the radius of the sphere,\r\n\t\t\t// then there is no intersection.\r\n\t\r\n\t\t\treturn Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclampPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\tresult.copy( point );\r\n\t\r\n\t\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\r\n\t\r\n\t\t\t\tresult.sub( this.center ).normalize();\r\n\t\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetBoundingBox: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar box = optionalTarget || new THREE.Box3();\r\n\t\r\n\t\t\tbox.set( this.center, this.center );\r\n\t\t\tbox.expandByScalar( this.radius );\r\n\t\r\n\t\t\treturn box;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix4: function ( matrix ) {\r\n\t\r\n\t\t\tthis.center.applyMatrix4( matrix );\r\n\t\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttranslate: function ( offset ) {\r\n\t\r\n\t\t\tthis.center.add( offset );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( sphere ) {\r\n\t\r\n\t\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Frustum.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author bhouston / http://clara.io\r\n\t */\r\n\t\r\n\tTHREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {\r\n\t\r\n\t\tthis.planes = [\r\n\t\r\n\t\t\t( p0 !== undefined ) ? p0 : new THREE.Plane(),\r\n\t\t\t( p1 !== undefined ) ? p1 : new THREE.Plane(),\r\n\t\t\t( p2 !== undefined ) ? p2 : new THREE.Plane(),\r\n\t\t\t( p3 !== undefined ) ? p3 : new THREE.Plane(),\r\n\t\t\t( p4 !== undefined ) ? p4 : new THREE.Plane(),\r\n\t\t\t( p5 !== undefined ) ? p5 : new THREE.Plane()\r\n\t\r\n\t\t];\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Frustum.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Frustum,\r\n\t\r\n\t\tset: function ( p0, p1, p2, p3, p4, p5 ) {\r\n\t\r\n\t\t\tvar planes = this.planes;\r\n\t\r\n\t\t\tplanes[ 0 ].copy( p0 );\r\n\t\t\tplanes[ 1 ].copy( p1 );\r\n\t\t\tplanes[ 2 ].copy( p2 );\r\n\t\t\tplanes[ 3 ].copy( p3 );\r\n\t\t\tplanes[ 4 ].copy( p4 );\r\n\t\t\tplanes[ 5 ].copy( p5 );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( frustum ) {\r\n\t\r\n\t\t\tvar planes = this.planes;\r\n\t\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromMatrix: function ( m ) {\r\n\t\r\n\t\t\tvar planes = this.planes;\r\n\t\t\tvar me = m.elements;\r\n\t\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\r\n\t\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\r\n\t\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\r\n\t\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\r\n\t\r\n\t\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\r\n\t\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\r\n\t\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\r\n\t\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\r\n\t\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\r\n\t\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsObject: function () {\r\n\t\r\n\t\t\tvar sphere = new THREE.Sphere();\r\n\t\r\n\t\t\treturn function ( object ) {\r\n\t\r\n\t\t\t\tvar geometry = object.geometry;\r\n\t\r\n\t\t\t\tif ( geometry.boundingSphere === null )\r\n\t\t\t\t\tgeometry.computeBoundingSphere();\r\n\t\r\n\t\t\t\tsphere.copy( geometry.boundingSphere )\r\n\t\t\t\t\t.applyMatrix4( object.matrixWorld );\r\n\t\r\n\t\t\t\treturn this.intersectsSphere( sphere );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tintersectsSprite: function () {\r\n\t\r\n\t\t\tvar sphere = new THREE.Sphere();\r\n\t\r\n\t\t\treturn function ( sprite ) {\r\n\t\r\n\t\t\t\tsphere.center.set( 0, 0, 0 );\r\n\t\t\t\tsphere.radius = 0.7071067811865476;\r\n\t\t\t\tsphere.applyMatrix4( sprite.matrixWorld );\r\n\t\r\n\t\t\t\treturn this.intersectsSphere( sphere );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tintersectsSphere: function ( sphere ) {\r\n\t\r\n\t\t\tvar planes = this.planes;\r\n\t\t\tvar center = sphere.center;\r\n\t\t\tvar negRadius = - sphere.radius;\r\n\t\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\tvar distance = planes[ i ].distanceToPoint( center );\r\n\t\r\n\t\t\t\tif ( distance < negRadius ) {\r\n\t\r\n\t\t\t\t\treturn false;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsBox: function () {\r\n\t\r\n\t\t\tvar p1 = new THREE.Vector3(),\r\n\t\t\t\tp2 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( box ) {\r\n\t\r\n\t\t\t\tvar planes = this.planes;\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < 6 ; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar plane = planes[ i ];\r\n\t\r\n\t\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\r\n\t\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\r\n\t\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\r\n\t\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\r\n\t\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\r\n\t\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\r\n\t\r\n\t\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\r\n\t\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\r\n\t\r\n\t\t\t\t\t// if both outside plane, no intersection\r\n\t\r\n\t\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\r\n\t\r\n\t\t\t\t\t\treturn false;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\r\n\t\tcontainsPoint: function ( point ) {\r\n\t\r\n\t\t\tvar planes = this.planes;\r\n\t\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\r\n\t\r\n\t\t\t\t\treturn false;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Plane.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://clara.io\r\n\t */\r\n\t\r\n\tTHREE.Plane = function ( normal, constant ) {\r\n\t\r\n\t\tthis.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );\r\n\t\tthis.constant = ( constant !== undefined ) ? constant : 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Plane.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Plane,\r\n\t\r\n\t\tset: function ( normal, constant ) {\r\n\t\r\n\t\t\tthis.normal.copy( normal );\r\n\t\t\tthis.constant = constant;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetComponents: function ( x, y, z, w ) {\r\n\t\r\n\t\t\tthis.normal.set( x, y, z );\r\n\t\t\tthis.constant = w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\r\n\t\r\n\t\t\tthis.normal.copy( normal );\r\n\t\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromCoplanarPoints: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\t\tvar v2 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( a, b, c ) {\r\n\t\r\n\t\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\r\n\t\r\n\t\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\r\n\t\r\n\t\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( plane ) {\r\n\t\r\n\t\t\tthis.normal.copy( plane.normal );\r\n\t\t\tthis.constant = plane.constant;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalize: function () {\r\n\t\r\n\t\t\t// Note: will lead to a divide by zero if the plane is invalid.\r\n\t\r\n\t\t\tvar inverseNormalLength = 1.0 / this.normal.length();\r\n\t\t\tthis.normal.multiplyScalar( inverseNormalLength );\r\n\t\t\tthis.constant *= inverseNormalLength;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnegate: function () {\r\n\t\r\n\t\t\tthis.constant *= - 1;\r\n\t\t\tthis.normal.negate();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToPoint: function ( point ) {\r\n\t\r\n\t\t\treturn this.normal.dot( point ) + this.constant;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdistanceToSphere: function ( sphere ) {\r\n\t\r\n\t\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tprojectPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\r\n\t\r\n\t\t},\r\n\t\r\n\t\torthoPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectLine: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( line, optionalTarget ) {\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\t\tvar direction = line.delta( v1 );\r\n\t\r\n\t\t\t\tvar denominator = this.normal.dot( direction );\r\n\t\r\n\t\t\t\tif ( denominator === 0 ) {\r\n\t\r\n\t\t\t\t\t// line is coplanar, return origin\r\n\t\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\r\n\t\r\n\t\t\t\t\t\treturn result.copy( line.start );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// Unsure if this is the correct method to handle this case.\r\n\t\t\t\t\treturn undefined;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\r\n\t\r\n\t\t\t\tif ( t < 0 || t > 1 ) {\r\n\t\r\n\t\t\t\t\treturn undefined;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tintersectsLine: function ( line ) {\r\n\t\r\n\t\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\r\n\t\r\n\t\t\tvar startSign = this.distanceToPoint( line.start );\r\n\t\t\tvar endSign = this.distanceToPoint( line.end );\r\n\t\r\n\t\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsBox: function ( box ) {\r\n\t\r\n\t\t\treturn box.intersectsPlane( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintersectsSphere: function ( sphere ) {\r\n\t\r\n\t\t\treturn sphere.intersectsPlane( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcoplanarPoint: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix4: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\t\tvar m1 = new THREE.Matrix3();\r\n\t\r\n\t\t\treturn function ( matrix, optionalNormalMatrix ) {\r\n\t\r\n\t\t\t\tvar referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );\r\n\t\r\n\t\t\t\t// transform normal based on theory here:\r\n\t\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\r\n\t\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\r\n\t\t\t\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\r\n\t\r\n\t\t\t\t// recalculate constant (like in setFromNormalAndCoplanarPoint)\r\n\t\t\t\tthis.constant = - referencePoint.dot( normal );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslate: function ( offset ) {\r\n\t\r\n\t\t\tthis.constant = this.constant - offset.dot( this.normal );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tequals: function ( plane ) {\r\n\t\r\n\t\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Spherical.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://clara.io\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t *\r\n\t * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\r\n\t *\r\n\t * The poles (phi) are at the positive and negative y axis.\r\n\t * The equator starts at positive z.\r\n\t */\r\n\t\r\n\tTHREE.Spherical = function ( radius, phi, theta ) {\r\n\t\r\n\t\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\r\n\t\tthis.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole\r\n\t\tthis.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Spherical.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Spherical,\r\n\t\r\n\t\tset: function ( radius, phi, theta ) {\r\n\t\r\n\t\t\tthis.radius = radius;\r\n\t\t\tthis.phi = phi;\r\n\t\t\tthis.theta = theta;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( other ) {\r\n\t\r\n\t\t\tthis.radius.copy( other.radius );\r\n\t\t\tthis.phi.copy( other.phi );\r\n\t\t\tthis.theta.copy( other.theta );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// restrict phi to be betwee EPS and PI-EPS\r\n\t\tmakeSafe: function() {\r\n\t\r\n\t\t\tvar EPS = 0.000001;\r\n\t\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromVector3: function( vec3 ) {\r\n\t\r\n\t\t\tthis.radius = vec3.length();\r\n\t\r\n\t\t\tif ( this.radius === 0 ) {\r\n\t\r\n\t\t\t\tthis.theta = 0;\r\n\t\t\t\tthis.phi = 0;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis\r\n\t\t\t\tthis.phi = Math.acos( THREE.Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Math.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Math = {\r\n\t\r\n\t\tDEG2RAD: Math.PI / 180,\r\n\t\tRAD2DEG: 180 / Math.PI,\r\n\t\r\n\t\tgenerateUUID: function () {\r\n\t\r\n\t\t\t// http://www.broofa.com/Tools/Math.uuid.htm\r\n\t\r\n\t\t\tvar chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );\r\n\t\t\tvar uuid = new Array( 36 );\r\n\t\t\tvar rnd = 0, r;\r\n\t\r\n\t\t\treturn function () {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < 36; i ++ ) {\r\n\t\r\n\t\t\t\t\tif ( i === 8 || i === 13 || i === 18 || i === 23 ) {\r\n\t\r\n\t\t\t\t\t\tuuid[ i ] = '-';\r\n\t\r\n\t\t\t\t\t} else if ( i === 14 ) {\r\n\t\r\n\t\t\t\t\t\tuuid[ i ] = '4';\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tif ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;\r\n\t\t\t\t\t\tr = rnd & 0xf;\r\n\t\t\t\t\t\trnd = rnd >> 4;\r\n\t\t\t\t\t\tuuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn uuid.join( '' );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tclamp: function ( value, min, max ) {\r\n\t\r\n\t\t\treturn Math.max( min, Math.min( max, value ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// compute euclidian modulo of m % n\r\n\t\t// https://en.wikipedia.org/wiki/Modulo_operation\r\n\t\r\n\t\teuclideanModulo: function ( n, m ) {\r\n\t\r\n\t\t\treturn ( ( n % m ) + m ) % m;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Linear mapping from range <a1, a2> to range <b1, b2>\r\n\t\r\n\t\tmapLinear: function ( x, a1, a2, b1, b2 ) {\r\n\t\r\n\t\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// http://en.wikipedia.org/wiki/Smoothstep\r\n\t\r\n\t\tsmoothstep: function ( x, min, max ) {\r\n\t\r\n\t\t\tif ( x <= min ) return 0;\r\n\t\t\tif ( x >= max ) return 1;\r\n\t\r\n\t\t\tx = ( x - min ) / ( max - min );\r\n\t\r\n\t\t\treturn x * x * ( 3 - 2 * x );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsmootherstep: function ( x, min, max ) {\r\n\t\r\n\t\t\tif ( x <= min ) return 0;\r\n\t\t\tif ( x >= max ) return 1;\r\n\t\r\n\t\t\tx = ( x - min ) / ( max - min );\r\n\t\r\n\t\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\trandom16: function () {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );\r\n\t\t\treturn Math.random();\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Random integer from <low, high> interval\r\n\t\r\n\t\trandInt: function ( low, high ) {\r\n\t\r\n\t\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Random float from <low, high> interval\r\n\t\r\n\t\trandFloat: function ( low, high ) {\r\n\t\r\n\t\t\treturn low + Math.random() * ( high - low );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Random float from <-range/2, range/2> interval\r\n\t\r\n\t\trandFloatSpread: function ( range ) {\r\n\t\r\n\t\t\treturn range * ( 0.5 - Math.random() );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdegToRad: function ( degrees ) {\r\n\t\r\n\t\t\treturn degrees * THREE.Math.DEG2RAD;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tradToDeg: function ( radians ) {\r\n\t\r\n\t\t\treturn radians * THREE.Math.RAD2DEG;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tisPowerOfTwo: function ( value ) {\r\n\t\r\n\t\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnearestPowerOfTwo: function ( value ) {\r\n\t\r\n\t\t\treturn Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnextPowerOfTwo: function ( value ) {\r\n\t\r\n\t\t\tvalue --;\r\n\t\t\tvalue |= value >> 1;\r\n\t\t\tvalue |= value >> 2;\r\n\t\t\tvalue |= value >> 4;\r\n\t\t\tvalue |= value >> 8;\r\n\t\t\tvalue |= value >> 16;\r\n\t\t\tvalue ++;\r\n\t\r\n\t\t\treturn value;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Spline.js\r\n\t\r\n\t/**\r\n\t * Spline from Tween.js, slightly optimized (and trashed)\r\n\t * http://sole.github.com/tween.js/examples/05_spline.html\r\n\t *\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Spline = function ( points ) {\r\n\t\r\n\t\tthis.points = points;\r\n\t\r\n\t\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\r\n\t\tpoint, intPoint, weight, w2, w3,\r\n\t\tpa, pb, pc, pd;\r\n\t\r\n\t\tthis.initFromArray = function ( a ) {\r\n\t\r\n\t\t\tthis.points = [];\r\n\t\r\n\t\t\tfor ( var i = 0; i < a.length; i ++ ) {\r\n\t\r\n\t\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getPoint = function ( k ) {\r\n\t\r\n\t\t\tpoint = ( this.points.length - 1 ) * k;\r\n\t\t\tintPoint = Math.floor( point );\r\n\t\t\tweight = point - intPoint;\r\n\t\r\n\t\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\r\n\t\t\tc[ 1 ] = intPoint;\r\n\t\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\r\n\t\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\r\n\t\r\n\t\t\tpa = this.points[ c[ 0 ] ];\r\n\t\t\tpb = this.points[ c[ 1 ] ];\r\n\t\t\tpc = this.points[ c[ 2 ] ];\r\n\t\t\tpd = this.points[ c[ 3 ] ];\r\n\t\r\n\t\t\tw2 = weight * weight;\r\n\t\t\tw3 = weight * w2;\r\n\t\r\n\t\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\r\n\t\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\r\n\t\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\r\n\t\r\n\t\t\treturn v3;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getControlPointsArray = function () {\r\n\t\r\n\t\t\tvar i, p, l = this.points.length,\r\n\t\t\t\tcoords = [];\r\n\t\r\n\t\t\tfor ( i = 0; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tp = this.points[ i ];\r\n\t\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn coords;\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// approximate length by summing linear segments\r\n\t\r\n\t\tthis.getLength = function ( nSubDivisions ) {\r\n\t\r\n\t\t\tvar i, index, nSamples, position,\r\n\t\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\r\n\t\t\t\toldPosition = new THREE.Vector3(),\r\n\t\t\t\ttmpVec = new THREE.Vector3(),\r\n\t\t\t\tchunkLengths = [],\r\n\t\t\t\ttotalLength = 0;\r\n\t\r\n\t\t\t// first point has 0 length\r\n\t\r\n\t\t\tchunkLengths[ 0 ] = 0;\r\n\t\r\n\t\t\tif ( ! nSubDivisions ) nSubDivisions = 100;\r\n\t\r\n\t\t\tnSamples = this.points.length * nSubDivisions;\r\n\t\r\n\t\t\toldPosition.copy( this.points[ 0 ] );\r\n\t\r\n\t\t\tfor ( i = 1; i < nSamples; i ++ ) {\r\n\t\r\n\t\t\t\tindex = i / nSamples;\r\n\t\r\n\t\t\t\tposition = this.getPoint( index );\r\n\t\t\t\ttmpVec.copy( position );\r\n\t\r\n\t\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\r\n\t\r\n\t\t\t\toldPosition.copy( position );\r\n\t\r\n\t\t\t\tpoint = ( this.points.length - 1 ) * index;\r\n\t\t\t\tintPoint = Math.floor( point );\r\n\t\r\n\t\t\t\tif ( intPoint !== oldIntPoint ) {\r\n\t\r\n\t\t\t\t\tchunkLengths[ intPoint ] = totalLength;\r\n\t\t\t\t\toldIntPoint = intPoint;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// last point ends with total length\r\n\t\r\n\t\t\tchunkLengths[ chunkLengths.length ] = totalLength;\r\n\t\r\n\t\t\treturn { chunks: chunkLengths, total: totalLength };\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\r\n\t\r\n\t\t\tvar i, j,\r\n\t\t\t\tindex, indexCurrent, indexNext,\r\n\t\t\t\trealDistance,\r\n\t\t\t\tsampling, position,\r\n\t\t\t\tnewpoints = [],\r\n\t\t\t\ttmpVec = new THREE.Vector3(),\r\n\t\t\t\tsl = this.getLength();\r\n\t\r\n\t\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\r\n\t\r\n\t\t\tfor ( i = 1; i < this.points.length; i ++ ) {\r\n\t\r\n\t\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\r\n\t\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\r\n\t\r\n\t\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\r\n\t\r\n\t\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\r\n\t\r\n\t\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\r\n\t\t\t\tindexNext = i / ( this.points.length - 1 );\r\n\t\r\n\t\t\t\tfor ( j = 1; j < sampling - 1; j ++ ) {\r\n\t\r\n\t\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\r\n\t\r\n\t\t\t\t\tposition = this.getPoint( index );\r\n\t\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.points = newpoints;\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Catmull-Rom\r\n\t\r\n\t\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\r\n\t\r\n\t\t\tvar v0 = ( p2 - p0 ) * 0.5,\r\n\t\t\t\tv1 = ( p3 - p1 ) * 0.5;\r\n\t\r\n\t\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Triangle.js\r\n\t\r\n\t/**\r\n\t * @author bhouston / http://clara.io\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Triangle = function ( a, b, c ) {\r\n\t\r\n\t\tthis.a = ( a !== undefined ) ? a : new THREE.Vector3();\r\n\t\tthis.b = ( b !== undefined ) ? b : new THREE.Vector3();\r\n\t\tthis.c = ( c !== undefined ) ? c : new THREE.Vector3();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Triangle.normal = function () {\r\n\t\r\n\t\tvar v0 = new THREE.Vector3();\r\n\t\r\n\t\treturn function ( a, b, c, optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\tresult.subVectors( c, b );\r\n\t\t\tv0.subVectors( a, b );\r\n\t\t\tresult.cross( v0 );\r\n\t\r\n\t\t\tvar resultLengthSq = result.lengthSq();\r\n\t\t\tif ( resultLengthSq > 0 ) {\r\n\t\r\n\t\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result.set( 0, 0, 0 );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\t// static/instance method to calculate barycentric coordinates\r\n\t// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\r\n\tTHREE.Triangle.barycoordFromPoint = function () {\r\n\t\r\n\t\tvar v0 = new THREE.Vector3();\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\t\r\n\t\treturn function ( point, a, b, c, optionalTarget ) {\r\n\t\r\n\t\t\tv0.subVectors( c, a );\r\n\t\t\tv1.subVectors( b, a );\r\n\t\t\tv2.subVectors( point, a );\r\n\t\r\n\t\t\tvar dot00 = v0.dot( v0 );\r\n\t\t\tvar dot01 = v0.dot( v1 );\r\n\t\t\tvar dot02 = v0.dot( v2 );\r\n\t\t\tvar dot11 = v1.dot( v1 );\r\n\t\t\tvar dot12 = v1.dot( v2 );\r\n\t\r\n\t\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\t// collinear or singular triangle\r\n\t\t\tif ( denom === 0 ) {\r\n\t\r\n\t\t\t\t// arbitrary location outside of triangle?\r\n\t\t\t\t// not sure if this is the best idea, maybe should be returning undefined\r\n\t\t\t\treturn result.set( - 2, - 1, - 1 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar invDenom = 1 / denom;\r\n\t\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\r\n\t\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\r\n\t\r\n\t\t\t// barycentric coordinates must always sum to 1\r\n\t\t\treturn result.set( 1 - u - v, v, u );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\tTHREE.Triangle.containsPoint = function () {\r\n\t\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\treturn function ( point, a, b, c ) {\r\n\t\r\n\t\t\tvar result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );\r\n\t\r\n\t\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\tTHREE.Triangle.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Triangle,\r\n\t\r\n\t\tset: function ( a, b, c ) {\r\n\t\r\n\t\t\tthis.a.copy( a );\r\n\t\t\tthis.b.copy( b );\r\n\t\t\tthis.c.copy( c );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\r\n\t\r\n\t\t\tthis.a.copy( points[ i0 ] );\r\n\t\t\tthis.b.copy( points[ i1 ] );\r\n\t\t\tthis.c.copy( points[ i2 ] );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( triangle ) {\r\n\t\r\n\t\t\tthis.a.copy( triangle.a );\r\n\t\t\tthis.b.copy( triangle.b );\r\n\t\t\tthis.c.copy( triangle.c );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tarea: function () {\r\n\t\r\n\t\t\tvar v0 = new THREE.Vector3();\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function () {\r\n\t\r\n\t\t\t\tv0.subVectors( this.c, this.b );\r\n\t\t\t\tv1.subVectors( this.a, this.b );\r\n\t\r\n\t\t\t\treturn v0.cross( v1 ).length() * 0.5;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tmidpoint: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormal: function ( optionalTarget ) {\r\n\t\r\n\t\t\treturn THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tplane: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Plane();\r\n\t\r\n\t\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tbarycoordFromPoint: function ( point, optionalTarget ) {\r\n\t\r\n\t\t\treturn THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcontainsPoint: function ( point ) {\r\n\t\r\n\t\t\treturn THREE.Triangle.containsPoint( point, this.a, this.b, this.c );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclosestPointToPoint: function () {\r\n\t\r\n\t\t\tvar plane, edgeList, projectedPoint, closestPoint;\r\n\t\r\n\t\t\treturn function closestPointToPoint( point, optionalTarget ) {\r\n\t\r\n\t\t\t\tif ( plane === undefined ) {\r\n\t\r\n\t\t\t\t\tplane = new THREE.Plane();\r\n\t\t\t\t\tedgeList = [ new THREE.Line3(), new THREE.Line3(), new THREE.Line3() ];\r\n\t\t\t\t\tprojectedPoint = new THREE.Vector3();\r\n\t\t\t\t\tclosestPoint = new THREE.Vector3();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\t\tvar minDistance = Infinity;\r\n\t\r\n\t\t\t\t// project the point onto the plane of the triangle\r\n\t\r\n\t\t\t\tplane.setFromCoplanarPoints( this.a, this.b, this.c );\r\n\t\t\t\tplane.projectPoint( point, projectedPoint );\r\n\t\r\n\t\t\t\t// check if the projection lies within the triangle\r\n\t\r\n\t\t\t\tif( this.containsPoint( projectedPoint ) === true ) {\r\n\t\r\n\t\t\t\t\t// if so, this is the closest point\r\n\t\r\n\t\t\t\t\tresult.copy( projectedPoint );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices\r\n\t\r\n\t\t\t\t\tedgeList[ 0 ].set( this.a, this.b );\r\n\t\t\t\t\tedgeList[ 1 ].set( this.b, this.c );\r\n\t\t\t\t\tedgeList[ 2 ].set( this.c, this.a );\r\n\t\r\n\t\t\t\t\tfor( var i = 0; i < edgeList.length; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tedgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );\r\n\t\r\n\t\t\t\t\t\tvar distance = projectedPoint.distanceToSquared( closestPoint );\r\n\t\r\n\t\t\t\t\t\tif( distance < minDistance ) {\r\n\t\r\n\t\t\t\t\t\t\tminDistance = distance;\r\n\t\r\n\t\t\t\t\t\t\tresult.copy( closestPoint );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn result;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tequals: function ( triangle ) {\r\n\t\r\n\t\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/math/Interpolant.js\r\n\t\r\n\t/**\r\n\t * Abstract base class of interpolants over parametric samples.\r\n\t *\r\n\t * The parameter domain is one dimensional, typically the time or a path\r\n\t * along a curve defined by the data.\r\n\t *\r\n\t * The sample values can have any dimensionality and derived classes may\r\n\t * apply special interpretations to the data.\r\n\t *\r\n\t * This class provides the interval seek in a Template Method, deferring\r\n\t * the actual interpolation to derived classes.\r\n\t *\r\n\t * Time complexity is O(1) for linear access crossing at most two points\r\n\t * and O(log N) for random access, where N is the number of positions.\r\n\t *\r\n\t * References:\r\n\t *\r\n\t * \t\thttp://www.oodesign.com/template-method-pattern.html\r\n\t *\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.Interpolant = function(\r\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\t\r\n\t\tthis.parameterPositions = parameterPositions;\r\n\t\tthis._cachedIndex = 0;\r\n\t\r\n\t\tthis.resultBuffer = resultBuffer !== undefined ?\r\n\t\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\r\n\t\tthis.sampleValues = sampleValues;\r\n\t\tthis.valueSize = sampleSize;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Interpolant.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Interpolant,\r\n\t\r\n\t\tevaluate: function( t ) {\r\n\t\r\n\t\t\tvar pp = this.parameterPositions,\r\n\t\t\t\ti1 = this._cachedIndex,\r\n\t\r\n\t\t\t\tt1 = pp[   i1   ],\r\n\t\t\t\tt0 = pp[ i1 - 1 ];\r\n\t\r\n\t\t\tvalidate_interval: {\r\n\t\r\n\t\t\t\tseek: {\r\n\t\r\n\t\t\t\t\tvar right;\r\n\t\r\n\t\t\t\t\tlinear_scan: {\r\n\t//- See http://jsperf.com/comparison-to-undefined/3\r\n\t//- slower code:\r\n\t//-\r\n\t//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\r\n\t\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( var giveUpAt = i1 + 2; ;) {\r\n\t\r\n\t\t\t\t\t\t\t\tif ( t1 === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\r\n\t\r\n\t\t\t\t\t\t\t\t\t// after end\r\n\t\r\n\t\t\t\t\t\t\t\t\ti1 = pp.length;\r\n\t\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\r\n\t\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\r\n\t\r\n\t\t\t\t\t\t\t\tt0 = t1;\r\n\t\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\r\n\t\r\n\t\t\t\t\t\t\t\tif ( t < t1 ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\r\n\t\t\t\t\t\t\t\t\tbreak seek;\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t// prepare binary search on the right side of the index\r\n\t\t\t\t\t\t\tright = pp.length;\r\n\t\t\t\t\t\t\tbreak linear_scan;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t//- slower code:\r\n\t//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\r\n\t\t\t\t\t\tif ( ! ( t >= t0 ) ) {\r\n\t\r\n\t\t\t\t\t\t\t// looping?\r\n\t\r\n\t\t\t\t\t\t\tvar t1global = pp[ 1 ];\r\n\t\r\n\t\t\t\t\t\t\tif ( t < t1global ) {\r\n\t\r\n\t\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\r\n\t\t\t\t\t\t\t\tt0 = t1global;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t// linear reverse scan\r\n\t\r\n\t\t\t\t\t\t\tfor ( var giveUpAt = i1 - 2; ;) {\r\n\t\r\n\t\t\t\t\t\t\t\tif ( t0 === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\t// before start\r\n\t\r\n\t\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\r\n\t\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\r\n\t\r\n\t\t\t\t\t\t\t\tt1 = t0;\r\n\t\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\r\n\t\r\n\t\t\t\t\t\t\t\tif ( t >= t0 ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\t// we have arrived at the sought interval\r\n\t\t\t\t\t\t\t\t\tbreak seek;\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t// prepare binary search on the left side of the index\r\n\t\t\t\t\t\t\tright = i1;\r\n\t\t\t\t\t\t\ti1 = 0;\r\n\t\t\t\t\t\t\tbreak linear_scan;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t// the interval is valid\r\n\t\r\n\t\t\t\t\t\tbreak validate_interval;\r\n\t\r\n\t\t\t\t\t} // linear scan\r\n\t\r\n\t\t\t\t\t// binary search\r\n\t\r\n\t\t\t\t\twhile ( i1 < right ) {\r\n\t\r\n\t\t\t\t\t\tvar mid = ( i1 + right ) >>> 1;\r\n\t\r\n\t\t\t\t\t\tif ( t < pp[ mid ] ) {\r\n\t\r\n\t\t\t\t\t\t\tright = mid;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\ti1 = mid + 1;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tt1 = pp[   i1   ];\r\n\t\t\t\t\tt0 = pp[ i1 - 1 ];\r\n\t\r\n\t\t\t\t\t// check boundary cases, again\r\n\t\r\n\t\t\t\t\tif ( t0 === undefined ) {\r\n\t\r\n\t\t\t\t\t\tthis._cachedIndex = 0;\r\n\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( t1 === undefined ) {\r\n\t\r\n\t\t\t\t\t\ti1 = pp.length;\r\n\t\t\t\t\t\tthis._cachedIndex = i1;\r\n\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} // seek\r\n\t\r\n\t\t\t\tthis._cachedIndex = i1;\r\n\t\r\n\t\t\t\tthis.intervalChanged_( i1, t0, t1 );\r\n\t\r\n\t\t\t} // validate_interval\r\n\t\r\n\t\t\treturn this.interpolate_( i1, t0, t, t1 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsettings: null, // optional, subclass-specific settings structure\r\n\t\t// Note: The indirection allows central control of many interpolants.\r\n\t\r\n\t\t// --- Protected interface\r\n\t\r\n\t\tDefaultSettings_: {},\r\n\t\r\n\t\tgetSettings_: function() {\r\n\t\r\n\t\t\treturn this.settings || this.DefaultSettings_;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopySampleValue_: function( index ) {\r\n\t\r\n\t\t\t// copies a sample value to the result buffer\r\n\t\r\n\t\t\tvar result = this.resultBuffer,\r\n\t\t\t\tvalues = this.sampleValues,\r\n\t\t\t\tstride = this.valueSize,\r\n\t\t\t\toffset = index * stride;\r\n\t\r\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\t\r\n\t\t\t\tresult[ i ] = values[ offset + i ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Template methods for derived classes:\r\n\t\r\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\r\n\t\r\n\t\t\tthrow new Error( \"call to abstract method\" );\r\n\t\t\t// implementations shall return this.resultBuffer\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintervalChanged_: function( i1, t0, t1 ) {\r\n\t\r\n\t\t\t// empty\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tObject.assign( THREE.Interpolant.prototype, {\r\n\t\r\n\t\tbeforeStart_: //( 0, t, t0 ), returns this.resultBuffer\r\n\t\t\tTHREE.Interpolant.prototype.copySampleValue_,\r\n\t\r\n\t\tafterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer\r\n\t\t\tTHREE.Interpolant.prototype.copySampleValue_\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/math/interpolants/CubicInterpolant.js\r\n\t\r\n\t/**\r\n\t * Fast and simple cubic spline interpolant.\r\n\t *\r\n\t * It was derived from a Hermitian construction setting the first derivative\r\n\t * at each sample position to the linear slope between neighboring positions\r\n\t * over their parameter interval.\r\n\t *\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.CubicInterpolant = function(\r\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\t\r\n\t\tTHREE.Interpolant.call(\r\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\t\r\n\t\tthis._weightPrev = -0;\r\n\t\tthis._offsetPrev = -0;\r\n\t\tthis._weightNext = -0;\r\n\t\tthis._offsetNext = -0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CubicInterpolant.prototype =\r\n\t\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.CubicInterpolant,\r\n\t\r\n\t\tDefaultSettings_: {\r\n\t\r\n\t\t\tendingStart: \tTHREE.ZeroCurvatureEnding,\r\n\t\t\tendingEnd:\t\tTHREE.ZeroCurvatureEnding\r\n\t\r\n\t\t},\r\n\t\r\n\t\tintervalChanged_: function( i1, t0, t1 ) {\r\n\t\r\n\t\t\tvar pp = this.parameterPositions,\r\n\t\t\t\tiPrev = i1 - 2,\r\n\t\t\t\tiNext = i1 + 1,\r\n\t\r\n\t\t\t\ttPrev = pp[ iPrev ],\r\n\t\t\t\ttNext = pp[ iNext ];\r\n\t\r\n\t\t\tif ( tPrev === undefined ) {\r\n\t\r\n\t\t\t\tswitch ( this.getSettings_().endingStart ) {\r\n\t\r\n\t\t\t\t\tcase THREE.ZeroSlopeEnding:\r\n\t\r\n\t\t\t\t\t\t// f'(t0) = 0\r\n\t\t\t\t\t\tiPrev = i1;\r\n\t\t\t\t\t\ttPrev = 2 * t0 - t1;\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.WrapAroundEnding:\r\n\t\r\n\t\t\t\t\t\t// use the other end of the curve\r\n\t\t\t\t\t\tiPrev = pp.length - 2;\r\n\t\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tdefault: // ZeroCurvatureEnding\r\n\t\r\n\t\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\r\n\t\t\t\t\t\tiPrev = i1;\r\n\t\t\t\t\t\ttPrev = t1;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( tNext === undefined ) {\r\n\t\r\n\t\t\t\tswitch ( this.getSettings_().endingEnd ) {\r\n\t\r\n\t\t\t\t\tcase THREE.ZeroSlopeEnding:\r\n\t\r\n\t\t\t\t\t\t// f'(tN) = 0\r\n\t\t\t\t\t\tiNext = i1;\r\n\t\t\t\t\t\ttNext = 2 * t1 - t0;\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.WrapAroundEnding:\r\n\t\r\n\t\t\t\t\t\t// use the other end of the curve\r\n\t\t\t\t\t\tiNext = 1;\r\n\t\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tdefault: // ZeroCurvatureEnding\r\n\t\r\n\t\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\r\n\t\t\t\t\t\tiNext = i1 - 1;\r\n\t\t\t\t\t\ttNext = t0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar halfDt = ( t1 - t0 ) * 0.5,\r\n\t\t\t\tstride = this.valueSize;\r\n\t\r\n\t\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\r\n\t\t\tthis._weightNext = halfDt / ( tNext - t1 );\r\n\t\t\tthis._offsetPrev = iPrev * stride;\r\n\t\t\tthis._offsetNext = iNext * stride;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\r\n\t\r\n\t\t\tvar result = this.resultBuffer,\r\n\t\t\t\tvalues = this.sampleValues,\r\n\t\t\t\tstride = this.valueSize,\r\n\t\r\n\t\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\r\n\t\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\r\n\t\t\t\twP = this._weightPrev,\twN = this._weightNext,\r\n\t\r\n\t\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\r\n\t\t\t\tpp = p * p,\r\n\t\t\t\tppp = pp * p;\r\n\t\r\n\t\t\t// evaluate polynomials\r\n\t\r\n\t\t\tvar sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;\r\n\t\t\tvar s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;\r\n\t\t\tvar s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;\r\n\t\t\tvar sN =       wN   * ppp   -           wN      * pp;\r\n\t\r\n\t\t\t// combine data linearly\r\n\t\r\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\t\r\n\t\t\t\tresult[ i ] =\r\n\t\t\t\t\t\tsP * values[ oP + i ] +\r\n\t\t\t\t\t\ts0 * values[ o0 + i ] +\r\n\t\t\t\t\t\ts1 * values[ o1 + i ] +\r\n\t\t\t\t\t\tsN * values[ oN + i ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/math/interpolants/DiscreteInterpolant.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * Interpolant that evaluates to the sample value at the position preceeding\r\n\t * the parameter.\r\n\t *\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.DiscreteInterpolant = function(\r\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\t\r\n\t\tTHREE.Interpolant.call(\r\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DiscreteInterpolant.prototype =\r\n\t\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.DiscreteInterpolant,\r\n\t\r\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\r\n\t\r\n\t\t\treturn this.copySampleValue_( i1 - 1 );\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/math/interpolants/LinearInterpolant.js\r\n\t\r\n\t/**\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.LinearInterpolant = function(\r\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\t\r\n\t\tTHREE.Interpolant.call(\r\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LinearInterpolant.prototype =\r\n\t\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.LinearInterpolant,\r\n\t\r\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\r\n\t\r\n\t\t\tvar result = this.resultBuffer,\r\n\t\t\t\tvalues = this.sampleValues,\r\n\t\t\t\tstride = this.valueSize,\r\n\t\r\n\t\t\t\toffset1 = i1 * stride,\r\n\t\t\t\toffset0 = offset1 - stride,\r\n\t\r\n\t\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\r\n\t\t\t\tweight0 = 1 - weight1;\r\n\t\r\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\t\r\n\t\t\t\tresult[ i ] =\r\n\t\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\r\n\t\t\t\t\t\tvalues[ offset1 + i ] * weight1;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/math/interpolants/QuaternionLinearInterpolant.js\r\n\t\r\n\t/**\r\n\t * Spherical linear unit quaternion interpolant.\r\n\t *\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.QuaternionLinearInterpolant = function(\r\n\t\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\t\r\n\t\tTHREE.Interpolant.call(\r\n\t\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.QuaternionLinearInterpolant.prototype =\r\n\t\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.QuaternionLinearInterpolant,\r\n\t\r\n\t\tinterpolate_: function( i1, t0, t, t1 ) {\r\n\t\r\n\t\t\tvar result = this.resultBuffer,\r\n\t\t\t\tvalues = this.sampleValues,\r\n\t\t\t\tstride = this.valueSize,\r\n\t\r\n\t\t\t\toffset = i1 * stride,\r\n\t\r\n\t\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\r\n\t\r\n\t\t\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\r\n\t\r\n\t\t\t\tTHREE.Quaternion.slerpFlat( result, 0,\r\n\t\t\t\t\t\tvalues, offset - stride, values, offset, alpha );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/core/Clock.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Clock = function ( autoStart ) {\r\n\t\r\n\t\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\r\n\t\r\n\t\tthis.startTime = 0;\r\n\t\tthis.oldTime = 0;\r\n\t\tthis.elapsedTime = 0;\r\n\t\r\n\t\tthis.running = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Clock.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Clock,\r\n\t\r\n\t\tstart: function () {\r\n\t\r\n\t\t\tthis.startTime = ( performance || Date ).now();\r\n\t\r\n\t\t\tthis.oldTime = this.startTime;\r\n\t\t\tthis.running = true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tstop: function () {\r\n\t\r\n\t\t\tthis.getElapsedTime();\r\n\t\t\tthis.running = false;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetElapsedTime: function () {\r\n\t\r\n\t\t\tthis.getDelta();\r\n\t\t\treturn this.elapsedTime;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetDelta: function () {\r\n\t\r\n\t\t\tvar diff = 0;\r\n\t\r\n\t\t\tif ( this.autoStart && ! this.running ) {\r\n\t\r\n\t\t\t\tthis.start();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.running ) {\r\n\t\r\n\t\t\t\tvar newTime = ( performance || Date ).now();\r\n\t\r\n\t\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\r\n\t\t\t\tthis.oldTime = newTime;\r\n\t\r\n\t\t\t\tthis.elapsedTime += diff;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn diff;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/EventDispatcher.js\r\n\t\r\n\t/**\r\n\t * https://github.com/mrdoob/eventdispatcher.js/\r\n\t */\r\n\t\r\n\tTHREE.EventDispatcher = function () {};\r\n\t\r\n\tObject.assign( THREE.EventDispatcher.prototype, {\r\n\t\r\n\t\taddEventListener: function ( type, listener ) {\r\n\t\r\n\t\t\tif ( this._listeners === undefined ) this._listeners = {};\r\n\t\r\n\t\t\tvar listeners = this._listeners;\r\n\t\r\n\t\t\tif ( listeners[ type ] === undefined ) {\r\n\t\r\n\t\t\t\tlisteners[ type ] = [];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\r\n\t\r\n\t\t\t\tlisteners[ type ].push( listener );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\thasEventListener: function ( type, listener ) {\r\n\t\r\n\t\t\tif ( this._listeners === undefined ) return false;\r\n\t\r\n\t\t\tvar listeners = this._listeners;\r\n\t\r\n\t\t\tif ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn false;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tremoveEventListener: function ( type, listener ) {\r\n\t\r\n\t\t\tif ( this._listeners === undefined ) return;\r\n\t\r\n\t\t\tvar listeners = this._listeners;\r\n\t\t\tvar listenerArray = listeners[ type ];\r\n\t\r\n\t\t\tif ( listenerArray !== undefined ) {\r\n\t\r\n\t\t\t\tvar index = listenerArray.indexOf( listener );\r\n\t\r\n\t\t\t\tif ( index !== - 1 ) {\r\n\t\r\n\t\t\t\t\tlistenerArray.splice( index, 1 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispatchEvent: function ( event ) {\r\n\t\r\n\t\t\tif ( this._listeners === undefined ) return;\r\n\t\r\n\t\t\tvar listeners = this._listeners;\r\n\t\t\tvar listenerArray = listeners[ event.type ];\r\n\t\r\n\t\t\tif ( listenerArray !== undefined ) {\r\n\t\r\n\t\t\t\tevent.target = this;\r\n\t\r\n\t\t\t\tvar array = [], i = 0;\r\n\t\t\t\tvar length = listenerArray.length;\r\n\t\r\n\t\t\t\tfor ( i = 0; i < length; i ++ ) {\r\n\t\r\n\t\t\t\t\tarray[ i ] = listenerArray[ i ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( i = 0; i < length; i ++ ) {\r\n\t\r\n\t\t\t\t\tarray[ i ].call( this, event );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/core/Layers.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Layers = function () {\r\n\t\r\n\t\tthis.mask = 1;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Layers.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Layers,\r\n\t\r\n\t\tset: function ( channel ) {\r\n\t\r\n\t\t\tthis.mask = 1 << channel;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tenable: function ( channel ) {\r\n\t\r\n\t\t\tthis.mask |= 1 << channel;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoggle: function ( channel ) {\r\n\t\r\n\t\t\tthis.mask ^= 1 << channel;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdisable: function ( channel ) {\r\n\t\r\n\t\t\tthis.mask &= ~ ( 1 << channel );\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttest: function ( layers ) {\r\n\t\r\n\t\t\treturn ( this.mask & layers.mask ) !== 0;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/Raycaster.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author bhouston / http://clara.io/\r\n\t * @author stephomi / http://stephaneginier.com/\r\n\t */\r\n\t\r\n\t( function ( THREE ) {\r\n\t\r\n\t\tTHREE.Raycaster = function ( origin, direction, near, far ) {\r\n\t\r\n\t\t\tthis.ray = new THREE.Ray( origin, direction );\r\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\r\n\t\r\n\t\t\tthis.near = near || 0;\r\n\t\t\tthis.far = far || Infinity;\r\n\t\r\n\t\t\tthis.params = {\r\n\t\t\t\tMesh: {},\r\n\t\t\t\tLine: {},\r\n\t\t\t\tLOD: {},\r\n\t\t\t\tPoints: { threshold: 1 },\r\n\t\t\t\tSprite: {}\r\n\t\t\t};\r\n\t\r\n\t\t\tObject.defineProperties( this.params, {\r\n\t\t\t\tPointCloud: {\r\n\t\t\t\t\tget: function () {\r\n\t\t\t\t\t\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\r\n\t\t\t\t\t\treturn this.Points;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction ascSort( a, b ) {\r\n\t\r\n\t\t\treturn a.distance - b.distance;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction intersectObject( object, raycaster, intersects, recursive ) {\r\n\t\r\n\t\t\tif ( object.visible === false ) return;\r\n\t\r\n\t\t\tobject.raycast( raycaster, intersects );\r\n\t\r\n\t\t\tif ( recursive === true ) {\r\n\t\r\n\t\t\t\tvar children = object.children;\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t//\r\n\t\r\n\t\tTHREE.Raycaster.prototype = {\r\n\t\r\n\t\t\tconstructor: THREE.Raycaster,\r\n\t\r\n\t\t\tlinePrecision: 1,\r\n\t\r\n\t\t\tset: function ( origin, direction ) {\r\n\t\r\n\t\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\r\n\t\r\n\t\t\t\tthis.ray.set( origin, direction );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tsetFromCamera: function ( coords, camera ) {\r\n\t\r\n\t\t\t\tif ( camera instanceof THREE.PerspectiveCamera ) {\r\n\t\r\n\t\t\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\r\n\t\t\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\r\n\t\r\n\t\t\t\t} else if ( camera instanceof THREE.OrthographicCamera ) {\r\n\t\r\n\t\t\t\t\tthis.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );\r\n\t\t\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tintersectObject: function ( object, recursive ) {\r\n\t\r\n\t\t\t\tvar intersects = [];\r\n\t\r\n\t\t\t\tintersectObject( object, this, intersects, recursive );\r\n\t\r\n\t\t\t\tintersects.sort( ascSort );\r\n\t\r\n\t\t\t\treturn intersects;\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tintersectObjects: function ( objects, recursive ) {\r\n\t\r\n\t\t\t\tvar intersects = [];\r\n\t\r\n\t\t\t\tif ( Array.isArray( objects ) === false ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\r\n\t\t\t\t\treturn intersects;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tintersects.sort( ascSort );\r\n\t\r\n\t\t\t\treturn intersects;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t}( THREE ) );\r\n\t\r\n\t// File:src/core/Object3D.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t * @author elephantatwork / www.elephantatwork.ch\r\n\t */\r\n\t\r\n\tTHREE.Object3D = function () {\r\n\t\r\n\t\tObject.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.name = '';\r\n\t\tthis.type = 'Object3D';\r\n\t\r\n\t\tthis.parent = null;\r\n\t\tthis.children = [];\r\n\t\r\n\t\tthis.up = THREE.Object3D.DefaultUp.clone();\r\n\t\r\n\t\tvar position = new THREE.Vector3();\r\n\t\tvar rotation = new THREE.Euler();\r\n\t\tvar quaternion = new THREE.Quaternion();\r\n\t\tvar scale = new THREE.Vector3( 1, 1, 1 );\r\n\t\r\n\t\tfunction onRotationChange() {\r\n\t\r\n\t\t\tquaternion.setFromEuler( rotation, false );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction onQuaternionChange() {\r\n\t\r\n\t\t\trotation.setFromQuaternion( quaternion, undefined, false );\r\n\t\r\n\t\t}\r\n\t\r\n\t\trotation.onChange( onRotationChange );\r\n\t\tquaternion.onChange( onQuaternionChange );\r\n\t\r\n\t\tObject.defineProperties( this, {\r\n\t\t\tposition: {\r\n\t\t\t\tenumerable: true,\r\n\t\t\t\tvalue: position\r\n\t\t\t},\r\n\t\t\trotation: {\r\n\t\t\t\tenumerable: true,\r\n\t\t\t\tvalue: rotation\r\n\t\t\t},\r\n\t\t\tquaternion: {\r\n\t\t\t\tenumerable: true,\r\n\t\t\t\tvalue: quaternion\r\n\t\t\t},\r\n\t\t\tscale: {\r\n\t\t\t\tenumerable: true,\r\n\t\t\t\tvalue: scale\r\n\t\t\t},\r\n\t\t\tmodelViewMatrix: {\r\n\t\t\t\tvalue: new THREE.Matrix4()\r\n\t\t\t},\r\n\t\t\tnormalMatrix: {\r\n\t\t\t\tvalue: new THREE.Matrix3()\r\n\t\t\t}\r\n\t\t} );\r\n\t\r\n\t\tthis.matrix = new THREE.Matrix4();\r\n\t\tthis.matrixWorld = new THREE.Matrix4();\r\n\t\r\n\t\tthis.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;\r\n\t\tthis.matrixWorldNeedsUpdate = false;\r\n\t\r\n\t\tthis.layers = new THREE.Layers();\r\n\t\tthis.visible = true;\r\n\t\r\n\t\tthis.castShadow = false;\r\n\t\tthis.receiveShadow = false;\r\n\t\r\n\t\tthis.frustumCulled = true;\r\n\t\tthis.renderOrder = 0;\r\n\t\r\n\t\tthis.userData = {};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );\r\n\tTHREE.Object3D.DefaultMatrixAutoUpdate = true;\r\n\t\r\n\tObject.assign( THREE.Object3D.prototype, THREE.EventDispatcher.prototype, {\r\n\t\r\n\t\tapplyMatrix: function ( matrix ) {\r\n\t\r\n\t\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\r\n\t\r\n\t\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetRotationFromAxisAngle: function ( axis, angle ) {\r\n\t\r\n\t\t\t// assumes axis is normalized\r\n\t\r\n\t\t\tthis.quaternion.setFromAxisAngle( axis, angle );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetRotationFromEuler: function ( euler ) {\r\n\t\r\n\t\t\tthis.quaternion.setFromEuler( euler, true );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetRotationFromMatrix: function ( m ) {\r\n\t\r\n\t\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\t\r\n\t\t\tthis.quaternion.setFromRotationMatrix( m );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetRotationFromQuaternion: function ( q ) {\r\n\t\r\n\t\t\t// assumes q is normalized\r\n\t\r\n\t\t\tthis.quaternion.copy( q );\r\n\t\r\n\t\t},\r\n\t\r\n\t\trotateOnAxis: function () {\r\n\t\r\n\t\t\t// rotate object on axis in object space\r\n\t\t\t// axis is assumed to be normalized\r\n\t\r\n\t\t\tvar q1 = new THREE.Quaternion();\r\n\t\r\n\t\t\treturn function ( axis, angle ) {\r\n\t\r\n\t\t\t\tq1.setFromAxisAngle( axis, angle );\r\n\t\r\n\t\t\t\tthis.quaternion.multiply( q1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\trotateX: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\r\n\t\r\n\t\t\treturn function ( angle ) {\r\n\t\r\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\trotateY: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\r\n\t\r\n\t\t\treturn function ( angle ) {\r\n\t\r\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\trotateZ: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\r\n\t\r\n\t\t\treturn function ( angle ) {\r\n\t\r\n\t\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslateOnAxis: function () {\r\n\t\r\n\t\t\t// translate object by distance along axis in object space\r\n\t\t\t// axis is assumed to be normalized\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( axis, distance ) {\r\n\t\r\n\t\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\r\n\t\r\n\t\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslateX: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\r\n\t\r\n\t\t\treturn function ( distance ) {\r\n\t\r\n\t\t\t\treturn this.translateOnAxis( v1, distance );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslateY: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\r\n\t\r\n\t\t\treturn function ( distance ) {\r\n\t\r\n\t\t\t\treturn this.translateOnAxis( v1, distance );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslateZ: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\r\n\t\r\n\t\t\treturn function ( distance ) {\r\n\t\r\n\t\t\t\treturn this.translateOnAxis( v1, distance );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tlocalToWorld: function ( vector ) {\r\n\t\r\n\t\t\treturn vector.applyMatrix4( this.matrixWorld );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tworldToLocal: function () {\r\n\t\r\n\t\t\tvar m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\treturn function ( vector ) {\r\n\t\r\n\t\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tlookAt: function () {\r\n\t\r\n\t\t\t// This routine does not support objects with rotated and/or translated parent(s)\r\n\t\r\n\t\t\tvar m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\treturn function ( vector ) {\r\n\t\r\n\t\t\t\tm1.lookAt( vector, this.position, this.up );\r\n\t\r\n\t\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tadd: function ( object ) {\r\n\t\r\n\t\t\tif ( arguments.length > 1 ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tthis.add( arguments[ i ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( object === this ) {\r\n\t\r\n\t\t\t\tconsole.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( object instanceof THREE.Object3D ) {\r\n\t\r\n\t\t\t\tif ( object.parent !== null ) {\r\n\t\r\n\t\t\t\t\tobject.parent.remove( object );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tobject.parent = this;\r\n\t\t\t\tobject.dispatchEvent( { type: 'added' } );\r\n\t\r\n\t\t\t\tthis.children.push( object );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tconsole.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tremove: function ( object ) {\r\n\t\r\n\t\t\tif ( arguments.length > 1 ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tthis.remove( arguments[ i ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar index = this.children.indexOf( object );\r\n\t\r\n\t\t\tif ( index !== - 1 ) {\r\n\t\r\n\t\t\t\tobject.parent = null;\r\n\t\r\n\t\t\t\tobject.dispatchEvent( { type: 'removed' } );\r\n\t\r\n\t\t\t\tthis.children.splice( index, 1 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetObjectById: function ( id ) {\r\n\t\r\n\t\t\treturn this.getObjectByProperty( 'id', id );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetObjectByName: function ( name ) {\r\n\t\r\n\t\t\treturn this.getObjectByProperty( 'name', name );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetObjectByProperty: function ( name, value ) {\r\n\t\r\n\t\t\tif ( this[ name ] === value ) return this;\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar child = this.children[ i ];\r\n\t\t\t\tvar object = child.getObjectByProperty( name, value );\r\n\t\r\n\t\t\t\tif ( object !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn object;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn undefined;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetWorldPosition: function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\tthis.updateMatrixWorld( true );\r\n\t\r\n\t\t\treturn result.setFromMatrixPosition( this.matrixWorld );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetWorldQuaternion: function () {\r\n\t\r\n\t\t\tvar position = new THREE.Vector3();\r\n\t\t\tvar scale = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function ( optionalTarget ) {\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Quaternion();\r\n\t\r\n\t\t\t\tthis.updateMatrixWorld( true );\r\n\t\r\n\t\t\t\tthis.matrixWorld.decompose( position, result, scale );\r\n\t\r\n\t\t\t\treturn result;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tgetWorldRotation: function () {\r\n\t\r\n\t\t\tvar quaternion = new THREE.Quaternion();\r\n\t\r\n\t\t\treturn function ( optionalTarget ) {\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Euler();\r\n\t\r\n\t\t\t\tthis.getWorldQuaternion( quaternion );\r\n\t\r\n\t\t\t\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tgetWorldScale: function () {\r\n\t\r\n\t\t\tvar position = new THREE.Vector3();\r\n\t\t\tvar quaternion = new THREE.Quaternion();\r\n\t\r\n\t\t\treturn function ( optionalTarget ) {\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\t\tthis.updateMatrixWorld( true );\r\n\t\r\n\t\t\t\tthis.matrixWorld.decompose( position, quaternion, result );\r\n\t\r\n\t\t\t\treturn result;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tgetWorldDirection: function () {\r\n\t\r\n\t\t\tvar quaternion = new THREE.Quaternion();\r\n\t\r\n\t\t\treturn function ( optionalTarget ) {\r\n\t\r\n\t\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\t\tthis.getWorldQuaternion( quaternion );\r\n\t\r\n\t\t\t\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\traycast: function () {},\r\n\t\r\n\t\ttraverse: function ( callback ) {\r\n\t\r\n\t\t\tcallback( this );\r\n\t\r\n\t\t\tvar children = this.children;\r\n\t\r\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tchildren[ i ].traverse( callback );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttraverseVisible: function ( callback ) {\r\n\t\r\n\t\t\tif ( this.visible === false ) return;\r\n\t\r\n\t\t\tcallback( this );\r\n\t\r\n\t\t\tvar children = this.children;\r\n\t\r\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tchildren[ i ].traverseVisible( callback );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttraverseAncestors: function ( callback ) {\r\n\t\r\n\t\t\tvar parent = this.parent;\r\n\t\r\n\t\t\tif ( parent !== null ) {\r\n\t\r\n\t\t\t\tcallback( parent );\r\n\t\r\n\t\t\t\tparent.traverseAncestors( callback );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdateMatrix: function () {\r\n\t\r\n\t\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\r\n\t\r\n\t\t\tthis.matrixWorldNeedsUpdate = true;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdateMatrixWorld: function ( force ) {\r\n\t\r\n\t\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\r\n\t\r\n\t\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\r\n\t\r\n\t\t\t\tif ( this.parent === null ) {\r\n\t\r\n\t\t\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.matrixWorldNeedsUpdate = false;\r\n\t\r\n\t\t\t\tforce = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// update children\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tthis.children[ i ].updateMatrixWorld( force );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoJSON: function ( meta ) {\r\n\t\r\n\t\t\t// meta is '' when called from JSON.stringify\r\n\t\t\tvar isRootObject = ( meta === undefined || meta === '' );\r\n\t\r\n\t\t\tvar output = {};\r\n\t\r\n\t\t\t// meta is a hash used to collect geometries, materials.\r\n\t\t\t// not providing it implies that this is the root object\r\n\t\t\t// being serialized.\r\n\t\t\tif ( isRootObject ) {\r\n\t\r\n\t\t\t\t// initialize meta obj\r\n\t\t\t\tmeta = {\r\n\t\t\t\t\tgeometries: {},\r\n\t\t\t\t\tmaterials: {},\r\n\t\t\t\t\ttextures: {},\r\n\t\t\t\t\timages: {}\r\n\t\t\t\t};\r\n\t\r\n\t\t\t\toutput.metadata = {\r\n\t\t\t\t\tversion: 4.4,\r\n\t\t\t\t\ttype: 'Object',\r\n\t\t\t\t\tgenerator: 'Object3D.toJSON'\r\n\t\t\t\t};\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// standard Object3D serialization\r\n\t\r\n\t\t\tvar object = {};\r\n\t\r\n\t\t\tobject.uuid = this.uuid;\r\n\t\t\tobject.type = this.type;\r\n\t\r\n\t\t\tif ( this.name !== '' ) object.name = this.name;\r\n\t\t\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\r\n\t\t\tif ( this.castShadow === true ) object.castShadow = true;\r\n\t\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\r\n\t\t\tif ( this.visible === false ) object.visible = false;\r\n\t\r\n\t\t\tobject.matrix = this.matrix.toArray();\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tif ( this.geometry !== undefined ) {\r\n\t\r\n\t\t\t\tif ( meta.geometries[ this.geometry.uuid ] === undefined ) {\r\n\t\r\n\t\t\t\t\tmeta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tobject.geometry = this.geometry.uuid;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.material !== undefined ) {\r\n\t\r\n\t\t\t\tif ( meta.materials[ this.material.uuid ] === undefined ) {\r\n\t\r\n\t\t\t\t\tmeta.materials[ this.material.uuid ] = this.material.toJSON( meta );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tobject.material = this.material.uuid;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tif ( this.children.length > 0 ) {\r\n\t\r\n\t\t\t\tobject.children = [];\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( isRootObject ) {\r\n\t\r\n\t\t\t\tvar geometries = extractFromCache( meta.geometries );\r\n\t\t\t\tvar materials = extractFromCache( meta.materials );\r\n\t\t\t\tvar textures = extractFromCache( meta.textures );\r\n\t\t\t\tvar images = extractFromCache( meta.images );\r\n\t\r\n\t\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\r\n\t\t\t\tif ( materials.length > 0 ) output.materials = materials;\r\n\t\t\t\tif ( textures.length > 0 ) output.textures = textures;\r\n\t\t\t\tif ( images.length > 0 ) output.images = images;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\toutput.object = object;\r\n\t\r\n\t\t\treturn output;\r\n\t\r\n\t\t\t// extract data from the cache hash\r\n\t\t\t// remove metadata on each item\r\n\t\t\t// and return as array\r\n\t\t\tfunction extractFromCache ( cache ) {\r\n\t\r\n\t\t\t\tvar values = [];\r\n\t\t\t\tfor ( var key in cache ) {\r\n\t\r\n\t\t\t\t\tvar data = cache[ key ];\r\n\t\t\t\t\tdelete data.metadata;\r\n\t\t\t\t\tvalues.push( data );\r\n\t\r\n\t\t\t\t}\r\n\t\t\t\treturn values;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function ( recursive ) {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this, recursive );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( source, recursive ) {\r\n\t\r\n\t\t\tif ( recursive === undefined ) recursive = true;\r\n\t\r\n\t\t\tthis.name = source.name;\r\n\t\r\n\t\t\tthis.up.copy( source.up );\r\n\t\r\n\t\t\tthis.position.copy( source.position );\r\n\t\t\tthis.quaternion.copy( source.quaternion );\r\n\t\t\tthis.scale.copy( source.scale );\r\n\t\r\n\t\t\tthis.matrix.copy( source.matrix );\r\n\t\t\tthis.matrixWorld.copy( source.matrixWorld );\r\n\t\r\n\t\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\r\n\t\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\r\n\t\r\n\t\t\tthis.visible = source.visible;\r\n\t\r\n\t\t\tthis.castShadow = source.castShadow;\r\n\t\t\tthis.receiveShadow = source.receiveShadow;\r\n\t\r\n\t\t\tthis.frustumCulled = source.frustumCulled;\r\n\t\t\tthis.renderOrder = source.renderOrder;\r\n\t\r\n\t\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\r\n\t\r\n\t\t\tif ( recursive === true ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar child = source.children[ i ];\r\n\t\t\t\t\tthis.add( child.clone() );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\tTHREE.Object3DIdCount = 0;\r\n\t\r\n\t// File:src/core/Face3.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {\r\n\t\r\n\t\tthis.a = a;\r\n\t\tthis.b = b;\r\n\t\tthis.c = c;\r\n\t\r\n\t\tthis.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\r\n\t\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\r\n\t\r\n\t\tthis.color = color instanceof THREE.Color ? color : new THREE.Color();\r\n\t\tthis.vertexColors = Array.isArray( color ) ? color : [];\r\n\t\r\n\t\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Face3.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Face3,\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tthis.a = source.a;\r\n\t\t\tthis.b = source.b;\r\n\t\t\tthis.c = source.c;\r\n\t\r\n\t\t\tthis.normal.copy( source.normal );\r\n\t\t\tthis.color.copy( source.color );\r\n\t\r\n\t\t\tthis.materialIndex = source.materialIndex;\r\n\t\r\n\t\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/BufferAttribute.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.BufferAttribute = function ( array, itemSize, normalized ) {\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.array = array;\r\n\t\tthis.itemSize = itemSize;\r\n\t\r\n\t\tthis.dynamic = false;\r\n\t\tthis.updateRange = { offset: 0, count: - 1 };\r\n\t\r\n\t\tthis.version = 0;\r\n\t\tthis.normalized = normalized === true;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BufferAttribute.prototype = {\r\n\t\r\n\t\tconstructor: THREE.BufferAttribute,\r\n\t\r\n\t\tget count() {\r\n\t\r\n\t\t\treturn this.array.length / this.itemSize;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset needsUpdate( value ) {\r\n\t\r\n\t\t\tif ( value === true ) this.version ++;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetDynamic: function ( value ) {\r\n\t\r\n\t\t\tthis.dynamic = value;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tthis.array = new source.array.constructor( source.array );\r\n\t\t\tthis.itemSize = source.itemSize;\r\n\t\r\n\t\t\tthis.dynamic = source.dynamic;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyAt: function ( index1, attribute, index2 ) {\r\n\t\r\n\t\t\tindex1 *= this.itemSize;\r\n\t\t\tindex2 *= attribute.itemSize;\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyArray: function ( array ) {\r\n\t\r\n\t\t\tthis.array.set( array );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyColorsArray: function ( colors ) {\r\n\t\r\n\t\t\tvar array = this.array, offset = 0;\r\n\t\r\n\t\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar color = colors[ i ];\r\n\t\r\n\t\t\t\tif ( color === undefined ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\r\n\t\t\t\t\tcolor = new THREE.Color();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tarray[ offset ++ ] = color.r;\r\n\t\t\t\tarray[ offset ++ ] = color.g;\r\n\t\t\t\tarray[ offset ++ ] = color.b;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyIndicesArray: function ( indices ) {\r\n\t\r\n\t\t\tvar array = this.array, offset = 0;\r\n\t\r\n\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar index = indices[ i ];\r\n\t\r\n\t\t\t\tarray[ offset ++ ] = index.a;\r\n\t\t\t\tarray[ offset ++ ] = index.b;\r\n\t\t\t\tarray[ offset ++ ] = index.c;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyVector2sArray: function ( vectors ) {\r\n\t\r\n\t\t\tvar array = this.array, offset = 0;\r\n\t\r\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar vector = vectors[ i ];\r\n\t\r\n\t\t\t\tif ( vector === undefined ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\r\n\t\t\t\t\tvector = new THREE.Vector2();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tarray[ offset ++ ] = vector.x;\r\n\t\t\t\tarray[ offset ++ ] = vector.y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyVector3sArray: function ( vectors ) {\r\n\t\r\n\t\t\tvar array = this.array, offset = 0;\r\n\t\r\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar vector = vectors[ i ];\r\n\t\r\n\t\t\t\tif ( vector === undefined ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\r\n\t\t\t\t\tvector = new THREE.Vector3();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tarray[ offset ++ ] = vector.x;\r\n\t\t\t\tarray[ offset ++ ] = vector.y;\r\n\t\t\t\tarray[ offset ++ ] = vector.z;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyVector4sArray: function ( vectors ) {\r\n\t\r\n\t\t\tvar array = this.array, offset = 0;\r\n\t\r\n\t\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar vector = vectors[ i ];\r\n\t\r\n\t\t\t\tif ( vector === undefined ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\r\n\t\t\t\t\tvector = new THREE.Vector4();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tarray[ offset ++ ] = vector.x;\r\n\t\t\t\tarray[ offset ++ ] = vector.y;\r\n\t\t\t\tarray[ offset ++ ] = vector.z;\r\n\t\t\t\tarray[ offset ++ ] = vector.w;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset: function ( value, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis.array.set( value, offset );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetX: function ( index ) {\r\n\t\r\n\t\t\treturn this.array[ index * this.itemSize ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetX: function ( index, x ) {\r\n\t\r\n\t\t\tthis.array[ index * this.itemSize ] = x;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetY: function ( index ) {\r\n\t\r\n\t\t\treturn this.array[ index * this.itemSize + 1 ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetY: function ( index, y ) {\r\n\t\r\n\t\t\tthis.array[ index * this.itemSize + 1 ] = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetZ: function ( index ) {\r\n\t\r\n\t\t\treturn this.array[ index * this.itemSize + 2 ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetZ: function ( index, z ) {\r\n\t\r\n\t\t\tthis.array[ index * this.itemSize + 2 ] = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetW: function ( index ) {\r\n\t\r\n\t\t\treturn this.array[ index * this.itemSize + 3 ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetW: function ( index, w ) {\r\n\t\r\n\t\t\tthis.array[ index * this.itemSize + 3 ] = w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetXY: function ( index, x, y ) {\r\n\t\r\n\t\t\tindex *= this.itemSize;\r\n\t\r\n\t\t\tthis.array[ index + 0 ] = x;\r\n\t\t\tthis.array[ index + 1 ] = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetXYZ: function ( index, x, y, z ) {\r\n\t\r\n\t\t\tindex *= this.itemSize;\r\n\t\r\n\t\t\tthis.array[ index + 0 ] = x;\r\n\t\t\tthis.array[ index + 1 ] = y;\r\n\t\t\tthis.array[ index + 2 ] = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetXYZW: function ( index, x, y, z, w ) {\r\n\t\r\n\t\t\tindex *= this.itemSize;\r\n\t\r\n\t\t\tthis.array[ index + 0 ] = x;\r\n\t\t\tthis.array[ index + 1 ] = y;\r\n\t\t\tthis.array[ index + 2 ] = z;\r\n\t\t\tthis.array[ index + 3 ] = w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t//\r\n\t\r\n\tTHREE.Int8Attribute = function ( array, itemSize ) {\r\n\t\r\n\t\treturn new THREE.BufferAttribute( new Int8Array( array ), itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Uint8Attribute = function ( array, itemSize ) {\r\n\t\r\n\t\treturn new THREE.BufferAttribute( new Uint8Array( array ), itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Uint8ClampedAttribute = function ( array, itemSize ) {\r\n\t\r\n\t\treturn new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Int16Attribute = function ( array, itemSize ) {\r\n\t\r\n\t\treturn new THREE.BufferAttribute( new Int16Array( array ), itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Uint16Attribute = function ( array, itemSize ) {\r\n\t\r\n\t\treturn new THREE.BufferAttribute( new Uint16Array( array ), itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Int32Attribute = function ( array, itemSize ) {\r\n\t\r\n\t\treturn new THREE.BufferAttribute( new Int32Array( array ), itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Uint32Attribute = function ( array, itemSize ) {\r\n\t\r\n\t\treturn new THREE.BufferAttribute( new Uint32Array( array ), itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Float32Attribute = function ( array, itemSize ) {\r\n\t\r\n\t\treturn new THREE.BufferAttribute( new Float32Array( array ), itemSize );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Float64Attribute = function ( array, itemSize ) {\r\n\t\r\n\t\treturn new THREE.BufferAttribute( new Float64Array( array ), itemSize );\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t// Deprecated\r\n\t\r\n\tTHREE.DynamicBufferAttribute = function ( array, itemSize ) {\r\n\t\r\n\t\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\r\n\t\treturn new THREE.BufferAttribute( array, itemSize ).setDynamic( true );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/InstancedBufferAttribute.js\r\n\t\r\n\t/**\r\n\t * @author benaadams / https://twitter.com/ben_a_adams\r\n\t */\r\n\t\r\n\tTHREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {\r\n\t\r\n\t\tTHREE.BufferAttribute.call( this, array, itemSize );\r\n\t\r\n\t\tthis.meshPerAttribute = meshPerAttribute || 1;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );\r\n\tTHREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;\r\n\t\r\n\tTHREE.InstancedBufferAttribute.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.BufferAttribute.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/InterleavedBuffer.js\r\n\t\r\n\t/**\r\n\t * @author benaadams / https://twitter.com/ben_a_adams\r\n\t */\r\n\t\r\n\tTHREE.InterleavedBuffer = function ( array, stride ) {\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.array = array;\r\n\t\tthis.stride = stride;\r\n\t\r\n\t\tthis.dynamic = false;\r\n\t\tthis.updateRange = { offset: 0, count: - 1 };\r\n\t\r\n\t\tthis.version = 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.InterleavedBuffer.prototype = {\r\n\t\r\n\t\tconstructor: THREE.InterleavedBuffer,\r\n\t\r\n\t\tget length () {\r\n\t\r\n\t\t\treturn this.array.length;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget count () {\r\n\t\r\n\t\t\treturn this.array.length / this.stride;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset needsUpdate( value ) {\r\n\t\r\n\t\t\tif ( value === true ) this.version ++;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetDynamic: function ( value ) {\r\n\t\r\n\t\t\tthis.dynamic = value;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tthis.array = new source.array.constructor( source.array );\r\n\t\t\tthis.stride = source.stride;\r\n\t\t\tthis.dynamic = source.dynamic;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopyAt: function ( index1, attribute, index2 ) {\r\n\t\r\n\t\t\tindex1 *= this.stride;\r\n\t\t\tindex2 *= attribute.stride;\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset: function ( value, offset ) {\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tthis.array.set( value, offset );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/InstancedInterleavedBuffer.js\r\n\t\r\n\t/**\r\n\t * @author benaadams / https://twitter.com/ben_a_adams\r\n\t */\r\n\t\r\n\tTHREE.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {\r\n\t\r\n\t\tTHREE.InterleavedBuffer.call( this, array, stride );\r\n\t\r\n\t\tthis.meshPerAttribute = meshPerAttribute || 1;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );\r\n\tTHREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;\r\n\t\r\n\tTHREE.InstancedInterleavedBuffer.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.InterleavedBuffer.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.meshPerAttribute = source.meshPerAttribute;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/InterleavedBufferAttribute.js\r\n\t\r\n\t/**\r\n\t * @author benaadams / https://twitter.com/ben_a_adams\r\n\t */\r\n\t\r\n\tTHREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.data = interleavedBuffer;\r\n\t\tthis.itemSize = itemSize;\r\n\t\tthis.offset = offset;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.InterleavedBufferAttribute.prototype = {\r\n\t\r\n\t\tconstructor: THREE.InterleavedBufferAttribute,\r\n\t\r\n\t\tget length() {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\r\n\t\t\treturn this.array.length;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget count() {\r\n\t\r\n\t\t\treturn this.data.count;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetX: function ( index, x ) {\r\n\t\r\n\t\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetY: function ( index, y ) {\r\n\t\r\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetZ: function ( index, z ) {\r\n\t\r\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetW: function ( index, w ) {\r\n\t\r\n\t\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetX: function ( index ) {\r\n\t\r\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetY: function ( index ) {\r\n\t\r\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetZ: function ( index ) {\r\n\t\r\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetW: function ( index ) {\r\n\t\r\n\t\t\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetXY: function ( index, x, y ) {\r\n\t\r\n\t\t\tindex = index * this.data.stride + this.offset;\r\n\t\r\n\t\t\tthis.data.array[ index + 0 ] = x;\r\n\t\t\tthis.data.array[ index + 1 ] = y;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetXYZ: function ( index, x, y, z ) {\r\n\t\r\n\t\t\tindex = index * this.data.stride + this.offset;\r\n\t\r\n\t\t\tthis.data.array[ index + 0 ] = x;\r\n\t\t\tthis.data.array[ index + 1 ] = y;\r\n\t\t\tthis.data.array[ index + 2 ] = z;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetXYZW: function ( index, x, y, z, w ) {\r\n\t\r\n\t\t\tindex = index * this.data.stride + this.offset;\r\n\t\r\n\t\t\tthis.data.array[ index + 0 ] = x;\r\n\t\t\tthis.data.array[ index + 1 ] = y;\r\n\t\t\tthis.data.array[ index + 2 ] = z;\r\n\t\t\tthis.data.array[ index + 3 ] = w;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/Geometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author kile / http://kile.stravaganza.org/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * @author bhouston / http://clara.io\r\n\t */\r\n\t\r\n\tTHREE.Geometry = function () {\r\n\t\r\n\t\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.name = '';\r\n\t\tthis.type = 'Geometry';\r\n\t\r\n\t\tthis.vertices = [];\r\n\t\tthis.colors = [];\r\n\t\tthis.faces = [];\r\n\t\tthis.faceVertexUvs = [ [] ];\r\n\t\r\n\t\tthis.morphTargets = [];\r\n\t\tthis.morphNormals = [];\r\n\t\r\n\t\tthis.skinWeights = [];\r\n\t\tthis.skinIndices = [];\r\n\t\r\n\t\tthis.lineDistances = [];\r\n\t\r\n\t\tthis.boundingBox = null;\r\n\t\tthis.boundingSphere = null;\r\n\t\r\n\t\t// update flags\r\n\t\r\n\t\tthis.verticesNeedUpdate = false;\r\n\t\tthis.elementsNeedUpdate = false;\r\n\t\tthis.uvsNeedUpdate = false;\r\n\t\tthis.normalsNeedUpdate = false;\r\n\t\tthis.colorsNeedUpdate = false;\r\n\t\tthis.lineDistancesNeedUpdate = false;\r\n\t\tthis.groupsNeedUpdate = false;\r\n\t\r\n\t};\r\n\t\r\n\tObject.assign( THREE.Geometry.prototype, THREE.EventDispatcher.prototype, {\r\n\t\r\n\t\tapplyMatrix: function ( matrix ) {\r\n\t\r\n\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\t\r\n\t\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar vertex = this.vertices[ i ];\r\n\t\t\t\tvertex.applyMatrix4( matrix );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = this.faces[ i ];\r\n\t\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.boundingBox !== null ) {\r\n\t\r\n\t\t\t\tthis.computeBoundingBox();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.boundingSphere !== null ) {\r\n\t\r\n\t\t\t\tthis.computeBoundingSphere();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.verticesNeedUpdate = true;\r\n\t\t\tthis.normalsNeedUpdate = true;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\trotateX: function () {\r\n\t\r\n\t\t\t// rotate geometry around world x-axis\r\n\t\r\n\t\t\tvar m1;\r\n\t\r\n\t\t\treturn function rotateX( angle ) {\r\n\t\r\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tm1.makeRotationX( angle );\r\n\t\r\n\t\t\t\tthis.applyMatrix( m1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\trotateY: function () {\r\n\t\r\n\t\t\t// rotate geometry around world y-axis\r\n\t\r\n\t\t\tvar m1;\r\n\t\r\n\t\t\treturn function rotateY( angle ) {\r\n\t\r\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tm1.makeRotationY( angle );\r\n\t\r\n\t\t\t\tthis.applyMatrix( m1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\trotateZ: function () {\r\n\t\r\n\t\t\t// rotate geometry around world z-axis\r\n\t\r\n\t\t\tvar m1;\r\n\t\r\n\t\t\treturn function rotateZ( angle ) {\r\n\t\r\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tm1.makeRotationZ( angle );\r\n\t\r\n\t\t\t\tthis.applyMatrix( m1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslate: function () {\r\n\t\r\n\t\t\t// translate geometry\r\n\t\r\n\t\t\tvar m1;\r\n\t\r\n\t\t\treturn function translate( x, y, z ) {\r\n\t\r\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tm1.makeTranslation( x, y, z );\r\n\t\r\n\t\t\t\tthis.applyMatrix( m1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tscale: function () {\r\n\t\r\n\t\t\t// scale geometry\r\n\t\r\n\t\t\tvar m1;\r\n\t\r\n\t\t\treturn function scale( x, y, z ) {\r\n\t\r\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tm1.makeScale( x, y, z );\r\n\t\r\n\t\t\t\tthis.applyMatrix( m1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tlookAt: function () {\r\n\t\r\n\t\t\tvar obj;\r\n\t\r\n\t\t\treturn function lookAt( vector ) {\r\n\t\r\n\t\t\t\tif ( obj === undefined ) obj = new THREE.Object3D();\r\n\t\r\n\t\t\t\tobj.lookAt( vector );\r\n\t\r\n\t\t\t\tobj.updateMatrix();\r\n\t\r\n\t\t\t\tthis.applyMatrix( obj.matrix );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tfromBufferGeometry: function ( geometry ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\r\n\t\t\tvar attributes = geometry.attributes;\r\n\t\r\n\t\t\tvar positions = attributes.position.array;\r\n\t\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\r\n\t\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\r\n\t\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\r\n\t\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\r\n\t\r\n\t\t\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\r\n\t\r\n\t\t\tvar tempNormals = [];\r\n\t\t\tvar tempUVs = [];\r\n\t\t\tvar tempUVs2 = [];\r\n\t\r\n\t\t\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\r\n\t\r\n\t\t\t\tscope.vertices.push( new THREE.Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\r\n\t\r\n\t\t\t\tif ( normals !== undefined ) {\r\n\t\r\n\t\t\t\t\ttempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( colors !== undefined ) {\r\n\t\r\n\t\t\t\t\tscope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( uvs !== undefined ) {\r\n\t\r\n\t\t\t\t\ttempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( uvs2 !== undefined ) {\r\n\t\r\n\t\t\t\t\ttempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction addFace( a, b, c, materialIndex ) {\r\n\t\r\n\t\t\t\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\r\n\t\t\t\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\r\n\t\r\n\t\t\t\tvar face = new THREE.Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\r\n\t\r\n\t\t\t\tscope.faces.push( face );\r\n\t\r\n\t\t\t\tif ( uvs !== undefined ) {\r\n\t\r\n\t\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( uvs2 !== undefined ) {\r\n\t\r\n\t\t\t\t\tscope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( indices !== undefined ) {\r\n\t\r\n\t\t\t\tvar groups = geometry.groups;\r\n\t\r\n\t\t\t\tif ( groups.length > 0 ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < groups.length; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar group = groups[ i ];\r\n\t\r\n\t\t\t\t\t\tvar start = group.start;\r\n\t\t\t\t\t\tvar count = group.count;\r\n\t\r\n\t\t\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\r\n\t\r\n\t\t\t\t\t\t\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\r\n\t\r\n\t\t\t\t\taddFace( i, i + 1, i + 2 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.computeFaceNormals();\r\n\t\r\n\t\t\tif ( geometry.boundingBox !== null ) {\r\n\t\r\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.boundingSphere !== null ) {\r\n\t\r\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcenter: function () {\r\n\t\r\n\t\t\tthis.computeBoundingBox();\r\n\t\r\n\t\t\tvar offset = this.boundingBox.center().negate();\r\n\t\r\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\r\n\t\r\n\t\t\treturn offset;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalize: function () {\r\n\t\r\n\t\t\tthis.computeBoundingSphere();\r\n\t\r\n\t\t\tvar center = this.boundingSphere.center;\r\n\t\t\tvar radius = this.boundingSphere.radius;\r\n\t\r\n\t\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\r\n\t\r\n\t\t\tvar matrix = new THREE.Matrix4();\r\n\t\t\tmatrix.set(\r\n\t\t\t\ts, 0, 0, - s * center.x,\r\n\t\t\t\t0, s, 0, - s * center.y,\r\n\t\t\t\t0, 0, s, - s * center.z,\r\n\t\t\t\t0, 0, 0, 1\r\n\t\t\t);\r\n\t\r\n\t\t\tthis.applyMatrix( matrix );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeFaceNormals: function () {\r\n\t\r\n\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\r\n\t\r\n\t\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\tvar face = this.faces[ f ];\r\n\t\r\n\t\t\t\tvar vA = this.vertices[ face.a ];\r\n\t\t\t\tvar vB = this.vertices[ face.b ];\r\n\t\t\t\tvar vC = this.vertices[ face.c ];\r\n\t\r\n\t\t\t\tcb.subVectors( vC, vB );\r\n\t\t\t\tab.subVectors( vA, vB );\r\n\t\t\t\tcb.cross( ab );\r\n\t\r\n\t\t\t\tcb.normalize();\r\n\t\r\n\t\t\t\tface.normal.copy( cb );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeVertexNormals: function ( areaWeighted ) {\r\n\t\r\n\t\t\tif ( areaWeighted === undefined ) areaWeighted = true;\r\n\t\r\n\t\t\tvar v, vl, f, fl, face, vertices;\r\n\t\r\n\t\t\tvertices = new Array( this.vertices.length );\r\n\t\r\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\t\r\n\t\t\t\tvertices[ v ] = new THREE.Vector3();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( areaWeighted ) {\r\n\t\r\n\t\t\t\t// vertex normals weighted by triangle areas\r\n\t\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\r\n\t\r\n\t\t\t\tvar vA, vB, vC;\r\n\t\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\t\tvA = this.vertices[ face.a ];\r\n\t\t\t\t\tvB = this.vertices[ face.b ];\r\n\t\t\t\t\tvC = this.vertices[ face.c ];\r\n\t\r\n\t\t\t\t\tcb.subVectors( vC, vB );\r\n\t\t\t\t\tab.subVectors( vA, vB );\r\n\t\t\t\t\tcb.cross( ab );\r\n\t\r\n\t\t\t\t\tvertices[ face.a ].add( cb );\r\n\t\t\t\t\tvertices[ face.b ].add( cb );\r\n\t\t\t\t\tvertices[ face.c ].add( cb );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\t\tvertices[ face.a ].add( face.normal );\r\n\t\t\t\t\tvertices[ face.b ].add( face.normal );\r\n\t\t\t\t\tvertices[ face.c ].add( face.normal );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\t\r\n\t\t\t\tvertices[ v ].normalize();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\tvar vertexNormals = face.vertexNormals;\r\n\t\r\n\t\t\t\tif ( vertexNormals.length === 3 ) {\r\n\t\r\n\t\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\r\n\t\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\r\n\t\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\r\n\t\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\r\n\t\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.faces.length > 0 ) {\r\n\t\r\n\t\t\t\tthis.normalsNeedUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeMorphNormals: function () {\r\n\t\r\n\t\t\tvar i, il, f, fl, face;\r\n\t\r\n\t\t\t// save original normals\r\n\t\t\t// - create temp variables on first access\r\n\t\t\t//   otherwise just copy (for faster repeated calls)\r\n\t\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\tif ( ! face.__originalFaceNormal ) {\r\n\t\r\n\t\t\t\t\tface.__originalFaceNormal = face.normal.clone();\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tface.__originalFaceNormal.copy( face.normal );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\r\n\t\r\n\t\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\r\n\t\r\n\t\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// use temp geometry to compute face and vertex normals for each morph\r\n\t\r\n\t\t\tvar tmpGeo = new THREE.Geometry();\r\n\t\t\ttmpGeo.faces = this.faces;\r\n\t\r\n\t\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t// create on first access\r\n\t\r\n\t\t\t\tif ( ! this.morphNormals[ i ] ) {\r\n\t\r\n\t\t\t\t\tthis.morphNormals[ i ] = {};\r\n\t\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\r\n\t\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\r\n\t\r\n\t\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\r\n\t\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\r\n\t\r\n\t\t\t\t\tvar faceNormal, vertexNormals;\r\n\t\r\n\t\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\t\tfaceNormal = new THREE.Vector3();\r\n\t\t\t\t\t\tvertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };\r\n\t\r\n\t\t\t\t\t\tdstNormalsFace.push( faceNormal );\r\n\t\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar morphNormals = this.morphNormals[ i ];\r\n\t\r\n\t\t\t\t// set vertices to morph target\r\n\t\r\n\t\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\r\n\t\r\n\t\t\t\t// compute morph normals\r\n\t\r\n\t\t\t\ttmpGeo.computeFaceNormals();\r\n\t\t\t\ttmpGeo.computeVertexNormals();\r\n\t\r\n\t\t\t\t// store morph normals\r\n\t\r\n\t\t\t\tvar faceNormal, vertexNormals;\r\n\t\r\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\r\n\t\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\r\n\t\r\n\t\t\t\t\tfaceNormal.copy( face.normal );\r\n\t\r\n\t\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\r\n\t\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\r\n\t\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// restore original normals\r\n\t\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\tface = this.faces[ f ];\r\n\t\r\n\t\t\t\tface.normal = face.__originalFaceNormal;\r\n\t\t\t\tface.vertexNormals = face.__originalVertexNormals;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeTangents: function () {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Geometry: .computeTangents() has been removed.' );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeLineDistances: function () {\r\n\t\r\n\t\t\tvar d = 0;\r\n\t\t\tvar vertices = this.vertices;\r\n\t\r\n\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tif ( i > 0 ) {\r\n\t\r\n\t\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.lineDistances[ i ] = d;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeBoundingBox: function () {\r\n\t\r\n\t\t\tif ( this.boundingBox === null ) {\r\n\t\r\n\t\t\t\tthis.boundingBox = new THREE.Box3();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.boundingBox.setFromPoints( this.vertices );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeBoundingSphere: function () {\r\n\t\r\n\t\t\tif ( this.boundingSphere === null ) {\r\n\t\r\n\t\t\t\tthis.boundingSphere = new THREE.Sphere();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.boundingSphere.setFromPoints( this.vertices );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmerge: function ( geometry, matrix, materialIndexOffset ) {\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.Geometry === false ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar normalMatrix,\r\n\t\t\tvertexOffset = this.vertices.length,\r\n\t\t\tvertices1 = this.vertices,\r\n\t\t\tvertices2 = geometry.vertices,\r\n\t\t\tfaces1 = this.faces,\r\n\t\t\tfaces2 = geometry.faces,\r\n\t\t\tuvs1 = this.faceVertexUvs[ 0 ],\r\n\t\t\tuvs2 = geometry.faceVertexUvs[ 0 ];\r\n\t\r\n\t\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\r\n\t\r\n\t\t\tif ( matrix !== undefined ) {\r\n\t\r\n\t\t\t\tnormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// vertices\r\n\t\r\n\t\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar vertex = vertices2[ i ];\r\n\t\r\n\t\t\t\tvar vertexCopy = vertex.clone();\r\n\t\r\n\t\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\r\n\t\r\n\t\t\t\tvertices1.push( vertexCopy );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// faces\r\n\t\r\n\t\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\r\n\t\t\t\tfaceVertexNormals = face.vertexNormals,\r\n\t\t\t\tfaceVertexColors = face.vertexColors;\r\n\t\r\n\t\t\t\tfaceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\r\n\t\t\t\tfaceCopy.normal.copy( face.normal );\r\n\t\r\n\t\t\t\tif ( normalMatrix !== undefined ) {\r\n\t\r\n\t\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tnormal = faceVertexNormals[ j ].clone();\r\n\t\r\n\t\t\t\t\tif ( normalMatrix !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tfaceCopy.vertexNormals.push( normal );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfaceCopy.color.copy( face.color );\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tcolor = faceVertexColors[ j ];\r\n\t\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\r\n\t\r\n\t\t\t\tfaces1.push( faceCopy );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// uvs\r\n\t\r\n\t\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar uv = uvs2[ i ], uvCopy = [];\r\n\t\r\n\t\t\t\tif ( uv === undefined ) {\r\n\t\r\n\t\t\t\t\tcontinue;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tuvCopy.push( uv[ j ].clone() );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tuvs1.push( uvCopy );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmergeMesh: function ( mesh ) {\r\n\t\r\n\t\t\tif ( mesh instanceof THREE.Mesh === false ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tmesh.matrixAutoUpdate && mesh.updateMatrix();\r\n\t\r\n\t\t\tthis.merge( mesh.geometry, mesh.matrix );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t/*\r\n\t\t * Checks for duplicate vertices with hashmap.\r\n\t\t * Duplicated vertices are removed\r\n\t\t * and faces' vertices are updated.\r\n\t\t */\r\n\t\r\n\t\tmergeVertices: function () {\r\n\t\r\n\t\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\r\n\t\t\tvar unique = [], changes = [];\r\n\t\r\n\t\t\tvar v, key;\r\n\t\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\r\n\t\t\tvar precision = Math.pow( 10, precisionPoints );\r\n\t\t\tvar i, il, face;\r\n\t\t\tvar indices, j, jl;\r\n\t\r\n\t\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tv = this.vertices[ i ];\r\n\t\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\r\n\t\r\n\t\t\t\tif ( verticesMap[ key ] === undefined ) {\r\n\t\r\n\t\t\t\t\tverticesMap[ key ] = i;\r\n\t\t\t\t\tunique.push( this.vertices[ i ] );\r\n\t\t\t\t\tchanges[ i ] = unique.length - 1;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\r\n\t\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\t// if faces are completely degenerate after merging vertices, we\r\n\t\t\t// have to remove them from the geometry.\r\n\t\t\tvar faceIndicesToRemove = [];\r\n\t\r\n\t\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tface = this.faces[ i ];\r\n\t\r\n\t\t\t\tface.a = changes[ face.a ];\r\n\t\t\t\tface.b = changes[ face.b ];\r\n\t\t\t\tface.c = changes[ face.c ];\r\n\t\r\n\t\t\t\tindices = [ face.a, face.b, face.c ];\r\n\t\r\n\t\t\t\tvar dupIndex = - 1;\r\n\t\r\n\t\t\t\t// if any duplicate vertices are found in a Face3\r\n\t\t\t\t// we have to remove the face as nothing can be saved\r\n\t\t\t\tfor ( var n = 0; n < 3; n ++ ) {\r\n\t\r\n\t\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\r\n\t\r\n\t\t\t\t\t\tdupIndex = n;\r\n\t\t\t\t\t\tfaceIndicesToRemove.push( i );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\r\n\t\r\n\t\t\t\tvar idx = faceIndicesToRemove[ i ];\r\n\t\r\n\t\t\t\tthis.faces.splice( idx, 1 );\r\n\t\r\n\t\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// Use unique set of vertices\r\n\t\r\n\t\t\tvar diff = this.vertices.length - unique.length;\r\n\t\t\tthis.vertices = unique;\r\n\t\t\treturn diff;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsortFacesByMaterialIndex: function () {\r\n\t\r\n\t\t\tvar faces = this.faces;\r\n\t\t\tvar length = faces.length;\r\n\t\r\n\t\t\t// tag faces\r\n\t\r\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\t\r\n\t\t\t\tfaces[ i ]._id = i;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// sort faces\r\n\t\r\n\t\t\tfunction materialIndexSort( a, b ) {\r\n\t\r\n\t\t\t\treturn a.materialIndex - b.materialIndex;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfaces.sort( materialIndexSort );\r\n\t\r\n\t\t\t// sort uvs\r\n\t\r\n\t\t\tvar uvs1 = this.faceVertexUvs[ 0 ];\r\n\t\t\tvar uvs2 = this.faceVertexUvs[ 1 ];\r\n\t\r\n\t\t\tvar newUvs1, newUvs2;\r\n\t\r\n\t\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\r\n\t\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\r\n\t\r\n\t\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\t\r\n\t\t\t\tvar id = faces[ i ]._id;\r\n\t\r\n\t\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\r\n\t\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\r\n\t\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoJSON: function () {\r\n\t\r\n\t\t\tvar data = {\r\n\t\t\t\tmetadata: {\r\n\t\t\t\t\tversion: 4.4,\r\n\t\t\t\t\ttype: 'Geometry',\r\n\t\t\t\t\tgenerator: 'Geometry.toJSON'\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\r\n\t\t\t// standard Geometry serialization\r\n\t\r\n\t\t\tdata.uuid = this.uuid;\r\n\t\t\tdata.type = this.type;\r\n\t\t\tif ( this.name !== '' ) data.name = this.name;\r\n\t\r\n\t\t\tif ( this.parameters !== undefined ) {\r\n\t\r\n\t\t\t\tvar parameters = this.parameters;\r\n\t\r\n\t\t\t\tfor ( var key in parameters ) {\r\n\t\r\n\t\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn data;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar vertices = [];\r\n\t\r\n\t\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\r\n\t\r\n\t\t\t\tvar vertex = this.vertices[ i ];\r\n\t\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar faces = [];\r\n\t\t\tvar normals = [];\r\n\t\t\tvar normalsHash = {};\r\n\t\t\tvar colors = [];\r\n\t\t\tvar colorsHash = {};\r\n\t\t\tvar uvs = [];\r\n\t\t\tvar uvsHash = {};\r\n\t\r\n\t\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = this.faces[ i ];\r\n\t\r\n\t\t\t\tvar hasMaterial = true;\r\n\t\t\t\tvar hasFaceUv = false; // deprecated\r\n\t\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\r\n\t\t\t\tvar hasFaceNormal = face.normal.length() > 0;\r\n\t\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\r\n\t\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\r\n\t\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\r\n\t\r\n\t\t\t\tvar faceType = 0;\r\n\t\r\n\t\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\r\n\t\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\r\n\t\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\r\n\t\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\r\n\t\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\r\n\t\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\r\n\t\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\r\n\t\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\r\n\t\r\n\t\t\t\tfaces.push( faceType );\r\n\t\t\t\tfaces.push( face.a, face.b, face.c );\r\n\t\t\t\tfaces.push( face.materialIndex );\r\n\t\r\n\t\t\t\tif ( hasFaceVertexUv ) {\r\n\t\r\n\t\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\r\n\t\r\n\t\t\t\t\tfaces.push(\r\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\r\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\r\n\t\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\r\n\t\t\t\t\t);\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasFaceNormal ) {\r\n\t\r\n\t\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\t\r\n\t\t\t\t\tvar vertexNormals = face.vertexNormals;\r\n\t\r\n\t\t\t\t\tfaces.push(\r\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\r\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\r\n\t\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\r\n\t\t\t\t\t);\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasFaceColor ) {\r\n\t\r\n\t\t\t\t\tfaces.push( getColorIndex( face.color ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasFaceVertexColor ) {\r\n\t\r\n\t\t\t\t\tvar vertexColors = face.vertexColors;\r\n\t\r\n\t\t\t\t\tfaces.push(\r\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\r\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\r\n\t\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\r\n\t\t\t\t\t);\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction setBit( value, position, enabled ) {\r\n\t\r\n\t\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction getNormalIndex( normal ) {\r\n\t\r\n\t\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\r\n\t\r\n\t\t\t\tif ( normalsHash[ hash ] !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn normalsHash[ hash ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tnormalsHash[ hash ] = normals.length / 3;\r\n\t\t\t\tnormals.push( normal.x, normal.y, normal.z );\r\n\t\r\n\t\t\t\treturn normalsHash[ hash ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction getColorIndex( color ) {\r\n\t\r\n\t\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\r\n\t\r\n\t\t\t\tif ( colorsHash[ hash ] !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn colorsHash[ hash ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tcolorsHash[ hash ] = colors.length;\r\n\t\t\t\tcolors.push( color.getHex() );\r\n\t\r\n\t\t\t\treturn colorsHash[ hash ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction getUvIndex( uv ) {\r\n\t\r\n\t\t\t\tvar hash = uv.x.toString() + uv.y.toString();\r\n\t\r\n\t\t\t\tif ( uvsHash[ hash ] !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn uvsHash[ hash ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tuvsHash[ hash ] = uvs.length / 2;\r\n\t\t\t\tuvs.push( uv.x, uv.y );\r\n\t\r\n\t\t\t\treturn uvsHash[ hash ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tdata.data = {};\r\n\t\r\n\t\t\tdata.data.vertices = vertices;\r\n\t\t\tdata.data.normals = normals;\r\n\t\t\tif ( colors.length > 0 ) data.data.colors = colors;\r\n\t\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\r\n\t\t\tdata.data.faces = faces;\r\n\t\r\n\t\t\treturn data;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\t/*\r\n\t\t\t// Handle primitives\r\n\t\r\n\t\t\tvar parameters = this.parameters;\r\n\t\r\n\t\t\tif ( parameters !== undefined ) {\r\n\t\r\n\t\t\t\tvar values = [];\r\n\t\r\n\t\t\t\tfor ( var key in parameters ) {\r\n\t\r\n\t\t\t\t\tvalues.push( parameters[ key ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar geometry = Object.create( this.constructor.prototype );\r\n\t\t\t\tthis.constructor.apply( geometry, values );\r\n\t\t\t\treturn geometry;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\t\t*/\r\n\t\r\n\t\t\treturn new THREE.Geometry().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tthis.vertices = [];\r\n\t\t\tthis.faces = [];\r\n\t\t\tthis.faceVertexUvs = [ [] ];\r\n\t\r\n\t\t\tvar vertices = source.vertices;\r\n\t\r\n\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tthis.vertices.push( vertices[ i ].clone() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar faces = source.faces;\r\n\t\r\n\t\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tthis.faces.push( faces[ i ].clone() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar faceVertexUvs = source.faceVertexUvs[ i ];\r\n\t\r\n\t\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\r\n\t\r\n\t\t\t\t\tthis.faceVertexUvs[ i ] = [];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\r\n\t\r\n\t\t\t\t\tfor ( var k = 0, kl = uvs.length; k < kl; k ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar uv = uvs[ k ];\r\n\t\r\n\t\t\t\t\t\tuvsCopy.push( uv.clone() );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispose: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\tTHREE.GeometryIdCount = 0;\r\n\t\r\n\t// File:src/core/DirectGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.DirectGeometry = function () {\r\n\t\r\n\t\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.name = '';\r\n\t\tthis.type = 'DirectGeometry';\r\n\t\r\n\t\tthis.indices = [];\r\n\t\tthis.vertices = [];\r\n\t\tthis.normals = [];\r\n\t\tthis.colors = [];\r\n\t\tthis.uvs = [];\r\n\t\tthis.uvs2 = [];\r\n\t\r\n\t\tthis.groups = [];\r\n\t\r\n\t\tthis.morphTargets = {};\r\n\t\r\n\t\tthis.skinWeights = [];\r\n\t\tthis.skinIndices = [];\r\n\t\r\n\t\t// this.lineDistances = [];\r\n\t\r\n\t\tthis.boundingBox = null;\r\n\t\tthis.boundingSphere = null;\r\n\t\r\n\t\t// update flags\r\n\t\r\n\t\tthis.verticesNeedUpdate = false;\r\n\t\tthis.normalsNeedUpdate = false;\r\n\t\tthis.colorsNeedUpdate = false;\r\n\t\tthis.uvsNeedUpdate = false;\r\n\t\tthis.groupsNeedUpdate = false;\r\n\t\r\n\t};\r\n\t\r\n\tObject.assign( THREE.DirectGeometry.prototype, THREE.EventDispatcher.prototype, {\r\n\t\r\n\t\tcomputeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,\r\n\t\tcomputeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,\r\n\t\r\n\t\tcomputeFaceNormals: function () {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeVertexNormals: function () {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeGroups: function ( geometry ) {\r\n\t\r\n\t\t\tvar group;\r\n\t\t\tvar groups = [];\r\n\t\t\tvar materialIndex;\r\n\t\r\n\t\t\tvar faces = geometry.faces;\r\n\t\r\n\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\t\t// materials\r\n\t\r\n\t\t\t\tif ( face.materialIndex !== materialIndex ) {\r\n\t\r\n\t\t\t\t\tmaterialIndex = face.materialIndex;\r\n\t\r\n\t\t\t\t\tif ( group !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\r\n\t\t\t\t\t\tgroups.push( group );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tgroup = {\r\n\t\t\t\t\t\tstart: i * 3,\r\n\t\t\t\t\t\tmaterialIndex: materialIndex\r\n\t\t\t\t\t};\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( group !== undefined ) {\r\n\t\r\n\t\t\t\tgroup.count = ( i * 3 ) - group.start;\r\n\t\t\t\tgroups.push( group );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.groups = groups;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromGeometry: function ( geometry ) {\r\n\t\r\n\t\t\tvar faces = geometry.faces;\r\n\t\t\tvar vertices = geometry.vertices;\r\n\t\t\tvar faceVertexUvs = geometry.faceVertexUvs;\r\n\t\r\n\t\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\r\n\t\t\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\r\n\t\r\n\t\t\t// morphs\r\n\t\r\n\t\t\tvar morphTargets = geometry.morphTargets;\r\n\t\t\tvar morphTargetsLength = morphTargets.length;\r\n\t\r\n\t\t\tvar morphTargetsPosition;\r\n\t\r\n\t\t\tif ( morphTargetsLength > 0 ) {\r\n\t\r\n\t\t\t\tmorphTargetsPosition = [];\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\r\n\t\r\n\t\t\t\t\tmorphTargetsPosition[ i ] = [];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.morphTargets.position = morphTargetsPosition;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar morphNormals = geometry.morphNormals;\r\n\t\t\tvar morphNormalsLength = morphNormals.length;\r\n\t\r\n\t\t\tvar morphTargetsNormal;\r\n\t\r\n\t\t\tif ( morphNormalsLength > 0 ) {\r\n\t\r\n\t\t\t\tmorphTargetsNormal = [];\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\r\n\t\r\n\t\t\t\t\tmorphTargetsNormal[ i ] = [];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.morphTargets.normal = morphTargetsNormal;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// skins\r\n\t\r\n\t\t\tvar skinIndices = geometry.skinIndices;\r\n\t\t\tvar skinWeights = geometry.skinWeights;\r\n\t\r\n\t\t\tvar hasSkinIndices = skinIndices.length === vertices.length;\r\n\t\t\tvar hasSkinWeights = skinWeights.length === vertices.length;\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tfor ( var i = 0; i < faces.length; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\r\n\t\r\n\t\t\t\tvar vertexNormals = face.vertexNormals;\r\n\t\r\n\t\t\t\tif ( vertexNormals.length === 3 ) {\r\n\t\r\n\t\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tvar normal = face.normal;\r\n\t\r\n\t\t\t\t\tthis.normals.push( normal, normal, normal );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar vertexColors = face.vertexColors;\r\n\t\r\n\t\t\t\tif ( vertexColors.length === 3 ) {\r\n\t\r\n\t\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tvar color = face.color;\r\n\t\r\n\t\t\t\t\tthis.colors.push( color, color, color );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasFaceVertexUv === true ) {\r\n\t\r\n\t\t\t\t\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\r\n\t\r\n\t\t\t\t\tif ( vertexUvs !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\r\n\t\r\n\t\t\t\t\t\tthis.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasFaceVertexUv2 === true ) {\r\n\t\r\n\t\t\t\t\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\r\n\t\r\n\t\t\t\t\tif ( vertexUvs !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\r\n\t\r\n\t\t\t\t\t\tthis.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// morphs\r\n\t\r\n\t\t\t\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar morphTarget = morphTargets[ j ].vertices;\r\n\t\r\n\t\t\t\t\tmorphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\r\n\t\r\n\t\t\t\t\tmorphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// skins\r\n\t\r\n\t\t\t\tif ( hasSkinIndices ) {\r\n\t\r\n\t\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( hasSkinWeights ) {\r\n\t\r\n\t\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.computeGroups( geometry );\r\n\t\r\n\t\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\r\n\t\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\r\n\t\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\r\n\t\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\r\n\t\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispose: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/core/BufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.BufferGeometry = function () {\r\n\t\r\n\t\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.name = '';\r\n\t\tthis.type = 'BufferGeometry';\r\n\t\r\n\t\tthis.index = null;\r\n\t\tthis.attributes = {};\r\n\t\r\n\t\tthis.morphAttributes = {};\r\n\t\r\n\t\tthis.groups = [];\r\n\t\r\n\t\tthis.boundingBox = null;\r\n\t\tthis.boundingSphere = null;\r\n\t\r\n\t\tthis.drawRange = { start: 0, count: Infinity };\r\n\t\r\n\t};\r\n\t\r\n\tObject.assign( THREE.BufferGeometry.prototype, THREE.EventDispatcher.prototype, {\r\n\t\r\n\t\tgetIndex: function () {\r\n\t\r\n\t\t\treturn this.index;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetIndex: function ( index ) {\r\n\t\r\n\t\t\tthis.index = index;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddAttribute: function ( name, attribute ) {\r\n\t\r\n\t\t\tif ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\r\n\t\r\n\t\t\t\tthis.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\r\n\t\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( name === 'index' ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\r\n\t\t\t\tthis.setIndex( attribute );\r\n\t\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.attributes[ name ] = attribute;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetAttribute: function ( name ) {\r\n\t\r\n\t\t\treturn this.attributes[ name ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tremoveAttribute: function ( name ) {\r\n\t\r\n\t\t\tdelete this.attributes[ name ];\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddGroup: function ( start, count, materialIndex ) {\r\n\t\r\n\t\t\tthis.groups.push( {\r\n\t\r\n\t\t\t\tstart: start,\r\n\t\t\t\tcount: count,\r\n\t\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\r\n\t\r\n\t\t\t} );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclearGroups: function () {\r\n\t\r\n\t\t\tthis.groups = [];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetDrawRange: function ( start, count ) {\r\n\t\r\n\t\t\tthis.drawRange.start = start;\r\n\t\t\tthis.drawRange.count = count;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tapplyMatrix: function ( matrix ) {\r\n\t\r\n\t\t\tvar position = this.attributes.position;\r\n\t\r\n\t\t\tif ( position !== undefined ) {\r\n\t\r\n\t\t\t\tmatrix.applyToVector3Array( position.array );\r\n\t\t\t\tposition.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar normal = this.attributes.normal;\r\n\t\r\n\t\t\tif ( normal !== undefined ) {\r\n\t\r\n\t\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\t\r\n\t\t\t\tnormalMatrix.applyToVector3Array( normal.array );\r\n\t\t\t\tnormal.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.boundingBox !== null ) {\r\n\t\r\n\t\t\t\tthis.computeBoundingBox();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.boundingSphere !== null ) {\r\n\t\r\n\t\t\t\tthis.computeBoundingSphere();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\trotateX: function () {\r\n\t\r\n\t\t\t// rotate geometry around world x-axis\r\n\t\r\n\t\t\tvar m1;\r\n\t\r\n\t\t\treturn function rotateX( angle ) {\r\n\t\r\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tm1.makeRotationX( angle );\r\n\t\r\n\t\t\t\tthis.applyMatrix( m1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\trotateY: function () {\r\n\t\r\n\t\t\t// rotate geometry around world y-axis\r\n\t\r\n\t\t\tvar m1;\r\n\t\r\n\t\t\treturn function rotateY( angle ) {\r\n\t\r\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tm1.makeRotationY( angle );\r\n\t\r\n\t\t\t\tthis.applyMatrix( m1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\trotateZ: function () {\r\n\t\r\n\t\t\t// rotate geometry around world z-axis\r\n\t\r\n\t\t\tvar m1;\r\n\t\r\n\t\t\treturn function rotateZ( angle ) {\r\n\t\r\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tm1.makeRotationZ( angle );\r\n\t\r\n\t\t\t\tthis.applyMatrix( m1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttranslate: function () {\r\n\t\r\n\t\t\t// translate geometry\r\n\t\r\n\t\t\tvar m1;\r\n\t\r\n\t\t\treturn function translate( x, y, z ) {\r\n\t\r\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tm1.makeTranslation( x, y, z );\r\n\t\r\n\t\t\t\tthis.applyMatrix( m1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tscale: function () {\r\n\t\r\n\t\t\t// scale geometry\r\n\t\r\n\t\t\tvar m1;\r\n\t\r\n\t\t\treturn function scale( x, y, z ) {\r\n\t\r\n\t\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tm1.makeScale( x, y, z );\r\n\t\r\n\t\t\t\tthis.applyMatrix( m1 );\r\n\t\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tlookAt: function () {\r\n\t\r\n\t\t\tvar obj;\r\n\t\r\n\t\t\treturn function lookAt( vector ) {\r\n\t\r\n\t\t\t\tif ( obj === undefined ) obj = new THREE.Object3D();\r\n\t\r\n\t\t\t\tobj.lookAt( vector );\r\n\t\r\n\t\t\t\tobj.updateMatrix();\r\n\t\r\n\t\t\t\tthis.applyMatrix( obj.matrix );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tcenter: function () {\r\n\t\r\n\t\t\tthis.computeBoundingBox();\r\n\t\r\n\t\t\tvar offset = this.boundingBox.center().negate();\r\n\t\r\n\t\t\tthis.translate( offset.x, offset.y, offset.z );\r\n\t\r\n\t\t\treturn offset;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFromObject: function ( object ) {\r\n\t\r\n\t\t\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\r\n\t\r\n\t\t\tvar geometry = object.geometry;\r\n\t\r\n\t\t\tif ( object instanceof THREE.Points || object instanceof THREE.Line ) {\r\n\t\r\n\t\t\t\tvar positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );\r\n\t\t\t\tvar colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );\r\n\t\r\n\t\t\t\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\r\n\t\t\t\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\r\n\t\r\n\t\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\r\n\t\r\n\t\t\t\t\tvar lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );\r\n\t\r\n\t\t\t\t\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( geometry.boundingSphere !== null ) {\r\n\t\r\n\t\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( geometry.boundingBox !== null ) {\r\n\t\r\n\t\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( object instanceof THREE.Mesh ) {\r\n\t\r\n\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\t\t\tthis.fromGeometry( geometry );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdateFromObject: function ( object ) {\r\n\t\r\n\t\t\tvar geometry = object.geometry;\r\n\t\r\n\t\t\tif ( object instanceof THREE.Mesh ) {\r\n\t\r\n\t\t\t\tvar direct = geometry.__directGeometry;\r\n\t\r\n\t\t\t\tif ( direct === undefined ) {\r\n\t\r\n\t\t\t\t\treturn this.fromGeometry( geometry );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\r\n\t\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\r\n\t\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\r\n\t\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\r\n\t\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\r\n\t\r\n\t\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\t\tgeometry.normalsNeedUpdate = false;\r\n\t\t\t\tgeometry.colorsNeedUpdate = false;\r\n\t\t\t\tgeometry.uvsNeedUpdate = false;\r\n\t\t\t\tgeometry.groupsNeedUpdate = false;\r\n\t\r\n\t\t\t\tgeometry = direct;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.verticesNeedUpdate === true ) {\r\n\t\r\n\t\t\t\tvar attribute = this.attributes.position;\r\n\t\r\n\t\t\t\tif ( attribute !== undefined ) {\r\n\t\r\n\t\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\r\n\t\t\t\t\tattribute.needsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.normalsNeedUpdate === true ) {\r\n\t\r\n\t\t\t\tvar attribute = this.attributes.normal;\r\n\t\r\n\t\t\t\tif ( attribute !== undefined ) {\r\n\t\r\n\t\t\t\t\tattribute.copyVector3sArray( geometry.normals );\r\n\t\t\t\t\tattribute.needsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.normalsNeedUpdate = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.colorsNeedUpdate === true ) {\r\n\t\r\n\t\t\t\tvar attribute = this.attributes.color;\r\n\t\r\n\t\t\t\tif ( attribute !== undefined ) {\r\n\t\r\n\t\t\t\t\tattribute.copyColorsArray( geometry.colors );\r\n\t\t\t\t\tattribute.needsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.colorsNeedUpdate = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.uvsNeedUpdate ) {\r\n\t\r\n\t\t\t\tvar attribute = this.attributes.uv;\r\n\t\r\n\t\t\t\tif ( attribute !== undefined ) {\r\n\t\r\n\t\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\r\n\t\t\t\t\tattribute.needsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.uvsNeedUpdate = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.lineDistancesNeedUpdate ) {\r\n\t\r\n\t\t\t\tvar attribute = this.attributes.lineDistance;\r\n\t\r\n\t\t\t\tif ( attribute !== undefined ) {\r\n\t\r\n\t\t\t\t\tattribute.copyArray( geometry.lineDistances );\r\n\t\t\t\t\tattribute.needsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.lineDistancesNeedUpdate = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.groupsNeedUpdate ) {\r\n\t\r\n\t\t\t\tgeometry.computeGroups( object.geometry );\r\n\t\t\t\tthis.groups = geometry.groups;\r\n\t\r\n\t\t\t\tgeometry.groupsNeedUpdate = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromGeometry: function ( geometry ) {\r\n\t\r\n\t\t\tgeometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );\r\n\t\r\n\t\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfromDirectGeometry: function ( geometry ) {\r\n\t\r\n\t\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\r\n\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\r\n\t\r\n\t\t\tif ( geometry.normals.length > 0 ) {\r\n\t\r\n\t\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\r\n\t\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.colors.length > 0 ) {\r\n\t\r\n\t\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\r\n\t\t\t\tthis.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.uvs.length > 0 ) {\r\n\t\r\n\t\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\r\n\t\t\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.uvs2.length > 0 ) {\r\n\t\r\n\t\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\r\n\t\t\t\tthis.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.indices.length > 0 ) {\r\n\t\r\n\t\t\t\tvar TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;\r\n\t\t\t\tvar indices = new TypeArray( geometry.indices.length * 3 );\r\n\t\t\t\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// groups\r\n\t\r\n\t\t\tthis.groups = geometry.groups;\r\n\t\r\n\t\t\t// morphs\r\n\t\r\n\t\t\tfor ( var name in geometry.morphTargets ) {\r\n\t\r\n\t\t\t\tvar array = [];\r\n\t\t\t\tvar morphTargets = geometry.morphTargets[ name ];\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar morphTarget = morphTargets[ i ];\r\n\t\r\n\t\t\t\t\tvar attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );\r\n\t\r\n\t\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.morphAttributes[ name ] = array;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// skinning\r\n\t\r\n\t\t\tif ( geometry.skinIndices.length > 0 ) {\r\n\t\r\n\t\t\t\tvar skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );\r\n\t\t\t\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.skinWeights.length > 0 ) {\r\n\t\r\n\t\t\t\tvar skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );\r\n\t\t\t\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tif ( geometry.boundingSphere !== null ) {\r\n\t\r\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry.boundingBox !== null ) {\r\n\t\r\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeBoundingBox: function () {\r\n\t\r\n\t\t\tif ( this.boundingBox === null ) {\r\n\t\r\n\t\t\t\tthis.boundingBox = new THREE.Box3();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar positions = this.attributes.position.array;\r\n\t\r\n\t\t\tif ( positions !== undefined ) {\r\n\t\r\n\t\t\t\tthis.boundingBox.setFromArray( positions );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.boundingBox.makeEmpty();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeBoundingSphere: function () {\r\n\t\r\n\t\t\tvar box = new THREE.Box3();\r\n\t\t\tvar vector = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function computeBoundingSphere() {\r\n\t\r\n\t\t\t\tif ( this.boundingSphere === null ) {\r\n\t\r\n\t\t\t\t\tthis.boundingSphere = new THREE.Sphere();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar positions = this.attributes.position.array;\r\n\t\r\n\t\t\t\tif ( positions ) {\r\n\t\r\n\t\t\t\t\tvar center = this.boundingSphere.center;\r\n\t\r\n\t\t\t\t\tbox.setFromArray( positions );\r\n\t\t\t\t\tbox.center( center );\r\n\t\r\n\t\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\r\n\t\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\r\n\t\r\n\t\t\t\t\tvar maxRadiusSq = 0;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\tvector.fromArray( positions, i );\r\n\t\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\r\n\t\r\n\t\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\r\n\t\r\n\t\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\tcomputeFaceNormals: function () {\r\n\t\r\n\t\t\t// backwards compatibility\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcomputeVertexNormals: function () {\r\n\t\r\n\t\t\tvar index = this.index;\r\n\t\t\tvar attributes = this.attributes;\r\n\t\t\tvar groups = this.groups;\r\n\t\r\n\t\t\tif ( attributes.position ) {\r\n\t\r\n\t\t\t\tvar positions = attributes.position.array;\r\n\t\r\n\t\t\t\tif ( attributes.normal === undefined ) {\r\n\t\r\n\t\t\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// reset existing normals to zero\r\n\t\r\n\t\t\t\t\tvar array = attributes.normal.array;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tarray[ i ] = 0;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar normals = attributes.normal.array;\r\n\t\r\n\t\t\t\tvar vA, vB, vC,\r\n\t\r\n\t\t\t\tpA = new THREE.Vector3(),\r\n\t\t\t\tpB = new THREE.Vector3(),\r\n\t\t\t\tpC = new THREE.Vector3(),\r\n\t\r\n\t\t\t\tcb = new THREE.Vector3(),\r\n\t\t\t\tab = new THREE.Vector3();\r\n\t\r\n\t\t\t\t// indexed elements\r\n\t\r\n\t\t\t\tif ( index ) {\r\n\t\r\n\t\t\t\t\tvar indices = index.array;\r\n\t\r\n\t\t\t\t\tif ( groups.length === 0 ) {\r\n\t\r\n\t\t\t\t\t\tthis.addGroup( 0, indices.length );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tfor ( var j = 0, jl = groups.length; j < jl; ++ j ) {\r\n\t\r\n\t\t\t\t\t\tvar group = groups[ j ];\r\n\t\r\n\t\t\t\t\t\tvar start = group.start;\r\n\t\t\t\t\t\tvar count = group.count;\r\n\t\r\n\t\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\t\tvA = indices[ i + 0 ] * 3;\r\n\t\t\t\t\t\t\tvB = indices[ i + 1 ] * 3;\r\n\t\t\t\t\t\t\tvC = indices[ i + 2 ] * 3;\r\n\t\r\n\t\t\t\t\t\t\tpA.fromArray( positions, vA );\r\n\t\t\t\t\t\t\tpB.fromArray( positions, vB );\r\n\t\t\t\t\t\t\tpC.fromArray( positions, vC );\r\n\t\r\n\t\t\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\t\t\tcb.cross( ab );\r\n\t\r\n\t\t\t\t\t\t\tnormals[ vA ] += cb.x;\r\n\t\t\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\r\n\t\t\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\r\n\t\r\n\t\t\t\t\t\t\tnormals[ vB ] += cb.x;\r\n\t\t\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\r\n\t\t\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\r\n\t\r\n\t\t\t\t\t\t\tnormals[ vC ] += cb.x;\r\n\t\t\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\r\n\t\t\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// non-indexed elements (unconnected triangle soup)\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\r\n\t\r\n\t\t\t\t\t\tpA.fromArray( positions, i );\r\n\t\t\t\t\t\tpB.fromArray( positions, i + 3 );\r\n\t\t\t\t\t\tpC.fromArray( positions, i + 6 );\r\n\t\r\n\t\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\t\tcb.cross( ab );\r\n\t\r\n\t\t\t\t\t\tnormals[ i ] = cb.x;\r\n\t\t\t\t\t\tnormals[ i + 1 ] = cb.y;\r\n\t\t\t\t\t\tnormals[ i + 2 ] = cb.z;\r\n\t\r\n\t\t\t\t\t\tnormals[ i + 3 ] = cb.x;\r\n\t\t\t\t\t\tnormals[ i + 4 ] = cb.y;\r\n\t\t\t\t\t\tnormals[ i + 5 ] = cb.z;\r\n\t\r\n\t\t\t\t\t\tnormals[ i + 6 ] = cb.x;\r\n\t\t\t\t\t\tnormals[ i + 7 ] = cb.y;\r\n\t\t\t\t\t\tnormals[ i + 8 ] = cb.z;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.normalizeNormals();\r\n\t\r\n\t\t\t\tattributes.normal.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmerge: function ( geometry, offset ) {\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry === false ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\r\n\t\t\tvar attributes = this.attributes;\r\n\t\r\n\t\t\tfor ( var key in attributes ) {\r\n\t\r\n\t\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\r\n\t\r\n\t\t\t\tvar attribute1 = attributes[ key ];\r\n\t\t\t\tvar attributeArray1 = attribute1.array;\r\n\t\r\n\t\t\t\tvar attribute2 = geometry.attributes[ key ];\r\n\t\t\t\tvar attributeArray2 = attribute2.array;\r\n\t\r\n\t\t\t\tvar attributeSize = attribute2.itemSize;\r\n\t\r\n\t\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\r\n\t\r\n\t\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalizeNormals: function () {\r\n\t\r\n\t\t\tvar normals = this.attributes.normal.array;\r\n\t\r\n\t\t\tvar x, y, z, n;\r\n\t\r\n\t\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\tx = normals[ i ];\r\n\t\t\t\ty = normals[ i + 1 ];\r\n\t\t\t\tz = normals[ i + 2 ];\r\n\t\r\n\t\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\r\n\t\r\n\t\t\t\tnormals[ i ] *= n;\r\n\t\t\t\tnormals[ i + 1 ] *= n;\r\n\t\t\t\tnormals[ i + 2 ] *= n;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoNonIndexed: function () {\r\n\t\r\n\t\t\tif ( this.index === null ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\r\n\t\t\t\treturn this;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar geometry2 = new THREE.BufferGeometry();\r\n\t\r\n\t\t\tvar indices = this.index.array;\r\n\t\t\tvar attributes = this.attributes;\r\n\t\r\n\t\t\tfor ( var name in attributes ) {\r\n\t\r\n\t\t\t\tvar attribute = attributes[ name ];\r\n\t\r\n\t\t\t\tvar array = attribute.array;\r\n\t\t\t\tvar itemSize = attribute.itemSize;\r\n\t\r\n\t\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\r\n\t\r\n\t\t\t\tvar index = 0, index2 = 0;\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tindex = indices[ i ] * itemSize;\r\n\t\r\n\t\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\r\n\t\r\n\t\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry2.addAttribute( name, new THREE.BufferAttribute( array2, itemSize ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn geometry2;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoJSON: function () {\r\n\t\r\n\t\t\tvar data = {\r\n\t\t\t\tmetadata: {\r\n\t\t\t\t\tversion: 4.4,\r\n\t\t\t\t\ttype: 'BufferGeometry',\r\n\t\t\t\t\tgenerator: 'BufferGeometry.toJSON'\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\r\n\t\t\t// standard BufferGeometry serialization\r\n\t\r\n\t\t\tdata.uuid = this.uuid;\r\n\t\t\tdata.type = this.type;\r\n\t\t\tif ( this.name !== '' ) data.name = this.name;\r\n\t\r\n\t\t\tif ( this.parameters !== undefined ) {\r\n\t\r\n\t\t\t\tvar parameters = this.parameters;\r\n\t\r\n\t\t\t\tfor ( var key in parameters ) {\r\n\t\r\n\t\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn data;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tdata.data = { attributes: {} };\r\n\t\r\n\t\t\tvar index = this.index;\r\n\t\r\n\t\t\tif ( index !== null ) {\r\n\t\r\n\t\t\t\tvar array = Array.prototype.slice.call( index.array );\r\n\t\r\n\t\t\t\tdata.data.index = {\r\n\t\t\t\t\ttype: index.array.constructor.name,\r\n\t\t\t\t\tarray: array\r\n\t\t\t\t};\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar attributes = this.attributes;\r\n\t\r\n\t\t\tfor ( var key in attributes ) {\r\n\t\r\n\t\t\t\tvar attribute = attributes[ key ];\r\n\t\r\n\t\t\t\tvar array = Array.prototype.slice.call( attribute.array );\r\n\t\r\n\t\t\t\tdata.data.attributes[ key ] = {\r\n\t\t\t\t\titemSize: attribute.itemSize,\r\n\t\t\t\t\ttype: attribute.array.constructor.name,\r\n\t\t\t\t\tarray: array,\r\n\t\t\t\t\tnormalized: attribute.normalized\r\n\t\t\t\t};\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar groups = this.groups;\r\n\t\r\n\t\t\tif ( groups.length > 0 ) {\r\n\t\r\n\t\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar boundingSphere = this.boundingSphere;\r\n\t\r\n\t\t\tif ( boundingSphere !== null ) {\r\n\t\r\n\t\t\t\tdata.data.boundingSphere = {\r\n\t\t\t\t\tcenter: boundingSphere.center.toArray(),\r\n\t\t\t\t\tradius: boundingSphere.radius\r\n\t\t\t\t};\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn data;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\t/*\r\n\t\t\t// Handle primitives\r\n\t\r\n\t\t\tvar parameters = this.parameters;\r\n\t\r\n\t\t\tif ( parameters !== undefined ) {\r\n\t\r\n\t\t\t\tvar values = [];\r\n\t\r\n\t\t\t\tfor ( var key in parameters ) {\r\n\t\r\n\t\t\t\t\tvalues.push( parameters[ key ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar geometry = Object.create( this.constructor.prototype );\r\n\t\t\t\tthis.constructor.apply( geometry, values );\r\n\t\t\t\treturn geometry;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\t\t*/\r\n\t\r\n\t\t\treturn new THREE.BufferGeometry().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tvar index = source.index;\r\n\t\r\n\t\t\tif ( index !== null ) {\r\n\t\r\n\t\t\t\tthis.setIndex( index.clone() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar attributes = source.attributes;\r\n\t\r\n\t\t\tfor ( var name in attributes ) {\r\n\t\r\n\t\t\t\tvar attribute = attributes[ name ];\r\n\t\t\t\tthis.addAttribute( name, attribute.clone() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar groups = source.groups;\r\n\t\r\n\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar group = groups[ i ];\r\n\t\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispose: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\tTHREE.BufferGeometry.MaxIndex = 65535;\r\n\t\r\n\t// File:src/core/InstancedBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author benaadams / https://twitter.com/ben_a_adams\r\n\t */\r\n\t\r\n\tTHREE.InstancedBufferGeometry = function () {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'InstancedBufferGeometry';\r\n\t\tthis.maxInstancedCount = undefined;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;\r\n\t\r\n\tTHREE.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {\r\n\t\r\n\t\tthis.groups.push( {\r\n\t\r\n\t\t\tstart: start,\r\n\t\t\tcount: count,\r\n\t\t\tinstances: instances\r\n\t\r\n\t\t} );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.InstancedBufferGeometry.prototype.copy = function ( source ) {\r\n\t\r\n\t\tvar index = source.index;\r\n\t\r\n\t\tif ( index !== null ) {\r\n\t\r\n\t\t\tthis.setIndex( index.clone() );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar attributes = source.attributes;\r\n\t\r\n\t\tfor ( var name in attributes ) {\r\n\t\r\n\t\t\tvar attribute = attributes[ name ];\r\n\t\t\tthis.addAttribute( name, attribute.clone() );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar groups = source.groups;\r\n\t\r\n\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tvar group = groups[ i ];\r\n\t\t\tthis.addGroup( group.start, group.count, group.instances );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/core/Uniform.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Uniform = function ( value ) {\r\n\t\r\n\t\tif ( typeof value === 'string' ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\r\n\t\t\tvalue = arguments[ 1 ];\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.value = value;\r\n\t\r\n\t\tthis.dynamic = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Uniform.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Uniform,\r\n\t\r\n\t\tonUpdate: function ( callback ) {\r\n\t\r\n\t\t\tthis.dynamic = true;\r\n\t\t\tthis.onUpdateCallback = callback;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/animation/AnimationAction.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * Action provided by AnimationMixer for scheduling clip playback on specific\r\n\t * objects.\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t * @author tschw\r\n\t *\r\n\t */\r\n\t\r\n\tTHREE.AnimationAction = function() {\r\n\t\r\n\t\tthrow new Error( \"THREE.AnimationAction: \" +\r\n\t\t\t\t\"Use mixer.clipAction for construction.\" );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AnimationAction._new =\r\n\t\t\tfunction AnimationAction( mixer, clip, localRoot ) {\r\n\t\r\n\t\tthis._mixer = mixer;\r\n\t\tthis._clip = clip;\r\n\t\tthis._localRoot = localRoot || null;\r\n\t\r\n\t\tvar tracks = clip.tracks,\r\n\t\t\tnTracks = tracks.length,\r\n\t\t\tinterpolants = new Array( nTracks );\r\n\t\r\n\t\tvar interpolantSettings = {\r\n\t\t\t\tendingStart: \tTHREE.ZeroCurvatureEnding,\r\n\t\t\t\tendingEnd:\t\tTHREE.ZeroCurvatureEnding\r\n\t\t};\r\n\t\r\n\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\r\n\t\r\n\t\t\tvar interpolant = tracks[ i ].createInterpolant( null );\r\n\t\t\tinterpolants[ i ] = interpolant;\r\n\t\t\tinterpolant.settings = interpolantSettings;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis._interpolantSettings = interpolantSettings;\r\n\t\r\n\t\tthis._interpolants = interpolants;\t// bound by the mixer\r\n\t\r\n\t\t// inside: PropertyMixer (managed by the mixer)\r\n\t\tthis._propertyBindings = new Array( nTracks );\r\n\t\r\n\t\tthis._cacheIndex = null;\t\t\t// for the memory manager\r\n\t\tthis._byClipCacheIndex = null;\t\t// for the memory manager\r\n\t\r\n\t\tthis._timeScaleInterpolant = null;\r\n\t\tthis._weightInterpolant = null;\r\n\t\r\n\t\tthis.loop = THREE.LoopRepeat;\r\n\t\tthis._loopCount = -1;\r\n\t\r\n\t\t// global mixer time when the action is to be started\r\n\t\t// it's set back to 'null' upon start of the action\r\n\t\tthis._startTime = null;\r\n\t\r\n\t\t// scaled local time of the action\r\n\t\t// gets clamped or wrapped to 0..clip.duration according to loop\r\n\t\tthis.time = 0;\r\n\t\r\n\t\tthis.timeScale = 1;\r\n\t\tthis._effectiveTimeScale = 1;\r\n\t\r\n\t\tthis.weight = 1;\r\n\t\tthis._effectiveWeight = 1;\r\n\t\r\n\t\tthis.repetitions = Infinity; \t\t// no. of repetitions when looping\r\n\t\r\n\t\tthis.paused = false;\t\t\t\t// false -> zero effective time scale\r\n\t\tthis.enabled = true;\t\t\t\t// true -> zero effective weight\r\n\t\r\n\t\tthis.clampWhenFinished \t= false;\t// keep feeding the last frame?\r\n\t\r\n\t\tthis.zeroSlopeAtStart \t= true;\t\t// for smooth interpolation w/o separate\r\n\t\tthis.zeroSlopeAtEnd\t\t= true;\t\t// clips for start, loop and end\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AnimationAction._new.prototype = {\r\n\t\r\n\t\tconstructor: THREE.AnimationAction._new,\r\n\t\r\n\t\t// State & Scheduling\r\n\t\r\n\t\tplay: function() {\r\n\t\r\n\t\t\tthis._mixer._activateAction( this );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tstop: function() {\r\n\t\r\n\t\t\tthis._mixer._deactivateAction( this );\r\n\t\r\n\t\t\treturn this.reset();\r\n\t\r\n\t\t},\r\n\t\r\n\t\treset: function() {\r\n\t\r\n\t\t\tthis.paused = false;\r\n\t\t\tthis.enabled = true;\r\n\t\r\n\t\t\tthis.time = 0;\t\t\t// restart clip\r\n\t\t\tthis._loopCount = -1;\t// forget previous loops\r\n\t\t\tthis._startTime = null;\t// forget scheduling\r\n\t\r\n\t\t\treturn this.stopFading().stopWarping();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tisRunning: function() {\r\n\t\r\n\t\t\tvar start = this._startTime;\r\n\t\r\n\t\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\r\n\t\t\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// return true when play has been called\r\n\t\tisScheduled: function() {\r\n\t\r\n\t\t\treturn this._mixer._isActiveAction( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tstartAt: function( time ) {\r\n\t\r\n\t\t\tthis._startTime = time;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetLoop: function( mode, repetitions ) {\r\n\t\r\n\t\t\tthis.loop = mode;\r\n\t\t\tthis.repetitions = repetitions;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Weight\r\n\t\r\n\t\t// set the weight stopping any scheduled fading\r\n\t\t// although .enabled = false yields an effective weight of zero, this\r\n\t\t// method does *not* change .enabled, because it would be confusing\r\n\t\tsetEffectiveWeight: function( weight ) {\r\n\t\r\n\t\t\tthis.weight = weight;\r\n\t\r\n\t\t\t// note: same logic as when updated at runtime\r\n\t\t\tthis._effectiveWeight = this.enabled ? weight : 0;\r\n\t\r\n\t\t\treturn this.stopFading();\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// return the weight considering fading and .enabled\r\n\t\tgetEffectiveWeight: function() {\r\n\t\r\n\t\t\treturn this._effectiveWeight;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfadeIn: function( duration ) {\r\n\t\r\n\t\t\treturn this._scheduleFading( duration, 0, 1 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfadeOut: function( duration ) {\r\n\t\r\n\t\t\treturn this._scheduleFading( duration, 1, 0 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcrossFadeFrom: function( fadeOutAction, duration, warp ) {\r\n\t\r\n\t\t\tvar mixer = this._mixer;\r\n\t\r\n\t\t\tfadeOutAction.fadeOut( duration );\r\n\t\t\tthis.fadeIn( duration );\r\n\t\r\n\t\t\tif( warp ) {\r\n\t\r\n\t\t\t\tvar fadeInDuration = this._clip.duration,\r\n\t\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\r\n\t\r\n\t\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\r\n\t\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\r\n\t\r\n\t\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\r\n\t\t\t\tthis.warp( endStartRatio, 1.0, duration );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcrossFadeTo: function( fadeInAction, duration, warp ) {\r\n\t\r\n\t\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tstopFading: function() {\r\n\t\r\n\t\t\tvar weightInterpolant = this._weightInterpolant;\r\n\t\r\n\t\t\tif ( weightInterpolant !== null ) {\r\n\t\r\n\t\t\t\tthis._weightInterpolant = null;\r\n\t\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Time Scale Control\r\n\t\r\n\t\t// set the weight stopping any scheduled warping\r\n\t\t// although .paused = true yields an effective time scale of zero, this\r\n\t\t// method does *not* change .paused, because it would be confusing\r\n\t\tsetEffectiveTimeScale: function( timeScale ) {\r\n\t\r\n\t\t\tthis.timeScale = timeScale;\r\n\t\t\tthis._effectiveTimeScale = this.paused ? 0 :timeScale;\r\n\t\r\n\t\t\treturn this.stopWarping();\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// return the time scale considering warping and .paused\r\n\t\tgetEffectiveTimeScale: function() {\r\n\t\r\n\t\t\treturn this._effectiveTimeScale;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetDuration: function( duration ) {\r\n\t\r\n\t\t\tthis.timeScale = this._clip.duration / duration;\r\n\t\r\n\t\t\treturn this.stopWarping();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsyncWith: function( action ) {\r\n\t\r\n\t\t\tthis.time = action.time;\r\n\t\t\tthis.timeScale = action.timeScale;\r\n\t\r\n\t\t\treturn this.stopWarping();\r\n\t\r\n\t\t},\r\n\t\r\n\t\thalt: function( duration ) {\r\n\t\r\n\t\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\r\n\t\r\n\t\t},\r\n\t\r\n\t\twarp: function( startTimeScale, endTimeScale, duration ) {\r\n\t\r\n\t\t\tvar mixer = this._mixer, now = mixer.time,\r\n\t\t\t\tinterpolant = this._timeScaleInterpolant,\r\n\t\r\n\t\t\t\ttimeScale = this.timeScale;\r\n\t\r\n\t\t\tif ( interpolant === null ) {\r\n\t\r\n\t\t\t\tinterpolant = mixer._lendControlInterpolant(),\r\n\t\t\t\tthis._timeScaleInterpolant = interpolant;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar times = interpolant.parameterPositions,\r\n\t\t\t\tvalues = interpolant.sampleValues;\r\n\t\r\n\t\t\ttimes[ 0 ] = now;\r\n\t\t\ttimes[ 1 ] = now + duration;\r\n\t\r\n\t\t\tvalues[ 0 ] = startTimeScale / timeScale;\r\n\t\t\tvalues[ 1 ] = endTimeScale / timeScale;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tstopWarping: function() {\r\n\t\r\n\t\t\tvar timeScaleInterpolant = this._timeScaleInterpolant;\r\n\t\r\n\t\t\tif ( timeScaleInterpolant !== null ) {\r\n\t\r\n\t\t\t\tthis._timeScaleInterpolant = null;\r\n\t\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Object Accessors\r\n\t\r\n\t\tgetMixer: function() {\r\n\t\r\n\t\t\treturn this._mixer;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetClip: function() {\r\n\t\r\n\t\t\treturn this._clip;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetRoot: function() {\r\n\t\r\n\t\t\treturn this._localRoot || this._mixer._root;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Interna\r\n\t\r\n\t\t_update: function( time, deltaTime, timeDirection, accuIndex ) {\r\n\t\t\t// called by the mixer\r\n\t\r\n\t\t\tvar startTime = this._startTime;\r\n\t\r\n\t\t\tif ( startTime !== null ) {\r\n\t\r\n\t\t\t\t// check for scheduled start of action\r\n\t\r\n\t\t\t\tvar timeRunning = ( time - startTime ) * timeDirection;\r\n\t\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\r\n\t\r\n\t\t\t\t\treturn; // yet to come / don't decide when delta = 0\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// start\r\n\t\r\n\t\t\t\tthis._startTime = null; // unschedule\r\n\t\t\t\tdeltaTime = timeDirection * timeRunning;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// apply time scale and advance time\r\n\t\r\n\t\t\tdeltaTime *= this._updateTimeScale( time );\r\n\t\t\tvar clipTime = this._updateTime( deltaTime );\r\n\t\r\n\t\t\t// note: _updateTime may disable the action resulting in\r\n\t\t\t// an effective weight of 0\r\n\t\r\n\t\t\tvar weight = this._updateWeight( time );\r\n\t\r\n\t\t\tif ( weight > 0 ) {\r\n\t\r\n\t\t\t\tvar interpolants = this._interpolants;\r\n\t\t\t\tvar propertyMixers = this._propertyBindings;\r\n\t\r\n\t\t\t\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\r\n\t\r\n\t\t\t\t\tinterpolants[ j ].evaluate( clipTime );\r\n\t\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_updateWeight: function( time ) {\r\n\t\r\n\t\t\tvar weight = 0;\r\n\t\r\n\t\t\tif ( this.enabled ) {\r\n\t\r\n\t\t\t\tweight = this.weight;\r\n\t\t\t\tvar interpolant = this._weightInterpolant;\r\n\t\r\n\t\t\t\tif ( interpolant !== null ) {\r\n\t\r\n\t\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\r\n\t\r\n\t\t\t\t\tweight *= interpolantValue;\r\n\t\r\n\t\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\r\n\t\r\n\t\t\t\t\t\tthis.stopFading();\r\n\t\r\n\t\t\t\t\t\tif ( interpolantValue === 0 ) {\r\n\t\r\n\t\t\t\t\t\t\t// faded out, disable\r\n\t\t\t\t\t\t\tthis.enabled = false;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._effectiveWeight = weight;\r\n\t\t\treturn weight;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_updateTimeScale: function( time ) {\r\n\t\r\n\t\t\tvar timeScale = 0;\r\n\t\r\n\t\t\tif ( ! this.paused ) {\r\n\t\r\n\t\t\t\ttimeScale = this.timeScale;\r\n\t\r\n\t\t\t\tvar interpolant = this._timeScaleInterpolant;\r\n\t\r\n\t\t\t\tif ( interpolant !== null ) {\r\n\t\r\n\t\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\r\n\t\r\n\t\t\t\t\ttimeScale *= interpolantValue;\r\n\t\r\n\t\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\r\n\t\r\n\t\t\t\t\t\tthis.stopWarping();\r\n\t\r\n\t\t\t\t\t\tif ( timeScale === 0 ) {\r\n\t\r\n\t\t\t\t\t\t\t// motion has halted, pause\r\n\t\t\t\t\t\t\tthis.paused = true;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t// warp done - apply final time scale\r\n\t\t\t\t\t\t\tthis.timeScale = timeScale;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._effectiveTimeScale = timeScale;\r\n\t\t\treturn timeScale;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_updateTime: function( deltaTime ) {\r\n\t\r\n\t\t\tvar time = this.time + deltaTime;\r\n\t\r\n\t\t\tif ( deltaTime === 0 ) return time;\r\n\t\r\n\t\t\tvar duration = this._clip.duration,\r\n\t\r\n\t\t\t\tloop = this.loop,\r\n\t\t\t\tloopCount = this._loopCount;\r\n\t\r\n\t\t\tif ( loop === THREE.LoopOnce ) {\r\n\t\r\n\t\t\t\tif ( loopCount === -1 ) {\r\n\t\t\t\t\t// just started\r\n\t\r\n\t\t\t\t\tthis.loopCount = 0;\r\n\t\t\t\t\tthis._setEndings( true, true, false );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\thandle_stop: {\r\n\t\r\n\t\t\t\t\tif ( time >= duration ) {\r\n\t\r\n\t\t\t\t\t\ttime = duration;\r\n\t\r\n\t\t\t\t\t} else if ( time < 0 ) {\r\n\t\r\n\t\t\t\t\t\ttime = 0;\r\n\t\r\n\t\t\t\t\t} else break handle_stop;\r\n\t\r\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\r\n\t\t\t\t\telse this.enabled = false;\r\n\t\r\n\t\t\t\t\tthis._mixer.dispatchEvent( {\r\n\t\t\t\t\t\ttype: 'finished', action: this,\r\n\t\t\t\t\t\tdirection: deltaTime < 0 ? -1 : 1\r\n\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else { // repetitive Repeat or PingPong\r\n\t\r\n\t\t\t\tvar pingPong = ( loop === THREE.LoopPingPong );\r\n\t\r\n\t\t\t\tif ( loopCount === -1 ) {\r\n\t\t\t\t\t// just started\r\n\t\r\n\t\t\t\t\tif ( deltaTime >= 0 ) {\r\n\t\r\n\t\t\t\t\t\tloopCount = 0;\r\n\t\r\n\t\t\t\t\t\tthis._setEndings(\r\n\t\t\t\t\t\t\t\ttrue, this.repetitions === 0, pingPong );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t// when looping in reverse direction, the initial\r\n\t\t\t\t\t\t// transition through zero counts as a repetition,\r\n\t\t\t\t\t\t// so leave loopCount at -1\r\n\t\r\n\t\t\t\t\t\tthis._setEndings(\r\n\t\t\t\t\t\t\t\tthis.repetitions === 0, true, pingPong );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( time >= duration || time < 0 ) {\r\n\t\t\t\t\t// wrap around\r\n\t\r\n\t\t\t\t\tvar loopDelta = Math.floor( time / duration ); // signed\r\n\t\t\t\t\ttime -= duration * loopDelta;\r\n\t\r\n\t\t\t\t\tloopCount += Math.abs( loopDelta );\r\n\t\r\n\t\t\t\t\tvar pending = this.repetitions - loopCount;\r\n\t\r\n\t\t\t\t\tif ( pending < 0 ) {\r\n\t\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\r\n\t\r\n\t\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\r\n\t\t\t\t\t\telse this.enabled = false;\r\n\t\r\n\t\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\r\n\t\r\n\t\t\t\t\t\tthis._mixer.dispatchEvent( {\r\n\t\t\t\t\t\t\ttype: 'finished', action: this,\r\n\t\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : -1\r\n\t\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// keep running\r\n\t\r\n\t\t\t\t\t\tif ( pending === 0 ) {\r\n\t\t\t\t\t\t\t// entering the last round\r\n\t\r\n\t\t\t\t\t\t\tvar atStart = deltaTime < 0;\r\n\t\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tthis._loopCount = loopCount;\r\n\t\r\n\t\t\t\t\t\tthis._mixer.dispatchEvent( {\r\n\t\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\r\n\t\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\r\n\t\t\t\t\t// invert time for the \"pong round\"\r\n\t\r\n\t\t\t\t\tthis.time = time;\r\n\t\t\t\t\treturn duration - time;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.time = time;\r\n\t\t\treturn time;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_setEndings: function( atStart, atEnd, pingPong ) {\r\n\t\r\n\t\t\tvar settings = this._interpolantSettings;\r\n\t\r\n\t\t\tif ( pingPong ) {\r\n\t\r\n\t\t\t\tsettings.endingStart \t= THREE.ZeroSlopeEnding;\r\n\t\t\t\tsettings.endingEnd\t\t= THREE.ZeroSlopeEnding;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// assuming for LoopOnce atStart == atEnd == true\r\n\t\r\n\t\t\t\tif ( atStart ) {\r\n\t\r\n\t\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ?\r\n\t\t\t\t\t\t\tTHREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tsettings.endingStart = THREE.WrapAroundEnding;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( atEnd ) {\r\n\t\r\n\t\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ?\r\n\t\t\t\t\t\t\tTHREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tsettings.endingEnd \t = THREE.WrapAroundEnding;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_scheduleFading: function( duration, weightNow, weightThen ) {\r\n\t\r\n\t\t\tvar mixer = this._mixer, now = mixer.time,\r\n\t\t\t\tinterpolant = this._weightInterpolant;\r\n\t\r\n\t\t\tif ( interpolant === null ) {\r\n\t\r\n\t\t\t\tinterpolant = mixer._lendControlInterpolant(),\r\n\t\t\t\tthis._weightInterpolant = interpolant;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar times = interpolant.parameterPositions,\r\n\t\t\t\tvalues = interpolant.sampleValues;\r\n\t\r\n\t\t\ttimes[ 0 ] = now; \t\t\t\tvalues[ 0 ] = weightNow;\r\n\t\t\ttimes[ 1 ] = now + duration;\tvalues[ 1 ] = weightThen;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t// File:src/animation/AnimationClip.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * Reusable set of Tracks that represent an animation.\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t */\r\n\t\r\n\tTHREE.AnimationClip = function ( name, duration, tracks ) {\r\n\t\r\n\t\tthis.name = name;\r\n\t\tthis.tracks = tracks;\r\n\t\tthis.duration = ( duration !== undefined ) ? duration : -1;\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\t// this means it should figure out its duration by scanning the tracks\r\n\t\tif ( this.duration < 0 ) {\r\n\t\r\n\t\t\tthis.resetDuration();\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// maybe only do these on demand, as doing them here could potentially slow down loading\r\n\t\t// but leaving these here during development as this ensures a lot of testing of these functions\r\n\t\tthis.trim();\r\n\t\tthis.optimize();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AnimationClip.prototype = {\r\n\t\r\n\t\tconstructor: THREE.AnimationClip,\r\n\t\r\n\t\tresetDuration: function() {\r\n\t\r\n\t\t\tvar tracks = this.tracks,\r\n\t\t\t\tduration = 0;\r\n\t\r\n\t\t\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tvar track = this.tracks[ i ];\r\n\t\r\n\t\t\t\tduration = Math.max(\r\n\t\t\t\t\t\tduration, track.times[ track.times.length - 1 ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.duration = duration;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttrim: function() {\r\n\t\r\n\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\r\n\t\r\n\t\t\t\tthis.tracks[ i ].trim( 0, this.duration );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\toptimize: function() {\r\n\t\r\n\t\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\r\n\t\r\n\t\t\t\tthis.tracks[ i ].optimize();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// Static methods:\r\n\t\r\n\tObject.assign( THREE.AnimationClip, {\r\n\t\r\n\t\tparse: function( json ) {\r\n\t\r\n\t\t\tvar tracks = [],\r\n\t\t\t\tjsonTracks = json.tracks,\r\n\t\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\r\n\t\r\n\t\t\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\ttracks.push( THREE.KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn new THREE.AnimationClip( json.name, json.duration, tracks );\r\n\t\r\n\t\t},\r\n\t\r\n\t\r\n\t\ttoJSON: function( clip ) {\r\n\t\r\n\t\t\tvar tracks = [],\r\n\t\t\t\tclipTracks = clip.tracks;\r\n\t\r\n\t\t\tvar json = {\r\n\t\r\n\t\t\t\t'name': clip.name,\r\n\t\t\t\t'duration': clip.duration,\r\n\t\t\t\t'tracks': tracks\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\ttracks.push( THREE.KeyframeTrack.toJSON( clipTracks[ i ] ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn json;\r\n\t\r\n\t\t},\r\n\t\r\n\t\r\n\t\tCreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {\r\n\t\r\n\t\t\tvar numMorphTargets = morphTargetSequence.length;\r\n\t\t\tvar tracks = [];\r\n\t\r\n\t\t\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\r\n\t\r\n\t\t\t\tvar times = [];\r\n\t\t\t\tvar values = [];\r\n\t\r\n\t\t\t\ttimes.push(\r\n\t\t\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\r\n\t\t\t\t\t\ti,\r\n\t\t\t\t\t\t( i + 1 ) % numMorphTargets );\r\n\t\r\n\t\t\t\tvalues.push( 0, 1, 0 );\r\n\t\r\n\t\t\t\tvar order = THREE.AnimationUtils.getKeyframeOrder( times );\r\n\t\t\t\ttimes = THREE.AnimationUtils.sortedArray( times, 1, order );\r\n\t\t\t\tvalues = THREE.AnimationUtils.sortedArray( values, 1, order );\r\n\t\r\n\t\t\t\t// if there is a key at the first frame, duplicate it as the\r\n\t\t\t\t// last frame as well for perfect loop.\r\n\t\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\r\n\t\r\n\t\t\t\t\ttimes.push( numMorphTargets );\r\n\t\t\t\t\tvalues.push( values[ 0 ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\ttracks.push(\r\n\t\t\t\t\t\tnew THREE.NumberKeyframeTrack(\r\n\t\t\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\r\n\t\t\t\t\t\t\ttimes, values\r\n\t\t\t\t\t\t).scale( 1.0 / fps ) );\r\n\t\t\t}\r\n\t\r\n\t\t\treturn new THREE.AnimationClip( name, -1, tracks );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfindByName: function( objectOrClipArray, name ) {\r\n\t\r\n\t\t\tvar clipArray = objectOrClipArray;\r\n\t\r\n\t\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\r\n\t\r\n\t\t\t\tvar o = objectOrClipArray;\r\n\t\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0; i < clipArray.length; i ++ ) {\r\n\t\r\n\t\t\t\tif ( clipArray[ i ].name === name ) {\r\n\t\r\n\t\t\t\t\treturn clipArray[ i ];\r\n\t\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\r\n\t\t\treturn null;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tCreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {\r\n\t\r\n\t\t\tvar animationToMorphTargets = {};\r\n\t\r\n\t\t\t// tested with https://regex101.com/ on trick sequences\r\n\t\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\r\n\t\t\tvar pattern = /^([\\w-]*?)([\\d]+)$/;\r\n\t\r\n\t\t\t// sort morph target names into animation groups based\r\n\t\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\r\n\t\t\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar morphTarget = morphTargets[ i ];\r\n\t\t\t\tvar parts = morphTarget.name.match( pattern );\r\n\t\r\n\t\t\t\tif ( parts && parts.length > 1 ) {\r\n\t\r\n\t\t\t\t\tvar name = parts[ 1 ];\r\n\t\r\n\t\t\t\t\tvar animationMorphTargets = animationToMorphTargets[ name ];\r\n\t\t\t\t\tif ( ! animationMorphTargets ) {\r\n\t\r\n\t\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tanimationMorphTargets.push( morphTarget );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar clips = [];\r\n\t\r\n\t\t\tfor ( var name in animationToMorphTargets ) {\r\n\t\r\n\t\t\t\tclips.push( THREE.AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn clips;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// parse the animation.hierarchy format\r\n\t\tparseAnimation: function( animation, bones, nodeName ) {\r\n\t\r\n\t\t\tif ( ! animation ) {\r\n\t\r\n\t\t\t\tconsole.error( \"  no animation in JSONLoader data\" );\r\n\t\t\t\treturn null;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar addNonemptyTrack = function(\r\n\t\t\t\t\ttrackType, trackName, animationKeys, propertyName, destTracks ) {\r\n\t\r\n\t\t\t\t// only return track if there are actually keys.\r\n\t\t\t\tif ( animationKeys.length !== 0 ) {\r\n\t\r\n\t\t\t\t\tvar times = [];\r\n\t\t\t\t\tvar values = [];\r\n\t\r\n\t\t\t\t\tTHREE.AnimationUtils.flattenJSON(\r\n\t\t\t\t\t\t\tanimationKeys, times, values, propertyName );\r\n\t\r\n\t\t\t\t\t// empty keys are filtered out, so check again\r\n\t\t\t\t\tif ( times.length !== 0 ) {\r\n\t\r\n\t\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tvar tracks = [];\r\n\t\r\n\t\t\tvar clipName = animation.name || 'default';\r\n\t\t\t// automatic length determination in AnimationClip.\r\n\t\t\tvar duration = animation.length || -1;\r\n\t\t\tvar fps = animation.fps || 30;\r\n\t\r\n\t\t\tvar hierarchyTracks = animation.hierarchy || [];\r\n\t\r\n\t\t\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\r\n\t\r\n\t\t\t\tvar animationKeys = hierarchyTracks[ h ].keys;\r\n\t\r\n\t\t\t\t// skip empty tracks\r\n\t\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\r\n\t\r\n\t\t\t\t// process morph targets in a way exactly compatible\r\n\t\t\t\t// with AnimationHandler.init( animation )\r\n\t\t\t\tif ( animationKeys[0].morphTargets ) {\r\n\t\r\n\t\t\t\t\t// figure out all morph targets used in this track\r\n\t\t\t\t\tvar morphTargetNames = {};\r\n\t\t\t\t\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\r\n\t\r\n\t\t\t\t\t\tif ( animationKeys[k].morphTargets ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// create a track for each morph target with all zero\r\n\t\t\t\t\t// morphTargetInfluences except for the keys in which\r\n\t\t\t\t\t// the morphTarget is named.\r\n\t\t\t\t\tfor ( var morphTargetName in morphTargetNames ) {\r\n\t\r\n\t\t\t\t\t\tvar times = [];\r\n\t\t\t\t\t\tvar values = [];\r\n\t\r\n\t\t\t\t\t\tfor ( var m = 0;\r\n\t\t\t\t\t\t\t\tm !== animationKeys[k].morphTargets.length; ++ m ) {\r\n\t\r\n\t\t\t\t\t\t\tvar animationKey = animationKeys[k];\r\n\t\r\n\t\t\t\t\t\t\ttimes.push( animationKey.time );\r\n\t\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\ttracks.push( new THREE.NumberKeyframeTrack(\r\n\t\t\t\t\t\t\t\t'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// ...assume skeletal animation\r\n\t\r\n\t\t\t\t\tvar boneName = '.bones[' + bones[ h ].name + ']';\r\n\t\r\n\t\t\t\t\taddNonemptyTrack(\r\n\t\t\t\t\t\t\tTHREE.VectorKeyframeTrack, boneName + '.position',\r\n\t\t\t\t\t\t\tanimationKeys, 'pos', tracks );\r\n\t\r\n\t\t\t\t\taddNonemptyTrack(\r\n\t\t\t\t\t\t\tTHREE.QuaternionKeyframeTrack, boneName + '.quaternion',\r\n\t\t\t\t\t\t\tanimationKeys, 'rot', tracks );\r\n\t\r\n\t\t\t\t\taddNonemptyTrack(\r\n\t\t\t\t\t\t\tTHREE.VectorKeyframeTrack, boneName + '.scale',\r\n\t\t\t\t\t\t\tanimationKeys, 'scl', tracks );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( tracks.length === 0 ) {\r\n\t\r\n\t\t\t\treturn null;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar clip = new THREE.AnimationClip( clipName, duration, tracks );\r\n\t\r\n\t\t\treturn clip;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/animation/AnimationMixer.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * Player for AnimationClips.\r\n\t *\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.AnimationMixer = function( root ) {\r\n\t\r\n\t\tthis._root = root;\r\n\t\tthis._initMemoryManager();\r\n\t\tthis._accuIndex = 0;\r\n\t\r\n\t\tthis.time = 0;\r\n\t\r\n\t\tthis.timeScale = 1.0;\r\n\t\r\n\t};\r\n\t\r\n\tObject.assign( THREE.AnimationMixer.prototype, THREE.EventDispatcher.prototype, {\r\n\t\r\n\t\t// return an action for a clip optionally using a custom root target\r\n\t\t// object (this method allocates a lot of dynamic memory in case a\r\n\t\t// previously unknown clip/root combination is specified)\r\n\t\tclipAction: function( clip, optionalRoot ) {\r\n\t\r\n\t\t\tvar root = optionalRoot || this._root,\r\n\t\t\t\trootUuid = root.uuid,\r\n\t\r\n\t\t\t\tclipObject = typeof clip === 'string' ?\r\n\t\t\t\t\t\tTHREE.AnimationClip.findByName( root, clip ) : clip,\r\n\t\r\n\t\t\t\tclipUuid = clipObject !== null ? clipObject.uuid : clip,\r\n\t\r\n\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ],\r\n\t\t\t\tprototypeAction = null;\r\n\t\r\n\t\t\tif ( actionsForClip !== undefined ) {\r\n\t\r\n\t\t\t\tvar existingAction =\r\n\t\t\t\t\t\tactionsForClip.actionByRoot[ rootUuid ];\r\n\t\r\n\t\t\t\tif ( existingAction !== undefined ) {\r\n\t\r\n\t\t\t\t\treturn existingAction;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// we know the clip, so we don't have to parse all\r\n\t\t\t\t// the bindings again but can just copy\r\n\t\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\r\n\t\r\n\t\t\t\t// also, take the clip from the prototype action\r\n\t\t\t\tif ( clipObject === null )\r\n\t\t\t\t\tclipObject = prototypeAction._clip;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// clip must be known when specified via string\r\n\t\t\tif ( clipObject === null ) return null;\r\n\t\r\n\t\t\t// allocate all resources required to run it\r\n\t\t\tvar newAction = new THREE.\r\n\t\t\t\t\tAnimationMixer._Action( this, clipObject, optionalRoot );\r\n\t\r\n\t\t\tthis._bindAction( newAction, prototypeAction );\r\n\t\r\n\t\t\t// and make the action known to the memory manager\r\n\t\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\r\n\t\r\n\t\t\treturn newAction;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// get an existing action\r\n\t\texistingAction: function( clip, optionalRoot ) {\r\n\t\r\n\t\t\tvar root = optionalRoot || this._root,\r\n\t\t\t\trootUuid = root.uuid,\r\n\t\r\n\t\t\t\tclipObject = typeof clip === 'string' ?\r\n\t\t\t\t\t\tTHREE.AnimationClip.findByName( root, clip ) : clip,\r\n\t\r\n\t\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\r\n\t\r\n\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\r\n\t\r\n\t\t\tif ( actionsForClip !== undefined ) {\r\n\t\r\n\t\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn null;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// deactivates all previously scheduled actions\r\n\t\tstopAllAction: function() {\r\n\t\r\n\t\t\tvar actions = this._actions,\r\n\t\t\t\tnActions = this._nActiveActions,\r\n\t\t\t\tbindings = this._bindings,\r\n\t\t\t\tnBindings = this._nActiveBindings;\r\n\t\r\n\t\t\tthis._nActiveActions = 0;\r\n\t\t\tthis._nActiveBindings = 0;\r\n\t\r\n\t\t\tfor ( var i = 0; i !== nActions; ++ i ) {\r\n\t\r\n\t\t\t\tactions[ i ].reset();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\r\n\t\r\n\t\t\t\tbindings[ i ].useCount = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// advance the time and update apply the animation\r\n\t\tupdate: function( deltaTime ) {\r\n\t\r\n\t\t\tdeltaTime *= this.timeScale;\r\n\t\r\n\t\t\tvar actions = this._actions,\r\n\t\t\t\tnActions = this._nActiveActions,\r\n\t\r\n\t\t\t\ttime = this.time += deltaTime,\r\n\t\t\t\ttimeDirection = Math.sign( deltaTime ),\r\n\t\r\n\t\t\t\taccuIndex = this._accuIndex ^= 1;\r\n\t\r\n\t\t\t// run active actions\r\n\t\r\n\t\t\tfor ( var i = 0; i !== nActions; ++ i ) {\r\n\t\r\n\t\t\t\tvar action = actions[ i ];\r\n\t\r\n\t\t\t\tif ( action.enabled ) {\r\n\t\r\n\t\t\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// update scene graph\r\n\t\r\n\t\t\tvar bindings = this._bindings,\r\n\t\t\t\tnBindings = this._nActiveBindings;\r\n\t\r\n\t\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\r\n\t\r\n\t\t\t\tbindings[ i ].apply( accuIndex );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// return this mixer's root target object\r\n\t\tgetRoot: function() {\r\n\t\r\n\t\t\treturn this._root;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// free all resources specific to a particular clip\r\n\t\tuncacheClip: function( clip ) {\r\n\t\r\n\t\t\tvar actions = this._actions,\r\n\t\t\t\tclipUuid = clip.uuid,\r\n\t\t\t\tactionsByClip = this._actionsByClip,\r\n\t\t\t\tactionsForClip = actionsByClip[ clipUuid ];\r\n\t\r\n\t\t\tif ( actionsForClip !== undefined ) {\r\n\t\r\n\t\t\t\t// note: just calling _removeInactiveAction would mess up the\r\n\t\t\t\t// iteration state and also require updating the state we can\r\n\t\t\t\t// just throw away\r\n\t\r\n\t\t\t\tvar actionsToRemove = actionsForClip.knownActions;\r\n\t\r\n\t\t\t\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\tvar action = actionsToRemove[ i ];\r\n\t\r\n\t\t\t\t\tthis._deactivateAction( action );\r\n\t\r\n\t\t\t\t\tvar cacheIndex = action._cacheIndex,\r\n\t\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\r\n\t\r\n\t\t\t\t\taction._cacheIndex = null;\r\n\t\t\t\t\taction._byClipCacheIndex = null;\r\n\t\r\n\t\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\r\n\t\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\r\n\t\t\t\t\tactions.pop();\r\n\t\r\n\t\t\t\t\tthis._removeInactiveBindingsForAction( action );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tdelete actionsByClip[ clipUuid ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// free all resources specific to a particular root target object\r\n\t\tuncacheRoot: function( root ) {\r\n\t\r\n\t\t\tvar rootUuid = root.uuid,\r\n\t\t\t\tactionsByClip = this._actionsByClip;\r\n\t\r\n\t\t\tfor ( var clipUuid in actionsByClip ) {\r\n\t\r\n\t\t\t\tvar actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\r\n\t\t\t\t\taction = actionByRoot[ rootUuid ];\r\n\t\r\n\t\t\t\tif ( action !== undefined ) {\r\n\t\r\n\t\t\t\t\tthis._deactivateAction( action );\r\n\t\t\t\t\tthis._removeInactiveAction( action );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar bindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\r\n\t\r\n\t\t\tif ( bindingByName !== undefined ) {\r\n\t\r\n\t\t\t\tfor ( var trackName in bindingByName ) {\r\n\t\r\n\t\t\t\t\tvar binding = bindingByName[ trackName ];\r\n\t\t\t\t\tbinding.restoreOriginalState();\r\n\t\t\t\t\tthis._removeInactiveBinding( binding );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// remove a targeted clip from the cache\r\n\t\tuncacheAction: function( clip, optionalRoot ) {\r\n\t\r\n\t\t\tvar action = this.existingAction( clip, optionalRoot );\r\n\t\r\n\t\t\tif ( action !== null ) {\r\n\t\r\n\t\t\t\tthis._deactivateAction( action );\r\n\t\t\t\tthis._removeInactiveAction( action );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\tTHREE.AnimationMixer._Action = THREE.AnimationAction._new;\r\n\t\r\n\t// Implementation details:\r\n\t\r\n\tObject.assign( THREE.AnimationMixer.prototype, {\r\n\t\r\n\t\t_bindAction: function( action, prototypeAction ) {\r\n\t\r\n\t\t\tvar root = action._localRoot || this._root,\r\n\t\t\t\ttracks = action._clip.tracks,\r\n\t\t\t\tnTracks = tracks.length,\r\n\t\t\t\tbindings = action._propertyBindings,\r\n\t\t\t\tinterpolants = action._interpolants,\r\n\t\t\t\trootUuid = root.uuid,\r\n\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\t\tbindingsByName = bindingsByRoot[ rootUuid ];\r\n\t\r\n\t\t\tif ( bindingsByName === undefined ) {\r\n\t\r\n\t\t\t\tbindingsByName = {};\r\n\t\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\r\n\t\r\n\t\t\t\tvar track = tracks[ i ],\r\n\t\t\t\t\ttrackName = track.name,\r\n\t\t\t\t\tbinding = bindingsByName[ trackName ];\r\n\t\r\n\t\t\t\tif ( binding !== undefined ) {\r\n\t\r\n\t\t\t\t\tbindings[ i ] = binding;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tbinding = bindings[ i ];\r\n\t\r\n\t\t\t\t\tif ( binding !== undefined ) {\r\n\t\r\n\t\t\t\t\t\t// existing binding, make sure the cache knows\r\n\t\r\n\t\t\t\t\t\tif ( binding._cacheIndex === null ) {\r\n\t\r\n\t\t\t\t\t\t\t++ binding.referenceCount;\r\n\t\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tcontinue;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar path = prototypeAction && prototypeAction.\r\n\t\t\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\r\n\t\r\n\t\t\t\t\tbinding = new THREE.PropertyMixer(\r\n\t\t\t\t\t\t\tTHREE.PropertyBinding.create( root, trackName, path ),\r\n\t\t\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\r\n\t\r\n\t\t\t\t\t++ binding.referenceCount;\r\n\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\r\n\t\r\n\t\t\t\t\tbindings[ i ] = binding;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_activateAction: function( action ) {\r\n\t\r\n\t\t\tif ( ! this._isActiveAction( action ) ) {\r\n\t\r\n\t\t\t\tif ( action._cacheIndex === null ) {\r\n\t\r\n\t\t\t\t\t// this action has been forgotten by the cache, but the user\r\n\t\t\t\t\t// appears to be still using it -> rebind\r\n\t\r\n\t\t\t\t\tvar rootUuid = ( action._localRoot || this._root ).uuid,\r\n\t\t\t\t\t\tclipUuid = action._clip.uuid,\r\n\t\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\r\n\t\r\n\t\t\t\t\tthis._bindAction( action,\r\n\t\t\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\r\n\t\r\n\t\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar bindings = action._propertyBindings;\r\n\t\r\n\t\t\t\t// increment reference counts / sort out state\r\n\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\tvar binding = bindings[ i ];\r\n\t\r\n\t\t\t\t\tif ( binding.useCount ++ === 0 ) {\r\n\t\r\n\t\t\t\t\t\tthis._lendBinding( binding );\r\n\t\t\t\t\t\tbinding.saveOriginalState();\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis._lendAction( action );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_deactivateAction: function( action ) {\r\n\t\r\n\t\t\tif ( this._isActiveAction( action ) ) {\r\n\t\r\n\t\t\t\tvar bindings = action._propertyBindings;\r\n\t\r\n\t\t\t\t// decrement reference counts / sort out state\r\n\t\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\tvar binding = bindings[ i ];\r\n\t\r\n\t\t\t\t\tif ( -- binding.useCount === 0 ) {\r\n\t\r\n\t\t\t\t\t\tbinding.restoreOriginalState();\r\n\t\t\t\t\t\tthis._takeBackBinding( binding );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis._takeBackAction( action );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Memory manager\r\n\t\r\n\t\t_initMemoryManager: function() {\r\n\t\r\n\t\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\r\n\t\t\tthis._nActiveActions = 0;\r\n\t\r\n\t\t\tthis._actionsByClip = {};\r\n\t\t\t// inside:\r\n\t\t\t// {\r\n\t\t\t// \t\tknownActions: Array< _Action >\t- used as prototypes\r\n\t\t\t// \t\tactionByRoot: _Action\t\t\t- lookup\r\n\t\t\t// }\r\n\t\r\n\t\r\n\t\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\r\n\t\t\tthis._nActiveBindings = 0;\r\n\t\r\n\t\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\r\n\t\r\n\t\r\n\t\t\tthis._controlInterpolants = []; // same game as above\r\n\t\t\tthis._nActiveControlInterpolants = 0;\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tthis.stats = {\r\n\t\r\n\t\t\t\tactions: {\r\n\t\t\t\t\tget total() { return scope._actions.length; },\r\n\t\t\t\t\tget inUse() { return scope._nActiveActions; }\r\n\t\t\t\t},\r\n\t\t\t\tbindings: {\r\n\t\t\t\t\tget total() { return scope._bindings.length; },\r\n\t\t\t\t\tget inUse() { return scope._nActiveBindings; }\r\n\t\t\t\t},\r\n\t\t\t\tcontrolInterpolants: {\r\n\t\t\t\t\tget total() { return scope._controlInterpolants.length; },\r\n\t\t\t\t\tget inUse() { return scope._nActiveControlInterpolants; }\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Memory management for _Action objects\r\n\t\r\n\t\t_isActiveAction: function( action ) {\r\n\t\r\n\t\t\tvar index = action._cacheIndex;\r\n\t\t\treturn index !== null && index < this._nActiveActions;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_addInactiveAction: function( action, clipUuid, rootUuid ) {\r\n\t\r\n\t\t\tvar actions = this._actions,\r\n\t\t\t\tactionsByClip = this._actionsByClip,\r\n\t\t\t\tactionsForClip = actionsByClip[ clipUuid ];\r\n\t\r\n\t\t\tif ( actionsForClip === undefined ) {\r\n\t\r\n\t\t\t\tactionsForClip = {\r\n\t\r\n\t\t\t\t\tknownActions: [ action ],\r\n\t\t\t\t\tactionByRoot: {}\r\n\t\r\n\t\t\t\t};\r\n\t\r\n\t\t\t\taction._byClipCacheIndex = 0;\r\n\t\r\n\t\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tvar knownActions = actionsForClip.knownActions;\r\n\t\r\n\t\t\t\taction._byClipCacheIndex = knownActions.length;\r\n\t\t\t\tknownActions.push( action );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\taction._cacheIndex = actions.length;\r\n\t\t\tactions.push( action );\r\n\t\r\n\t\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_removeInactiveAction: function( action ) {\r\n\t\r\n\t\t\tvar actions = this._actions,\r\n\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\r\n\t\t\t\tcacheIndex = action._cacheIndex;\r\n\t\r\n\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\r\n\t\t\tactions[ cacheIndex ] = lastInactiveAction;\r\n\t\t\tactions.pop();\r\n\t\r\n\t\t\taction._cacheIndex = null;\r\n\t\r\n\t\r\n\t\t\tvar clipUuid = action._clip.uuid,\r\n\t\t\t\tactionsByClip = this._actionsByClip,\r\n\t\t\t\tactionsForClip = actionsByClip[ clipUuid ],\r\n\t\t\t\tknownActionsForClip = actionsForClip.knownActions,\r\n\t\r\n\t\t\t\tlastKnownAction =\r\n\t\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\r\n\t\r\n\t\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\r\n\t\r\n\t\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\r\n\t\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\r\n\t\t\tknownActionsForClip.pop();\r\n\t\r\n\t\t\taction._byClipCacheIndex = null;\r\n\t\r\n\t\r\n\t\t\tvar actionByRoot = actionsForClip.actionByRoot,\r\n\t\t\t\trootUuid = ( actions._localRoot || this._root ).uuid;\r\n\t\r\n\t\t\tdelete actionByRoot[ rootUuid ];\r\n\t\r\n\t\t\tif ( knownActionsForClip.length === 0 ) {\r\n\t\r\n\t\t\t\tdelete actionsByClip[ clipUuid ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis._removeInactiveBindingsForAction( action );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_removeInactiveBindingsForAction: function( action ) {\r\n\t\r\n\t\t\tvar bindings = action._propertyBindings;\r\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tvar binding = bindings[ i ];\r\n\t\r\n\t\t\t\tif ( -- binding.referenceCount === 0 ) {\r\n\t\r\n\t\t\t\t\tthis._removeInactiveBinding( binding );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_lendAction: function( action ) {\r\n\t\r\n\t\t\t// [ active actions |  inactive actions  ]\r\n\t\t\t// [  active actions >| inactive actions ]\r\n\t\t\t//                 s        a\r\n\t\t\t//                  <-swap->\r\n\t\t\t//                 a        s\r\n\t\r\n\t\t\tvar actions = this._actions,\r\n\t\t\t\tprevIndex = action._cacheIndex,\r\n\t\r\n\t\t\t\tlastActiveIndex = this._nActiveActions ++,\r\n\t\r\n\t\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\r\n\t\r\n\t\t\taction._cacheIndex = lastActiveIndex;\r\n\t\t\tactions[ lastActiveIndex ] = action;\r\n\t\r\n\t\t\tfirstInactiveAction._cacheIndex = prevIndex;\r\n\t\t\tactions[ prevIndex ] = firstInactiveAction;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_takeBackAction: function( action ) {\r\n\t\r\n\t\t\t// [  active actions  | inactive actions ]\r\n\t\t\t// [ active actions |< inactive actions  ]\r\n\t\t\t//        a        s\r\n\t\t\t//         <-swap->\r\n\t\t\t//        s        a\r\n\t\r\n\t\t\tvar actions = this._actions,\r\n\t\t\t\tprevIndex = action._cacheIndex,\r\n\t\r\n\t\t\t\tfirstInactiveIndex = -- this._nActiveActions,\r\n\t\r\n\t\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\r\n\t\r\n\t\t\taction._cacheIndex = firstInactiveIndex;\r\n\t\t\tactions[ firstInactiveIndex ] = action;\r\n\t\r\n\t\t\tlastActiveAction._cacheIndex = prevIndex;\r\n\t\t\tactions[ prevIndex ] = lastActiveAction;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Memory management for PropertyMixer objects\r\n\t\r\n\t\t_addInactiveBinding: function( binding, rootUuid, trackName ) {\r\n\t\r\n\t\t\tvar bindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\r\n\t\r\n\t\t\t\tbindings = this._bindings;\r\n\t\r\n\t\t\tif ( bindingByName === undefined ) {\r\n\t\r\n\t\t\t\tbindingByName = {};\r\n\t\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tbindingByName[ trackName ] = binding;\r\n\t\r\n\t\t\tbinding._cacheIndex = bindings.length;\r\n\t\t\tbindings.push( binding );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_removeInactiveBinding: function( binding ) {\r\n\t\r\n\t\t\tvar bindings = this._bindings,\r\n\t\t\t\tpropBinding = binding.binding,\r\n\t\t\t\trootUuid = propBinding.rootNode.uuid,\r\n\t\t\t\ttrackName = propBinding.path,\r\n\t\t\t\tbindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\r\n\t\r\n\t\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\r\n\t\t\t\tcacheIndex = binding._cacheIndex;\r\n\t\r\n\t\t\tlastInactiveBinding._cacheIndex = cacheIndex;\r\n\t\t\tbindings[ cacheIndex ] = lastInactiveBinding;\r\n\t\t\tbindings.pop();\r\n\t\r\n\t\t\tdelete bindingByName[ trackName ];\r\n\t\r\n\t\t\tremove_empty_map: {\r\n\t\r\n\t\t\t\tfor ( var _ in bindingByName ) break remove_empty_map;\r\n\t\r\n\t\t\t\tdelete bindingsByRoot[ rootUuid ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_lendBinding: function( binding ) {\r\n\t\r\n\t\t\tvar bindings = this._bindings,\r\n\t\t\t\tprevIndex = binding._cacheIndex,\r\n\t\r\n\t\t\t\tlastActiveIndex = this._nActiveBindings ++,\r\n\t\r\n\t\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\r\n\t\r\n\t\t\tbinding._cacheIndex = lastActiveIndex;\r\n\t\t\tbindings[ lastActiveIndex ] = binding;\r\n\t\r\n\t\t\tfirstInactiveBinding._cacheIndex = prevIndex;\r\n\t\t\tbindings[ prevIndex ] = firstInactiveBinding;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_takeBackBinding: function( binding ) {\r\n\t\r\n\t\t\tvar bindings = this._bindings,\r\n\t\t\t\tprevIndex = binding._cacheIndex,\r\n\t\r\n\t\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\r\n\t\r\n\t\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\r\n\t\r\n\t\t\tbinding._cacheIndex = firstInactiveIndex;\r\n\t\t\tbindings[ firstInactiveIndex ] = binding;\r\n\t\r\n\t\t\tlastActiveBinding._cacheIndex = prevIndex;\r\n\t\t\tbindings[ prevIndex ] = lastActiveBinding;\r\n\t\r\n\t\t},\r\n\t\r\n\t\r\n\t\t// Memory management of Interpolants for weight and time scale\r\n\t\r\n\t\t_lendControlInterpolant: function() {\r\n\t\r\n\t\t\tvar interpolants = this._controlInterpolants,\r\n\t\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++,\r\n\t\t\t\tinterpolant = interpolants[ lastActiveIndex ];\r\n\t\r\n\t\t\tif ( interpolant === undefined ) {\r\n\t\r\n\t\t\t\tinterpolant = new THREE.LinearInterpolant(\r\n\t\t\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\r\n\t\t\t\t\t\t\t1, this._controlInterpolantsResultBuffer );\r\n\t\r\n\t\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\r\n\t\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn interpolant;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_takeBackControlInterpolant: function( interpolant ) {\r\n\t\r\n\t\t\tvar interpolants = this._controlInterpolants,\r\n\t\t\t\tprevIndex = interpolant.__cacheIndex,\r\n\t\r\n\t\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\r\n\t\r\n\t\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\r\n\t\r\n\t\t\tinterpolant.__cacheIndex = firstInactiveIndex;\r\n\t\t\tinterpolants[ firstInactiveIndex ] = interpolant;\r\n\t\r\n\t\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\r\n\t\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_controlInterpolantsResultBuffer: new Float32Array( 1 )\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/animation/AnimationObjectGroup.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * A group of objects that receives a shared animation state.\r\n\t *\r\n\t * Usage:\r\n\t *\r\n\t * \t-\tAdd objects you would otherwise pass as 'root' to the\r\n\t * \t\tconstructor or the .clipAction method of AnimationMixer.\r\n\t *\r\n\t * \t-\tInstead pass this object as 'root'.\r\n\t *\r\n\t * \t-\tYou can also add and remove objects later when the mixer\r\n\t * \t\tis running.\r\n\t *\r\n\t * Note:\r\n\t *\r\n\t *  \tObjects of this class appear as one object to the mixer,\r\n\t *  \tso cache control of the individual objects must be done\r\n\t *  \ton the group.\r\n\t *\r\n\t * Limitation:\r\n\t *\r\n\t * \t- \tThe animated properties must be compatible among the\r\n\t * \t\tall objects in the group.\r\n\t *\r\n\t *  -\tA single property can either be controlled through a\r\n\t *  \ttarget group or directly, but not both.\r\n\t *\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.AnimationObjectGroup = function( var_args ) {\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\t// cached objects followed by the active ones\r\n\t\tthis._objects = Array.prototype.slice.call( arguments );\r\n\t\r\n\t\tthis.nCachedObjects_ = 0;\t\t\t// threshold\r\n\t\t// note: read by PropertyBinding.Composite\r\n\t\r\n\t\tvar indices = {};\r\n\t\tthis._indicesByUUID = indices;\t\t// for bookkeeping\r\n\t\r\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\tindices[ arguments[ i ].uuid ] = i;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis._paths = [];\t\t\t\t\t// inside: string\r\n\t\tthis._parsedPaths = [];\t\t\t\t// inside: { we don't care, here }\r\n\t\tthis._bindings = []; \t\t\t\t// inside: Array< PropertyBinding >\r\n\t\tthis._bindingsIndicesByPath = {}; \t// inside: indices in these arrays\r\n\t\r\n\t\tvar scope = this;\r\n\t\r\n\t\tthis.stats = {\r\n\t\r\n\t\t\tobjects: {\r\n\t\t\t\tget total() { return scope._objects.length; },\r\n\t\t\t\tget inUse() { return this.total - scope.nCachedObjects_;  }\r\n\t\t\t},\r\n\t\r\n\t\t\tget bindingsPerObject() { return scope._bindings.length; }\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AnimationObjectGroup.prototype = {\r\n\t\r\n\t\tconstructor: THREE.AnimationObjectGroup,\r\n\t\r\n\t\tadd: function( var_args ) {\r\n\t\r\n\t\t\tvar objects = this._objects,\r\n\t\t\t\tnObjects = objects.length,\r\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\r\n\t\t\t\tindicesByUUID = this._indicesByUUID,\r\n\t\t\t\tpaths = this._paths,\r\n\t\t\t\tparsedPaths = this._parsedPaths,\r\n\t\t\t\tbindings = this._bindings,\r\n\t\t\t\tnBindings = bindings.length;\r\n\t\r\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tvar object = arguments[ i ],\r\n\t\t\t\t\tuuid = object.uuid,\r\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\r\n\t\r\n\t\t\t\tif ( index === undefined ) {\r\n\t\r\n\t\t\t\t\t// unknown object -> add it to the ACTIVE region\r\n\t\r\n\t\t\t\t\tindex = nObjects ++;\r\n\t\t\t\t\tindicesByUUID[ uuid ] = index;\r\n\t\t\t\t\tobjects.push( object );\r\n\t\r\n\t\t\t\t\t// accounting is done, now do the same for all bindings\r\n\t\r\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\t\r\n\t\t\t\t\t\tbindings[ j ].push(\r\n\t\t\t\t\t\t\t\tnew THREE.PropertyBinding(\r\n\t\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( index < nCachedObjects ) {\r\n\t\r\n\t\t\t\t\tvar knownObject = objects[ index ];\r\n\t\r\n\t\t\t\t\t// move existing object to the ACTIVE region\r\n\t\r\n\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\r\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\r\n\t\r\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\r\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\r\n\t\r\n\t\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\r\n\t\t\t\t\tobjects[ firstActiveIndex ] = object;\r\n\t\r\n\t\t\t\t\t// accounting is done, now do the same for all bindings\r\n\t\r\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\t\r\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\r\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\r\n\t\t\t\t\t\t\tbinding = bindingsForPath[ index ];\r\n\t\r\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\r\n\t\r\n\t\t\t\t\t\tif ( binding === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\t// since we do not bother to create new bindings\r\n\t\t\t\t\t\t\t// for objects that are cached, the binding may\r\n\t\t\t\t\t\t\t// or may not exist\r\n\t\r\n\t\t\t\t\t\t\tbinding = new THREE.PropertyBinding(\r\n\t\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( objects[ index ] !== knownObject) {\r\n\t\r\n\t\t\t\t\tconsole.error( \"Different objects with the same UUID \" +\r\n\t\t\t\t\t\t\t\"detected. Clean the caches or recreate your \" +\r\n\t\t\t\t\t\t\t\"infrastructure when reloading scenes...\" );\r\n\t\r\n\t\t\t\t} // else the object is already where we want it to be\r\n\t\r\n\t\t\t} // for arguments\r\n\t\r\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tremove: function( var_args ) {\r\n\t\r\n\t\t\tvar objects = this._objects,\r\n\t\t\t\tnObjects = objects.length,\r\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\r\n\t\t\t\tindicesByUUID = this._indicesByUUID,\r\n\t\t\t\tbindings = this._bindings,\r\n\t\t\t\tnBindings = bindings.length;\r\n\t\r\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tvar object = arguments[ i ],\r\n\t\t\t\t\tuuid = object.uuid,\r\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\r\n\t\r\n\t\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\r\n\t\r\n\t\t\t\t\t// move existing object into the CACHED region\r\n\t\r\n\t\t\t\t\tvar lastCachedIndex = nCachedObjects ++,\r\n\t\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\r\n\t\r\n\t\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\r\n\t\t\t\t\tobjects[ index ] = firstActiveObject;\r\n\t\r\n\t\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\r\n\t\t\t\t\tobjects[ lastCachedIndex ] = object;\r\n\t\r\n\t\t\t\t\t// accounting is done, now do the same for all bindings\r\n\t\r\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\t\r\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\r\n\t\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\r\n\t\t\t\t\t\t\tbinding = bindingsForPath[ index ];\r\n\t\r\n\t\t\t\t\t\tbindingsForPath[ index ] = firstActive;\r\n\t\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} // for arguments\r\n\t\r\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// remove & forget\r\n\t\tuncache: function( var_args ) {\r\n\t\r\n\t\t\tvar objects = this._objects,\r\n\t\t\t\tnObjects = objects.length,\r\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\r\n\t\t\t\tindicesByUUID = this._indicesByUUID,\r\n\t\t\t\tbindings = this._bindings,\r\n\t\t\t\tnBindings = bindings.length;\r\n\t\r\n\t\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tvar object = arguments[ i ],\r\n\t\t\t\t\tuuid = object.uuid,\r\n\t\t\t\t\tindex = indicesByUUID[ uuid ];\r\n\t\r\n\t\t\t\tif ( index !== undefined ) {\r\n\t\r\n\t\t\t\t\tdelete indicesByUUID[ uuid ];\r\n\t\r\n\t\t\t\t\tif ( index < nCachedObjects ) {\r\n\t\r\n\t\t\t\t\t\t// object is cached, shrink the CACHED region\r\n\t\r\n\t\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\r\n\t\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\r\n\t\t\t\t\t\t\tlastIndex = -- nObjects,\r\n\t\t\t\t\t\t\tlastObject = objects[ lastIndex ];\r\n\t\r\n\t\t\t\t\t\t// last cached object takes this object's place\r\n\t\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\r\n\t\t\t\t\t\tobjects[ index ] = lastCachedObject;\r\n\t\r\n\t\t\t\t\t\t// last object goes to the activated slot and pop\r\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\r\n\t\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\r\n\t\t\t\t\t\tobjects.pop();\r\n\t\r\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\r\n\t\r\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\t\r\n\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\r\n\t\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\r\n\t\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\r\n\t\r\n\t\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\r\n\t\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\r\n\t\t\t\t\t\t\tbindingsForPath.pop();\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t// object is active, just swap with the last and pop\r\n\t\r\n\t\t\t\t\t\tvar lastIndex = -- nObjects,\r\n\t\t\t\t\t\t\tlastObject = objects[ lastIndex ];\r\n\t\r\n\t\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\r\n\t\t\t\t\t\tobjects[ index ] = lastObject;\r\n\t\t\t\t\t\tobjects.pop();\r\n\t\r\n\t\t\t\t\t\t// accounting is done, now do the same for all bindings\r\n\t\r\n\t\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\t\r\n\t\t\t\t\t\t\tvar bindingsForPath = bindings[ j ];\r\n\t\r\n\t\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\r\n\t\t\t\t\t\t\tbindingsForPath.pop();\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} // cached or active\r\n\t\r\n\t\t\t\t} // if object is known\r\n\t\r\n\t\t\t} // for arguments\r\n\t\r\n\t\t\tthis.nCachedObjects_ = nCachedObjects;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Internal interface used by befriended PropertyBinding.Composite:\r\n\t\r\n\t\tsubscribe_: function( path, parsedPath ) {\r\n\t\t\t// returns an array of bindings for the given path that is changed\r\n\t\t\t// according to the contained objects in the group\r\n\t\r\n\t\t\tvar indicesByPath = this._bindingsIndicesByPath,\r\n\t\t\t\tindex = indicesByPath[ path ],\r\n\t\t\t\tbindings = this._bindings;\r\n\t\r\n\t\t\tif ( index !== undefined ) return bindings[ index ];\r\n\t\r\n\t\t\tvar paths = this._paths,\r\n\t\t\t\tparsedPaths = this._parsedPaths,\r\n\t\t\t\tobjects = this._objects,\r\n\t\t\t\tnObjects = objects.length,\r\n\t\t\t\tnCachedObjects = this.nCachedObjects_,\r\n\t\t\t\tbindingsForPath = new Array( nObjects );\r\n\t\r\n\t\t\tindex = bindings.length;\r\n\t\r\n\t\t\tindicesByPath[ path ] = index;\r\n\t\r\n\t\t\tpaths.push( path );\r\n\t\t\tparsedPaths.push( parsedPath );\r\n\t\t\tbindings.push( bindingsForPath );\r\n\t\r\n\t\t\tfor ( var i = nCachedObjects,\r\n\t\t\t\t\tn = objects.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tvar object = objects[ i ];\r\n\t\r\n\t\t\t\tbindingsForPath[ i ] =\r\n\t\t\t\t\t\tnew THREE.PropertyBinding( object, path, parsedPath );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn bindingsForPath;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tunsubscribe_: function( path ) {\r\n\t\t\t// tells the group to forget about a property path and no longer\r\n\t\t\t// update the array previously obtained with 'subscribe_'\r\n\t\r\n\t\t\tvar indicesByPath = this._bindingsIndicesByPath,\r\n\t\t\t\tindex = indicesByPath[ path ];\r\n\t\r\n\t\t\tif ( index !== undefined ) {\r\n\t\r\n\t\t\t\tvar paths = this._paths,\r\n\t\t\t\t\tparsedPaths = this._parsedPaths,\r\n\t\t\t\t\tbindings = this._bindings,\r\n\t\t\t\t\tlastBindingsIndex = bindings.length - 1,\r\n\t\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\r\n\t\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\r\n\t\r\n\t\t\t\tindicesByPath[ lastBindingsPath ] = index;\r\n\t\r\n\t\t\t\tbindings[ index ] = lastBindings;\r\n\t\t\t\tbindings.pop();\r\n\t\r\n\t\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\r\n\t\t\t\tparsedPaths.pop();\r\n\t\r\n\t\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\r\n\t\t\t\tpaths.pop();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t// File:src/animation/AnimationUtils.js\r\n\t\r\n\t/**\r\n\t * @author tschw\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t */\r\n\t\r\n\tTHREE.AnimationUtils = {\r\n\t\r\n\t\t// same as Array.prototype.slice, but also works on typed arrays\r\n\t\tarraySlice: function( array, from, to ) {\r\n\t\r\n\t\t\tif ( THREE.AnimationUtils.isTypedArray( array ) ) {\r\n\t\r\n\t\t\t\treturn new array.constructor( array.subarray( from, to ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn array.slice( from, to );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// converts an array to a specific type\r\n\t\tconvertArray: function( array, type, forceClone ) {\r\n\t\r\n\t\t\tif ( ! array || // let 'undefined' and 'null' pass\r\n\t\t\t\t\t! forceClone && array.constructor === type ) return array;\r\n\t\r\n\t\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\r\n\t\r\n\t\t\t\treturn new type( array ); // create typed array\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn Array.prototype.slice.call( array ); // create Array\r\n\t\r\n\t\t},\r\n\t\r\n\t\tisTypedArray: function( object ) {\r\n\t\r\n\t\t\treturn ArrayBuffer.isView( object ) &&\r\n\t\t\t\t\t! ( object instanceof DataView );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// returns an array by which times and values can be sorted\r\n\t\tgetKeyframeOrder: function( times ) {\r\n\t\r\n\t\t\tfunction compareTime( i, j ) {\r\n\t\r\n\t\t\t\treturn times[ i ] - times[ j ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar n = times.length;\r\n\t\t\tvar result = new Array( n );\r\n\t\t\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\r\n\t\r\n\t\t\tresult.sort( compareTime );\r\n\t\r\n\t\t\treturn result;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// uses the array previously returned by 'getKeyframeOrder' to sort data\r\n\t\tsortedArray: function( values, stride, order ) {\r\n\t\r\n\t\t\tvar nValues = values.length;\r\n\t\t\tvar result = new values.constructor( nValues );\r\n\t\r\n\t\t\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\r\n\t\r\n\t\t\t\tvar srcOffset = order[ i ] * stride;\r\n\t\r\n\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\r\n\t\r\n\t\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// function for parsing AOS keyframe formats\r\n\t\tflattenJSON: function( jsonKeys, times, values, valuePropertyName ) {\r\n\t\r\n\t\t\tvar i = 1, key = jsonKeys[ 0 ];\r\n\t\r\n\t\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\r\n\t\r\n\t\t\t\tkey = jsonKeys[ i ++ ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( key === undefined ) return; // no data\r\n\t\r\n\t\t\tvar value = key[ valuePropertyName ];\r\n\t\t\tif ( value === undefined ) return; // no data\r\n\t\r\n\t\t\tif ( Array.isArray( value ) ) {\r\n\t\r\n\t\t\t\tdo {\r\n\t\r\n\t\t\t\t\tvalue = key[ valuePropertyName ];\r\n\t\r\n\t\t\t\t\tif ( value !== undefined ) {\r\n\t\r\n\t\t\t\t\t\ttimes.push( key.time );\r\n\t\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\r\n\t\r\n\t\t\t\t} while ( key !== undefined );\r\n\t\r\n\t\t\t} else if ( value.toArray !== undefined ) {\r\n\t\t\t\t// ...assume THREE.Math-ish\r\n\t\r\n\t\t\t\tdo {\r\n\t\r\n\t\t\t\t\tvalue = key[ valuePropertyName ];\r\n\t\r\n\t\t\t\t\tif ( value !== undefined ) {\r\n\t\r\n\t\t\t\t\t\ttimes.push( key.time );\r\n\t\t\t\t\t\tvalue.toArray( values, values.length );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\r\n\t\r\n\t\t\t\t} while ( key !== undefined );\r\n\t\r\n\t\t\t} else {\r\n\t\t\t\t// otherwise push as-is\r\n\t\r\n\t\t\t\tdo {\r\n\t\r\n\t\t\t\t\tvalue = key[ valuePropertyName ];\r\n\t\r\n\t\t\t\t\tif ( value !== undefined ) {\r\n\t\r\n\t\t\t\t\t\ttimes.push( key.time );\r\n\t\t\t\t\t\tvalues.push( value );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tkey = jsonKeys[ i ++ ];\r\n\t\r\n\t\t\t\t} while ( key !== undefined );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/animation/KeyframeTrack.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * A timed sequence of keyframes for a specific property.\r\n\t *\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.KeyframeTrack = function ( name, times, values, interpolation ) {\r\n\t\r\n\t\tif( name === undefined ) throw new Error( \"track name is undefined\" );\r\n\t\r\n\t\tif( times === undefined || times.length === 0 ) {\r\n\t\r\n\t\t\tthrow new Error( \"no keyframes in track named \" + name );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.name = name;\r\n\t\r\n\t\tthis.times = THREE.AnimationUtils.convertArray( times, this.TimeBufferType );\r\n\t\tthis.values = THREE.AnimationUtils.convertArray( values, this.ValueBufferType );\r\n\t\r\n\t\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\r\n\t\r\n\t\tthis.validate();\r\n\t\tthis.optimize();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.KeyframeTrack.prototype = {\r\n\t\r\n\t\tconstructor: THREE.KeyframeTrack,\r\n\t\r\n\t\tTimeBufferType: Float32Array,\r\n\t\tValueBufferType: Float32Array,\r\n\t\r\n\t\tDefaultInterpolation: THREE.InterpolateLinear,\r\n\t\r\n\t\tInterpolantFactoryMethodDiscrete: function( result ) {\r\n\t\r\n\t\t\treturn new THREE.DiscreteInterpolant(\r\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tInterpolantFactoryMethodLinear: function( result ) {\r\n\t\r\n\t\t\treturn new THREE.LinearInterpolant(\r\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tInterpolantFactoryMethodSmooth: function( result ) {\r\n\t\r\n\t\t\treturn new THREE.CubicInterpolant(\r\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetInterpolation: function( interpolation ) {\r\n\t\r\n\t\t\tvar factoryMethod;\r\n\t\r\n\t\t\tswitch ( interpolation ) {\r\n\t\r\n\t\t\t\tcase THREE.InterpolateDiscrete:\r\n\t\r\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase THREE.InterpolateLinear:\r\n\t\r\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase THREE.InterpolateSmooth:\r\n\t\r\n\t\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( factoryMethod === undefined ) {\r\n\t\r\n\t\t\t\tvar message = \"unsupported interpolation for \" +\r\n\t\t\t\t\t\tthis.ValueTypeName + \" keyframe track named \" + this.name;\r\n\t\r\n\t\t\t\tif ( this.createInterpolant === undefined ) {\r\n\t\r\n\t\t\t\t\t// fall back to default, unless the default itself is messed up\r\n\t\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\r\n\t\r\n\t\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tthrow new Error( message ); // fatal, in this case\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tconsole.warn( message );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.createInterpolant = factoryMethod;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetInterpolation: function() {\r\n\t\r\n\t\t\tswitch ( this.createInterpolant ) {\r\n\t\r\n\t\t\t\tcase this.InterpolantFactoryMethodDiscrete:\r\n\t\r\n\t\t\t\t\treturn THREE.InterpolateDiscrete;\r\n\t\r\n\t\t\t\tcase this.InterpolantFactoryMethodLinear:\r\n\t\r\n\t\t\t\t\treturn THREE.InterpolateLinear;\r\n\t\r\n\t\t\t\tcase this.InterpolantFactoryMethodSmooth:\r\n\t\r\n\t\t\t\t\treturn THREE.InterpolateSmooth;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetValueSize: function() {\r\n\t\r\n\t\t\treturn this.values.length / this.times.length;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// move all keyframes either forwards or backwards in time\r\n\t\tshift: function( timeOffset ) {\r\n\t\r\n\t\t\tif( timeOffset !== 0.0 ) {\r\n\t\r\n\t\t\t\tvar times = this.times;\r\n\t\r\n\t\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\ttimes[ i ] += timeOffset;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\r\n\t\tscale: function( timeScale ) {\r\n\t\r\n\t\t\tif( timeScale !== 1.0 ) {\r\n\t\r\n\t\t\t\tvar times = this.times;\r\n\t\r\n\t\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\ttimes[ i ] *= timeScale;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\r\n\t\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\r\n\t\ttrim: function( startTime, endTime ) {\r\n\t\r\n\t\t\tvar times = this.times,\r\n\t\t\t\tnKeys = times.length,\r\n\t\t\t\tfrom = 0,\r\n\t\t\t\tto = nKeys - 1;\r\n\t\r\n\t\t\twhile ( from !== nKeys && times[ from ] < startTime ) ++ from;\r\n\t\t\twhile ( to !== -1 && times[ to ] > endTime ) -- to;\r\n\t\r\n\t\t\t++ to; // inclusive -> exclusive bound\r\n\t\r\n\t\t\tif( from !== 0 || to !== nKeys ) {\r\n\t\r\n\t\t\t\t// empty tracks are forbidden, so keep at least one keyframe\r\n\t\t\t\tif ( from >= to ) to = Math.max( to , 1 ), from = to - 1;\r\n\t\r\n\t\t\t\tvar stride = this.getValueSize();\r\n\t\t\t\tthis.times = THREE.AnimationUtils.arraySlice( times, from, to );\r\n\t\t\t\tthis.values = THREE.AnimationUtils.\r\n\t\t\t\t\t\tarraySlice( this.values, from * stride, to * stride );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\r\n\t\tvalidate: function() {\r\n\t\r\n\t\t\tvar valid = true;\r\n\t\r\n\t\t\tvar valueSize = this.getValueSize();\r\n\t\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\r\n\t\r\n\t\t\t\tconsole.error( \"invalid value size in track\", this );\r\n\t\t\t\tvalid = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar times = this.times,\r\n\t\t\t\tvalues = this.values,\r\n\t\r\n\t\t\t\tnKeys = times.length;\r\n\t\r\n\t\t\tif( nKeys === 0 ) {\r\n\t\r\n\t\t\t\tconsole.error( \"track is empty\", this );\r\n\t\t\t\tvalid = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar prevTime = null;\r\n\t\r\n\t\t\tfor( var i = 0; i !== nKeys; i ++ ) {\r\n\t\r\n\t\t\t\tvar currTime = times[ i ];\r\n\t\r\n\t\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\r\n\t\r\n\t\t\t\t\tconsole.error( \"time is not a valid number\", this, i, currTime );\r\n\t\t\t\t\tvalid = false;\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif( prevTime !== null && prevTime > currTime ) {\r\n\t\r\n\t\t\t\t\tconsole.error( \"out of order keys\", this, i, currTime, prevTime );\r\n\t\t\t\t\tvalid = false;\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tprevTime = currTime;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( values !== undefined ) {\r\n\t\r\n\t\t\t\tif ( THREE.AnimationUtils.isTypedArray( values ) ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\t\tvar value = values[ i ];\r\n\t\r\n\t\t\t\t\t\tif ( isNaN( value ) ) {\r\n\t\r\n\t\t\t\t\t\t\tconsole.error( \"value is not a valid number\", this, i, value );\r\n\t\t\t\t\t\t\tvalid = false;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn valid;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// removes equivalent sequential keys as common in morph target sequences\r\n\t\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\r\n\t\toptimize: function() {\r\n\t\r\n\t\t\tvar times = this.times,\r\n\t\t\t\tvalues = this.values,\r\n\t\t\t\tstride = this.getValueSize(),\r\n\t\r\n\t\t\t\twriteIndex = 1;\r\n\t\r\n\t\t\tfor( var i = 1, n = times.length - 1; i <= n; ++ i ) {\r\n\t\r\n\t\t\t\tvar keep = false;\r\n\t\r\n\t\t\t\tvar time = times[ i ];\r\n\t\t\t\tvar timeNext = times[ i + 1 ];\r\n\t\r\n\t\t\t\t// remove adjacent keyframes scheduled at the same time\r\n\t\r\n\t\t\t\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\r\n\t\r\n\t\t\t\t\t// remove unnecessary keyframes same as their neighbors\r\n\t\t\t\t\tvar offset = i * stride,\r\n\t\t\t\t\t\toffsetP = offset - stride,\r\n\t\t\t\t\t\toffsetN = offset + stride;\r\n\t\r\n\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\r\n\t\r\n\t\t\t\t\t\tvar value = values[ offset + j ];\r\n\t\r\n\t\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\r\n\t\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\r\n\t\r\n\t\t\t\t\t\t\tkeep = true;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// in-place compaction\r\n\t\r\n\t\t\t\tif ( keep ) {\r\n\t\r\n\t\t\t\t\tif ( i !== writeIndex ) {\r\n\t\r\n\t\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\r\n\t\r\n\t\t\t\t\t\tvar readOffset = i * stride,\r\n\t\t\t\t\t\t\twriteOffset = writeIndex * stride;\r\n\t\r\n\t\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\r\n\t\r\n\t\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t++ writeIndex;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( writeIndex !== times.length ) {\r\n\t\r\n\t\t\t\tthis.times = THREE.AnimationUtils.arraySlice( times, 0, writeIndex );\r\n\t\t\t\tthis.values = THREE.AnimationUtils.arraySlice( values, 0, writeIndex * stride );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// Static methods:\r\n\t\r\n\tObject.assign( THREE.KeyframeTrack, {\r\n\t\r\n\t\t// Serialization (in static context, because of constructor invocation\r\n\t\t// and automatic invocation of .toJSON):\r\n\t\r\n\t\tparse: function( json ) {\r\n\t\r\n\t\t\tif( json.type === undefined ) {\r\n\t\r\n\t\t\t\tthrow new Error( \"track type undefined, can not parse\" );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar trackType = THREE.KeyframeTrack._getTrackTypeForValueTypeName( json.type );\r\n\t\r\n\t\t\tif ( json.times === undefined ) {\r\n\t\r\n\t\t\t\tvar times = [], values = [];\r\n\t\r\n\t\t\t\tTHREE.AnimationUtils.flattenJSON( json.keys, times, values, 'value' );\r\n\t\r\n\t\t\t\tjson.times = times;\r\n\t\t\t\tjson.values = values;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// derived classes can define a static parse method\r\n\t\t\tif ( trackType.parse !== undefined ) {\r\n\t\r\n\t\t\t\treturn trackType.parse( json );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// by default, we asssume a constructor compatible with the base\r\n\t\t\t\treturn new trackType(\r\n\t\t\t\t\t\tjson.name, json.times, json.values, json.interpolation );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoJSON: function( track ) {\r\n\t\r\n\t\t\tvar trackType = track.constructor;\r\n\t\r\n\t\t\tvar json;\r\n\t\r\n\t\t\t// derived classes can define a static toJSON method\r\n\t\t\tif ( trackType.toJSON !== undefined ) {\r\n\t\r\n\t\t\t\tjson = trackType.toJSON( track );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// by default, we assume the data can be serialized as-is\r\n\t\t\t\tjson = {\r\n\t\r\n\t\t\t\t\t'name': track.name,\r\n\t\t\t\t\t'times': THREE.AnimationUtils.convertArray( track.times, Array ),\r\n\t\t\t\t\t'values': THREE.AnimationUtils.convertArray( track.values, Array )\r\n\t\r\n\t\t\t\t};\r\n\t\r\n\t\t\t\tvar interpolation = track.getInterpolation();\r\n\t\r\n\t\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\r\n\t\r\n\t\t\t\t\tjson.interpolation = interpolation;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tjson.type = track.ValueTypeName; // mandatory\r\n\t\r\n\t\t\treturn json;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_getTrackTypeForValueTypeName: function( typeName ) {\r\n\t\r\n\t\t\tswitch( typeName.toLowerCase() ) {\r\n\t\r\n\t\t\t\tcase \"scalar\":\r\n\t\t\t\tcase \"double\":\r\n\t\t\t\tcase \"float\":\r\n\t\t\t\tcase \"number\":\r\n\t\t\t\tcase \"integer\":\r\n\t\r\n\t\t\t\t\treturn THREE.NumberKeyframeTrack;\r\n\t\r\n\t\t\t\tcase \"vector\":\r\n\t\t\t\tcase \"vector2\":\r\n\t\t\t\tcase \"vector3\":\r\n\t\t\t\tcase \"vector4\":\r\n\t\r\n\t\t\t\t\treturn THREE.VectorKeyframeTrack;\r\n\t\r\n\t\t\t\tcase \"color\":\r\n\t\r\n\t\t\t\t\treturn THREE.ColorKeyframeTrack;\r\n\t\r\n\t\t\t\tcase \"quaternion\":\r\n\t\r\n\t\t\t\t\treturn THREE.QuaternionKeyframeTrack;\r\n\t\r\n\t\t\t\tcase \"bool\":\r\n\t\t\t\tcase \"boolean\":\r\n\t\r\n\t\t\t\t\treturn THREE.BooleanKeyframeTrack;\r\n\t\r\n\t\t\t\tcase \"string\":\r\n\t\r\n\t\t\t\t\treturn THREE.StringKeyframeTrack;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthrow new Error( \"Unsupported typeName: \" + typeName );\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/animation/PropertyBinding.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * A reference to a real property in the scene graph.\r\n\t *\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.PropertyBinding = function ( rootNode, path, parsedPath ) {\r\n\t\r\n\t\tthis.path = path;\r\n\t\tthis.parsedPath = parsedPath ||\r\n\t\t\t\tTHREE.PropertyBinding.parseTrackName( path );\r\n\t\r\n\t\tthis.node = THREE.PropertyBinding.findNode(\r\n\t\t\t\trootNode, this.parsedPath.nodeName ) || rootNode;\r\n\t\r\n\t\tthis.rootNode = rootNode;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PropertyBinding.prototype = {\r\n\t\r\n\t\tconstructor: THREE.PropertyBinding,\r\n\t\r\n\t\tgetValue: function getValue_unbound( targetArray, offset ) {\r\n\t\r\n\t\t\tthis.bind();\r\n\t\t\tthis.getValue( targetArray, offset );\r\n\t\r\n\t\t\t// Note: This class uses a State pattern on a per-method basis:\r\n\t\t\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\r\n\t\t\t// prototype version of these methods with one that represents\r\n\t\t\t// the bound state. When the property is not found, the methods\r\n\t\t\t// become no-ops.\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetValue: function getValue_unbound( sourceArray, offset ) {\r\n\t\r\n\t\t\tthis.bind();\r\n\t\t\tthis.setValue( sourceArray, offset );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// create getter / setter pair for a property in the scene graph\r\n\t\tbind: function() {\r\n\t\r\n\t\t\tvar targetObject = this.node,\r\n\t\t\t\tparsedPath = this.parsedPath,\r\n\t\r\n\t\t\t\tobjectName = parsedPath.objectName,\r\n\t\t\t\tpropertyName = parsedPath.propertyName,\r\n\t\t\t\tpropertyIndex = parsedPath.propertyIndex;\r\n\t\r\n\t\t\tif ( ! targetObject ) {\r\n\t\r\n\t\t\t\ttargetObject = THREE.PropertyBinding.findNode(\r\n\t\t\t\t\t\tthis.rootNode, parsedPath.nodeName ) || this.rootNode;\r\n\t\r\n\t\t\t\tthis.node = targetObject;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// set fail state so we can just 'return' on error\r\n\t\t\tthis.getValue = this._getValue_unavailable;\r\n\t\t\tthis.setValue = this._setValue_unavailable;\r\n\t\r\n\t \t\t// ensure there is a value node\r\n\t\t\tif ( ! targetObject ) {\r\n\t\r\n\t\t\t\tconsole.error( \"  trying to update node for track: \" + this.path + \" but it wasn't found.\" );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif( objectName ) {\r\n\t\r\n\t\t\t\tvar objectIndex = parsedPath.objectIndex;\r\n\t\r\n\t\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\r\n\t\t\t\tswitch ( objectName ) {\r\n\t\r\n\t\t\t\t\tcase 'materials':\r\n\t\r\n\t\t\t\t\t\tif( ! targetObject.material ) {\r\n\t\r\n\t\t\t\t\t\t\tconsole.error( '  can not bind to material as node does not have a material', this );\r\n\t\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif( ! targetObject.material.materials ) {\r\n\t\r\n\t\t\t\t\t\t\tconsole.error( '  can not bind to material.materials as node.material does not have a materials array', this );\r\n\t\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\ttargetObject = targetObject.material.materials;\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'bones':\r\n\t\r\n\t\t\t\t\t\tif( ! targetObject.skeleton ) {\r\n\t\r\n\t\t\t\t\t\t\tconsole.error( '  can not bind to bones as node does not have a skeleton', this );\r\n\t\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\r\n\t\t\t\t\t\t// and convert the integer string to a true integer.\r\n\t\r\n\t\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\r\n\t\r\n\t\t\t\t\t\t// support resolving morphTarget names into indices.\r\n\t\t\t\t\t\tfor ( var i = 0; i < targetObject.length; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( targetObject[i].name === objectIndex ) {\r\n\t\r\n\t\t\t\t\t\t\t\tobjectIndex = i;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tdefault:\r\n\t\r\n\t\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tconsole.error( '  can not bind to objectName of node, undefined', this );\r\n\t\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\ttargetObject = targetObject[ objectName ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\tif ( objectIndex !== undefined ) {\r\n\t\r\n\t\t\t\t\tif( targetObject[ objectIndex ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\tconsole.error( \"  trying to bind to objectIndex of objectName, but is undefined:\", this, targetObject );\r\n\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttargetObject = targetObject[ objectIndex ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// resolve property\r\n\t\t\tvar nodeProperty = targetObject[ propertyName ];\r\n\t\r\n\t\t\tif ( ! nodeProperty ) {\r\n\t\r\n\t\t\t\tvar nodeName = parsedPath.nodeName;\r\n\t\r\n\t\t\t\tconsole.error( \"  trying to update property for track: \" + nodeName +\r\n\t\t\t\t\t\t'.' + propertyName + \" but it wasn't found.\", targetObject );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// determine versioning scheme\r\n\t\t\tvar versioning = this.Versioning.None;\r\n\t\r\n\t\t\tif ( targetObject.needsUpdate !== undefined ) { // material\r\n\t\r\n\t\t\t\tversioning = this.Versioning.NeedsUpdate;\r\n\t\t\t\tthis.targetObject = targetObject;\r\n\t\r\n\t\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\r\n\t\r\n\t\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\r\n\t\t\t\tthis.targetObject = targetObject;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// determine how the property gets bound\r\n\t\t\tvar bindingType = this.BindingType.Direct;\r\n\t\r\n\t\t\tif ( propertyIndex !== undefined ) {\r\n\t\t\t\t// access a sub element of the property array (only primitives are supported right now)\r\n\t\r\n\t\t\t\tif ( propertyName === \"morphTargetInfluences\" ) {\r\n\t\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\r\n\t\r\n\t\t\t\t\t// support resolving morphTarget names into indices.\r\n\t\t\t\t\tif ( ! targetObject.geometry ) {\r\n\t\r\n\t\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );\r\n\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( ! targetObject.geometry.morphTargets ) {\r\n\t\r\n\t\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );\r\n\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tif ( targetObject.geometry.morphTargets[i].name === propertyIndex ) {\r\n\t\r\n\t\t\t\t\t\t\tpropertyIndex = i;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tbindingType = this.BindingType.ArrayElement;\r\n\t\r\n\t\t\t\tthis.resolvedProperty = nodeProperty;\r\n\t\t\t\tthis.propertyIndex = propertyIndex;\r\n\t\r\n\t\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\r\n\t\t\t\t// must use copy for Object3D.Euler/Quaternion\r\n\t\r\n\t\t\t\tbindingType = this.BindingType.HasFromToArray;\r\n\t\r\n\t\t\t\tthis.resolvedProperty = nodeProperty;\r\n\t\r\n\t\t\t} else if ( nodeProperty.length !== undefined ) {\r\n\t\r\n\t\t\t\tbindingType = this.BindingType.EntireArray;\r\n\t\r\n\t\t\t\tthis.resolvedProperty = nodeProperty;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.propertyName = propertyName;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// select getter / setter\r\n\t\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\r\n\t\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tunbind: function() {\r\n\t\r\n\t\t\tthis.node = null;\r\n\t\r\n\t\t\t// back to the prototype version of getValue / setValue\r\n\t\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\r\n\t\t\tthis.getValue = this._getValue_unbound;\r\n\t\t\tthis.setValue = this._setValue_unbound;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tObject.assign( THREE.PropertyBinding.prototype, { // prototype, continued\r\n\t\r\n\t\t// these are used to \"bind\" a nonexistent property\r\n\t\t_getValue_unavailable: function() {},\r\n\t\t_setValue_unavailable: function() {},\r\n\t\r\n\t\t// initial state of these methods that calls 'bind'\r\n\t\t_getValue_unbound: THREE.PropertyBinding.prototype.getValue,\r\n\t\t_setValue_unbound: THREE.PropertyBinding.prototype.setValue,\r\n\t\r\n\t\tBindingType: {\r\n\t\t\tDirect: 0,\r\n\t\t\tEntireArray: 1,\r\n\t\t\tArrayElement: 2,\r\n\t\t\tHasFromToArray: 3\r\n\t\t},\r\n\t\r\n\t\tVersioning: {\r\n\t\t\tNone: 0,\r\n\t\t\tNeedsUpdate: 1,\r\n\t\t\tMatrixWorldNeedsUpdate: 2\r\n\t\t},\r\n\t\r\n\t\tGetterByBindingType: [\r\n\t\r\n\t\t\tfunction getValue_direct( buffer, offset ) {\r\n\t\r\n\t\t\t\tbuffer[ offset ] = this.node[ this.propertyName ];\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tfunction getValue_array( buffer, offset ) {\r\n\t\r\n\t\t\t\tvar source = this.resolvedProperty;\r\n\t\r\n\t\t\t\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\tbuffer[ offset ++ ] = source[ i ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tfunction getValue_arrayElement( buffer, offset ) {\r\n\t\r\n\t\t\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tfunction getValue_toArray( buffer, offset ) {\r\n\t\r\n\t\t\t\tthis.resolvedProperty.toArray( buffer, offset );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t],\r\n\t\r\n\t\tSetterByBindingTypeAndVersioning: [\r\n\t\r\n\t\t\t[\r\n\t\t\t\t// Direct\r\n\t\r\n\t\t\t\tfunction setValue_direct( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\r\n\t\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\r\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\r\n\t\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\r\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t], [\r\n\t\r\n\t\t\t\t// EntireArray\r\n\t\r\n\t\t\t\tfunction setValue_array( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tvar dest = this.resolvedProperty;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tvar dest = this.resolvedProperty;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\r\n\t\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tvar dest = this.resolvedProperty;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t], [\r\n\t\r\n\t\t\t\t// ArrayElement\r\n\t\r\n\t\t\t\tfunction setValue_arrayElement( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\r\n\t\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\r\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\r\n\t\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\r\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t], [\r\n\t\r\n\t\t\t\t// HasToFromArray\r\n\t\r\n\t\t\t\tfunction setValue_fromArray( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\r\n\t\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\r\n\t\t\t\t\tthis.targetObject.needsUpdate = true;\r\n\t\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\t\r\n\t\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\r\n\t\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t]\r\n\t\r\n\t\t]\r\n\t\r\n\t} );\r\n\t\r\n\tTHREE.PropertyBinding.Composite =\r\n\t\t\tfunction( targetGroup, path, optionalParsedPath ) {\r\n\t\r\n\t\tvar parsedPath = optionalParsedPath ||\r\n\t\t\t\tTHREE.PropertyBinding.parseTrackName( path );\r\n\t\r\n\t\tthis._targetGroup = targetGroup;\r\n\t\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PropertyBinding.Composite.prototype = {\r\n\t\r\n\t\tconstructor: THREE.PropertyBinding.Composite,\r\n\t\r\n\t\tgetValue: function( array, offset ) {\r\n\t\r\n\t\t\tthis.bind(); // bind all binding\r\n\t\r\n\t\t\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\r\n\t\t\t\tbinding = this._bindings[ firstValidIndex ];\r\n\t\r\n\t\t\t// and only call .getValue on the first\r\n\t\t\tif ( binding !== undefined ) binding.getValue( array, offset );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetValue: function( array, offset ) {\r\n\t\r\n\t\t\tvar bindings = this._bindings;\r\n\t\r\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\r\n\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tbindings[ i ].setValue( array, offset );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tbind: function() {\r\n\t\r\n\t\t\tvar bindings = this._bindings;\r\n\t\r\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\r\n\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tbindings[ i ].bind();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tunbind: function() {\r\n\t\r\n\t\t\tvar bindings = this._bindings;\r\n\t\r\n\t\t\tfor ( var i = this._targetGroup.nCachedObjects_,\r\n\t\t\t\t\tn = bindings.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tbindings[ i ].unbind();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PropertyBinding.create = function( root, path, parsedPath ) {\r\n\t\r\n\t\tif ( ! ( root instanceof THREE.AnimationObjectGroup ) ) {\r\n\t\r\n\t\t\treturn new THREE.PropertyBinding( root, path, parsedPath );\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\treturn new THREE.PropertyBinding.Composite( root, path, parsedPath );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PropertyBinding.parseTrackName = function( trackName ) {\r\n\t\r\n\t\t// matches strings in the form of:\r\n\t\t//    nodeName.property\r\n\t\t//    nodeName.property[accessor]\r\n\t\t//    nodeName.material.property[accessor]\r\n\t\t//    uuid.property[accessor]\r\n\t\t//    uuid.objectName[objectIndex].propertyName[propertyIndex]\r\n\t\t//    parentName/nodeName.property\r\n\t\t//    parentName/parentName/nodeName.property[index]\r\n\t\t//\t  .bone[Armature.DEF_cog].position\r\n\t\t// created and tested via https://regex101.com/#javascript\r\n\t\r\n\t\tvar re = /^(([\\w]+\\/)*)([\\w-\\d]+)?(\\.([\\w]+)(\\[([\\w\\d\\[\\]\\_.:\\- ]+)\\])?)?(\\.([\\w.]+)(\\[([\\w\\d\\[\\]\\_. ]+)\\])?)$/;\r\n\t\tvar matches = re.exec(trackName);\r\n\t\r\n\t\tif( ! matches ) {\r\n\t\t\tthrow new Error( \"cannot parse trackName at all: \" + trackName );\r\n\t\t}\r\n\t\r\n\t    if (matches.index === re.lastIndex) {\r\n\t        re.lastIndex++;\r\n\t    }\r\n\t\r\n\t\tvar results = {\r\n\t\t\t// directoryName: matches[1], // (tschw) currently unused\r\n\t\t\tnodeName: matches[3], \t// allowed to be null, specified root node.\r\n\t\t\tobjectName: matches[5],\r\n\t\t\tobjectIndex: matches[7],\r\n\t\t\tpropertyName: matches[9],\r\n\t\t\tpropertyIndex: matches[11]\t// allowed to be null, specifies that the whole property is set.\r\n\t\t};\r\n\t\r\n\t\tif( results.propertyName === null || results.propertyName.length === 0 ) {\r\n\t\t\tthrow new Error( \"can not parse propertyName from trackName: \" + trackName );\r\n\t\t}\r\n\t\r\n\t\treturn results;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PropertyBinding.findNode = function( root, nodeName ) {\r\n\t\r\n\t\tif( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {\r\n\t\r\n\t\t\treturn root;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// search into skeleton bones.\r\n\t\tif( root.skeleton ) {\r\n\t\r\n\t\t\tvar searchSkeleton = function( skeleton ) {\r\n\t\r\n\t\t\t\tfor( var i = 0; i < skeleton.bones.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar bone = skeleton.bones[i];\r\n\t\r\n\t\t\t\t\tif( bone.name === nodeName ) {\r\n\t\r\n\t\t\t\t\t\treturn bone;\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn null;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tvar bone = searchSkeleton( root.skeleton );\r\n\t\r\n\t\t\tif( bone ) {\r\n\t\r\n\t\t\t\treturn bone;\r\n\t\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\t// search into node subtree.\r\n\t\tif( root.children ) {\r\n\t\r\n\t\t\tvar searchNodeSubtree = function( children ) {\r\n\t\r\n\t\t\t\tfor( var i = 0; i < children.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar childNode = children[i];\r\n\t\r\n\t\t\t\t\tif( childNode.name === nodeName || childNode.uuid === nodeName ) {\r\n\t\r\n\t\t\t\t\t\treturn childNode;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar result = searchNodeSubtree( childNode.children );\r\n\t\r\n\t\t\t\t\tif( result ) return result;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn null;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tvar subTreeNode = searchNodeSubtree( root.children );\r\n\t\r\n\t\t\tif( subTreeNode ) {\r\n\t\r\n\t\t\t\treturn subTreeNode;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn null;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/animation/PropertyMixer.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * Buffered scene graph property that allows weighted accumulation.\r\n\t *\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.PropertyMixer = function ( binding, typeName, valueSize ) {\r\n\t\r\n\t\tthis.binding = binding;\r\n\t\tthis.valueSize = valueSize;\r\n\t\r\n\t\tvar bufferType = Float64Array,\r\n\t\t\tmixFunction;\r\n\t\r\n\t\tswitch ( typeName ) {\r\n\t\r\n\t\t\tcase 'quaternion':\t\t\tmixFunction = this._slerp;\t\tbreak;\r\n\t\r\n\t\t\tcase 'string':\r\n\t\t\tcase 'bool':\r\n\t\r\n\t\t\t\tbufferType = Array,\t\tmixFunction = this._select;\t\tbreak;\r\n\t\r\n\t\t\tdefault:\t\t\t\t\tmixFunction = this._lerp;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.buffer = new bufferType( valueSize * 4 );\r\n\t\t// layout: [ incoming | accu0 | accu1 | orig ]\r\n\t\t//\r\n\t\t// interpolators can use .buffer as their .result\r\n\t\t// the data then goes to 'incoming'\r\n\t\t//\r\n\t\t// 'accu0' and 'accu1' are used frame-interleaved for\r\n\t\t// the cumulative result and are compared to detect\r\n\t\t// changes\r\n\t\t//\r\n\t\t// 'orig' stores the original state of the property\r\n\t\r\n\t\tthis._mixBufferRegion = mixFunction;\r\n\t\r\n\t\tthis.cumulativeWeight = 0;\r\n\t\r\n\t\tthis.useCount = 0;\r\n\t\tthis.referenceCount = 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PropertyMixer.prototype = {\r\n\t\r\n\t\tconstructor: THREE.PropertyMixer,\r\n\t\r\n\t\t// accumulate data in the 'incoming' region into 'accu<i>'\r\n\t\taccumulate: function( accuIndex, weight ) {\r\n\t\r\n\t\t\t// note: happily accumulating nothing when weight = 0, the caller knows\r\n\t\t\t// the weight and shouldn't have made the call in the first place\r\n\t\r\n\t\t\tvar buffer = this.buffer,\r\n\t\t\t\tstride = this.valueSize,\r\n\t\t\t\toffset = accuIndex * stride + stride,\r\n\t\r\n\t\t\t\tcurrentWeight = this.cumulativeWeight;\r\n\t\r\n\t\t\tif ( currentWeight === 0 ) {\r\n\t\r\n\t\t\t\t// accuN := incoming * weight\r\n\t\r\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\t\r\n\t\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tcurrentWeight = weight;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// accuN := accuN + incoming * weight\r\n\t\r\n\t\t\t\tcurrentWeight += weight;\r\n\t\t\t\tvar mix = weight / currentWeight;\r\n\t\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.cumulativeWeight = currentWeight;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// apply the state of 'accu<i>' to the binding when accus differ\r\n\t\tapply: function( accuIndex ) {\r\n\t\r\n\t\t\tvar stride = this.valueSize,\r\n\t\t\t\tbuffer = this.buffer,\r\n\t\t\t\toffset = accuIndex * stride + stride,\r\n\t\r\n\t\t\t\tweight = this.cumulativeWeight,\r\n\t\r\n\t\t\t\tbinding = this.binding;\r\n\t\r\n\t\t\tthis.cumulativeWeight = 0;\r\n\t\r\n\t\t\tif ( weight < 1 ) {\r\n\t\r\n\t\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\r\n\t\r\n\t\t\t\tvar originalValueOffset = stride * 3;\r\n\t\r\n\t\t\t\tthis._mixBufferRegion(\r\n\t\t\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\r\n\t\r\n\t\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\r\n\t\r\n\t\t\t\t\t// value has changed -> update scene graph\r\n\t\r\n\t\t\t\t\tbinding.setValue( buffer, offset );\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// remember the state of the bound property and copy it to both accus\r\n\t\tsaveOriginalState: function() {\r\n\t\r\n\t\t\tvar binding = this.binding;\r\n\t\r\n\t\t\tvar buffer = this.buffer,\r\n\t\t\t\tstride = this.valueSize,\r\n\t\r\n\t\t\t\toriginalValueOffset = stride * 3;\r\n\t\r\n\t\t\tbinding.getValue( buffer, originalValueOffset );\r\n\t\r\n\t\t\t// accu[0..1] := orig -- initially detect changes against the original\r\n\t\t\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\r\n\t\r\n\t\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.cumulativeWeight = 0;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// apply the state previously taken via 'saveOriginalState' to the binding\r\n\t\trestoreOriginalState: function() {\r\n\t\r\n\t\t\tvar originalValueOffset = this.valueSize * 3;\r\n\t\t\tthis.binding.setValue( this.buffer, originalValueOffset );\r\n\t\r\n\t\t},\r\n\t\r\n\t\r\n\t\t// mix functions\r\n\t\r\n\t\t_select: function( buffer, dstOffset, srcOffset, t, stride ) {\r\n\t\r\n\t\t\tif ( t >= 0.5 ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\t\r\n\t\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {\r\n\t\r\n\t\t\tTHREE.Quaternion.slerpFlat( buffer, dstOffset,\r\n\t\t\t\t\tbuffer, dstOffset, buffer, srcOffset, t );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {\r\n\t\r\n\t\t\tvar s = 1 - t;\r\n\t\r\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\t\r\n\t\t\t\tvar j = dstOffset + i;\r\n\t\r\n\t\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/animation/tracks/BooleanKeyframeTrack.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * A Track of Boolean keyframe values.\r\n\t *\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.BooleanKeyframeTrack = function ( name, times, values ) {\r\n\t\r\n\t\tTHREE.KeyframeTrack.call( this, name, times, values );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BooleanKeyframeTrack.prototype =\r\n\t\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.BooleanKeyframeTrack,\r\n\t\r\n\t\tValueTypeName: 'bool',\r\n\t\tValueBufferType: Array,\r\n\t\r\n\t\tDefaultInterpolation: THREE.InterpolateDiscrete,\r\n\t\r\n\t\tInterpolantFactoryMethodLinear: undefined,\r\n\t\tInterpolantFactoryMethodSmooth: undefined\r\n\t\r\n\t\t// Note: Actually this track could have a optimized / compressed\r\n\t\t// representation of a single value and a custom interpolant that\r\n\t\t// computes \"firstValue ^ isOdd( index )\".\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/animation/tracks/ColorKeyframeTrack.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * A Track of keyframe values that represent color.\r\n\t *\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.ColorKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\t\r\n\t\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ColorKeyframeTrack.prototype =\r\n\t\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.ColorKeyframeTrack,\r\n\t\r\n\t\tValueTypeName: 'color'\r\n\t\r\n\t\t// ValueBufferType is inherited\r\n\t\r\n\t\t// DefaultInterpolation is inherited\r\n\t\r\n\t\r\n\t\t// Note: Very basic implementation and nothing special yet.\r\n\t\t// However, this is the place for color space parameterization.\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/animation/tracks/NumberKeyframeTrack.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * A Track of numeric keyframe values.\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.NumberKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\t\r\n\t\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.NumberKeyframeTrack.prototype =\r\n\t\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.NumberKeyframeTrack,\r\n\t\r\n\t\tValueTypeName: 'number',\r\n\t\r\n\t\t// ValueBufferType is inherited\r\n\t\r\n\t\t// DefaultInterpolation is inherited\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/animation/tracks/QuaternionKeyframeTrack.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * A Track of quaternion keyframe values.\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.QuaternionKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\t\r\n\t\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.QuaternionKeyframeTrack.prototype =\r\n\t\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.QuaternionKeyframeTrack,\r\n\t\r\n\t\tValueTypeName: 'quaternion',\r\n\t\r\n\t\t// ValueBufferType is inherited\r\n\t\r\n\t\tDefaultInterpolation: THREE.InterpolateLinear,\r\n\t\r\n\t\tInterpolantFactoryMethodLinear: function( result ) {\r\n\t\r\n\t\t\treturn new THREE.QuaternionLinearInterpolant(\r\n\t\t\t\t\tthis.times, this.values, this.getValueSize(), result );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/animation/tracks/StringKeyframeTrack.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * A Track that interpolates Strings\r\n\t *\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.StringKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\t\r\n\t\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.StringKeyframeTrack.prototype =\r\n\t\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.StringKeyframeTrack,\r\n\t\r\n\t\tValueTypeName: 'string',\r\n\t\tValueBufferType: Array,\r\n\t\r\n\t\tDefaultInterpolation: THREE.InterpolateDiscrete,\r\n\t\r\n\t\tInterpolantFactoryMethodLinear: undefined,\r\n\t\r\n\t\tInterpolantFactoryMethodSmooth: undefined\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/animation/tracks/VectorKeyframeTrack.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * A Track of vectored keyframe values.\r\n\t *\r\n\t *\r\n\t * @author Ben Houston / http://clara.io/\r\n\t * @author David Sarno / http://lighthaus.us/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.VectorKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\t\r\n\t\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.VectorKeyframeTrack.prototype =\r\n\t\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.VectorKeyframeTrack,\r\n\t\r\n\t\tValueTypeName: 'vector'\r\n\t\r\n\t\t// ValueBufferType is inherited\r\n\t\r\n\t\t// DefaultInterpolation is inherited\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/audio/Audio.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\r\n\t */\r\n\t\r\n\tTHREE.Audio = function ( listener ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Audio';\r\n\t\r\n\t\tthis.context = listener.context;\r\n\t\tthis.source = this.context.createBufferSource();\r\n\t\tthis.source.onended = this.onEnded.bind( this );\r\n\t\r\n\t\tthis.gain = this.context.createGain();\r\n\t\tthis.gain.connect( listener.getInput() );\r\n\t\r\n\t\tthis.autoplay = false;\r\n\t\r\n\t\tthis.startTime = 0;\r\n\t\tthis.playbackRate = 1;\r\n\t\tthis.isPlaying = false;\r\n\t\tthis.hasPlaybackControl = true;\r\n\t\tthis.sourceType = 'empty';\r\n\t\r\n\t\tthis.filters = [];\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Audio.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.Audio,\r\n\t\r\n\t\tgetOutput: function () {\r\n\t\r\n\t\t\treturn this.gain;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetNodeSource: function ( audioNode ) {\r\n\t\r\n\t\t\tthis.hasPlaybackControl = false;\r\n\t\t\tthis.sourceType = 'audioNode';\r\n\t\t\tthis.source = audioNode;\r\n\t\t\tthis.connect();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetBuffer: function ( audioBuffer ) {\r\n\t\r\n\t\t\tthis.source.buffer = audioBuffer;\r\n\t\t\tthis.sourceType = 'buffer';\r\n\t\r\n\t\t\tif ( this.autoplay ) this.play();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tplay: function () {\r\n\t\r\n\t\t\tif ( this.isPlaying === true ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.hasPlaybackControl === false ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar source = this.context.createBufferSource();\r\n\t\r\n\t\t\tsource.buffer = this.source.buffer;\r\n\t\t\tsource.loop = this.source.loop;\r\n\t\t\tsource.onended = this.source.onended;\r\n\t\t\tsource.start( 0, this.startTime );\r\n\t\t\tsource.playbackRate.value = this.playbackRate;\r\n\t\r\n\t\t\tthis.isPlaying = true;\r\n\t\r\n\t\t\tthis.source = source;\r\n\t\r\n\t\t\treturn this.connect();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tpause: function () {\r\n\t\r\n\t\t\tif ( this.hasPlaybackControl === false ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.source.stop();\r\n\t\t\tthis.startTime = this.context.currentTime;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tstop: function () {\r\n\t\r\n\t\t\tif ( this.hasPlaybackControl === false ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.source.stop();\r\n\t\t\tthis.startTime = 0;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tconnect: function () {\r\n\t\r\n\t\t\tif ( this.filters.length > 0 ) {\r\n\t\r\n\t\t\t\tthis.source.connect( this.filters[ 0 ] );\r\n\t\r\n\t\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.source.connect( this.getOutput() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdisconnect: function () {\r\n\t\r\n\t\t\tif ( this.filters.length > 0 ) {\r\n\t\r\n\t\t\t\tthis.source.disconnect( this.filters[ 0 ] );\r\n\t\r\n\t\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.source.disconnect( this.getOutput() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetFilters: function () {\r\n\t\r\n\t\t\treturn this.filters;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFilters: function ( value ) {\r\n\t\r\n\t\t\tif ( ! value ) value = [];\r\n\t\r\n\t\t\tif ( this.isPlaying === true ) {\r\n\t\r\n\t\t\t\tthis.disconnect();\r\n\t\t\t\tthis.filters = value;\r\n\t\t\t\tthis.connect();\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.filters = value;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetFilter: function () {\r\n\t\r\n\t\t\treturn this.getFilters()[ 0 ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFilter: function ( filter ) {\r\n\t\r\n\t\t\treturn this.setFilters( filter ? [ filter ] : [] );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetPlaybackRate: function ( value ) {\r\n\t\r\n\t\t\tif ( this.hasPlaybackControl === false ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.playbackRate = value;\r\n\t\r\n\t\t\tif ( this.isPlaying === true ) {\r\n\t\r\n\t\t\t\tthis.source.playbackRate.value = this.playbackRate;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetPlaybackRate: function () {\r\n\t\r\n\t\t\treturn this.playbackRate;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tonEnded: function () {\r\n\t\r\n\t\t\tthis.isPlaying = false;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetLoop: function () {\r\n\t\r\n\t\t\tif ( this.hasPlaybackControl === false ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\t\t\treturn false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this.source.loop;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetLoop: function ( value ) {\r\n\t\r\n\t\t\tif ( this.hasPlaybackControl === false ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.source.loop = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetVolume: function () {\r\n\t\r\n\t\t\treturn this.gain.gain.value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\r\n\t\tsetVolume: function ( value ) {\r\n\t\r\n\t\t\tthis.gain.gain.value = value;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/audio/AudioAnalyser.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.AudioAnalyser = function ( audio, fftSize ) {\r\n\t\r\n\t\tthis.analyser = audio.context.createAnalyser();\r\n\t\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\r\n\t\r\n\t\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\r\n\t\r\n\t\taudio.getOutput().connect( this.analyser );\r\n\t\r\n\t};\r\n\t\r\n\tObject.assign( THREE.AudioAnalyser.prototype, {\r\n\t\r\n\t\tgetFrequencyData: function () {\r\n\t\r\n\t\t\tthis.analyser.getByteFrequencyData( this.data );\r\n\t\r\n\t\t\treturn this.data;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetAverageFrequency: function () {\r\n\t\r\n\t\t\tvar value = 0, data = this.getFrequencyData();\r\n\t\r\n\t\t\tfor ( var i = 0; i < data.length; i ++ ) {\r\n\t\r\n\t\t\t\tvalue += data[ i ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn value / data.length;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/audio/AudioContext.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tObject.defineProperty( THREE, 'AudioContext', {\r\n\t\r\n\t\tget: ( function () {\r\n\t\r\n\t\t\tvar context;\r\n\t\r\n\t\t\treturn function () {\r\n\t\r\n\t\t\t\tif ( context === undefined ) {\r\n\t\r\n\t\t\t\t\tcontext = new ( window.AudioContext || window.webkitAudioContext )();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn context;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )()\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/audio/PositionalAudio.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.PositionalAudio = function ( listener ) {\r\n\t\r\n\t\tTHREE.Audio.call( this, listener );\r\n\t\r\n\t\tthis.panner = this.context.createPanner();\r\n\t\tthis.panner.connect( this.gain );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PositionalAudio.prototype = Object.assign( Object.create( THREE.Audio.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.PositionalAudio,\r\n\t\r\n\t\tgetOutput: function () {\r\n\t\r\n\t\t\treturn this.panner;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetRefDistance: function () {\r\n\t\r\n\t\t\treturn this.panner.refDistance;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetRefDistance: function ( value ) {\r\n\t\r\n\t\t\tthis.panner.refDistance = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetRolloffFactor: function () {\r\n\t\r\n\t\t\treturn this.panner.rolloffFactor;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetRolloffFactor: function ( value ) {\r\n\t\r\n\t\t\tthis.panner.rolloffFactor = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetDistanceModel: function () {\r\n\t\r\n\t\t\treturn this.panner.distanceModel;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetDistanceModel: function ( value ) {\r\n\t\r\n\t\t\tthis.panner.distanceModel = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetMaxDistance: function () {\r\n\t\r\n\t\t\treturn this.panner.maxDistance;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetMaxDistance: function ( value ) {\r\n\t\r\n\t\t\tthis.panner.maxDistance = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdateMatrixWorld: ( function () {\r\n\t\r\n\t\t\tvar position = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function updateMatrixWorld( force ) {\r\n\t\r\n\t\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\r\n\t\r\n\t\t\t\tposition.setFromMatrixPosition( this.matrixWorld );\r\n\t\r\n\t\t\t\tthis.panner.setPosition( position.x, position.y, position.z );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )()\r\n\t\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/audio/AudioListener.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.AudioListener = function () {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'AudioListener';\r\n\t\r\n\t\tthis.context = THREE.AudioContext;\r\n\t\r\n\t\tthis.gain = this.context.createGain();\r\n\t\tthis.gain.connect( this.context.destination );\r\n\t\r\n\t\tthis.filter = null;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AudioListener.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.AudioListener,\r\n\t\r\n\t\tgetInput: function () {\r\n\t\r\n\t\t\treturn this.gain;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tremoveFilter: function ( ) {\r\n\t\r\n\t\t\tif ( this.filter !== null ) {\r\n\t\r\n\t\t\t\tthis.gain.disconnect( this.filter );\r\n\t\t\t\tthis.filter.disconnect( this.context.destination );\r\n\t\t\t\tthis.gain.connect( this.context.destination );\r\n\t\t\t\tthis.filter = null;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetFilter: function () {\r\n\t\r\n\t\t\treturn this.filter;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetFilter: function ( value ) {\r\n\t\r\n\t\t\tif ( this.filter !== null ) {\r\n\t\r\n\t\t\t\tthis.gain.disconnect( this.filter );\r\n\t\t\t\tthis.filter.disconnect( this.context.destination );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.gain.disconnect( this.context.destination );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.filter = value;\r\n\t\t\tthis.gain.connect( this.filter );\r\n\t\t\tthis.filter.connect( this.context.destination );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetMasterVolume: function () {\r\n\t\r\n\t\t\treturn this.gain.gain.value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetMasterVolume: function ( value ) {\r\n\t\r\n\t\t\tthis.gain.gain.value = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdateMatrixWorld: ( function () {\r\n\t\r\n\t\t\tvar position = new THREE.Vector3();\r\n\t\t\tvar quaternion = new THREE.Quaternion();\r\n\t\t\tvar scale = new THREE.Vector3();\r\n\t\r\n\t\t\tvar orientation = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function updateMatrixWorld( force ) {\r\n\t\r\n\t\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\r\n\t\r\n\t\t\t\tvar listener = this.context.listener;\r\n\t\t\t\tvar up = this.up;\r\n\t\r\n\t\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\r\n\t\r\n\t\t\t\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\r\n\t\r\n\t\t\t\tlistener.setPosition( position.x, position.y, position.z );\r\n\t\t\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )()\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/cameras/Camera.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t*/\r\n\t\r\n\tTHREE.Camera = function () {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Camera';\r\n\t\r\n\t\tthis.matrixWorldInverse = new THREE.Matrix4();\r\n\t\tthis.projectionMatrix = new THREE.Matrix4();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Camera.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Camera.prototype.constructor = THREE.Camera;\r\n\t\r\n\tTHREE.Camera.prototype.getWorldDirection = function () {\r\n\t\r\n\t\tvar quaternion = new THREE.Quaternion();\r\n\t\r\n\t\treturn function ( optionalTarget ) {\r\n\t\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\r\n\t\t\tthis.getWorldQuaternion( quaternion );\r\n\t\r\n\t\t\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\tTHREE.Camera.prototype.lookAt = function () {\r\n\t\r\n\t\t// This routine does not support cameras with rotated and/or translated parent(s)\r\n\t\r\n\t\tvar m1 = new THREE.Matrix4();\r\n\t\r\n\t\treturn function ( vector ) {\r\n\t\r\n\t\t\tm1.lookAt( this.position, vector, this.up );\r\n\t\r\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\tTHREE.Camera.prototype.clone = function () {\r\n\t\r\n\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Camera.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\r\n\t\tthis.projectionMatrix.copy( source.projectionMatrix );\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/cameras/CubeCamera.js\r\n\t\r\n\t/**\r\n\t * Camera for rendering cube maps\r\n\t *\t- renders scene into axis-aligned cube\r\n\t *\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.CubeCamera = function ( near, far, cubeResolution ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'CubeCamera';\r\n\t\r\n\t\tvar fov = 90, aspect = 1;\r\n\t\r\n\t\tvar cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\t\tcameraPX.up.set( 0, - 1, 0 );\r\n\t\tcameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );\r\n\t\tthis.add( cameraPX );\r\n\t\r\n\t\tvar cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\t\tcameraNX.up.set( 0, - 1, 0 );\r\n\t\tcameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );\r\n\t\tthis.add( cameraNX );\r\n\t\r\n\t\tvar cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\t\tcameraPY.up.set( 0, 0, 1 );\r\n\t\tcameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );\r\n\t\tthis.add( cameraPY );\r\n\t\r\n\t\tvar cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\t\tcameraNY.up.set( 0, 0, - 1 );\r\n\t\tcameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );\r\n\t\tthis.add( cameraNY );\r\n\t\r\n\t\tvar cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\t\tcameraPZ.up.set( 0, - 1, 0 );\r\n\t\tcameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );\r\n\t\tthis.add( cameraPZ );\r\n\t\r\n\t\tvar cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\t\tcameraNZ.up.set( 0, - 1, 0 );\r\n\t\tcameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );\r\n\t\tthis.add( cameraNZ );\r\n\t\r\n\t\tvar options = { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter };\r\n\t\r\n\t\tthis.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\r\n\t\r\n\t\tthis.updateCubeMap = function ( renderer, scene ) {\r\n\t\r\n\t\t\tif ( this.parent === null ) this.updateMatrixWorld();\r\n\t\r\n\t\t\tvar renderTarget = this.renderTarget;\r\n\t\t\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\r\n\t\r\n\t\t\trenderTarget.texture.generateMipmaps = false;\r\n\t\r\n\t\t\trenderTarget.activeCubeFace = 0;\r\n\t\t\trenderer.render( scene, cameraPX, renderTarget );\r\n\t\r\n\t\t\trenderTarget.activeCubeFace = 1;\r\n\t\t\trenderer.render( scene, cameraNX, renderTarget );\r\n\t\r\n\t\t\trenderTarget.activeCubeFace = 2;\r\n\t\t\trenderer.render( scene, cameraPY, renderTarget );\r\n\t\r\n\t\t\trenderTarget.activeCubeFace = 3;\r\n\t\t\trenderer.render( scene, cameraNY, renderTarget );\r\n\t\r\n\t\t\trenderTarget.activeCubeFace = 4;\r\n\t\t\trenderer.render( scene, cameraPZ, renderTarget );\r\n\t\r\n\t\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\r\n\t\r\n\t\t\trenderTarget.activeCubeFace = 5;\r\n\t\t\trenderer.render( scene, cameraNZ, renderTarget );\r\n\t\r\n\t\t\trenderer.setRenderTarget( null );\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.CubeCamera.prototype.constructor = THREE.CubeCamera;\r\n\t\r\n\t// File:src/cameras/OrthographicCamera.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {\r\n\t\r\n\t\tTHREE.Camera.call( this );\r\n\t\r\n\t\tthis.type = 'OrthographicCamera';\r\n\t\r\n\t\tthis.zoom = 1;\r\n\t\r\n\t\tthis.left = left;\r\n\t\tthis.right = right;\r\n\t\tthis.top = top;\r\n\t\tthis.bottom = bottom;\r\n\t\r\n\t\tthis.near = ( near !== undefined ) ? near : 0.1;\r\n\t\tthis.far = ( far !== undefined ) ? far : 2000;\r\n\t\r\n\t\tthis.updateProjectionMatrix();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.OrthographicCamera.prototype = Object.assign( Object.create( THREE.Camera.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.OrthographicCamera,\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tTHREE.Camera.prototype.copy.call( this, source );\r\n\t\r\n\t\t\tthis.left = source.left;\r\n\t\t\tthis.right = source.right;\r\n\t\t\tthis.top = source.top;\r\n\t\t\tthis.bottom = source.bottom;\r\n\t\t\tthis.near = source.near;\r\n\t\t\tthis.far = source.far;\r\n\t\r\n\t\t\tthis.zoom = source.zoom;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdateProjectionMatrix: function () {\r\n\t\r\n\t\t\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\r\n\t\t\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\r\n\t\t\tvar cx = ( this.right + this.left ) / 2;\r\n\t\t\tvar cy = ( this.top + this.bottom ) / 2;\r\n\t\r\n\t\t\tthis.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoJSON: function ( meta ) {\r\n\t\r\n\t\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\t\r\n\t\t\tdata.object.zoom = this.zoom;\r\n\t\t\tdata.object.left = this.left;\r\n\t\t\tdata.object.right = this.right;\r\n\t\t\tdata.object.top = this.top;\r\n\t\t\tdata.object.bottom = this.bottom;\r\n\t\t\tdata.object.near = this.near;\r\n\t\t\tdata.object.far = this.far;\r\n\t\r\n\t\t\treturn data;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/cameras/PerspectiveCamera.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author greggman / http://games.greggman.com/\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.PerspectiveCamera = function( fov, aspect, near, far ) {\r\n\t\r\n\t\tTHREE.Camera.call( this );\r\n\t\r\n\t\tthis.type = 'PerspectiveCamera';\r\n\t\r\n\t\tthis.fov = fov !== undefined ? fov : 50;\r\n\t\tthis.zoom = 1;\r\n\t\r\n\t\tthis.near = near !== undefined ? near : 0.1;\r\n\t\tthis.far = far !== undefined ? far : 2000;\r\n\t\tthis.focus = 10;\r\n\t\r\n\t\tthis.aspect = aspect !== undefined ? aspect : 1;\r\n\t\tthis.view = null;\r\n\t\r\n\t\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\r\n\t\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\r\n\t\r\n\t\tthis.updateProjectionMatrix();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PerspectiveCamera.prototype = Object.assign( Object.create( THREE.Camera.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.PerspectiveCamera,\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tTHREE.Camera.prototype.copy.call( this, source );\r\n\t\r\n\t\t\tthis.fov = source.fov;\r\n\t\t\tthis.zoom = source.zoom;\r\n\t\r\n\t\t\tthis.near = source.near;\r\n\t\t\tthis.far = source.far;\r\n\t\t\tthis.focus = source.focus;\r\n\t\r\n\t\t\tthis.aspect = source.aspect;\r\n\t\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\r\n\t\r\n\t\t\tthis.filmGauge = source.filmGauge;\r\n\t\t\tthis.filmOffset = source.filmOffset;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t/**\r\n\t\t * Sets the FOV by focal length in respect to the current .filmGauge.\r\n\t\t *\r\n\t\t * The default film gauge is 35, so that the focal length can be specified for\r\n\t\t * a 35mm (full frame) camera.\r\n\t\t *\r\n\t\t * Values for focal length and film gauge must have the same unit.\r\n\t\t */\r\n\t\tsetFocalLength: function ( focalLength ) {\r\n\t\r\n\t\t\t// see http://www.bobatkins.com/photography/technical/field_of_view.html\r\n\t\t\tvar vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\r\n\t\r\n\t\t\tthis.fov = THREE.Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\r\n\t\t\tthis.updateProjectionMatrix();\r\n\t\r\n\t\t},\r\n\t\r\n\t\t/**\r\n\t\t * Calculates the focal length from the current .fov and .filmGauge.\r\n\t\t */\r\n\t\tgetFocalLength: function () {\r\n\t\r\n\t\t\tvar vExtentSlope = Math.tan( THREE.Math.DEG2RAD * 0.5 * this.fov );\r\n\t\r\n\t\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetEffectiveFOV: function () {\r\n\t\r\n\t\t\treturn THREE.Math.RAD2DEG * 2 * Math.atan(\r\n\t\t\t\t\tMath.tan( THREE.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetFilmWidth: function () {\r\n\t\r\n\t\t\t// film not completely covered in portrait format (aspect < 1)\r\n\t\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetFilmHeight: function () {\r\n\t\r\n\t\t\t// film not completely covered in landscape format (aspect > 1)\r\n\t\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t/**\r\n\t\t * Sets an offset in a larger frustum. This is useful for multi-window or\r\n\t\t * multi-monitor/multi-machine setups.\r\n\t\t *\r\n\t\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\r\n\t\t * the monitors are in grid like this\r\n\t\t *\r\n\t\t *   +---+---+---+\r\n\t\t *   | A | B | C |\r\n\t\t *   +---+---+---+\r\n\t\t *   | D | E | F |\r\n\t\t *   +---+---+---+\r\n\t\t *\r\n\t\t * then for each monitor you would call it like this\r\n\t\t *\r\n\t\t *   var w = 1920;\r\n\t\t *   var h = 1080;\r\n\t\t *   var fullWidth = w * 3;\r\n\t\t *   var fullHeight = h * 2;\r\n\t\t *\r\n\t\t *   --A--\r\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\r\n\t\t *   --B--\r\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\r\n\t\t *   --C--\r\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\r\n\t\t *   --D--\r\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\r\n\t\t *   --E--\r\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\r\n\t\t *   --F--\r\n\t\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\r\n\t\t *\r\n\t\t *   Note there is no reason monitors have to be the same size or in a grid.\r\n\t\t */\r\n\t\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\r\n\t\r\n\t\t\tthis.aspect = fullWidth / fullHeight;\r\n\t\r\n\t\t\tthis.view = {\r\n\t\t\t\tfullWidth: fullWidth,\r\n\t\t\t\tfullHeight: fullHeight,\r\n\t\t\t\toffsetX: x,\r\n\t\t\t\toffsetY: y,\r\n\t\t\t\twidth: width,\r\n\t\t\t\theight: height\r\n\t\t\t};\r\n\t\r\n\t\t\tthis.updateProjectionMatrix();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclearViewOffset: function() {\r\n\t\r\n\t\t\tthis.view = null;\r\n\t\t\tthis.updateProjectionMatrix();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdateProjectionMatrix: function () {\r\n\t\r\n\t\t\tvar near = this.near,\r\n\t\t\t\ttop = near * Math.tan(\r\n\t\t\t\t\t\tTHREE.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,\r\n\t\t\t\theight = 2 * top,\r\n\t\t\t\twidth = this.aspect * height,\r\n\t\t\t\tleft = - 0.5 * width,\r\n\t\t\t\tview = this.view;\r\n\t\r\n\t\t\tif ( view !== null ) {\r\n\t\r\n\t\t\t\tvar fullWidth = view.fullWidth,\r\n\t\t\t\t\tfullHeight = view.fullHeight;\r\n\t\r\n\t\t\t\tleft += view.offsetX * width / fullWidth;\r\n\t\t\t\ttop -= view.offsetY * height / fullHeight;\r\n\t\t\t\twidth *= view.width / fullWidth;\r\n\t\t\t\theight *= view.height / fullHeight;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar skew = this.filmOffset;\r\n\t\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\r\n\t\r\n\t\t\tthis.projectionMatrix.makeFrustum(\r\n\t\t\t\t\tleft, left + width, top - height, top, near, this.far );\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoJSON: function ( meta ) {\r\n\t\r\n\t\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\t\r\n\t\t\tdata.object.fov = this.fov;\r\n\t\t\tdata.object.zoom = this.zoom;\r\n\t\r\n\t\t\tdata.object.near = this.near;\r\n\t\t\tdata.object.far = this.far;\r\n\t\t\tdata.object.focus = this.focus;\r\n\t\r\n\t\t\tdata.object.aspect = this.aspect;\r\n\t\r\n\t\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\r\n\t\r\n\t\t\tdata.object.filmGauge = this.filmGauge;\r\n\t\t\tdata.object.filmOffset = this.filmOffset;\r\n\t\r\n\t\t\treturn data;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/cameras/StereoCamera.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.StereoCamera = function () {\r\n\t\r\n\t\tthis.type = 'StereoCamera';\r\n\t\r\n\t\tthis.aspect = 1;\r\n\t\r\n\t\tthis.cameraL = new THREE.PerspectiveCamera();\r\n\t\tthis.cameraL.layers.enable( 1 );\r\n\t\tthis.cameraL.matrixAutoUpdate = false;\r\n\t\r\n\t\tthis.cameraR = new THREE.PerspectiveCamera();\r\n\t\tthis.cameraR.layers.enable( 2 );\r\n\t\tthis.cameraR.matrixAutoUpdate = false;\r\n\t\r\n\t};\r\n\t\r\n\tObject.assign( THREE.StereoCamera.prototype, {\r\n\t\r\n\t\tupdate: ( function () {\r\n\t\r\n\t\t\tvar focus, fov, aspect, near, far;\r\n\t\r\n\t\t\tvar eyeRight = new THREE.Matrix4();\r\n\t\t\tvar eyeLeft = new THREE.Matrix4();\r\n\t\r\n\t\t\treturn function update ( camera ) {\r\n\t\r\n\t\t\t\tvar needsUpdate = focus !== camera.focus || fov !== camera.fov ||\r\n\t\t\t\t\t\t\t\t\t\t\t\t\taspect !== camera.aspect * this.aspect || near !== camera.near ||\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tfar !== camera.far;\r\n\t\r\n\t\t\t\tif ( needsUpdate ) {\r\n\t\r\n\t\t\t\t\tfocus = camera.focus;\r\n\t\t\t\t\tfov = camera.fov;\r\n\t\t\t\t\taspect = camera.aspect * this.aspect;\r\n\t\t\t\t\tnear = camera.near;\r\n\t\t\t\t\tfar = camera.far;\r\n\t\r\n\t\t\t\t\t// Off-axis stereoscopic effect based on\r\n\t\t\t\t\t// http://paulbourke.net/stereographics/stereorender/\r\n\t\r\n\t\t\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\r\n\t\t\t\t\tvar eyeSep = 0.064 / 2;\r\n\t\t\t\t\tvar eyeSepOnProjection = eyeSep * near / focus;\r\n\t\t\t\t\tvar ymax = near * Math.tan( THREE.Math.DEG2RAD * fov * 0.5 );\r\n\t\t\t\t\tvar xmin, xmax;\r\n\t\r\n\t\t\t\t\t// translate xOffset\r\n\t\r\n\t\t\t\t\teyeLeft.elements[ 12 ] = - eyeSep;\r\n\t\t\t\t\teyeRight.elements[ 12 ] = eyeSep;\r\n\t\r\n\t\t\t\t\t// for left eye\r\n\t\r\n\t\t\t\t\txmin = - ymax * aspect + eyeSepOnProjection;\r\n\t\t\t\t\txmax = ymax * aspect + eyeSepOnProjection;\r\n\t\r\n\t\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\r\n\t\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\r\n\t\r\n\t\t\t\t\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\r\n\t\r\n\t\t\t\t\t// for right eye\r\n\t\r\n\t\t\t\t\txmin = - ymax * aspect - eyeSepOnProjection;\r\n\t\t\t\t\txmax = ymax * aspect - eyeSepOnProjection;\r\n\t\r\n\t\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\r\n\t\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\r\n\t\r\n\t\t\t\t\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\r\n\t\t\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )()\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/lights/Light.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Light = function ( color, intensity ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Light';\r\n\t\r\n\t\tthis.color = new THREE.Color( color );\r\n\t\tthis.intensity = intensity !== undefined ? intensity : 1;\r\n\t\r\n\t\tthis.receiveShadow = undefined;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Light.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.Light,\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tTHREE.Object3D.prototype.copy.call( this, source );\r\n\t\r\n\t\t\tthis.color.copy( source.color );\r\n\t\t\tthis.intensity = source.intensity;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoJSON: function ( meta ) {\r\n\t\r\n\t\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\t\r\n\t\t\tdata.object.color = this.color.getHex();\r\n\t\t\tdata.object.intensity = this.intensity;\r\n\t\r\n\t\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\r\n\t\r\n\t\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\r\n\t\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\r\n\t\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\r\n\t\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\r\n\t\r\n\t\t\treturn data;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/lights/LightShadow.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.LightShadow = function ( camera ) {\r\n\t\r\n\t\tthis.camera = camera;\r\n\t\r\n\t\tthis.bias = 0;\r\n\t\tthis.radius = 1;\r\n\t\r\n\t\tthis.mapSize = new THREE.Vector2( 512, 512 );\r\n\t\r\n\t\tthis.map = null;\r\n\t\tthis.matrix = new THREE.Matrix4();\r\n\t\r\n\t};\r\n\t\r\n\tObject.assign( THREE.LightShadow.prototype, {\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tthis.camera = source.camera.clone();\r\n\t\r\n\t\t\tthis.bias = source.bias;\r\n\t\t\tthis.radius = source.radius;\r\n\t\r\n\t\t\tthis.mapSize.copy( source.mapSize );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/lights/AmbientLight.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.AmbientLight = function ( color, intensity ) {\r\n\t\r\n\t\tTHREE.Light.call( this, color, intensity );\r\n\t\r\n\t\tthis.type = 'AmbientLight';\r\n\t\r\n\t\tthis.castShadow = undefined;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AmbientLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.AmbientLight\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/lights/DirectionalLight.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.DirectionalLight = function ( color, intensity ) {\r\n\t\r\n\t\tTHREE.Light.call( this, color, intensity );\r\n\t\r\n\t\tthis.type = 'DirectionalLight';\r\n\t\r\n\t\tthis.position.set( 0, 1, 0 );\r\n\t\tthis.updateMatrix();\r\n\t\r\n\t\tthis.target = new THREE.Object3D();\r\n\t\r\n\t\tthis.shadow = new THREE.DirectionalLightShadow();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DirectionalLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.DirectionalLight,\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tTHREE.Light.prototype.copy.call( this, source );\r\n\t\r\n\t\t\tthis.target = source.target.clone();\r\n\t\r\n\t\t\tthis.shadow = source.shadow.clone();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/lights/DirectionalLightShadow.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.DirectionalLightShadow = function ( light ) {\r\n\t\r\n\t\tTHREE.LightShadow.call( this, new THREE.OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DirectionalLightShadow.prototype = Object.assign( Object.create( THREE.LightShadow.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.DirectionalLightShadow\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/lights/HemisphereLight.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {\r\n\t\r\n\t\tTHREE.Light.call( this, skyColor, intensity );\r\n\t\r\n\t\tthis.type = 'HemisphereLight';\r\n\t\r\n\t\tthis.castShadow = undefined;\r\n\t\r\n\t\tthis.position.set( 0, 1, 0 );\r\n\t\tthis.updateMatrix();\r\n\t\r\n\t\tthis.groundColor = new THREE.Color( groundColor );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.HemisphereLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.HemisphereLight,\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tTHREE.Light.prototype.copy.call( this, source );\r\n\t\r\n\t\t\tthis.groundColor.copy( source.groundColor );\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/lights/PointLight.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\t\r\n\tTHREE.PointLight = function ( color, intensity, distance, decay ) {\r\n\t\r\n\t\tTHREE.Light.call( this, color, intensity );\r\n\t\r\n\t\tthis.type = 'PointLight';\r\n\t\r\n\t\tObject.defineProperty( this, 'power', {\r\n\t\t\tget: function () {\r\n\t\t\t\t// intensity = power per solid angle.\r\n\t\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\r\n\t\t\t\treturn this.intensity * 4 * Math.PI;\r\n\t\r\n\t\t\t},\r\n\t\t\tset: function ( power ) {\r\n\t\t\t\t// intensity = power per solid angle.\r\n\t\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\r\n\t\t\t\tthis.intensity = power / ( 4 * Math.PI );\r\n\t\t\t}\r\n\t\t} );\r\n\t\r\n\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\r\n\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\r\n\t\r\n\t\tthis.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 90, 1, 0.5, 500 ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PointLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.PointLight,\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tTHREE.Light.prototype.copy.call( this, source );\r\n\t\r\n\t\t\tthis.distance = source.distance;\r\n\t\t\tthis.decay = source.decay;\r\n\t\r\n\t\t\tthis.shadow = source.shadow.clone();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/lights/SpotLight.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.SpotLight = function ( color, intensity, distance, angle, penumbra, decay ) {\r\n\t\r\n\t\tTHREE.Light.call( this, color, intensity );\r\n\t\r\n\t\tthis.type = 'SpotLight';\r\n\t\r\n\t\tthis.position.set( 0, 1, 0 );\r\n\t\tthis.updateMatrix();\r\n\t\r\n\t\tthis.target = new THREE.Object3D();\r\n\t\r\n\t\tObject.defineProperty( this, 'power', {\r\n\t\t\tget: function () {\r\n\t\t\t\t// intensity = power per solid angle.\r\n\t\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\r\n\t\t\t\treturn this.intensity * Math.PI;\r\n\t\t\t},\r\n\t\t\tset: function ( power ) {\r\n\t\t\t\t// intensity = power per solid angle.\r\n\t\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\r\n\t\t\t\tthis.intensity = power / Math.PI;\r\n\t\t\t}\r\n\t\t} );\r\n\t\r\n\t\tthis.distance = ( distance !== undefined ) ? distance : 0;\r\n\t\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\r\n\t\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\r\n\t\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\r\n\t\r\n\t\tthis.shadow = new THREE.SpotLightShadow();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SpotLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.SpotLight,\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tTHREE.Light.prototype.copy.call( this, source );\r\n\t\r\n\t\t\tthis.distance = source.distance;\r\n\t\t\tthis.angle = source.angle;\r\n\t\t\tthis.penumbra = source.penumbra;\r\n\t\t\tthis.decay = source.decay;\r\n\t\r\n\t\t\tthis.target = source.target.clone();\r\n\t\r\n\t\t\tthis.shadow = source.shadow.clone();\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/lights/SpotLightShadow.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.SpotLightShadow = function () {\r\n\t\r\n\t\tTHREE.LightShadow.call( this, new THREE.PerspectiveCamera( 50, 1, 0.5, 500 ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SpotLightShadow.prototype = Object.assign( Object.create( THREE.LightShadow.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.SpotLightShadow,\r\n\t\r\n\t\tupdate: function ( light ) {\r\n\t\r\n\t\t\tvar fov = THREE.Math.RAD2DEG * 2 * light.angle;\r\n\t\t\tvar aspect = this.mapSize.width / this.mapSize.height;\r\n\t\t\tvar far = light.distance || 500;\r\n\t\r\n\t\t\tvar camera = this.camera;\r\n\t\r\n\t\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\r\n\t\r\n\t\t\t\tcamera.fov = fov;\r\n\t\t\t\tcamera.aspect = aspect;\r\n\t\t\t\tcamera.far = far;\r\n\t\t\t\tcamera.updateProjectionMatrix();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/loaders/AudioLoader.js\r\n\t\r\n\t/**\r\n\t * @author Reece Aaron Lecrivain / http://reecenotes.com/\r\n\t */\r\n\t\r\n\tTHREE.AudioLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AudioLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.AudioLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\r\n\t\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\t\tloader.load( url, function ( buffer ) {\r\n\t\r\n\t\t\t\tvar context = THREE.AudioContext;\r\n\t\r\n\t\t\t\tcontext.decodeAudioData( buffer, function ( audioBuffer ) {\r\n\t\r\n\t\t\t\t\tonLoad( audioBuffer );\r\n\t\r\n\t\t\t\t} );\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/Cache.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Cache = {\r\n\t\r\n\t\tenabled: false,\r\n\t\r\n\t\tfiles: {},\r\n\t\r\n\t\tadd: function ( key, file ) {\r\n\t\r\n\t\t\tif ( this.enabled === false ) return;\r\n\t\r\n\t\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\r\n\t\r\n\t\t\tthis.files[ key ] = file;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget: function ( key ) {\r\n\t\r\n\t\t\tif ( this.enabled === false ) return;\r\n\t\r\n\t\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\r\n\t\r\n\t\t\treturn this.files[ key ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tremove: function ( key ) {\r\n\t\r\n\t\t\tdelete this.files[ key ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclear: function () {\r\n\t\r\n\t\t\tthis.files = {};\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/Loader.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Loader = function () {\r\n\t\r\n\t\tthis.onLoadStart = function () {};\r\n\t\tthis.onLoadProgress = function () {};\r\n\t\tthis.onLoadComplete = function () {};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Loader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Loader,\r\n\t\r\n\t\tcrossOrigin: undefined,\r\n\t\r\n\t\textractUrlBase: function ( url ) {\r\n\t\r\n\t\t\tvar parts = url.split( '/' );\r\n\t\r\n\t\t\tif ( parts.length === 1 ) return './';\r\n\t\r\n\t\t\tparts.pop();\r\n\t\r\n\t\t\treturn parts.join( '/' ) + '/';\r\n\t\r\n\t\t},\r\n\t\r\n\t\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\r\n\t\r\n\t\t\tvar array = [];\r\n\t\r\n\t\t\tfor ( var i = 0; i < materials.length; ++ i ) {\r\n\t\r\n\t\t\t\tarray[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn array;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcreateMaterial: ( function () {\r\n\t\r\n\t\t\tvar color, textureLoader, materialLoader;\r\n\t\r\n\t\t\treturn function ( m, texturePath, crossOrigin ) {\r\n\t\r\n\t\t\t\tif ( color === undefined ) color = new THREE.Color();\r\n\t\t\t\tif ( textureLoader === undefined ) textureLoader = new THREE.TextureLoader();\r\n\t\t\t\tif ( materialLoader === undefined ) materialLoader = new THREE.MaterialLoader();\r\n\t\r\n\t\t\t\t// convert from old material format\r\n\t\r\n\t\t\t\tvar textures = {};\r\n\t\r\n\t\t\t\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\r\n\t\r\n\t\t\t\t\tvar fullPath = texturePath + path;\r\n\t\t\t\t\tvar loader = THREE.Loader.Handlers.get( fullPath );\r\n\t\r\n\t\t\t\t\tvar texture;\r\n\t\r\n\t\t\t\t\tif ( loader !== null ) {\r\n\t\r\n\t\t\t\t\t\ttexture = loader.load( fullPath );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\ttextureLoader.setCrossOrigin( crossOrigin );\r\n\t\t\t\t\t\ttexture = textureLoader.load( fullPath );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( repeat !== undefined ) {\r\n\t\r\n\t\t\t\t\t\ttexture.repeat.fromArray( repeat );\r\n\t\r\n\t\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\r\n\t\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( offset !== undefined ) {\r\n\t\r\n\t\t\t\t\t\ttexture.offset.fromArray( offset );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( wrap !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = THREE.RepeatWrapping;\r\n\t\t\t\t\t\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = THREE.MirroredRepeatWrapping;\r\n\t\r\n\t\t\t\t\t\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = THREE.RepeatWrapping;\r\n\t\t\t\t\t\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = THREE.MirroredRepeatWrapping;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( anisotropy !== undefined ) {\r\n\t\r\n\t\t\t\t\t\ttexture.anisotropy = anisotropy;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\t\t\t\ttextures[ uuid ] = texture;\r\n\t\r\n\t\t\t\t\treturn uuid;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t//\r\n\t\r\n\t\t\t\tvar json = {\r\n\t\t\t\t\tuuid: THREE.Math.generateUUID(),\r\n\t\t\t\t\ttype: 'MeshLambertMaterial'\r\n\t\t\t\t};\r\n\t\r\n\t\t\t\tfor ( var name in m ) {\r\n\t\r\n\t\t\t\t\tvar value = m[ name ];\r\n\t\r\n\t\t\t\t\tswitch ( name ) {\r\n\t\t\t\t\t\tcase 'DbgColor':\r\n\t\t\t\t\t\tcase 'DbgIndex':\r\n\t\t\t\t\t\tcase 'opticalDensity':\r\n\t\t\t\t\t\tcase 'illumination':\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'DbgName':\r\n\t\t\t\t\t\t\tjson.name = value;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'blending':\r\n\t\t\t\t\t\t\tjson.blending = THREE[ value ];\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'colorAmbient':\r\n\t\t\t\t\t\tcase 'mapAmbient':\r\n\t\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'colorDiffuse':\r\n\t\t\t\t\t\t\tjson.color = color.fromArray( value ).getHex();\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'colorSpecular':\r\n\t\t\t\t\t\t\tjson.specular = color.fromArray( value ).getHex();\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'colorEmissive':\r\n\t\t\t\t\t\t\tjson.emissive = color.fromArray( value ).getHex();\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'specularCoef':\r\n\t\t\t\t\t\t\tjson.shininess = value;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'shading':\r\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\r\n\t\t\t\t\t\t\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapDiffuse':\r\n\t\t\t\t\t\t\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapDiffuseRepeat':\r\n\t\t\t\t\t\tcase 'mapDiffuseOffset':\r\n\t\t\t\t\t\tcase 'mapDiffuseWrap':\r\n\t\t\t\t\t\tcase 'mapDiffuseAnisotropy':\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapLight':\r\n\t\t\t\t\t\t\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapLightRepeat':\r\n\t\t\t\t\t\tcase 'mapLightOffset':\r\n\t\t\t\t\t\tcase 'mapLightWrap':\r\n\t\t\t\t\t\tcase 'mapLightAnisotropy':\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapAO':\r\n\t\t\t\t\t\t\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapAORepeat':\r\n\t\t\t\t\t\tcase 'mapAOOffset':\r\n\t\t\t\t\t\tcase 'mapAOWrap':\r\n\t\t\t\t\t\tcase 'mapAOAnisotropy':\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapBump':\r\n\t\t\t\t\t\t\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapBumpScale':\r\n\t\t\t\t\t\t\tjson.bumpScale = value;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapBumpRepeat':\r\n\t\t\t\t\t\tcase 'mapBumpOffset':\r\n\t\t\t\t\t\tcase 'mapBumpWrap':\r\n\t\t\t\t\t\tcase 'mapBumpAnisotropy':\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapNormal':\r\n\t\t\t\t\t\t\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapNormalFactor':\r\n\t\t\t\t\t\t\tjson.normalScale = [ value, value ];\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapNormalRepeat':\r\n\t\t\t\t\t\tcase 'mapNormalOffset':\r\n\t\t\t\t\t\tcase 'mapNormalWrap':\r\n\t\t\t\t\t\tcase 'mapNormalAnisotropy':\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapSpecular':\r\n\t\t\t\t\t\t\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapSpecularRepeat':\r\n\t\t\t\t\t\tcase 'mapSpecularOffset':\r\n\t\t\t\t\t\tcase 'mapSpecularWrap':\r\n\t\t\t\t\t\tcase 'mapSpecularAnisotropy':\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapAlpha':\r\n\t\t\t\t\t\t\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'mapAlphaRepeat':\r\n\t\t\t\t\t\tcase 'mapAlphaOffset':\r\n\t\t\t\t\t\tcase 'mapAlphaWrap':\r\n\t\t\t\t\t\tcase 'mapAlphaAnisotropy':\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'flipSided':\r\n\t\t\t\t\t\t\tjson.side = THREE.BackSide;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'doubleSided':\r\n\t\t\t\t\t\t\tjson.side = THREE.DoubleSide;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'transparency':\r\n\t\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\r\n\t\t\t\t\t\t\tjson.opacity = value;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'depthTest':\r\n\t\t\t\t\t\tcase 'depthWrite':\r\n\t\t\t\t\t\tcase 'colorWrite':\r\n\t\t\t\t\t\tcase 'opacity':\r\n\t\t\t\t\t\tcase 'reflectivity':\r\n\t\t\t\t\t\tcase 'transparent':\r\n\t\t\t\t\t\tcase 'visible':\r\n\t\t\t\t\t\tcase 'wireframe':\r\n\t\t\t\t\t\t\tjson[ name ] = value;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tcase 'vertexColors':\r\n\t\t\t\t\t\t\tif ( value === true ) json.vertexColors = THREE.VertexColors;\r\n\t\t\t\t\t\t\tif ( value === 'face' ) json.vertexColors = THREE.FaceColors;\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\tconsole.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\r\n\t\t\t\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\r\n\t\r\n\t\t\t\tif ( json.opacity < 1 ) json.transparent = true;\r\n\t\r\n\t\t\t\tmaterialLoader.setTextures( textures );\r\n\t\r\n\t\t\t\treturn materialLoader.parse( json );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )()\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Loader.Handlers = {\r\n\t\r\n\t\thandlers: [],\r\n\t\r\n\t\tadd: function ( regex, loader ) {\r\n\t\r\n\t\t\tthis.handlers.push( regex, loader );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tget: function ( file ) {\r\n\t\r\n\t\t\tvar handlers = this.handlers;\r\n\t\r\n\t\t\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\r\n\t\r\n\t\t\t\tvar regex = handlers[ i ];\r\n\t\t\t\tvar loader  = handlers[ i + 1 ];\r\n\t\r\n\t\t\t\tif ( regex.test( file ) ) {\r\n\t\r\n\t\t\t\t\treturn loader;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn null;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/XHRLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.XHRLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.XHRLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.XHRLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tif ( this.path !== undefined ) url = this.path + url;\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar cached = THREE.Cache.get( url );\r\n\t\r\n\t\t\tif ( cached !== undefined ) {\r\n\t\r\n\t\t\t\tif ( onLoad ) {\r\n\t\r\n\t\t\t\t\tsetTimeout( function () {\r\n\t\r\n\t\t\t\t\t\tonLoad( cached );\r\n\t\r\n\t\t\t\t\t}, 0 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn cached;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar request = new XMLHttpRequest();\r\n\t\t\trequest.overrideMimeType( 'text/plain' );\r\n\t\t\trequest.open( 'GET', url, true );\r\n\t\r\n\t\t\trequest.addEventListener( 'load', function ( event ) {\r\n\t\r\n\t\t\t\tvar response = event.target.response;\r\n\t\r\n\t\t\t\tTHREE.Cache.add( url, response );\r\n\t\r\n\t\t\t\tif ( this.status === 200 ) {\r\n\t\r\n\t\t\t\t\tif ( onLoad ) onLoad( response );\r\n\t\r\n\t\t\t\t\tscope.manager.itemEnd( url );\r\n\t\r\n\t\t\t\t} else if ( this.status === 0 ) {\r\n\t\r\n\t\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\r\n\t\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );\r\n\t\r\n\t\t\t\t\tif ( onLoad ) onLoad( response );\r\n\t\r\n\t\t\t\t\tscope.manager.itemEnd( url );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tif ( onError ) onError( event );\r\n\t\r\n\t\t\t\t\tscope.manager.itemError( url );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}, false );\r\n\t\r\n\t\t\tif ( onProgress !== undefined ) {\r\n\t\r\n\t\t\t\trequest.addEventListener( 'progress', function ( event ) {\r\n\t\r\n\t\t\t\t\tonProgress( event );\r\n\t\r\n\t\t\t\t}, false );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\trequest.addEventListener( 'error', function ( event ) {\r\n\t\r\n\t\t\t\tif ( onError ) onError( event );\r\n\t\r\n\t\t\t\tscope.manager.itemError( url );\r\n\t\r\n\t\t\t}, false );\r\n\t\r\n\t\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\r\n\t\t\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\r\n\t\r\n\t\t\trequest.send( null );\r\n\t\r\n\t\t\tscope.manager.itemStart( url );\r\n\t\r\n\t\t\treturn request;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetPath: function ( value ) {\r\n\t\r\n\t\t\tthis.path = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetResponseType: function ( value ) {\r\n\t\r\n\t\t\tthis.responseType = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetWithCredentials: function ( value ) {\r\n\t\r\n\t\t\tthis.withCredentials = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/FontLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.FontLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.FontLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.FontLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\r\n\t\t\tloader.load( url, function ( text ) {\r\n\t\r\n\t\t\t\tvar json;\r\n\t\r\n\t\t\t\ttry {\r\n\t\r\n\t\t\t\t\tjson = JSON.parse( text );\r\n\t\r\n\t\t\t\t} catch ( e ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\r\n\t\t\t\t\tjson = JSON.parse( text.substring( 65, text.length - 2 ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar font = scope.parse( json );\r\n\t\r\n\t\t\t\tif ( onLoad ) onLoad( font );\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparse: function ( json ) {\r\n\t\r\n\t\t\treturn new THREE.Font( json );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/ImageLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.ImageLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ImageLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.ImageLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tif ( this.path !== undefined ) url = this.path + url;\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar cached = THREE.Cache.get( url );\r\n\t\r\n\t\t\tif ( cached !== undefined ) {\r\n\t\r\n\t\t\t\tscope.manager.itemStart( url );\r\n\t\r\n\t\t\t\tif ( onLoad ) {\r\n\t\r\n\t\t\t\t\tsetTimeout( function () {\r\n\t\r\n\t\t\t\t\t\tonLoad( cached );\r\n\t\r\n\t\t\t\t\t\tscope.manager.itemEnd( url );\r\n\t\r\n\t\t\t\t\t}, 0 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tscope.manager.itemEnd( url );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn cached;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar image = document.createElement( 'img' );\r\n\t\r\n\t\t\timage.addEventListener( 'load', function ( event ) {\r\n\t\r\n\t\t\t\tTHREE.Cache.add( url, this );\r\n\t\r\n\t\t\t\tif ( onLoad ) onLoad( this );\r\n\t\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\t\r\n\t\t\t}, false );\r\n\t\r\n\t\t\tif ( onProgress !== undefined ) {\r\n\t\r\n\t\t\t\timage.addEventListener( 'progress', function ( event ) {\r\n\t\r\n\t\t\t\t\tonProgress( event );\r\n\t\r\n\t\t\t\t}, false );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\timage.addEventListener( 'error', function ( event ) {\r\n\t\r\n\t\t\t\tif ( onError ) onError( event );\r\n\t\r\n\t\t\t\tscope.manager.itemError( url );\r\n\t\r\n\t\t\t}, false );\r\n\t\r\n\t\t\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\r\n\t\r\n\t\t\tscope.manager.itemStart( url );\r\n\t\r\n\t\t\timage.src = url;\r\n\t\r\n\t\t\treturn image;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetCrossOrigin: function ( value ) {\r\n\t\r\n\t\t\tthis.crossOrigin = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetPath: function ( value ) {\r\n\t\r\n\t\t\tthis.path = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/JSONLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.JSONLoader = function ( manager ) {\r\n\t\r\n\t\tif ( typeof manager === 'boolean' ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\r\n\t\t\tmanager = undefined;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t\tthis.withCredentials = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.JSONLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.JSONLoader,\r\n\t\r\n\t\t// Deprecated\r\n\t\r\n\t\tget statusDomElement () {\r\n\t\r\n\t\t\tif ( this._statusDomElement === undefined ) {\r\n\t\r\n\t\t\t\tthis._statusDomElement = document.createElement( 'div' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tconsole.warn( 'THREE.JSONLoader: .statusDomElement has been removed.' );\r\n\t\t\treturn this._statusDomElement;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tload: function( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar texturePath = this.texturePath && ( typeof this.texturePath === \"string\" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\r\n\t\t\tloader.setWithCredentials( this.withCredentials );\r\n\t\t\tloader.load( url, function ( text ) {\r\n\t\r\n\t\t\t\tvar json = JSON.parse( text );\r\n\t\t\t\tvar metadata = json.metadata;\r\n\t\r\n\t\t\t\tif ( metadata !== undefined ) {\r\n\t\r\n\t\t\t\t\tvar type = metadata.type;\r\n\t\r\n\t\t\t\t\tif ( type !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tif ( type.toLowerCase() === 'object' ) {\r\n\t\r\n\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\r\n\t\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif ( type.toLowerCase() === 'scene' ) {\r\n\t\r\n\t\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\r\n\t\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar object = scope.parse( json, texturePath );\r\n\t\t\t\tonLoad( object.geometry, object.materials );\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetTexturePath: function ( value ) {\r\n\t\r\n\t\t\tthis.texturePath = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparse: function ( json, texturePath ) {\r\n\t\r\n\t\t\tvar geometry = new THREE.Geometry(),\r\n\t\t\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\r\n\t\r\n\t\t\tparseModel( scale );\r\n\t\r\n\t\t\tparseSkin();\r\n\t\t\tparseMorphing( scale );\r\n\t\t\tparseAnimations();\r\n\t\r\n\t\t\tgeometry.computeFaceNormals();\r\n\t\t\tgeometry.computeBoundingSphere();\r\n\t\r\n\t\t\tfunction parseModel( scale ) {\r\n\t\r\n\t\t\t\tfunction isBitSet( value, position ) {\r\n\t\r\n\t\t\t\t\treturn value & ( 1 << position );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar i, j, fi,\r\n\t\r\n\t\t\t\toffset, zLength,\r\n\t\r\n\t\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\r\n\t\r\n\t\t\t\ttype,\r\n\t\t\t\tisQuad,\r\n\t\t\t\thasMaterial,\r\n\t\t\t\thasFaceVertexUv,\r\n\t\t\t\thasFaceNormal, hasFaceVertexNormal,\r\n\t\t\t\thasFaceColor, hasFaceVertexColor,\r\n\t\r\n\t\t\tvertex, face, faceA, faceB, hex, normal,\r\n\t\r\n\t\t\t\tuvLayer, uv, u, v,\r\n\t\r\n\t\t\t\tfaces = json.faces,\r\n\t\t\t\tvertices = json.vertices,\r\n\t\t\t\tnormals = json.normals,\r\n\t\t\t\tcolors = json.colors,\r\n\t\r\n\t\t\t\tnUvLayers = 0;\r\n\t\r\n\t\t\t\tif ( json.uvs !== undefined ) {\r\n\t\r\n\t\t\t\t\t// disregard empty arrays\r\n\t\r\n\t\t\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\toffset = 0;\r\n\t\t\t\tzLength = vertices.length;\r\n\t\r\n\t\t\t\twhile ( offset < zLength ) {\r\n\t\r\n\t\t\t\t\tvertex = new THREE.Vector3();\r\n\t\r\n\t\t\t\t\tvertex.x = vertices[ offset ++ ] * scale;\r\n\t\t\t\t\tvertex.y = vertices[ offset ++ ] * scale;\r\n\t\t\t\t\tvertex.z = vertices[ offset ++ ] * scale;\r\n\t\r\n\t\t\t\t\tgeometry.vertices.push( vertex );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\toffset = 0;\r\n\t\t\t\tzLength = faces.length;\r\n\t\r\n\t\t\t\twhile ( offset < zLength ) {\r\n\t\r\n\t\t\t\t\ttype = faces[ offset ++ ];\r\n\t\r\n\t\r\n\t\t\t\t\tisQuad              = isBitSet( type, 0 );\r\n\t\t\t\t\thasMaterial         = isBitSet( type, 1 );\r\n\t\t\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\r\n\t\t\t\t\thasFaceNormal       = isBitSet( type, 4 );\r\n\t\t\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\r\n\t\t\t\t\thasFaceColor\t     = isBitSet( type, 6 );\r\n\t\t\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\r\n\t\r\n\t\t\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\r\n\t\r\n\t\t\t\t\tif ( isQuad ) {\r\n\t\r\n\t\t\t\t\t\tfaceA = new THREE.Face3();\r\n\t\t\t\t\t\tfaceA.a = faces[ offset ];\r\n\t\t\t\t\t\tfaceA.b = faces[ offset + 1 ];\r\n\t\t\t\t\t\tfaceA.c = faces[ offset + 3 ];\r\n\t\r\n\t\t\t\t\t\tfaceB = new THREE.Face3();\r\n\t\t\t\t\t\tfaceB.a = faces[ offset + 1 ];\r\n\t\t\t\t\t\tfaceB.b = faces[ offset + 2 ];\r\n\t\t\t\t\t\tfaceB.c = faces[ offset + 3 ];\r\n\t\r\n\t\t\t\t\t\toffset += 4;\r\n\t\r\n\t\t\t\t\t\tif ( hasMaterial ) {\r\n\t\r\n\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\t\tfaceA.materialIndex = materialIndex;\r\n\t\t\t\t\t\t\tfaceB.materialIndex = materialIndex;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t// to get face <=> uv index correspondence\r\n\t\r\n\t\t\t\t\t\tfi = geometry.faces.length;\r\n\t\r\n\t\t\t\t\t\tif ( hasFaceVertexUv ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\t\r\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\r\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\r\n\t\r\n\t\t\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\t\r\n\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\t\r\n\t\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\r\n\t\r\n\t\t\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n\t\t\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif ( hasFaceNormal ) {\r\n\t\r\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\t\r\n\t\t\t\t\t\t\tfaceA.normal.set(\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tfaceB.normal.copy( faceA.normal );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\t\r\n\t\t\t\t\t\t\t\tnormal = new THREE.Vector3(\r\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t\t\t);\r\n\t\r\n\t\r\n\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\r\n\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\t\t\tif ( hasFaceColor ) {\r\n\t\r\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\t\thex = colors[ colorIndex ];\r\n\t\r\n\t\t\t\t\t\t\tfaceA.color.setHex( hex );\r\n\t\t\t\t\t\t\tfaceB.color.setHex( hex );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\t\t\tif ( hasFaceVertexColor ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\t\t\thex = colors[ colorIndex ];\r\n\t\r\n\t\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );\r\n\t\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tgeometry.faces.push( faceA );\r\n\t\t\t\t\t\tgeometry.faces.push( faceB );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tface = new THREE.Face3();\r\n\t\t\t\t\t\tface.a = faces[ offset ++ ];\r\n\t\t\t\t\t\tface.b = faces[ offset ++ ];\r\n\t\t\t\t\t\tface.c = faces[ offset ++ ];\r\n\t\r\n\t\t\t\t\t\tif ( hasMaterial ) {\r\n\t\r\n\t\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\t\tface.materialIndex = materialIndex;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t// to get face <=> uv index correspondence\r\n\t\r\n\t\t\t\t\t\tfi = geometry.faces.length;\r\n\t\r\n\t\t\t\t\t\tif ( hasFaceVertexUv ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\t\r\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\r\n\t\r\n\t\t\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\t\r\n\t\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\t\r\n\t\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\r\n\t\r\n\t\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif ( hasFaceNormal ) {\r\n\t\r\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\t\r\n\t\t\t\t\t\t\tface.normal.set(\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\t\r\n\t\t\t\t\t\t\t\tnormal = new THREE.Vector3(\r\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\t\tface.vertexNormals.push( normal );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\t\t\tif ( hasFaceColor ) {\r\n\t\r\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\t\t\tif ( hasFaceVertexColor ) {\r\n\t\r\n\t\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\t\t\tface.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tgeometry.faces.push( face );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction parseSkin() {\r\n\t\r\n\t\t\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\r\n\t\r\n\t\t\t\tif ( json.skinWeights ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\r\n\t\r\n\t\t\t\t\t\tvar x =                               json.skinWeights[ i ];\r\n\t\t\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\r\n\t\t\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\r\n\t\t\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\r\n\t\r\n\t\t\t\t\t\tgeometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( json.skinIndices ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\r\n\t\r\n\t\t\t\t\t\tvar a =                               json.skinIndices[ i ];\r\n\t\t\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\r\n\t\t\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\r\n\t\t\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\r\n\t\r\n\t\t\t\t\t\tgeometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.bones = json.bones;\r\n\t\r\n\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\r\n\t\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction parseMorphing( scale ) {\r\n\t\r\n\t\t\t\tif ( json.morphTargets !== undefined ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tgeometry.morphTargets[ i ] = {};\r\n\t\t\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\r\n\t\t\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\r\n\t\r\n\t\t\t\t\t\tvar dstVertices = geometry.morphTargets[ i ].vertices;\r\n\t\t\t\t\t\tvar srcVertices = json.morphTargets[ i ].vertices;\r\n\t\r\n\t\t\t\t\t\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\r\n\t\r\n\t\t\t\t\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\r\n\t\t\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\r\n\t\t\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\r\n\t\r\n\t\t\t\t\t\t\tdstVertices.push( vertex );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.' );\r\n\t\r\n\t\t\t\t\tvar faces = geometry.faces;\r\n\t\t\t\t\tvar morphColors = json.morphColors[ 0 ].colors;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tfaces[ i ].color.fromArray( morphColors, i * 3 );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction parseAnimations() {\r\n\t\r\n\t\t\t\tvar outputAnimations = [];\r\n\t\r\n\t\t\t\t// parse old style Bone/Hierarchy animations\r\n\t\t\t\tvar animations = [];\r\n\t\r\n\t\t\t\tif ( json.animation !== undefined ) {\r\n\t\r\n\t\t\t\t\tanimations.push( json.animation );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( json.animations !== undefined ) {\r\n\t\r\n\t\t\t\t\tif ( json.animations.length ) {\r\n\t\r\n\t\t\t\t\t\tanimations = animations.concat( json.animations );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tanimations.push( json.animations );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < animations.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar clip = THREE.AnimationClip.parseAnimation( animations[ i ], geometry.bones );\r\n\t\t\t\t\tif ( clip ) outputAnimations.push( clip );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// parse implicit morph animations\r\n\t\t\t\tif ( geometry.morphTargets ) {\r\n\t\r\n\t\t\t\t\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\r\n\t\t\t\t\tvar morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\r\n\t\t\t\t\toutputAnimations = outputAnimations.concat( morphAnimationClips );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( json.materials === undefined || json.materials.length === 0 ) {\r\n\t\r\n\t\t\t\treturn { geometry: geometry };\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tvar materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\r\n\t\r\n\t\t\t\treturn { geometry: geometry, materials: materials };\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/LoadingManager.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.LoadingManager = function ( onLoad, onProgress, onError ) {\r\n\t\r\n\t\tvar scope = this;\r\n\t\r\n\t\tvar isLoading = false, itemsLoaded = 0, itemsTotal = 0;\r\n\t\r\n\t\tthis.onStart = undefined;\r\n\t\tthis.onLoad = onLoad;\r\n\t\tthis.onProgress = onProgress;\r\n\t\tthis.onError = onError;\r\n\t\r\n\t\tthis.itemStart = function ( url ) {\r\n\t\r\n\t\t\titemsTotal ++;\r\n\t\r\n\t\t\tif ( isLoading === false ) {\r\n\t\r\n\t\t\t\tif ( scope.onStart !== undefined ) {\r\n\t\r\n\t\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tisLoading = true;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.itemEnd = function ( url ) {\r\n\t\r\n\t\t\titemsLoaded ++;\r\n\t\r\n\t\t\tif ( scope.onProgress !== undefined ) {\r\n\t\r\n\t\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( itemsLoaded === itemsTotal ) {\r\n\t\r\n\t\t\t\tisLoading = false;\r\n\t\r\n\t\t\t\tif ( scope.onLoad !== undefined ) {\r\n\t\r\n\t\t\t\t\tscope.onLoad();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.itemError = function ( url ) {\r\n\t\r\n\t\t\tif ( scope.onError !== undefined ) {\r\n\t\r\n\t\t\t\tscope.onError( url );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DefaultLoadingManager = new THREE.LoadingManager();\r\n\t\r\n\t// File:src/loaders/BufferGeometryLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.BufferGeometryLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BufferGeometryLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.BufferGeometryLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\t\tloader.load( url, function ( text ) {\r\n\t\r\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparse: function ( json ) {\r\n\t\r\n\t\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\r\n\t\t\tvar index = json.data.index;\r\n\t\r\n\t\t\tvar TYPED_ARRAYS = {\r\n\t\t\t\t'Int8Array': Int8Array,\r\n\t\t\t\t'Uint8Array': Uint8Array,\r\n\t\t\t\t'Uint8ClampedArray': Uint8ClampedArray,\r\n\t\t\t\t'Int16Array': Int16Array,\r\n\t\t\t\t'Uint16Array': Uint16Array,\r\n\t\t\t\t'Int32Array': Int32Array,\r\n\t\t\t\t'Uint32Array': Uint32Array,\r\n\t\t\t\t'Float32Array': Float32Array,\r\n\t\t\t\t'Float64Array': Float64Array\r\n\t\t\t};\r\n\t\r\n\t\t\tif ( index !== undefined ) {\r\n\t\r\n\t\t\t\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\r\n\t\t\t\tgeometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar attributes = json.data.attributes;\r\n\t\r\n\t\t\tfor ( var key in attributes ) {\r\n\t\r\n\t\t\t\tvar attribute = attributes[ key ];\r\n\t\t\t\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\r\n\t\r\n\t\t\t\tgeometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\r\n\t\r\n\t\t\tif ( groups !== undefined ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\tvar group = groups[ i ];\r\n\t\r\n\t\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar boundingSphere = json.data.boundingSphere;\r\n\t\r\n\t\t\tif ( boundingSphere !== undefined ) {\r\n\t\r\n\t\t\t\tvar center = new THREE.Vector3();\r\n\t\r\n\t\t\t\tif ( boundingSphere.center !== undefined ) {\r\n\t\r\n\t\t\t\t\tcenter.fromArray( boundingSphere.center );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgeometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn geometry;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/MaterialLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.MaterialLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\tthis.textures = {};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MaterialLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.MaterialLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\t\tloader.load( url, function ( text ) {\r\n\t\r\n\t\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetTextures: function ( value ) {\r\n\t\r\n\t\t\tthis.textures = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetTexture: function ( name ) {\r\n\t\r\n\t\t\tvar textures = this.textures;\r\n\t\r\n\t\t\tif ( textures[ name ] === undefined ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn textures[ name ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparse: function ( json ) {\r\n\t\r\n\t\t\tvar material = new THREE[ json.type ];\r\n\t\r\n\t\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\r\n\t\t\tif ( json.name !== undefined ) material.name = json.name;\r\n\t\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\r\n\t\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\r\n\t\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\r\n\t\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\r\n\t\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\r\n\t\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\r\n\t\t\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\r\n\t\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\r\n\t\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\r\n\t\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\r\n\t\t\tif ( json.shading !== undefined ) material.shading = json.shading;\r\n\t\t\tif ( json.blending !== undefined ) material.blending = json.blending;\r\n\t\t\tif ( json.side !== undefined ) material.side = json.side;\r\n\t\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\r\n\t\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\r\n\t\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\r\n\t\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\r\n\t\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\r\n\t\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\r\n\t\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\r\n\t\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\r\n\t\r\n\t\t\t// for PointsMaterial\r\n\t\t\tif ( json.size !== undefined ) material.size = json.size;\r\n\t\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\r\n\t\r\n\t\t\t// maps\r\n\t\r\n\t\t\tif ( json.map !== undefined ) material.map = this.getTexture( json.map );\r\n\t\r\n\t\t\tif ( json.alphaMap !== undefined ) {\r\n\t\r\n\t\t\t\tmaterial.alphaMap = this.getTexture( json.alphaMap );\r\n\t\t\t\tmaterial.transparent = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );\r\n\t\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\r\n\t\r\n\t\t\tif ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );\r\n\t\t\tif ( json.normalScale !== undefined ) {\r\n\t\r\n\t\t\t\tvar normalScale = json.normalScale;\r\n\t\r\n\t\t\t\tif ( Array.isArray( normalScale ) === false ) {\r\n\t\r\n\t\t\t\t\t// Blender exporter used to export a scalar. See #7459\r\n\t\r\n\t\t\t\t\tnormalScale = [ normalScale, normalScale ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tmaterial.normalScale = new THREE.Vector2().fromArray( normalScale );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );\r\n\t\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\r\n\t\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\r\n\t\r\n\t\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = this.getTexture( json.roughnessMap );\r\n\t\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = this.getTexture( json.metalnessMap );\r\n\t\r\n\t\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = this.getTexture( json.emissiveMap );\r\n\t\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\r\n\t\r\n\t\t\tif ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );\r\n\t\r\n\t\t\tif ( json.envMap !== undefined ) {\r\n\t\r\n\t\t\t\tmaterial.envMap = this.getTexture( json.envMap );\r\n\t\t\t\tmaterial.combine = THREE.MultiplyOperation;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( json.reflectivity ) material.reflectivity = json.reflectivity;\r\n\t\r\n\t\t\tif ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );\r\n\t\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\r\n\t\r\n\t\t\tif ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );\r\n\t\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\r\n\t\r\n\t\t\t// MultiMaterial\r\n\t\r\n\t\t\tif ( json.materials !== undefined ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tmaterial.materials.push( this.parse( json.materials[ i ] ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn material;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/ObjectLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.ObjectLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\tthis.texturePath = '';\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ObjectLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.ObjectLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tif ( this.texturePath === '' ) {\r\n\t\r\n\t\t\t\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\t\tloader.load( url, function ( text ) {\r\n\t\r\n\t\t\t\tscope.parse( JSON.parse( text ), onLoad );\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetTexturePath: function ( value ) {\r\n\t\r\n\t\t\tthis.texturePath = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetCrossOrigin: function ( value ) {\r\n\t\r\n\t\t\tthis.crossOrigin = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparse: function ( json, onLoad ) {\r\n\t\r\n\t\t\tvar geometries = this.parseGeometries( json.geometries );\r\n\t\r\n\t\t\tvar images = this.parseImages( json.images, function () {\r\n\t\r\n\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\r\n\t\r\n\t\t\t} );\r\n\t\r\n\t\t\tvar textures  = this.parseTextures( json.textures, images );\r\n\t\t\tvar materials = this.parseMaterials( json.materials, textures );\r\n\t\r\n\t\t\tvar object = this.parseObject( json.object, geometries, materials );\r\n\t\r\n\t\t\tif ( json.animations ) {\r\n\t\r\n\t\t\t\tobject.animations = this.parseAnimations( json.animations );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( json.images === undefined || json.images.length === 0 ) {\r\n\t\r\n\t\t\t\tif ( onLoad !== undefined ) onLoad( object );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn object;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparseGeometries: function ( json ) {\r\n\t\r\n\t\t\tvar geometries = {};\r\n\t\r\n\t\t\tif ( json !== undefined ) {\r\n\t\r\n\t\t\t\tvar geometryLoader = new THREE.JSONLoader();\r\n\t\t\t\tvar bufferGeometryLoader = new THREE.BufferGeometryLoader();\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar geometry;\r\n\t\t\t\t\tvar data = json[ i ];\r\n\t\r\n\t\t\t\t\tswitch ( data.type ) {\r\n\t\r\n\t\t\t\t\t\tcase 'PlaneGeometry':\r\n\t\t\t\t\t\tcase 'PlaneBufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\t\tdata.width,\r\n\t\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\t\tdata.heightSegments\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'BoxGeometry':\r\n\t\t\t\t\t\tcase 'BoxBufferGeometry':\r\n\t\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\t\tdata.width,\r\n\t\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\t\tdata.depth,\r\n\t\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\t\tdata.depthSegments\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'CircleGeometry':\r\n\t\t\t\t\t\tcase 'CircleBufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.segments,\r\n\t\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'CylinderGeometry':\r\n\t\t\t\t\t\tcase 'CylinderBufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\t\tdata.radiusTop,\r\n\t\t\t\t\t\t\t\tdata.radiusBottom,\r\n\t\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\t\tdata.openEnded,\r\n\t\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'ConeGeometry':\r\n\t\t\t\t\t\tcase 'ConeBufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE [ data.type ](\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\t\tdata.openEnded,\r\n\t\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'SphereGeometry':\r\n\t\t\t\t\t\tcase 'SphereBufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\t\tdata.phiStart,\r\n\t\t\t\t\t\t\t\tdata.phiLength,\r\n\t\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'DodecahedronGeometry':\r\n\t\t\t\t\t\tcase 'IcosahedronGeometry':\r\n\t\t\t\t\t\tcase 'OctahedronGeometry':\r\n\t\t\t\t\t\tcase 'TetrahedronGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.detail\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'RingGeometry':\r\n\t\t\t\t\t\tcase 'RingBufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\t\tdata.innerRadius,\r\n\t\t\t\t\t\t\t\tdata.outerRadius,\r\n\t\t\t\t\t\t\t\tdata.thetaSegments,\r\n\t\t\t\t\t\t\t\tdata.phiSegments,\r\n\t\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'TorusGeometry':\r\n\t\t\t\t\t\tcase 'TorusBufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.tube,\r\n\t\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\t\tdata.tubularSegments,\r\n\t\t\t\t\t\t\t\tdata.arc\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'TorusKnotGeometry':\r\n\t\t\t\t\t\tcase 'TorusKnotBufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\t\tdata.tube,\r\n\t\t\t\t\t\t\t\tdata.tubularSegments,\r\n\t\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\t\tdata.p,\r\n\t\t\t\t\t\t\t\tdata.q\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'LatheGeometry':\r\n\t\t\t\t\t\tcase 'LatheBufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\t\tdata.points,\r\n\t\t\t\t\t\t\t\tdata.segments,\r\n\t\t\t\t\t\t\t\tdata.phiStart,\r\n\t\t\t\t\t\t\t\tdata.phiLength\r\n\t\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'BufferGeometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase 'Geometry':\r\n\t\r\n\t\t\t\t\t\t\tgeometry = geometryLoader.parse( data.data, this.texturePath ).geometry;\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tdefault:\r\n\t\r\n\t\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\r\n\t\r\n\t\t\t\t\t\t\tcontinue;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tgeometry.uuid = data.uuid;\r\n\t\r\n\t\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\r\n\t\r\n\t\t\t\t\tgeometries[ data.uuid ] = geometry;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn geometries;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparseMaterials: function ( json, textures ) {\r\n\t\r\n\t\t\tvar materials = {};\r\n\t\r\n\t\t\tif ( json !== undefined ) {\r\n\t\r\n\t\t\t\tvar loader = new THREE.MaterialLoader();\r\n\t\t\t\tloader.setTextures( textures );\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar material = loader.parse( json[ i ] );\r\n\t\t\t\t\tmaterials[ material.uuid ] = material;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn materials;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparseAnimations: function ( json ) {\r\n\t\r\n\t\t\tvar animations = [];\r\n\t\r\n\t\t\tfor ( var i = 0; i < json.length; i ++ ) {\r\n\t\r\n\t\t\t\tvar clip = THREE.AnimationClip.parse( json[ i ] );\r\n\t\r\n\t\t\t\tanimations.push( clip );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn animations;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparseImages: function ( json, onLoad ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\t\tvar images = {};\r\n\t\r\n\t\t\tfunction loadImage( url ) {\r\n\t\r\n\t\t\t\tscope.manager.itemStart( url );\r\n\t\r\n\t\t\t\treturn loader.load( url, function () {\r\n\t\r\n\t\t\t\t\tscope.manager.itemEnd( url );\r\n\t\r\n\t\t\t\t} );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( json !== undefined && json.length > 0 ) {\r\n\t\r\n\t\t\t\tvar manager = new THREE.LoadingManager( onLoad );\r\n\t\r\n\t\t\t\tvar loader = new THREE.ImageLoader( manager );\r\n\t\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar image = json[ i ];\r\n\t\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\r\n\t\r\n\t\t\t\t\timages[ image.uuid ] = loadImage( path );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn images;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparseTextures: function ( json, images ) {\r\n\t\r\n\t\t\tfunction parseConstant( value ) {\r\n\t\r\n\t\t\t\tif ( typeof( value ) === 'number' ) return value;\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\r\n\t\r\n\t\t\t\treturn THREE[ value ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar textures = {};\r\n\t\r\n\t\t\tif ( json !== undefined ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar data = json[ i ];\r\n\t\r\n\t\t\t\t\tif ( data.image === undefined ) {\r\n\t\r\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( images[ data.image ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar texture = new THREE.Texture( images[ data.image ] );\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\t\ttexture.uuid = data.uuid;\r\n\t\r\n\t\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\r\n\t\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );\r\n\t\t\t\t\tif ( data.offset !== undefined ) texture.offset = new THREE.Vector2( data.offset[ 0 ], data.offset[ 1 ] );\r\n\t\t\t\t\tif ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );\r\n\t\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );\r\n\t\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );\r\n\t\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\r\n\t\t\t\t\tif ( Array.isArray( data.wrap ) ) {\r\n\t\r\n\t\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ] );\r\n\t\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ] );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttextures[ data.uuid ] = texture;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn textures;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tparseObject: function () {\r\n\t\r\n\t\t\tvar matrix = new THREE.Matrix4();\r\n\t\r\n\t\t\treturn function ( data, geometries, materials ) {\r\n\t\r\n\t\t\t\tvar object;\r\n\t\r\n\t\t\t\tfunction getGeometry( name ) {\r\n\t\r\n\t\t\t\t\tif ( geometries[ name ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\treturn geometries[ name ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfunction getMaterial( name ) {\r\n\t\r\n\t\t\t\t\tif ( name === undefined ) return undefined;\r\n\t\r\n\t\t\t\t\tif ( materials[ name ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\treturn materials[ name ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tswitch ( data.type ) {\r\n\t\r\n\t\t\t\t\tcase 'Scene':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.Scene();\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'PerspectiveCamera':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\r\n\t\r\n\t\t\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\r\n\t\t\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\r\n\t\t\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\r\n\t\t\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\r\n\t\t\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'OrthographicCamera':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'AmbientLight':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.AmbientLight( data.color, data.intensity );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'DirectionalLight':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.DirectionalLight( data.color, data.intensity );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'PointLight':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'SpotLight':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'HemisphereLight':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'Mesh':\r\n\t\r\n\t\t\t\t\t\tvar geometry = getGeometry( data.geometry );\r\n\t\t\t\t\t\tvar material = getMaterial( data.material );\r\n\t\r\n\t\t\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 ) {\r\n\t\r\n\t\t\t\t\t\t\tobject = new THREE.SkinnedMesh( geometry, material );\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tobject = new THREE.Mesh( geometry, material );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'LOD':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.LOD();\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'Line':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'PointCloud':\r\n\t\t\t\t\tcase 'Points':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'Sprite':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.Sprite( getMaterial( data.material ) );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase 'Group':\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.Group();\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tdefault:\r\n\t\r\n\t\t\t\t\t\tobject = new THREE.Object3D();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tobject.uuid = data.uuid;\r\n\t\r\n\t\t\t\tif ( data.name !== undefined ) object.name = data.name;\r\n\t\t\t\tif ( data.matrix !== undefined ) {\r\n\t\r\n\t\t\t\t\tmatrix.fromArray( data.matrix );\r\n\t\t\t\t\tmatrix.decompose( object.position, object.quaternion, object.scale );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\r\n\t\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\r\n\t\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\r\n\t\t\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\r\n\t\r\n\t\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\r\n\t\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\r\n\t\r\n\t\t\t\tif ( data.children !== undefined ) {\r\n\t\r\n\t\t\t\t\tfor ( var child in data.children ) {\r\n\t\r\n\t\t\t\t\t\tobject.add( this.parseObject( data.children[ child ], geometries, materials ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( data.type === 'LOD' ) {\r\n\t\r\n\t\t\t\t\tvar levels = data.levels;\r\n\t\r\n\t\t\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar level = levels[ l ];\r\n\t\t\t\t\t\tvar child = object.getObjectByProperty( 'uuid', level.object );\r\n\t\r\n\t\t\t\t\t\tif ( child !== undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tobject.addLevel( child, level.distance );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn object;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}()\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/TextureLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.TextureLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TextureLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.TextureLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar texture = new THREE.Texture();\r\n\t\r\n\t\t\tvar loader = new THREE.ImageLoader( this.manager );\r\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\t\tloader.setPath( this.path );\r\n\t\t\tloader.load( url, function ( image ) {\r\n\t\r\n\t\t\t\ttexture.image = image;\r\n\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\tif ( onLoad !== undefined ) {\r\n\t\r\n\t\t\t\t\tonLoad( texture );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetCrossOrigin: function ( value ) {\r\n\t\r\n\t\t\tthis.crossOrigin = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetPath: function ( value ) {\r\n\t\r\n\t\t\tthis.path = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/CubeTextureLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.CubeTextureLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CubeTextureLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.CubeTextureLoader,\r\n\t\r\n\t\tload: function ( urls, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar texture = new THREE.CubeTexture();\r\n\t\r\n\t\t\tvar loader = new THREE.ImageLoader( this.manager );\r\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\t\tloader.setPath( this.path );\r\n\t\r\n\t\t\tvar loaded = 0;\r\n\t\r\n\t\t\tfunction loadTexture( i ) {\r\n\t\r\n\t\t\t\tloader.load( urls[ i ], function ( image ) {\r\n\t\r\n\t\t\t\t\ttexture.images[ i ] = image;\r\n\t\r\n\t\t\t\t\tloaded ++;\r\n\t\r\n\t\t\t\t\tif ( loaded === 6 ) {\r\n\t\r\n\t\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}, undefined, onError );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0; i < urls.length; ++ i ) {\r\n\t\r\n\t\t\t\tloadTexture( i );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetCrossOrigin: function ( value ) {\r\n\t\r\n\t\t\tthis.crossOrigin = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetPath: function ( value ) {\r\n\t\r\n\t\t\tthis.path = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/BinaryTextureLoader.js\r\n\t\r\n\t/**\r\n\t * @author Nikos M. / https://github.com/foo123/\r\n\t *\r\n\t * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\r\n\t */\r\n\t\r\n\tTHREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t\t// override in sub classes\r\n\t\tthis._parser = null;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BinaryTextureLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.BinaryTextureLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar texture = new THREE.DataTexture();\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\r\n\t\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\r\n\t\t\tloader.load( url, function ( buffer ) {\r\n\t\r\n\t\t\t\tvar texData = scope._parser( buffer );\r\n\t\r\n\t\t\t\tif ( ! texData ) return;\r\n\t\r\n\t\t\t\tif ( undefined !== texData.image ) {\r\n\t\r\n\t\t\t\t\ttexture.image = texData.image;\r\n\t\r\n\t\t\t\t} else if ( undefined !== texData.data ) {\r\n\t\r\n\t\t\t\t\ttexture.image.width = texData.width;\r\n\t\t\t\t\ttexture.image.height = texData.height;\r\n\t\t\t\t\ttexture.image.data = texData.data;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;\r\n\t\t\t\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;\r\n\t\r\n\t\t\t\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;\r\n\t\t\t\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;\r\n\t\r\n\t\t\t\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\r\n\t\r\n\t\t\t\tif ( undefined !== texData.format ) {\r\n\t\r\n\t\t\t\t\ttexture.format = texData.format;\r\n\t\r\n\t\t\t\t}\r\n\t\t\t\tif ( undefined !== texData.type ) {\r\n\t\r\n\t\t\t\t\ttexture.type = texData.type;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( undefined !== texData.mipmaps ) {\r\n\t\r\n\t\t\t\t\ttexture.mipmaps = texData.mipmaps;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( 1 === texData.mipmapCount ) {\r\n\t\r\n\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\tif ( onLoad ) onLoad( texture, texData );\r\n\t\r\n\t\t\t}, onProgress, onError );\r\n\t\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/loaders/CompressedTextureLoader.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t *\r\n\t * Abstract Base class to block based textures loader (dds, pvr, ...)\r\n\t */\r\n\t\r\n\tTHREE.CompressedTextureLoader = function ( manager ) {\r\n\t\r\n\t\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\t\r\n\t\t// override in sub classes\r\n\t\tthis._parser = null;\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.CompressedTextureLoader.prototype = {\r\n\t\r\n\t\tconstructor: THREE.CompressedTextureLoader,\r\n\t\r\n\t\tload: function ( url, onLoad, onProgress, onError ) {\r\n\t\r\n\t\t\tvar scope = this;\r\n\t\r\n\t\t\tvar images = [];\r\n\t\r\n\t\t\tvar texture = new THREE.CompressedTexture();\r\n\t\t\ttexture.image = images;\r\n\t\r\n\t\t\tvar loader = new THREE.XHRLoader( this.manager );\r\n\t\t\tloader.setPath( this.path );\r\n\t\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\r\n\t\t\tfunction loadTexture( i ) {\r\n\t\r\n\t\t\t\tloader.load( url[ i ], function ( buffer ) {\r\n\t\r\n\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\r\n\t\r\n\t\t\t\t\timages[ i ] = {\r\n\t\t\t\t\t\twidth: texDatas.width,\r\n\t\t\t\t\t\theight: texDatas.height,\r\n\t\t\t\t\t\tformat: texDatas.format,\r\n\t\t\t\t\t\tmipmaps: texDatas.mipmaps\r\n\t\t\t\t\t};\r\n\t\r\n\t\t\t\t\tloaded += 1;\r\n\t\r\n\t\t\t\t\tif ( loaded === 6 ) {\r\n\t\r\n\t\t\t\t\t\tif ( texDatas.mipmapCount === 1 )\r\n\t\t\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\r\n\t\r\n\t\t\t\t\t\ttexture.format = texDatas.format;\r\n\t\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( Array.isArray( url ) ) {\r\n\t\r\n\t\t\t\tvar loaded = 0;\r\n\t\r\n\t\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\r\n\t\r\n\t\t\t\t\tloadTexture( i );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// compressed cubemap texture stored in a single DDS file\r\n\t\r\n\t\t\t\tloader.load( url, function ( buffer ) {\r\n\t\r\n\t\t\t\t\tvar texDatas = scope._parser( buffer, true );\r\n\t\r\n\t\t\t\t\tif ( texDatas.isCubemap ) {\r\n\t\r\n\t\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\r\n\t\r\n\t\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\r\n\t\r\n\t\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\r\n\t\r\n\t\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\r\n\t\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\r\n\t\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\r\n\t\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\ttexture.image.width = texDatas.width;\r\n\t\t\t\t\t\ttexture.image.height = texDatas.height;\r\n\t\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\r\n\t\r\n\t\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttexture.format = texDatas.format;\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\t\r\n\t\t\t\t}, onProgress, onError );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetPath: function ( value ) {\r\n\t\r\n\t\t\tthis.path = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/Material.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Material = function () {\r\n\t\r\n\t\tObject.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.name = '';\r\n\t\tthis.type = 'Material';\r\n\t\r\n\t\tthis.fog = true;\r\n\t\tthis.lights = true;\r\n\t\r\n\t\tthis.blending = THREE.NormalBlending;\r\n\t\tthis.side = THREE.FrontSide;\r\n\t\tthis.shading = THREE.SmoothShading; // THREE.FlatShading, THREE.SmoothShading\r\n\t\tthis.vertexColors = THREE.NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors\r\n\t\r\n\t\tthis.opacity = 1;\r\n\t\tthis.transparent = false;\r\n\t\r\n\t\tthis.blendSrc = THREE.SrcAlphaFactor;\r\n\t\tthis.blendDst = THREE.OneMinusSrcAlphaFactor;\r\n\t\tthis.blendEquation = THREE.AddEquation;\r\n\t\tthis.blendSrcAlpha = null;\r\n\t\tthis.blendDstAlpha = null;\r\n\t\tthis.blendEquationAlpha = null;\r\n\t\r\n\t\tthis.depthFunc = THREE.LessEqualDepth;\r\n\t\tthis.depthTest = true;\r\n\t\tthis.depthWrite = true;\r\n\t\r\n\t\tthis.clippingPlanes = null;\r\n\t\tthis.clipShadows = false;\r\n\t\r\n\t\tthis.colorWrite = true;\r\n\t\r\n\t\tthis.precision = null; // override the renderer's default precision for this material\r\n\t\r\n\t\tthis.polygonOffset = false;\r\n\t\tthis.polygonOffsetFactor = 0;\r\n\t\tthis.polygonOffsetUnits = 0;\r\n\t\r\n\t\tthis.alphaTest = 0;\r\n\t\tthis.premultipliedAlpha = false;\r\n\t\r\n\t\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\r\n\t\r\n\t\tthis.visible = true;\r\n\t\r\n\t\tthis._needsUpdate = true;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Material.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Material,\r\n\t\r\n\t\tget needsUpdate() {\r\n\t\r\n\t\t\treturn this._needsUpdate;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset needsUpdate( value ) {\r\n\t\r\n\t\t\tif ( value === true ) this.update();\r\n\t\t\tthis._needsUpdate = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsetValues: function ( values ) {\r\n\t\r\n\t\t\tif ( values === undefined ) return;\r\n\t\r\n\t\t\tfor ( var key in values ) {\r\n\t\r\n\t\t\t\tvar newValue = values[ key ];\r\n\t\r\n\t\t\t\tif ( newValue === undefined ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\r\n\t\t\t\t\tcontinue;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar currentValue = this[ key ];\r\n\t\r\n\t\t\t\tif ( currentValue === undefined ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( \"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\" );\r\n\t\t\t\t\tcontinue;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( currentValue instanceof THREE.Color ) {\r\n\t\r\n\t\t\t\t\tcurrentValue.set( newValue );\r\n\t\r\n\t\t\t\t} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {\r\n\t\r\n\t\t\t\t\tcurrentValue.copy( newValue );\r\n\t\r\n\t\t\t\t} else if ( key === 'overdraw' ) {\r\n\t\r\n\t\t\t\t\t// ensure overdraw is backwards-compatible with legacy boolean type\r\n\t\t\t\t\tthis[ key ] = Number( newValue );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis[ key ] = newValue;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoJSON: function ( meta ) {\r\n\t\r\n\t\t\tvar isRoot = meta === undefined;\r\n\t\r\n\t\t\tif ( isRoot ) {\r\n\t\r\n\t\t\t\tmeta = {\r\n\t\t\t\t\ttextures: {},\r\n\t\t\t\t\timages: {}\r\n\t\t\t\t};\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar data = {\r\n\t\t\t\tmetadata: {\r\n\t\t\t\t\tversion: 4.4,\r\n\t\t\t\t\ttype: 'Material',\r\n\t\t\t\t\tgenerator: 'Material.toJSON'\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\r\n\t\t\t// standard Material serialization\r\n\t\t\tdata.uuid = this.uuid;\r\n\t\t\tdata.type = this.type;\r\n\t\r\n\t\t\tif ( this.name !== '' ) data.name = this.name;\r\n\t\r\n\t\t\tif ( this.color instanceof THREE.Color ) data.color = this.color.getHex();\r\n\t\r\n\t\t\tif ( this.roughness !== 0.5 ) data.roughness = this.roughness;\r\n\t\t\tif ( this.metalness !== 0.5 ) data.metalness = this.metalness;\r\n\t\r\n\t\t\tif ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();\r\n\t\t\tif ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();\r\n\t\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\r\n\t\r\n\t\t\tif ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;\r\n\t\t\tif ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\r\n\t\t\tif ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\r\n\t\t\tif ( this.bumpMap instanceof THREE.Texture ) {\r\n\t\r\n\t\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\r\n\t\t\t\tdata.bumpScale = this.bumpScale;\r\n\t\r\n\t\t\t}\r\n\t\t\tif ( this.normalMap instanceof THREE.Texture ) {\r\n\t\r\n\t\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\r\n\t\t\t\tdata.normalScale = this.normalScale.toArray();\r\n\t\r\n\t\t\t}\r\n\t\t\tif ( this.displacementMap instanceof THREE.Texture ) {\r\n\t\r\n\t\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\r\n\t\t\t\tdata.displacementScale = this.displacementScale;\r\n\t\t\t\tdata.displacementBias = this.displacementBias;\r\n\t\r\n\t\t\t}\r\n\t\t\tif ( this.roughnessMap instanceof THREE.Texture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\r\n\t\t\tif ( this.metalnessMap instanceof THREE.Texture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\r\n\t\r\n\t\t\tif ( this.emissiveMap instanceof THREE.Texture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\r\n\t\t\tif ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\r\n\t\r\n\t\t\tif ( this.envMap instanceof THREE.Texture ) {\r\n\t\r\n\t\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\r\n\t\t\t\tdata.reflectivity = this.reflectivity; // Scale behind envMap\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.size !== undefined ) data.size = this.size;\r\n\t\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\r\n\t\r\n\t\t\tif ( this.blending !== THREE.NormalBlending ) data.blending = this.blending;\r\n\t\t\tif ( this.shading !== THREE.SmoothShading ) data.shading = this.shading;\r\n\t\t\tif ( this.side !== THREE.FrontSide ) data.side = this.side;\r\n\t\t\tif ( this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;\r\n\t\r\n\t\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\r\n\t\t\tif ( this.transparent === true ) data.transparent = this.transparent;\r\n\t\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\r\n\t\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\r\n\t\t\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\r\n\t\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\r\n\t\r\n\t\t\t// TODO: Copied from Object3D.toJSON\r\n\t\r\n\t\t\tfunction extractFromCache ( cache ) {\r\n\t\r\n\t\t\t\tvar values = [];\r\n\t\r\n\t\t\t\tfor ( var key in cache ) {\r\n\t\r\n\t\t\t\t\tvar data = cache[ key ];\r\n\t\t\t\t\tdelete data.metadata;\r\n\t\t\t\t\tvalues.push( data );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn values;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( isRoot ) {\r\n\t\r\n\t\t\t\tvar textures = extractFromCache( meta.textures );\r\n\t\t\t\tvar images = extractFromCache( meta.images );\r\n\t\r\n\t\t\t\tif ( textures.length > 0 ) data.textures = textures;\r\n\t\t\t\tif ( images.length > 0 ) data.images = images;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn data;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tthis.name = source.name;\r\n\t\r\n\t\t\tthis.fog = source.fog;\r\n\t\t\tthis.lights = source.lights;\r\n\t\r\n\t\t\tthis.blending = source.blending;\r\n\t\t\tthis.side = source.side;\r\n\t\t\tthis.vertexColors = source.vertexColors;\r\n\t\r\n\t\t\tthis.opacity = source.opacity;\r\n\t\t\tthis.transparent = source.transparent;\r\n\t\r\n\t\t\tthis.blendSrc = source.blendSrc;\r\n\t\t\tthis.blendDst = source.blendDst;\r\n\t\t\tthis.blendEquation = source.blendEquation;\r\n\t\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\r\n\t\t\tthis.blendDstAlpha = source.blendDstAlpha;\r\n\t\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\r\n\t\r\n\t\t\tthis.depthFunc = source.depthFunc;\r\n\t\t\tthis.depthTest = source.depthTest;\r\n\t\t\tthis.depthWrite = source.depthWrite;\r\n\t\r\n\t\t\tthis.colorWrite = source.colorWrite;\r\n\t\r\n\t\t\tthis.precision = source.precision;\r\n\t\r\n\t\t\tthis.polygonOffset = source.polygonOffset;\r\n\t\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\r\n\t\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\r\n\t\r\n\t\t\tthis.alphaTest = source.alphaTest;\r\n\t\r\n\t\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\r\n\t\r\n\t\t\tthis.overdraw = source.overdraw;\r\n\t\r\n\t\t\tthis.visible = source.visible;\r\n\t\t\tthis.clipShadows = source.clipShadows;\r\n\t\r\n\t\t\tvar srcPlanes = source.clippingPlanes,\r\n\t\t\t\tdstPlanes = null;\r\n\t\r\n\t\t\tif ( srcPlanes !== null ) {\r\n\t\r\n\t\t\t\tvar n = srcPlanes.length;\r\n\t\t\t\tdstPlanes = new Array( n );\r\n\t\r\n\t\t\t\tfor ( var i = 0; i !== n; ++ i )\r\n\t\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.clippingPlanes = dstPlanes;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdate: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'update' } );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispose: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tObject.assign( THREE.Material.prototype, THREE.EventDispatcher.prototype );\r\n\t\r\n\tTHREE.MaterialIdCount = 0;\r\n\t\r\n\t// File:src/materials/LineBasicMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  linewidth: <float>,\r\n\t *  linecap: \"round\",\r\n\t *  linejoin: \"round\"\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.LineBasicMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'LineBasicMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff );\r\n\t\r\n\t\tthis.linewidth = 1;\r\n\t\tthis.linecap = 'round';\r\n\t\tthis.linejoin = 'round';\r\n\t\r\n\t\tthis.lights = false;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;\r\n\t\r\n\tTHREE.LineBasicMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.color.copy( source.color );\r\n\t\r\n\t\tthis.linewidth = source.linewidth;\r\n\t\tthis.linecap = source.linecap;\r\n\t\tthis.linejoin = source.linejoin;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/LineDashedMaterial.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  linewidth: <float>,\r\n\t *\r\n\t *  scale: <float>,\r\n\t *  dashSize: <float>,\r\n\t *  gapSize: <float>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.LineDashedMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'LineDashedMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff );\r\n\t\r\n\t\tthis.linewidth = 1;\r\n\t\r\n\t\tthis.scale = 1;\r\n\t\tthis.dashSize = 3;\r\n\t\tthis.gapSize = 1;\r\n\t\r\n\t\tthis.lights = false;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;\r\n\t\r\n\tTHREE.LineDashedMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.color.copy( source.color );\r\n\t\r\n\t\tthis.linewidth = source.linewidth;\r\n\t\r\n\t\tthis.scale = source.scale;\r\n\t\tthis.dashSize = source.dashSize;\r\n\t\tthis.gapSize = source.gapSize;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshBasicMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  opacity: <float>,\r\n\t *  map: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  aoMap: new THREE.Texture( <Image> ),\r\n\t *  aoMapIntensity: <float>\r\n\t *\r\n\t *  specularMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  alphaMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n\t *  combine: THREE.Multiply,\r\n\t *  reflectivity: <float>,\r\n\t *  refractionRatio: <float>,\r\n\t *\r\n\t *  shading: THREE.SmoothShading,\r\n\t *  depthTest: <bool>,\r\n\t *  depthWrite: <bool>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>,\r\n\t *\r\n\t *  skinning: <bool>,\r\n\t *  morphTargets: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.MeshBasicMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'MeshBasicMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff ); // emissive\r\n\t\r\n\t\tthis.map = null;\r\n\t\r\n\t\tthis.aoMap = null;\r\n\t\tthis.aoMapIntensity = 1.0;\r\n\t\r\n\t\tthis.specularMap = null;\r\n\t\r\n\t\tthis.alphaMap = null;\r\n\t\r\n\t\tthis.envMap = null;\r\n\t\tthis.combine = THREE.MultiplyOperation;\r\n\t\tthis.reflectivity = 1;\r\n\t\tthis.refractionRatio = 0.98;\r\n\t\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\tthis.wireframeLinecap = 'round';\r\n\t\tthis.wireframeLinejoin = 'round';\r\n\t\r\n\t\tthis.skinning = false;\r\n\t\tthis.morphTargets = false;\r\n\t\r\n\t\tthis.lights = false;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;\r\n\t\r\n\tTHREE.MeshBasicMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.color.copy( source.color );\r\n\t\r\n\t\tthis.map = source.map;\r\n\t\r\n\t\tthis.aoMap = source.aoMap;\r\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\r\n\t\r\n\t\tthis.specularMap = source.specularMap;\r\n\t\r\n\t\tthis.alphaMap = source.alphaMap;\r\n\t\r\n\t\tthis.envMap = source.envMap;\r\n\t\tthis.combine = source.combine;\r\n\t\tthis.reflectivity = source.reflectivity;\r\n\t\tthis.refractionRatio = source.refractionRatio;\r\n\t\r\n\t\tthis.wireframe = source.wireframe;\r\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\r\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\r\n\t\r\n\t\tthis.skinning = source.skinning;\r\n\t\tthis.morphTargets = source.morphTargets;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshDepthMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author bhouston / https://clara.io\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t *\r\n\t * parameters = {\r\n\t *\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  map: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  alphaMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  displacementMap: new THREE.Texture( <Image> ),\r\n\t *  displacementScale: <float>,\r\n\t *  displacementBias: <float>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.MeshDepthMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'MeshDepthMaterial';\r\n\t\r\n\t\tthis.depthPacking = THREE.BasicDepthPacking;\r\n\t\r\n\t\tthis.skinning = false;\r\n\t\tthis.morphTargets = false;\r\n\t\r\n\t\tthis.map = null;\r\n\t\r\n\t\tthis.alphaMap = null;\r\n\t\r\n\t\tthis.displacementMap = null;\r\n\t\tthis.displacementScale = 1;\r\n\t\tthis.displacementBias = 0;\r\n\t\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\r\n\t\tthis.fog = false;\r\n\t\tthis.lights = false;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;\r\n\t\r\n\tTHREE.MeshDepthMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.depthPacking = source.depthPacking;\r\n\t\r\n\t\tthis.skinning = source.skinning;\r\n\t\tthis.morphTargets = source.morphTargets;\r\n\t\r\n\t\tthis.map = source.map;\r\n\t\r\n\t\tthis.alphaMap = source.alphaMap;\r\n\t\r\n\t\tthis.displacementMap = source.displacementMap;\r\n\t\tthis.displacementScale = source.displacementScale;\r\n\t\tthis.displacementBias = source.displacementBias;\r\n\t\r\n\t\tthis.wireframe = source.wireframe;\r\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshLambertMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  map: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  lightMap: new THREE.Texture( <Image> ),\r\n\t *  lightMapIntensity: <float>\r\n\t *\r\n\t *  aoMap: new THREE.Texture( <Image> ),\r\n\t *  aoMapIntensity: <float>\r\n\t *\r\n\t *  emissive: <hex>,\r\n\t *  emissiveIntensity: <float>\r\n\t *  emissiveMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  specularMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  alphaMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n\t *  combine: THREE.Multiply,\r\n\t *  reflectivity: <float>,\r\n\t *  refractionRatio: <float>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>,\r\n\t *\r\n\t *  skinning: <bool>,\r\n\t *  morphTargets: <bool>,\r\n\t *  morphNormals: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.MeshLambertMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'MeshLambertMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\t\r\n\t\tthis.map = null;\r\n\t\r\n\t\tthis.lightMap = null;\r\n\t\tthis.lightMapIntensity = 1.0;\r\n\t\r\n\t\tthis.aoMap = null;\r\n\t\tthis.aoMapIntensity = 1.0;\r\n\t\r\n\t\tthis.emissive = new THREE.Color( 0x000000 );\r\n\t\tthis.emissiveIntensity = 1.0;\r\n\t\tthis.emissiveMap = null;\r\n\t\r\n\t\tthis.specularMap = null;\r\n\t\r\n\t\tthis.alphaMap = null;\r\n\t\r\n\t\tthis.envMap = null;\r\n\t\tthis.combine = THREE.MultiplyOperation;\r\n\t\tthis.reflectivity = 1;\r\n\t\tthis.refractionRatio = 0.98;\r\n\t\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\tthis.wireframeLinecap = 'round';\r\n\t\tthis.wireframeLinejoin = 'round';\r\n\t\r\n\t\tthis.skinning = false;\r\n\t\tthis.morphTargets = false;\r\n\t\tthis.morphNormals = false;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;\r\n\t\r\n\tTHREE.MeshLambertMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.color.copy( source.color );\r\n\t\r\n\t\tthis.map = source.map;\r\n\t\r\n\t\tthis.lightMap = source.lightMap;\r\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\r\n\t\r\n\t\tthis.aoMap = source.aoMap;\r\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\r\n\t\r\n\t\tthis.emissive.copy( source.emissive );\r\n\t\tthis.emissiveMap = source.emissiveMap;\r\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\r\n\t\r\n\t\tthis.specularMap = source.specularMap;\r\n\t\r\n\t\tthis.alphaMap = source.alphaMap;\r\n\t\r\n\t\tthis.envMap = source.envMap;\r\n\t\tthis.combine = source.combine;\r\n\t\tthis.reflectivity = source.reflectivity;\r\n\t\tthis.refractionRatio = source.refractionRatio;\r\n\t\r\n\t\tthis.wireframe = source.wireframe;\r\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\r\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\r\n\t\r\n\t\tthis.skinning = source.skinning;\r\n\t\tthis.morphTargets = source.morphTargets;\r\n\t\tthis.morphNormals = source.morphNormals;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshNormalMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.MeshNormalMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this, parameters );\r\n\t\r\n\t\tthis.type = 'MeshNormalMaterial';\r\n\t\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\r\n\t\tthis.fog = false;\r\n\t\tthis.lights = false;\r\n\t\tthis.morphTargets = false;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;\r\n\t\r\n\tTHREE.MeshNormalMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.wireframe = source.wireframe;\r\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshPhongMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  specular: <hex>,\r\n\t *  shininess: <float>,\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  map: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  lightMap: new THREE.Texture( <Image> ),\r\n\t *  lightMapIntensity: <float>\r\n\t *\r\n\t *  aoMap: new THREE.Texture( <Image> ),\r\n\t *  aoMapIntensity: <float>\r\n\t *\r\n\t *  emissive: <hex>,\r\n\t *  emissiveIntensity: <float>\r\n\t *  emissiveMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  bumpMap: new THREE.Texture( <Image> ),\r\n\t *  bumpScale: <float>,\r\n\t *\r\n\t *  normalMap: new THREE.Texture( <Image> ),\r\n\t *  normalScale: <Vector2>,\r\n\t *\r\n\t *  displacementMap: new THREE.Texture( <Image> ),\r\n\t *  displacementScale: <float>,\r\n\t *  displacementBias: <float>,\r\n\t *\r\n\t *  specularMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  alphaMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n\t *  combine: THREE.Multiply,\r\n\t *  reflectivity: <float>,\r\n\t *  refractionRatio: <float>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>,\r\n\t *\r\n\t *  skinning: <bool>,\r\n\t *  morphTargets: <bool>,\r\n\t *  morphNormals: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.MeshPhongMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'MeshPhongMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\t\tthis.specular = new THREE.Color( 0x111111 );\r\n\t\tthis.shininess = 30;\r\n\t\r\n\t\tthis.map = null;\r\n\t\r\n\t\tthis.lightMap = null;\r\n\t\tthis.lightMapIntensity = 1.0;\r\n\t\r\n\t\tthis.aoMap = null;\r\n\t\tthis.aoMapIntensity = 1.0;\r\n\t\r\n\t\tthis.emissive = new THREE.Color( 0x000000 );\r\n\t\tthis.emissiveIntensity = 1.0;\r\n\t\tthis.emissiveMap = null;\r\n\t\r\n\t\tthis.bumpMap = null;\r\n\t\tthis.bumpScale = 1;\r\n\t\r\n\t\tthis.normalMap = null;\r\n\t\tthis.normalScale = new THREE.Vector2( 1, 1 );\r\n\t\r\n\t\tthis.displacementMap = null;\r\n\t\tthis.displacementScale = 1;\r\n\t\tthis.displacementBias = 0;\r\n\t\r\n\t\tthis.specularMap = null;\r\n\t\r\n\t\tthis.alphaMap = null;\r\n\t\r\n\t\tthis.envMap = null;\r\n\t\tthis.combine = THREE.MultiplyOperation;\r\n\t\tthis.reflectivity = 1;\r\n\t\tthis.refractionRatio = 0.98;\r\n\t\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\tthis.wireframeLinecap = 'round';\r\n\t\tthis.wireframeLinejoin = 'round';\r\n\t\r\n\t\tthis.skinning = false;\r\n\t\tthis.morphTargets = false;\r\n\t\tthis.morphNormals = false;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;\r\n\t\r\n\tTHREE.MeshPhongMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.color.copy( source.color );\r\n\t\tthis.specular.copy( source.specular );\r\n\t\tthis.shininess = source.shininess;\r\n\t\r\n\t\tthis.map = source.map;\r\n\t\r\n\t\tthis.lightMap = source.lightMap;\r\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\r\n\t\r\n\t\tthis.aoMap = source.aoMap;\r\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\r\n\t\r\n\t\tthis.emissive.copy( source.emissive );\r\n\t\tthis.emissiveMap = source.emissiveMap;\r\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\r\n\t\r\n\t\tthis.bumpMap = source.bumpMap;\r\n\t\tthis.bumpScale = source.bumpScale;\r\n\t\r\n\t\tthis.normalMap = source.normalMap;\r\n\t\tthis.normalScale.copy( source.normalScale );\r\n\t\r\n\t\tthis.displacementMap = source.displacementMap;\r\n\t\tthis.displacementScale = source.displacementScale;\r\n\t\tthis.displacementBias = source.displacementBias;\r\n\t\r\n\t\tthis.specularMap = source.specularMap;\r\n\t\r\n\t\tthis.alphaMap = source.alphaMap;\r\n\t\r\n\t\tthis.envMap = source.envMap;\r\n\t\tthis.combine = source.combine;\r\n\t\tthis.reflectivity = source.reflectivity;\r\n\t\tthis.refractionRatio = source.refractionRatio;\r\n\t\r\n\t\tthis.wireframe = source.wireframe;\r\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\r\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\r\n\t\r\n\t\tthis.skinning = source.skinning;\r\n\t\tthis.morphTargets = source.morphTargets;\r\n\t\tthis.morphNormals = source.morphNormals;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshStandardMaterial.js\r\n\t\r\n\t/**\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  roughness: <float>,\r\n\t *  metalness: <float>,\r\n\t *  opacity: <float>,\r\n\t *\r\n\t *  map: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  lightMap: new THREE.Texture( <Image> ),\r\n\t *  lightMapIntensity: <float>\r\n\t *\r\n\t *  aoMap: new THREE.Texture( <Image> ),\r\n\t *  aoMapIntensity: <float>\r\n\t *\r\n\t *  emissive: <hex>,\r\n\t *  emissiveIntensity: <float>\r\n\t *  emissiveMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  bumpMap: new THREE.Texture( <Image> ),\r\n\t *  bumpScale: <float>,\r\n\t *\r\n\t *  normalMap: new THREE.Texture( <Image> ),\r\n\t *  normalScale: <Vector2>,\r\n\t *\r\n\t *  displacementMap: new THREE.Texture( <Image> ),\r\n\t *  displacementScale: <float>,\r\n\t *  displacementBias: <float>,\r\n\t *\r\n\t *  roughnessMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  metalnessMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  alphaMap: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\r\n\t *  envMapIntensity: <float>\r\n\t *\r\n\t *  refractionRatio: <float>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>,\r\n\t *\r\n\t *  skinning: <bool>,\r\n\t *  morphTargets: <bool>,\r\n\t *  morphNormals: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.MeshStandardMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.defines = { 'STANDARD': '' };\r\n\t\r\n\t\tthis.type = 'MeshStandardMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\t\tthis.roughness = 0.5;\r\n\t\tthis.metalness = 0.5;\r\n\t\r\n\t\tthis.map = null;\r\n\t\r\n\t\tthis.lightMap = null;\r\n\t\tthis.lightMapIntensity = 1.0;\r\n\t\r\n\t\tthis.aoMap = null;\r\n\t\tthis.aoMapIntensity = 1.0;\r\n\t\r\n\t\tthis.emissive = new THREE.Color( 0x000000 );\r\n\t\tthis.emissiveIntensity = 1.0;\r\n\t\tthis.emissiveMap = null;\r\n\t\r\n\t\tthis.bumpMap = null;\r\n\t\tthis.bumpScale = 1;\r\n\t\r\n\t\tthis.normalMap = null;\r\n\t\tthis.normalScale = new THREE.Vector2( 1, 1 );\r\n\t\r\n\t\tthis.displacementMap = null;\r\n\t\tthis.displacementScale = 1;\r\n\t\tthis.displacementBias = 0;\r\n\t\r\n\t\tthis.roughnessMap = null;\r\n\t\r\n\t\tthis.metalnessMap = null;\r\n\t\r\n\t\tthis.alphaMap = null;\r\n\t\r\n\t\tthis.envMap = null;\r\n\t\tthis.envMapIntensity = 1.0;\r\n\t\r\n\t\tthis.refractionRatio = 0.98;\r\n\t\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\tthis.wireframeLinecap = 'round';\r\n\t\tthis.wireframeLinejoin = 'round';\r\n\t\r\n\t\tthis.skinning = false;\r\n\t\tthis.morphTargets = false;\r\n\t\tthis.morphNormals = false;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshStandardMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.MeshStandardMaterial.prototype.constructor = THREE.MeshStandardMaterial;\r\n\t\r\n\tTHREE.MeshStandardMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.defines = { 'STANDARD': '' };\r\n\t\r\n\t\tthis.color.copy( source.color );\r\n\t\tthis.roughness = source.roughness;\r\n\t\tthis.metalness = source.metalness;\r\n\t\r\n\t\tthis.map = source.map;\r\n\t\r\n\t\tthis.lightMap = source.lightMap;\r\n\t\tthis.lightMapIntensity = source.lightMapIntensity;\r\n\t\r\n\t\tthis.aoMap = source.aoMap;\r\n\t\tthis.aoMapIntensity = source.aoMapIntensity;\r\n\t\r\n\t\tthis.emissive.copy( source.emissive );\r\n\t\tthis.emissiveMap = source.emissiveMap;\r\n\t\tthis.emissiveIntensity = source.emissiveIntensity;\r\n\t\r\n\t\tthis.bumpMap = source.bumpMap;\r\n\t\tthis.bumpScale = source.bumpScale;\r\n\t\r\n\t\tthis.normalMap = source.normalMap;\r\n\t\tthis.normalScale.copy( source.normalScale );\r\n\t\r\n\t\tthis.displacementMap = source.displacementMap;\r\n\t\tthis.displacementScale = source.displacementScale;\r\n\t\tthis.displacementBias = source.displacementBias;\r\n\t\r\n\t\tthis.roughnessMap = source.roughnessMap;\r\n\t\r\n\t\tthis.metalnessMap = source.metalnessMap;\r\n\t\r\n\t\tthis.alphaMap = source.alphaMap;\r\n\t\r\n\t\tthis.envMap = source.envMap;\r\n\t\tthis.envMapIntensity = source.envMapIntensity;\r\n\t\r\n\t\tthis.refractionRatio = source.refractionRatio;\r\n\t\r\n\t\tthis.wireframe = source.wireframe;\r\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\t\tthis.wireframeLinecap = source.wireframeLinecap;\r\n\t\tthis.wireframeLinejoin = source.wireframeLinejoin;\r\n\t\r\n\t\tthis.skinning = source.skinning;\r\n\t\tthis.morphTargets = source.morphTargets;\r\n\t\tthis.morphNormals = source.morphNormals;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MeshPhysicalMaterial.js\r\n\t\r\n\t/**\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t *\r\n\t * parameters = {\r\n\t *  reflectivity: <float>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.MeshPhysicalMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.MeshStandardMaterial.call( this );\r\n\t\r\n\t\tthis.defines = { 'PHYSICAL': '' };\r\n\t\r\n\t\tthis.type = 'MeshPhysicalMaterial';\r\n\t\r\n\t\tthis.reflectivity = 0.5; // maps to F0 = 0.04\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MeshPhysicalMaterial.prototype = Object.create( THREE.MeshStandardMaterial.prototype );\r\n\tTHREE.MeshPhysicalMaterial.prototype.constructor = THREE.MeshPhysicalMaterial;\r\n\t\r\n\tTHREE.MeshPhysicalMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.MeshStandardMaterial.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.defines = { 'PHYSICAL': '' };\r\n\t\r\n\t\tthis.reflectivity = source.reflectivity;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/MultiMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.MultiMaterial = function ( materials ) {\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.type = 'MultiMaterial';\r\n\t\r\n\t\tthis.materials = materials instanceof Array ? materials : [];\r\n\t\r\n\t\tthis.visible = true;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MultiMaterial.prototype = {\r\n\t\r\n\t\tconstructor: THREE.MultiMaterial,\r\n\t\r\n\t\ttoJSON: function ( meta ) {\r\n\t\r\n\t\t\tvar output = {\r\n\t\t\t\tmetadata: {\r\n\t\t\t\t\tversion: 4.2,\r\n\t\t\t\t\ttype: 'material',\r\n\t\t\t\t\tgenerator: 'MaterialExporter'\r\n\t\t\t\t},\r\n\t\t\t\tuuid: this.uuid,\r\n\t\t\t\ttype: this.type,\r\n\t\t\t\tmaterials: []\r\n\t\t\t};\r\n\t\r\n\t\t\tvar materials = this.materials;\r\n\t\r\n\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar material = materials[ i ].toJSON( meta );\r\n\t\t\t\tdelete material.metadata;\r\n\t\r\n\t\t\t\toutput.materials.push( material );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\toutput.visible = this.visible;\r\n\t\r\n\t\t\treturn output;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\tvar material = new this.constructor();\r\n\t\r\n\t\t\tfor ( var i = 0; i < this.materials.length; i ++ ) {\r\n\t\r\n\t\t\t\tmaterial.materials.push( this.materials[ i ].clone() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tmaterial.visible = this.visible;\r\n\t\r\n\t\t\treturn material;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/PointsMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  opacity: <float>,\r\n\t *  map: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *  size: <float>,\r\n\t *  sizeAttenuation: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.PointsMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'PointsMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff );\r\n\t\r\n\t\tthis.map = null;\r\n\t\r\n\t\tthis.size = 1;\r\n\t\tthis.sizeAttenuation = true;\r\n\t\r\n\t\tthis.lights = false;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;\r\n\t\r\n\tTHREE.PointsMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.color.copy( source.color );\r\n\t\r\n\t\tthis.map = source.map;\r\n\t\r\n\t\tthis.size = source.size;\r\n\t\tthis.sizeAttenuation = source.sizeAttenuation;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/ShaderMaterial.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  defines: { \"label\" : \"value\" },\r\n\t *  uniforms: { \"parameter1\": { type: \"1f\", value: 1.0 }, \"parameter2\": { type: \"1i\" value2: 2 } },\r\n\t *\r\n\t *  fragmentShader: <string>,\r\n\t *  vertexShader: <string>,\r\n\t *\r\n\t *  wireframe: <boolean>,\r\n\t *  wireframeLinewidth: <float>,\r\n\t *\r\n\t *  lights: <bool>,\r\n\t *\r\n\t *  skinning: <bool>,\r\n\t *  morphTargets: <bool>,\r\n\t *  morphNormals: <bool>\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.ShaderMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'ShaderMaterial';\r\n\t\r\n\t\tthis.defines = {};\r\n\t\tthis.uniforms = {};\r\n\t\r\n\t\tthis.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\r\n\t\tthis.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\r\n\t\r\n\t\tthis.linewidth = 1;\r\n\t\r\n\t\tthis.wireframe = false;\r\n\t\tthis.wireframeLinewidth = 1;\r\n\t\r\n\t\tthis.fog = false; // set to use scene fog\r\n\t\tthis.lights = false; // set to use scene lights\r\n\t\tthis.clipping = false; // set to use user-defined clipping planes\r\n\t\r\n\t\tthis.skinning = false; // set to use skinning attribute streams\r\n\t\tthis.morphTargets = false; // set to use morph targets\r\n\t\tthis.morphNormals = false; // set to use morph normals\r\n\t\r\n\t\tthis.extensions = {\r\n\t\t\tderivatives: false, // set to use derivatives\r\n\t\t\tfragDepth: false, // set to use fragment depth values\r\n\t\t\tdrawBuffers: false, // set to use draw buffers\r\n\t\t\tshaderTextureLOD: false // set to use shader texture LOD\r\n\t\t};\r\n\t\r\n\t\t// When rendered geometry doesn't include these attributes but the material does,\r\n\t\t// use these default values in WebGL. This avoids errors when buffer data is missing.\r\n\t\tthis.defaultAttributeValues = {\r\n\t\t\t'color': [ 1, 1, 1 ],\r\n\t\t\t'uv': [ 0, 0 ],\r\n\t\t\t'uv2': [ 0, 0 ]\r\n\t\t};\r\n\t\r\n\t\tthis.index0AttributeName = undefined;\r\n\t\r\n\t\tif ( parameters !== undefined ) {\r\n\t\r\n\t\t\tif ( parameters.attributes !== undefined ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.setValues( parameters );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;\r\n\t\r\n\tTHREE.ShaderMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.fragmentShader = source.fragmentShader;\r\n\t\tthis.vertexShader = source.vertexShader;\r\n\t\r\n\t\tthis.uniforms = THREE.UniformsUtils.clone( source.uniforms );\r\n\t\r\n\t\tthis.defines = source.defines;\r\n\t\r\n\t\tthis.wireframe = source.wireframe;\r\n\t\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\t\r\n\t\tthis.lights = source.lights;\r\n\t\tthis.clipping = source.clipping;\r\n\t\r\n\t\tthis.skinning = source.skinning;\r\n\t\r\n\t\tthis.morphTargets = source.morphTargets;\r\n\t\tthis.morphNormals = source.morphNormals;\r\n\t\r\n\t\tthis.extensions = source.extensions;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ShaderMaterial.prototype.toJSON = function ( meta ) {\r\n\t\r\n\t\tvar data = THREE.Material.prototype.toJSON.call( this, meta );\r\n\t\r\n\t\tdata.uniforms = this.uniforms;\r\n\t\tdata.vertexShader = this.vertexShader;\r\n\t\tdata.fragmentShader = this.fragmentShader;\r\n\t\r\n\t\treturn data;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/RawShaderMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.RawShaderMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.ShaderMaterial.call( this, parameters );\r\n\t\r\n\t\tthis.type = 'RawShaderMaterial';\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\r\n\tTHREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;\r\n\t\r\n\t// File:src/materials/SpriteMaterial.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * parameters = {\r\n\t *  color: <hex>,\r\n\t *  opacity: <float>,\r\n\t *  map: new THREE.Texture( <Image> ),\r\n\t *\r\n\t *\tuvOffset: new THREE.Vector2(),\r\n\t *\tuvScale: new THREE.Vector2()\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.SpriteMaterial = function ( parameters ) {\r\n\t\r\n\t\tTHREE.Material.call( this );\r\n\t\r\n\t\tthis.type = 'SpriteMaterial';\r\n\t\r\n\t\tthis.color = new THREE.Color( 0xffffff );\r\n\t\tthis.map = null;\r\n\t\r\n\t\tthis.rotation = 0;\r\n\t\r\n\t\tthis.fog = false;\r\n\t\tthis.lights = false;\r\n\t\r\n\t\tthis.setValues( parameters );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );\r\n\tTHREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;\r\n\t\r\n\tTHREE.SpriteMaterial.prototype.copy = function ( source ) {\r\n\t\r\n\t\tTHREE.Material.prototype.copy.call( this, source );\r\n\t\r\n\t\tthis.color.copy( source.color );\r\n\t\tthis.map = source.map;\r\n\t\r\n\t\tthis.rotation = source.rotation;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/materials/ShadowMaterial.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.ShadowMaterial = function () {\r\n\t\r\n\t\tTHREE.ShaderMaterial.call( this, {\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\t\t\tTHREE.UniformsLib[ \"lights\" ],\r\n\t\t\t\t{\r\n\t\t\t\t\topacity: { value: 1.0 }\r\n\t\t\t\t}\r\n\t\t\t] ),\r\n\t\t\tvertexShader: THREE.ShaderChunk[ 'shadow_vert' ],\r\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'shadow_frag' ]\r\n\t\t} );\r\n\t\r\n\t\tthis.lights = true;\r\n\t\tthis.transparent = true;\r\n\t\r\n\t\tObject.defineProperties( this, {\r\n\t\t\topacity: {\r\n\t\t\t\tenumerable: true,\r\n\t\t\t\tget: function () {\r\n\t\t\t\t\treturn this.uniforms.opacity.value;\r\n\t\t\t\t},\r\n\t\t\t\tset: function ( value ) {\r\n\t\t\t\t\tthis.uniforms.opacity.value = value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ShadowMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\r\n\tTHREE.ShadowMaterial.prototype.constructor = THREE.ShadowMaterial;\r\n\t\r\n\t// File:src/textures/Texture.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author szimek / https://github.com/szimek/\r\n\t */\r\n\t\r\n\tTHREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\r\n\t\r\n\t\tObject.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.name = '';\r\n\t\tthis.sourceFile = '';\r\n\t\r\n\t\tthis.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;\r\n\t\tthis.mipmaps = [];\r\n\t\r\n\t\tthis.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;\r\n\t\r\n\t\tthis.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\r\n\t\tthis.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\r\n\t\r\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\r\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\r\n\t\r\n\t\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\r\n\t\r\n\t\tthis.format = format !== undefined ? format : THREE.RGBAFormat;\r\n\t\tthis.type = type !== undefined ? type : THREE.UnsignedByteType;\r\n\t\r\n\t\tthis.offset = new THREE.Vector2( 0, 0 );\r\n\t\tthis.repeat = new THREE.Vector2( 1, 1 );\r\n\t\r\n\t\tthis.generateMipmaps = true;\r\n\t\tthis.premultiplyAlpha = false;\r\n\t\tthis.flipY = true;\r\n\t\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\r\n\t\r\n\t\r\n\t\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\r\n\t\t//\r\n\t\t// Also changing the encoding after already used by a Material will not automatically make the Material\r\n\t\t// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\r\n\t\tthis.encoding = encoding !== undefined ? encoding :  THREE.LinearEncoding;\r\n\t\r\n\t\tthis.version = 0;\r\n\t\tthis.onUpdate = null;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Texture.DEFAULT_IMAGE = undefined;\r\n\tTHREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;\r\n\t\r\n\tTHREE.Texture.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Texture,\r\n\t\r\n\t\tset needsUpdate( value ) {\r\n\t\r\n\t\t\tif ( value === true ) this.version ++;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tthis.image = source.image;\r\n\t\t\tthis.mipmaps = source.mipmaps.slice( 0 );\r\n\t\r\n\t\t\tthis.mapping = source.mapping;\r\n\t\r\n\t\t\tthis.wrapS = source.wrapS;\r\n\t\t\tthis.wrapT = source.wrapT;\r\n\t\r\n\t\t\tthis.magFilter = source.magFilter;\r\n\t\t\tthis.minFilter = source.minFilter;\r\n\t\r\n\t\t\tthis.anisotropy = source.anisotropy;\r\n\t\r\n\t\t\tthis.format = source.format;\r\n\t\t\tthis.type = source.type;\r\n\t\r\n\t\t\tthis.offset.copy( source.offset );\r\n\t\t\tthis.repeat.copy( source.repeat );\r\n\t\r\n\t\t\tthis.generateMipmaps = source.generateMipmaps;\r\n\t\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\r\n\t\t\tthis.flipY = source.flipY;\r\n\t\t\tthis.unpackAlignment = source.unpackAlignment;\r\n\t\t\tthis.encoding = source.encoding;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoJSON: function ( meta ) {\r\n\t\r\n\t\t\tif ( meta.textures[ this.uuid ] !== undefined ) {\r\n\t\r\n\t\t\t\treturn meta.textures[ this.uuid ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction getDataURL( image ) {\r\n\t\r\n\t\t\t\tvar canvas;\r\n\t\r\n\t\t\t\tif ( image.toDataURL !== undefined ) {\r\n\t\r\n\t\t\t\t\tcanvas = image;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tcanvas = document.createElement( 'canvas' );\r\n\t\t\t\t\tcanvas.width = image.width;\r\n\t\t\t\t\tcanvas.height = image.height;\r\n\t\r\n\t\t\t\t\tcanvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\r\n\t\r\n\t\t\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\treturn canvas.toDataURL( 'image/png' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar output = {\r\n\t\t\t\tmetadata: {\r\n\t\t\t\t\tversion: 4.4,\r\n\t\t\t\t\ttype: 'Texture',\r\n\t\t\t\t\tgenerator: 'Texture.toJSON'\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tuuid: this.uuid,\r\n\t\t\t\tname: this.name,\r\n\t\r\n\t\t\t\tmapping: this.mapping,\r\n\t\r\n\t\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\r\n\t\t\t\toffset: [ this.offset.x, this.offset.y ],\r\n\t\t\t\twrap: [ this.wrapS, this.wrapT ],\r\n\t\r\n\t\t\t\tminFilter: this.minFilter,\r\n\t\t\t\tmagFilter: this.magFilter,\r\n\t\t\t\tanisotropy: this.anisotropy\r\n\t\t\t};\r\n\t\r\n\t\t\tif ( this.image !== undefined ) {\r\n\t\r\n\t\t\t\t// TODO: Move to THREE.Image\r\n\t\r\n\t\t\t\tvar image = this.image;\r\n\t\r\n\t\t\t\tif ( image.uuid === undefined ) {\r\n\t\r\n\t\t\t\t\timage.uuid = THREE.Math.generateUUID(); // UGH\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( meta.images[ image.uuid ] === undefined ) {\r\n\t\r\n\t\t\t\t\tmeta.images[ image.uuid ] = {\r\n\t\t\t\t\t\tuuid: image.uuid,\r\n\t\t\t\t\t\turl: getDataURL( image )\r\n\t\t\t\t\t};\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\toutput.image = image.uuid;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tmeta.textures[ this.uuid ] = output;\r\n\t\r\n\t\t\treturn output;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispose: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttransformUv: function ( uv ) {\r\n\t\r\n\t\t\tif ( this.mapping !== THREE.UVMapping )  return;\r\n\t\r\n\t\t\tuv.multiply( this.repeat );\r\n\t\t\tuv.add( this.offset );\r\n\t\r\n\t\t\tif ( uv.x < 0 || uv.x > 1 ) {\r\n\t\r\n\t\t\t\tswitch ( this.wrapS ) {\r\n\t\r\n\t\t\t\t\tcase THREE.RepeatWrapping:\r\n\t\r\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.ClampToEdgeWrapping:\r\n\t\r\n\t\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.MirroredRepeatWrapping:\r\n\t\r\n\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\r\n\t\r\n\t\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( uv.y < 0 || uv.y > 1 ) {\r\n\t\r\n\t\t\t\tswitch ( this.wrapT ) {\r\n\t\r\n\t\t\t\t\tcase THREE.RepeatWrapping:\r\n\t\r\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.ClampToEdgeWrapping:\r\n\t\r\n\t\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.MirroredRepeatWrapping:\r\n\t\r\n\t\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\r\n\t\r\n\t\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.flipY ) {\r\n\t\r\n\t\t\t\tuv.y = 1 - uv.y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tObject.assign( THREE.Texture.prototype, THREE.EventDispatcher.prototype );\r\n\t\r\n\tTHREE.TextureIdCount = 0;\r\n\t\r\n\t// File:src/textures/DepthTexture.js\r\n\t\r\n\t/**\r\n\t * @author Matt DesLauriers / @mattdesl\r\n\t */\r\n\t\r\n\tTHREE.DepthTexture = function ( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\r\n\t\r\n\t  THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, THREE.DepthFormat, type, anisotropy );\r\n\t\r\n\t  this.image = { width: width, height: height };\r\n\t\r\n\t  this.type = type !== undefined ? type : THREE.UnsignedShortType;\r\n\t\r\n\t  this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;\r\n\t  this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;\r\n\t\r\n\t  this.flipY = false;\r\n\t  this.generateMipmaps  = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DepthTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\tTHREE.DepthTexture.prototype.constructor = THREE.DepthTexture;\r\n\t\r\n\t// File:src/textures/CanvasTexture.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\t\r\n\t\tTHREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\t\r\n\t\tthis.needsUpdate = true;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\tTHREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;\r\n\t\r\n\t// File:src/textures/CubeTexture.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\r\n\t\r\n\t\timages = images !== undefined ? images : [];\r\n\t\tmapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;\r\n\t\r\n\t\tTHREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\r\n\t\r\n\t\tthis.flipY = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\tTHREE.CubeTexture.prototype.constructor = THREE.CubeTexture;\r\n\t\r\n\tObject.defineProperty( THREE.CubeTexture.prototype, 'images', {\r\n\t\r\n\t\tget: function () {\r\n\t\r\n\t\t\treturn this.image;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tset: function ( value ) {\r\n\t\r\n\t\t\tthis.image = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/textures/CompressedTexture.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\r\n\t\r\n\t\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\r\n\t\r\n\t\tthis.image = { width: width, height: height };\r\n\t\tthis.mipmaps = mipmaps;\r\n\t\r\n\t\t// no flipping for cube textures\r\n\t\t// (also flipping doesn't work for compressed textures )\r\n\t\r\n\t\tthis.flipY = false;\r\n\t\r\n\t\t// can't generate mipmaps for compressed textures\r\n\t\t// mips must be embedded in DDS files\r\n\t\r\n\t\tthis.generateMipmaps = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\tTHREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;\r\n\t\r\n\t// File:src/textures/DataTexture.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\r\n\t\r\n\t\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\r\n\t\r\n\t\tthis.image = { data: data, width: width, height: height };\r\n\t\r\n\t\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;\r\n\t\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;\r\n\t\r\n\t\tthis.flipY = false;\r\n\t\tthis.generateMipmaps  = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\tTHREE.DataTexture.prototype.constructor = THREE.DataTexture;\r\n\t\r\n\t// File:src/textures/VideoTexture.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\t\r\n\t\tTHREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\t\r\n\t\tthis.generateMipmaps = false;\r\n\t\r\n\t\tvar scope = this;\r\n\t\r\n\t\tfunction update() {\r\n\t\r\n\t\t\trequestAnimationFrame( update );\r\n\t\r\n\t\t\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\r\n\t\r\n\t\t\t\tscope.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tupdate();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );\r\n\tTHREE.VideoTexture.prototype.constructor = THREE.VideoTexture;\r\n\t\r\n\t// File:src/objects/Group.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Group = function () {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Group';\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Group.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.Group\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/objects/Points.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Points = function ( geometry, material ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Points';\r\n\t\r\n\t\tthis.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();\r\n\t\tthis.material = material !== undefined ? material : new THREE.PointsMaterial( { color: Math.random() * 0xffffff } );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Points.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.Points,\r\n\t\r\n\t\traycast: ( function () {\r\n\t\r\n\t\t\tvar inverseMatrix = new THREE.Matrix4();\r\n\t\t\tvar ray = new THREE.Ray();\r\n\t\t\tvar sphere = new THREE.Sphere();\r\n\t\r\n\t\t\treturn function raycast( raycaster, intersects ) {\r\n\t\r\n\t\t\t\tvar object = this;\r\n\t\t\t\tvar geometry = this.geometry;\r\n\t\t\t\tvar matrixWorld = this.matrixWorld;\r\n\t\t\t\tvar threshold = raycaster.params.Points.threshold;\r\n\t\r\n\t\t\t\t// Checking boundingSphere distance to ray\r\n\t\r\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\t\r\n\t\t\t\tsphere.copy( geometry.boundingSphere );\r\n\t\t\t\tsphere.applyMatrix4( matrixWorld );\r\n\t\r\n\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\r\n\t\r\n\t\t\t\t//\r\n\t\r\n\t\t\t\tinverseMatrix.getInverse( matrixWorld );\r\n\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\t\r\n\t\t\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\r\n\t\t\t\tvar localThresholdSq = localThreshold * localThreshold;\r\n\t\t\t\tvar position = new THREE.Vector3();\r\n\t\r\n\t\t\t\tfunction testPoint( point, index ) {\r\n\t\r\n\t\t\t\t\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\r\n\t\r\n\t\t\t\t\tif ( rayPointDistanceSq < localThresholdSq ) {\r\n\t\r\n\t\t\t\t\t\tvar intersectPoint = ray.closestPointToPoint( point );\r\n\t\t\t\t\t\tintersectPoint.applyMatrix4( matrixWorld );\r\n\t\r\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\r\n\t\r\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\r\n\t\r\n\t\t\t\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\r\n\t\t\t\t\t\t\tpoint: intersectPoint.clone(),\r\n\t\t\t\t\t\t\tindex: index,\r\n\t\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\t\tobject: object\r\n\t\r\n\t\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\t\tvar index = geometry.index;\r\n\t\t\t\t\tvar attributes = geometry.attributes;\r\n\t\t\t\t\tvar positions = attributes.position.array;\r\n\t\r\n\t\t\t\t\tif ( index !== null ) {\r\n\t\r\n\t\t\t\t\t\tvar indices = index.array;\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tvar a = indices[ i ];\r\n\t\r\n\t\t\t\t\t\t\tposition.fromArray( positions, a * 3 );\r\n\t\r\n\t\t\t\t\t\t\ttestPoint( position, a );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tposition.fromArray( positions, i * 3 );\r\n\t\r\n\t\t\t\t\t\t\ttestPoint( position, i );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tvar vertices = geometry.vertices;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\t\ttestPoint( vertices[ i ], i );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}() ),\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/objects/Line.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Line = function ( geometry, material, mode ) {\r\n\t\r\n\t\tif ( mode === 1 ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\r\n\t\t\treturn new THREE.LineSegments( geometry, material );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Line';\r\n\t\r\n\t\tthis.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();\r\n\t\tthis.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Line.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.Line,\r\n\t\r\n\t\traycast: ( function () {\r\n\t\r\n\t\t\tvar inverseMatrix = new THREE.Matrix4();\r\n\t\t\tvar ray = new THREE.Ray();\r\n\t\t\tvar sphere = new THREE.Sphere();\r\n\t\r\n\t\t\treturn function raycast( raycaster, intersects ) {\r\n\t\r\n\t\t\t\tvar precision = raycaster.linePrecision;\r\n\t\t\t\tvar precisionSq = precision * precision;\r\n\t\r\n\t\t\t\tvar geometry = this.geometry;\r\n\t\t\t\tvar matrixWorld = this.matrixWorld;\r\n\t\r\n\t\t\t\t// Checking boundingSphere distance to ray\r\n\t\r\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\t\r\n\t\t\t\tsphere.copy( geometry.boundingSphere );\r\n\t\t\t\tsphere.applyMatrix4( matrixWorld );\r\n\t\r\n\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\r\n\t\r\n\t\t\t\t//\r\n\t\r\n\t\t\t\tinverseMatrix.getInverse( matrixWorld );\r\n\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\t\r\n\t\t\t\tvar vStart = new THREE.Vector3();\r\n\t\t\t\tvar vEnd = new THREE.Vector3();\r\n\t\t\t\tvar interSegment = new THREE.Vector3();\r\n\t\t\t\tvar interRay = new THREE.Vector3();\r\n\t\t\t\tvar step = this instanceof THREE.LineSegments ? 2 : 1;\r\n\t\r\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\t\tvar index = geometry.index;\r\n\t\t\t\t\tvar attributes = geometry.attributes;\r\n\t\t\t\t\tvar positions = attributes.position.array;\r\n\t\r\n\t\t\t\t\tif ( index !== null ) {\r\n\t\r\n\t\t\t\t\t\tvar indices = index.array;\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\r\n\t\r\n\t\t\t\t\t\t\tvar a = indices[ i ];\r\n\t\t\t\t\t\t\tvar b = indices[ i + 1 ];\r\n\t\r\n\t\t\t\t\t\t\tvStart.fromArray( positions, a * 3 );\r\n\t\t\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\r\n\t\r\n\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\r\n\t\r\n\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\t\r\n\t\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\r\n\t\r\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\r\n\t\r\n\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\t\r\n\t\t\t\t\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\t\t\tobject: this\r\n\t\r\n\t\t\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\r\n\t\r\n\t\t\t\t\t\t\tvStart.fromArray( positions, 3 * i );\r\n\t\t\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\r\n\t\r\n\t\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\r\n\t\r\n\t\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\t\r\n\t\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\r\n\t\r\n\t\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\r\n\t\r\n\t\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\t\r\n\t\t\t\t\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\t\t\tobject: this\r\n\t\r\n\t\t\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\t\t\tvar vertices = geometry.vertices;\r\n\t\t\t\t\tvar nbVertices = vertices.length;\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\r\n\t\r\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\r\n\t\r\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\t\r\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\r\n\t\r\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\r\n\t\r\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\t\r\n\t\t\t\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\t\tobject: this\r\n\t\r\n\t\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}() ),\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/objects/LineSegments.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.LineSegments = function ( geometry, material ) {\r\n\t\r\n\t\tTHREE.Line.call( this, geometry, material );\r\n\t\r\n\t\tthis.type = 'LineSegments';\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LineSegments.prototype = Object.assign( Object.create( THREE.Line.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.LineSegments\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/objects/Mesh.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author jonobr1 / http://jonobr1.com/\r\n\t */\r\n\t\r\n\tTHREE.Mesh = function ( geometry, material ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Mesh';\r\n\t\r\n\t\tthis.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();\r\n\t\tthis.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\t\r\n\t\tthis.drawMode = THREE.TrianglesDrawMode;\r\n\t\r\n\t\tthis.updateMorphTargets();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Mesh.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.Mesh,\r\n\t\r\n\t\tsetDrawMode: function ( value ) {\r\n\t\r\n\t\t\tthis.drawMode = value;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdateMorphTargets: function () {\r\n\t\r\n\t\t\tif ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {\r\n\t\r\n\t\t\t\tthis.morphTargetBase = - 1;\r\n\t\t\t\tthis.morphTargetInfluences = [];\r\n\t\t\t\tthis.morphTargetDictionary = {};\r\n\t\r\n\t\t\t\tfor ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {\r\n\t\r\n\t\t\t\t\tthis.morphTargetInfluences.push( 0 );\r\n\t\t\t\t\tthis.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetMorphTargetIndexByName: function ( name ) {\r\n\t\r\n\t\t\tif ( this.morphTargetDictionary[ name ] !== undefined ) {\r\n\t\r\n\t\t\t\treturn this.morphTargetDictionary[ name ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );\r\n\t\r\n\t\t\treturn 0;\r\n\t\r\n\t\t},\r\n\t\r\n\t\traycast: ( function () {\r\n\t\r\n\t\t\tvar inverseMatrix = new THREE.Matrix4();\r\n\t\t\tvar ray = new THREE.Ray();\r\n\t\t\tvar sphere = new THREE.Sphere();\r\n\t\r\n\t\t\tvar vA = new THREE.Vector3();\r\n\t\t\tvar vB = new THREE.Vector3();\r\n\t\t\tvar vC = new THREE.Vector3();\r\n\t\r\n\t\t\tvar tempA = new THREE.Vector3();\r\n\t\t\tvar tempB = new THREE.Vector3();\r\n\t\t\tvar tempC = new THREE.Vector3();\r\n\t\r\n\t\t\tvar uvA = new THREE.Vector2();\r\n\t\t\tvar uvB = new THREE.Vector2();\r\n\t\t\tvar uvC = new THREE.Vector2();\r\n\t\r\n\t\t\tvar barycoord = new THREE.Vector3();\r\n\t\r\n\t\t\tvar intersectionPoint = new THREE.Vector3();\r\n\t\t\tvar intersectionPointWorld = new THREE.Vector3();\r\n\t\r\n\t\t\tfunction uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\r\n\t\r\n\t\t\t\tTHREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\r\n\t\r\n\t\t\t\tuv1.multiplyScalar( barycoord.x );\r\n\t\t\t\tuv2.multiplyScalar( barycoord.y );\r\n\t\t\t\tuv3.multiplyScalar( barycoord.z );\r\n\t\r\n\t\t\t\tuv1.add( uv2 ).add( uv3 );\r\n\t\r\n\t\t\t\treturn uv1.clone();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {\r\n\t\r\n\t\t\t\tvar intersect;\r\n\t\t\t\tvar material = object.material;\r\n\t\r\n\t\t\t\tif ( material.side === THREE.BackSide ) {\r\n\t\r\n\t\t\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== THREE.DoubleSide, point );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( intersect === null ) return null;\r\n\t\r\n\t\t\t\tintersectionPointWorld.copy( point );\r\n\t\t\t\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\r\n\t\r\n\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\r\n\t\r\n\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\r\n\t\r\n\t\t\t\treturn {\r\n\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\tpoint: intersectionPointWorld.clone(),\r\n\t\t\t\t\tobject: object\r\n\t\t\t\t};\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {\r\n\t\r\n\t\t\t\tvA.fromArray( positions, a * 3 );\r\n\t\t\t\tvB.fromArray( positions, b * 3 );\r\n\t\t\t\tvC.fromArray( positions, c * 3 );\r\n\t\r\n\t\t\t\tvar intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );\r\n\t\r\n\t\t\t\tif ( intersection ) {\r\n\t\r\n\t\t\t\t\tif ( uvs ) {\r\n\t\r\n\t\t\t\t\t\tuvA.fromArray( uvs, a * 2 );\r\n\t\t\t\t\t\tuvB.fromArray( uvs, b * 2 );\r\n\t\t\t\t\t\tuvC.fromArray( uvs, c * 2 );\r\n\t\r\n\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tintersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );\r\n\t\t\t\t\tintersection.faceIndex = a;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn intersection;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn function raycast( raycaster, intersects ) {\r\n\t\r\n\t\t\t\tvar geometry = this.geometry;\r\n\t\t\t\tvar material = this.material;\r\n\t\t\t\tvar matrixWorld = this.matrixWorld;\r\n\t\r\n\t\t\t\tif ( material === undefined ) return;\r\n\t\r\n\t\t\t\t// Checking boundingSphere distance to ray\r\n\t\r\n\t\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\t\r\n\t\t\t\tsphere.copy( geometry.boundingSphere );\r\n\t\t\t\tsphere.applyMatrix4( matrixWorld );\r\n\t\r\n\t\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\r\n\t\r\n\t\t\t\t//\r\n\t\r\n\t\t\t\tinverseMatrix.getInverse( matrixWorld );\r\n\t\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\t\r\n\t\t\t\t// Check boundingBox before continuing\r\n\t\r\n\t\t\t\tif ( geometry.boundingBox !== null ) {\r\n\t\r\n\t\t\t\t\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar uvs, intersection;\r\n\t\r\n\t\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\t\tvar a, b, c;\r\n\t\t\t\t\tvar index = geometry.index;\r\n\t\t\t\t\tvar attributes = geometry.attributes;\r\n\t\t\t\t\tvar positions = attributes.position.array;\r\n\t\r\n\t\t\t\t\tif ( attributes.uv !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tuvs = attributes.uv.array;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( index !== null ) {\r\n\t\r\n\t\t\t\t\t\tvar indices = index.array;\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\t\ta = indices[ i ];\r\n\t\t\t\t\t\t\tb = indices[ i + 1 ];\r\n\t\t\t\t\t\t\tc = indices[ i + 2 ];\r\n\t\r\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\r\n\t\r\n\t\t\t\t\t\t\tif ( intersection ) {\r\n\t\r\n\t\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics\r\n\t\t\t\t\t\t\t\tintersects.push( intersection );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\r\n\t\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 9 ) {\r\n\t\r\n\t\t\t\t\t\t\ta = i / 3;\r\n\t\t\t\t\t\t\tb = a + 1;\r\n\t\t\t\t\t\t\tc = a + 2;\r\n\t\r\n\t\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\r\n\t\r\n\t\t\t\t\t\t\tif ( intersection ) {\r\n\t\r\n\t\t\t\t\t\t\t\tintersection.index = a; // triangle number in positions buffer semantics\r\n\t\t\t\t\t\t\t\tintersects.push( intersection );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\t\t\tvar fvA, fvB, fvC;\r\n\t\t\t\t\tvar isFaceMaterial = material instanceof THREE.MultiMaterial;\r\n\t\t\t\t\tvar materials = isFaceMaterial === true ? material.materials : null;\r\n\t\r\n\t\t\t\t\tvar vertices = geometry.vertices;\r\n\t\t\t\t\tvar faces = geometry.faces;\r\n\t\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\r\n\t\t\t\t\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\r\n\t\r\n\t\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar face = faces[ f ];\r\n\t\t\t\t\t\tvar faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;\r\n\t\r\n\t\t\t\t\t\tif ( faceMaterial === undefined ) continue;\r\n\t\r\n\t\t\t\t\t\tfvA = vertices[ face.a ];\r\n\t\t\t\t\t\tfvB = vertices[ face.b ];\r\n\t\t\t\t\t\tfvC = vertices[ face.c ];\r\n\t\r\n\t\t\t\t\t\tif ( faceMaterial.morphTargets === true ) {\r\n\t\r\n\t\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\r\n\t\t\t\t\t\t\tvar morphInfluences = this.morphTargetInfluences;\r\n\t\r\n\t\t\t\t\t\t\tvA.set( 0, 0, 0 );\r\n\t\t\t\t\t\t\tvB.set( 0, 0, 0 );\r\n\t\t\t\t\t\t\tvC.set( 0, 0, 0 );\r\n\t\r\n\t\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\r\n\t\r\n\t\t\t\t\t\t\t\tif ( influence === 0 ) continue;\r\n\t\r\n\t\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\r\n\t\r\n\t\t\t\t\t\t\t\tvA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\r\n\t\t\t\t\t\t\t\tvB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\r\n\t\t\t\t\t\t\t\tvC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\tvA.add( fvA );\r\n\t\t\t\t\t\t\tvB.add( fvB );\r\n\t\t\t\t\t\t\tvC.add( fvC );\r\n\t\r\n\t\t\t\t\t\t\tfvA = vA;\r\n\t\t\t\t\t\t\tfvB = vB;\r\n\t\t\t\t\t\t\tfvC = vC;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tintersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\r\n\t\r\n\t\t\t\t\t\tif ( intersection ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( uvs ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvar uvs_f = uvs[ f ];\r\n\t\t\t\t\t\t\t\tuvA.copy( uvs_f[ 0 ] );\r\n\t\t\t\t\t\t\t\tuvB.copy( uvs_f[ 1 ] );\r\n\t\t\t\t\t\t\t\tuvC.copy( uvs_f[ 2 ] );\r\n\t\r\n\t\t\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\tintersection.face = face;\r\n\t\t\t\t\t\t\tintersection.faceIndex = f;\r\n\t\t\t\t\t\t\tintersects.push( intersection );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}() ),\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/objects/Bone.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author ikerr / http://verold.com\r\n\t */\r\n\t\r\n\tTHREE.Bone = function ( skin ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Bone';\r\n\t\r\n\t\tthis.skin = skin;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Bone.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.Bone,\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tTHREE.Object3D.prototype.copy.call( this, source );\r\n\t\r\n\t\t\tthis.skin = source.skin;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/objects/Skeleton.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author michael guerrero / http://realitymeltdown.com\r\n\t * @author ikerr / http://verold.com\r\n\t */\r\n\t\r\n\tTHREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {\r\n\t\r\n\t\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\r\n\t\r\n\t\tthis.identityMatrix = new THREE.Matrix4();\r\n\t\r\n\t\t// copy the bone array\r\n\t\r\n\t\tbones = bones || [];\r\n\t\r\n\t\tthis.bones = bones.slice( 0 );\r\n\t\r\n\t\t// create a bone texture or an array of floats\r\n\t\r\n\t\tif ( this.useVertexTexture ) {\r\n\t\r\n\t\t\t// layout (1 matrix = 4 pixels)\r\n\t\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\r\n\t\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\r\n\t\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\r\n\t\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\r\n\t\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\r\n\t\r\n\t\r\n\t\t\tvar size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\r\n\t\t\tsize = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );\r\n\t\t\tsize = Math.max( size, 4 );\r\n\t\r\n\t\t\tthis.boneTextureWidth = size;\r\n\t\t\tthis.boneTextureHeight = size;\r\n\t\r\n\t\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\r\n\t\t\tthis.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tthis.boneMatrices = new Float32Array( 16 * this.bones.length );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// use the supplied bone inverses or calculate the inverses\r\n\t\r\n\t\tif ( boneInverses === undefined ) {\r\n\t\r\n\t\t\tthis.calculateInverses();\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tif ( this.bones.length === boneInverses.length ) {\r\n\t\r\n\t\t\t\tthis.boneInverses = boneInverses.slice( 0 );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.Skeleton bonInverses is the wrong length.' );\r\n\t\r\n\t\t\t\tthis.boneInverses = [];\r\n\t\r\n\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\t\r\n\t\t\t\t\tthis.boneInverses.push( new THREE.Matrix4() );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tObject.assign( THREE.Skeleton.prototype, {\r\n\t\r\n\t\tcalculateInverses: function () {\r\n\t\r\n\t\t\tthis.boneInverses = [];\r\n\t\r\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\t\r\n\t\t\t\tvar inverse = new THREE.Matrix4();\r\n\t\r\n\t\t\t\tif ( this.bones[ b ] ) {\r\n\t\r\n\t\t\t\t\tinverse.getInverse( this.bones[ b ].matrixWorld );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.boneInverses.push( inverse );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tpose: function () {\r\n\t\r\n\t\t\tvar bone;\r\n\t\r\n\t\t\t// recover the bind-time world matrices\r\n\t\r\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\t\r\n\t\t\t\tbone = this.bones[ b ];\r\n\t\r\n\t\t\t\tif ( bone ) {\r\n\t\r\n\t\t\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ b ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// compute the local matrices, positions, rotations and scales\r\n\t\r\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\t\r\n\t\t\t\tbone = this.bones[ b ];\r\n\t\r\n\t\t\t\tif ( bone ) {\r\n\t\r\n\t\t\t\t\tif ( bone.parent ) {\r\n\t\r\n\t\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\r\n\t\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdate: ( function () {\r\n\t\r\n\t\t\tvar offsetMatrix = new THREE.Matrix4();\r\n\t\r\n\t\t\treturn function update() {\r\n\t\r\n\t\t\t\t// flatten bone matrices to array\r\n\t\r\n\t\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\t\r\n\t\t\t\t\t// compute the offset between the current and the original transform\r\n\t\r\n\t\t\t\t\tvar matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;\r\n\t\r\n\t\t\t\t\toffsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );\r\n\t\t\t\t\toffsetMatrix.toArray( this.boneMatrices, b * 16 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( this.useVertexTexture ) {\r\n\t\r\n\t\t\t\t\tthis.boneTexture.needsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )(),\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/objects/SkinnedMesh.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author ikerr / http://verold.com\r\n\t */\r\n\t\r\n\tTHREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {\r\n\t\r\n\t\tTHREE.Mesh.call( this, geometry, material );\r\n\t\r\n\t\tthis.type = 'SkinnedMesh';\r\n\t\r\n\t\tthis.bindMode = \"attached\";\r\n\t\tthis.bindMatrix = new THREE.Matrix4();\r\n\t\tthis.bindMatrixInverse = new THREE.Matrix4();\r\n\t\r\n\t\t// init bones\r\n\t\r\n\t\t// TODO: remove bone creation as there is no reason (other than\r\n\t\t// convenience) for THREE.SkinnedMesh to do this.\r\n\t\r\n\t\tvar bones = [];\r\n\t\r\n\t\tif ( this.geometry && this.geometry.bones !== undefined ) {\r\n\t\r\n\t\t\tvar bone, gbone;\r\n\t\r\n\t\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\r\n\t\r\n\t\t\t\tgbone = this.geometry.bones[ b ];\r\n\t\r\n\t\t\t\tbone = new THREE.Bone( this );\r\n\t\t\t\tbones.push( bone );\r\n\t\r\n\t\t\t\tbone.name = gbone.name;\r\n\t\t\t\tbone.position.fromArray( gbone.pos );\r\n\t\t\t\tbone.quaternion.fromArray( gbone.rotq );\r\n\t\t\t\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\r\n\t\r\n\t\t\t\tgbone = this.geometry.bones[ b ];\r\n\t\r\n\t\t\t\tif ( gbone.parent !== - 1 && gbone.parent !== null &&\r\n\t\t\t\t\t\tbones[ gbone.parent ] !== undefined ) {\r\n\t\r\n\t\t\t\t\tbones[ gbone.parent ].add( bones[ b ] );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthis.add( bones[ b ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.normalizeSkinWeights();\r\n\t\r\n\t\tthis.updateMatrixWorld( true );\r\n\t\tthis.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.SkinnedMesh.prototype = Object.assign( Object.create( THREE.Mesh.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.SkinnedMesh,\r\n\t\r\n\t\tbind: function( skeleton, bindMatrix ) {\r\n\t\r\n\t\t\tthis.skeleton = skeleton;\r\n\t\r\n\t\t\tif ( bindMatrix === undefined ) {\r\n\t\r\n\t\t\t\tthis.updateMatrixWorld( true );\r\n\t\r\n\t\t\t\tthis.skeleton.calculateInverses();\r\n\t\r\n\t\t\t\tbindMatrix = this.matrixWorld;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.bindMatrix.copy( bindMatrix );\r\n\t\t\tthis.bindMatrixInverse.getInverse( bindMatrix );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tpose: function () {\r\n\t\r\n\t\t\tthis.skeleton.pose();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalizeSkinWeights: function () {\r\n\t\r\n\t\t\tif ( this.geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar sw = this.geometry.skinWeights[ i ];\r\n\t\r\n\t\t\t\t\tvar scale = 1.0 / sw.lengthManhattan();\r\n\t\r\n\t\t\t\t\tif ( scale !== Infinity ) {\r\n\t\r\n\t\t\t\t\t\tsw.multiplyScalar( scale );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tsw.set( 1, 0, 0, 0 ); // do something reasonable\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( this.geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\tvar vec = new THREE.Vector4();\r\n\t\r\n\t\t\t\tvar skinWeight = this.geometry.attributes.skinWeight;\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < skinWeight.count; i ++ ) {\r\n\t\r\n\t\t\t\t\tvec.x = skinWeight.getX( i );\r\n\t\t\t\t\tvec.y = skinWeight.getY( i );\r\n\t\t\t\t\tvec.z = skinWeight.getZ( i );\r\n\t\t\t\t\tvec.w = skinWeight.getW( i );\r\n\t\r\n\t\t\t\t\tvar scale = 1.0 / vec.lengthManhattan();\r\n\t\r\n\t\t\t\t\tif ( scale !== Infinity ) {\r\n\t\r\n\t\t\t\t\t\tvec.multiplyScalar( scale );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tvec.set( 1, 0, 0, 0 ); // do something reasonable\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tskinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdateMatrixWorld: function( force ) {\r\n\t\r\n\t\t\tTHREE.Mesh.prototype.updateMatrixWorld.call( this, true );\r\n\t\r\n\t\t\tif ( this.bindMode === \"attached\" ) {\r\n\t\r\n\t\t\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\r\n\t\r\n\t\t\t} else if ( this.bindMode === \"detached\" ) {\r\n\t\r\n\t\t\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function() {\r\n\t\r\n\t\t\treturn new this.constructor( this.geometry, this.material, this.useVertexTexture ).copy( this );\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/objects/LOD.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.LOD = function () {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'LOD';\r\n\t\r\n\t\tObject.defineProperties( this, {\r\n\t\t\tlevels: {\r\n\t\t\t\tenumerable: true,\r\n\t\t\t\tvalue: []\r\n\t\t\t}\r\n\t\t} );\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.LOD.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.LOD,\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tTHREE.Object3D.prototype.copy.call( this, source, false );\r\n\t\r\n\t\t\tvar levels = source.levels;\r\n\t\r\n\t\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar level = levels[ i ];\r\n\t\r\n\t\t\t\tthis.addLevel( level.object.clone(), level.distance );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\taddLevel: function ( object, distance ) {\r\n\t\r\n\t\t\tif ( distance === undefined ) distance = 0;\r\n\t\r\n\t\t\tdistance = Math.abs( distance );\r\n\t\r\n\t\t\tvar levels = this.levels;\r\n\t\r\n\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\r\n\t\r\n\t\t\t\tif ( distance < levels[ l ].distance ) {\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tlevels.splice( l, 0, { distance: distance, object: object } );\r\n\t\r\n\t\t\tthis.add( object );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetObjectForDistance: function ( distance ) {\r\n\t\r\n\t\t\tvar levels = this.levels;\r\n\t\r\n\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tif ( distance < levels[ i ].distance ) {\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn levels[ i - 1 ].object;\r\n\t\r\n\t\t},\r\n\t\r\n\t\traycast: ( function () {\r\n\t\r\n\t\t\tvar matrixPosition = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function raycast( raycaster, intersects ) {\r\n\t\r\n\t\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\r\n\t\r\n\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\r\n\t\r\n\t\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}() ),\r\n\t\r\n\t\tupdate: function () {\r\n\t\r\n\t\t\tvar v1 = new THREE.Vector3();\r\n\t\t\tvar v2 = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function update( camera ) {\r\n\t\r\n\t\t\t\tvar levels = this.levels;\r\n\t\r\n\t\t\t\tif ( levels.length > 1 ) {\r\n\t\r\n\t\t\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\r\n\t\t\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\r\n\t\r\n\t\t\t\t\tvar distance = v1.distanceTo( v2 );\r\n\t\r\n\t\t\t\t\tlevels[ 0 ].object.visible = true;\r\n\t\r\n\t\t\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tif ( distance >= levels[ i ].distance ) {\r\n\t\r\n\t\t\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\r\n\t\t\t\t\t\t\tlevels[ i ].object.visible = true;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tfor ( ; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tlevels[ i ].object.visible = false;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}(),\r\n\t\r\n\t\ttoJSON: function ( meta ) {\r\n\t\r\n\t\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\t\r\n\t\t\tdata.object.levels = [];\r\n\t\r\n\t\t\tvar levels = this.levels;\r\n\t\r\n\t\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar level = levels[ i ];\r\n\t\r\n\t\t\t\tdata.object.levels.push( {\r\n\t\t\t\t\tobject: level.object.uuid,\r\n\t\t\t\t\tdistance: level.distance\r\n\t\t\t\t} );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn data;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/objects/Sprite.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Sprite = function ( material ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Sprite';\r\n\t\r\n\t\tthis.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Sprite.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.Sprite,\r\n\t\r\n\t\traycast: ( function () {\r\n\t\r\n\t\t\tvar matrixPosition = new THREE.Vector3();\r\n\t\r\n\t\t\treturn function raycast( raycaster, intersects ) {\r\n\t\r\n\t\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\r\n\t\r\n\t\t\t\tvar distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );\r\n\t\t\t\tvar guessSizeSq = this.scale.x * this.scale.y / 4;\r\n\t\r\n\t\t\t\tif ( distanceSq > guessSizeSq ) {\r\n\t\r\n\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tintersects.push( {\r\n\t\r\n\t\t\t\t\tdistance: Math.sqrt( distanceSq ),\r\n\t\t\t\t\tpoint: this.position,\r\n\t\t\t\t\tface: null,\r\n\t\t\t\t\tobject: this\r\n\t\r\n\t\t\t\t} );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}() ),\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor( this.material ).copy( this );\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/objects/LensFlare.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.LensFlare = function ( texture, size, distance, blending, color ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.lensFlares = [];\r\n\t\r\n\t\tthis.positionScreen = new THREE.Vector3();\r\n\t\tthis.customUpdateCallback = undefined;\r\n\t\r\n\t\tif ( texture !== undefined ) {\r\n\t\r\n\t\t\tthis.add( texture, size, distance, blending, color );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LensFlare.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.LensFlare,\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tTHREE.Object3D.prototype.copy.call( this, source );\r\n\t\r\n\t\t\tthis.positionScreen.copy( source.positionScreen );\r\n\t\t\tthis.customUpdateCallback = source.customUpdateCallback;\r\n\t\r\n\t\t\tfor ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tthis.lensFlares.push( source.lensFlares[ i ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tadd: function ( texture, size, distance, blending, color, opacity ) {\r\n\t\r\n\t\t\tif ( size === undefined ) size = - 1;\r\n\t\t\tif ( distance === undefined ) distance = 0;\r\n\t\t\tif ( opacity === undefined ) opacity = 1;\r\n\t\t\tif ( color === undefined ) color = new THREE.Color( 0xffffff );\r\n\t\t\tif ( blending === undefined ) blending = THREE.NormalBlending;\r\n\t\r\n\t\t\tdistance = Math.min( distance, Math.max( 0, distance ) );\r\n\t\r\n\t\t\tthis.lensFlares.push( {\r\n\t\t\t\ttexture: texture,\t// THREE.Texture\r\n\t\t\t\tsize: size, \t\t// size in pixels (-1 = use texture.width)\r\n\t\t\t\tdistance: distance, \t// distance (0-1) from light source (0=at light source)\r\n\t\t\t\tx: 0, y: 0, z: 0,\t// screen position (-1 => 1) z = 0 is in front z = 1 is back\r\n\t\t\t\tscale: 1, \t\t// scale\r\n\t\t\t\trotation: 0, \t\t// rotation\r\n\t\t\t\topacity: opacity,\t// opacity\r\n\t\t\t\tcolor: color,\t\t// color\r\n\t\t\t\tblending: blending\t// blending\r\n\t\t\t} );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t/*\r\n\t\t * Update lens flares update positions on all flares based on the screen position\r\n\t\t * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\r\n\t\t */\r\n\t\r\n\t\tupdateLensFlares: function () {\r\n\t\r\n\t\t\tvar f, fl = this.lensFlares.length;\r\n\t\t\tvar flare;\r\n\t\t\tvar vecX = - this.positionScreen.x * 2;\r\n\t\t\tvar vecY = - this.positionScreen.y * 2;\r\n\t\r\n\t\t\tfor ( f = 0; f < fl; f ++ ) {\r\n\t\r\n\t\t\t\tflare = this.lensFlares[ f ];\r\n\t\r\n\t\t\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\r\n\t\t\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\r\n\t\r\n\t\t\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\r\n\t\t\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/scenes/Scene.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Scene = function () {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.type = 'Scene';\r\n\t\r\n\t\tthis.fog = null;\r\n\t\tthis.overrideMaterial = null;\r\n\t\r\n\t\tthis.autoUpdate = true; // checked by the renderer\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Scene.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.Scene.prototype.constructor = THREE.Scene;\r\n\t\r\n\tTHREE.Scene.prototype.copy = function ( source, recursive ) {\r\n\t\r\n\t\tTHREE.Object3D.prototype.copy.call( this, source, recursive );\r\n\t\r\n\t\tif ( source.fog !== null ) this.fog = source.fog.clone();\r\n\t\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\r\n\t\r\n\t\tthis.autoUpdate = source.autoUpdate;\r\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/scenes/Fog.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.Fog = function ( color, near, far ) {\r\n\t\r\n\t\tthis.name = '';\r\n\t\r\n\t\tthis.color = new THREE.Color( color );\r\n\t\r\n\t\tthis.near = ( near !== undefined ) ? near : 1;\r\n\t\tthis.far = ( far !== undefined ) ? far : 1000;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Fog.prototype.clone = function () {\r\n\t\r\n\t\treturn new THREE.Fog( this.color.getHex(), this.near, this.far );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/scenes/FogExp2.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.FogExp2 = function ( color, density ) {\r\n\t\r\n\t\tthis.name = '';\r\n\t\r\n\t\tthis.color = new THREE.Color( color );\r\n\t\tthis.density = ( density !== undefined ) ? density : 0.00025;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.FogExp2.prototype.clone = function () {\r\n\t\r\n\t\treturn new THREE.FogExp2( this.color.getHex(), this.density );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk.js\r\n\t\r\n\tTHREE.ShaderChunk = {};\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'alphamap_fragment' ] = \"#ifdef USE_ALPHAMAP\\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'alphamap_pars_fragment' ] = \"#ifdef USE_ALPHAMAP\\n\tuniform sampler2D alphaMap;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'alphatest_fragment' ] = \"#ifdef ALPHATEST\\n\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'aomap_fragment' ] = \"#ifdef USE_AOMAP\\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'aomap_pars_fragment' ] = \"#ifdef USE_AOMAP\\n\tuniform sampler2D aoMap;\\n\tuniform float aoMapIntensity;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'begin_vertex' ] = \"\\nvec3 transformed = vec3( position );\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'beginnormal_vertex' ] = \"\\nvec3 objectNormal = vec3( normal );\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/bsdfs.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'bsdfs' ] = \"bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\t\tif( decayExponent > 0.0 ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\\n#else\\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n#endif\\n\t\t}\\n\t\treturn 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\tfloat alpha = pow2( roughness );\\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\tfloat D = D_GGX( alpha, dotNH );\\n\treturn F * ( G * D );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\tvec4 r = roughness * c0 + c1;\\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\treturn specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\tfloat G = G_BlinnPhong_Implicit( );\\n\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'bumpmap_pars_fragment' ] = \"#ifdef USE_BUMPMAP\\n\tuniform sampler2D bumpMap;\\n\tuniform float bumpScale;\\n\tvec2 dHdxy_fwd() {\\n\t\tvec2 dSTdx = dFdx( vUv );\\n\t\tvec2 dSTdy = dFdy( vUv );\\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\t\treturn vec2( dBx, dBy );\\n\t}\\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\t\tvec3 vSigmaX = dFdx( surf_pos );\\n\t\tvec3 vSigmaY = dFdy( surf_pos );\\n\t\tvec3 vN = surf_norm;\\n\t\tvec3 R1 = cross( vSigmaY, vN );\\n\t\tvec3 R2 = cross( vN, vSigmaX );\\n\t\tfloat fDet = dot( vSigmaX, R1 );\\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\t}\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/clipping_planes_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'clipping_planes_fragment' ] = \"#if NUM_CLIPPING_PLANES > 0\\n\tfor ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\\n\t\tvec4 plane = clippingPlanes[ i ];\\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\t}\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'clipping_planes_pars_fragment' ] = \"#if NUM_CLIPPING_PLANES > 0\\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\n\t\tvarying vec3 vViewPosition;\\n\t#endif\\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'clipping_planes_pars_vertex' ] = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\tvarying vec3 vViewPosition;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/clipping_planes_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'clipping_planes_vertex' ] = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\tvViewPosition = - mvPosition.xyz;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'color_fragment' ] = \"#ifdef USE_COLOR\\n\tdiffuseColor.rgb *= vColor;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'color_pars_fragment' ] = \"#ifdef USE_COLOR\\n\tvarying vec3 vColor;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'color_pars_vertex' ] = \"#ifdef USE_COLOR\\n\tvarying vec3 vColor;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'color_vertex' ] = \"#ifdef USE_COLOR\\n\tvColor.xyz = color.xyz;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/common.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'common' ] = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\tvec3 color;\\n\tvec3 direction;\\n\tbool visible;\\n};\\nstruct ReflectedLight {\\n\tvec3 directDiffuse;\\n\tvec3 directSpecular;\\n\tvec3 indirectDiffuse;\\n\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\tvec3 position;\\n\tvec3 normal;\\n\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/cube_uv_reflection_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'cube_uv_reflection_fragment' ] = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\tvec3 absDirection = abs(direction);\\n\tint face = -1;\\n\tif( absDirection.x > absDirection.z ) {\\n\t\tif(absDirection.x > absDirection.y )\\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\\n\t\telse\\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\\n\t}\\n\telse {\\n\t\tif(absDirection.z > absDirection.y )\\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\\n\t\telse\\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\\n\t}\\n\treturn face;\\n}\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\tfloat dxRoughness = dFdx(roughness);\\n\tfloat dyRoughness = dFdy(roughness);\\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\tfloat mipLevel = 0.5 * log2(d);\\n\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\tbool bRes = mipLevel == 0.0;\\n\tscale =  bRes && (scale < a) ? a : scale;\\n\tvec3 r;\\n\tvec2 offset;\\n\tint face = getFaceFromDirection(direction);\\n\tfloat rcpPowScale = 1.0 / powScale;\\n\tif( face == 0) {\\n\t\tr = vec3(direction.x, -direction.z, direction.y);\\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 1) {\\n\t\tr = vec3(direction.y, direction.x, direction.z);\\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 2) {\\n\t\tr = vec3(direction.z, direction.x, direction.y);\\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 3) {\\n\t\tr = vec3(direction.x, direction.z, direction.y);\\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\telse if( face == 4) {\\n\t\tr = vec3(direction.y, direction.x, -direction.z);\\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\telse {\\n\t\tr = vec3(direction.z, -direction.x, direction.y);\\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\tr = normalize(r);\\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\tvec2 base = offset + vec2( texelOffset );\\n\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\tfloat r1 = floor(roughnessVal);\\n\tfloat r2 = r1 + 1.0;\\n\tfloat t = fract(roughnessVal);\\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\tfloat s = mipInfo.y;\\n\tfloat level0 = mipInfo.x;\\n\tfloat level1 = level0 + 1.0;\\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\tvec4 result = mix(color10, color20, t);\\n\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'defaultnormal_vertex' ] = \"#ifdef FLIP_SIDED\\n\tobjectNormal = -objectNormal;\\n#endif\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'displacementmap_vertex' ] = \"#ifdef USE_DISPLACEMENTMAP\\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'displacementmap_pars_vertex' ] = \"#ifdef USE_DISPLACEMENTMAP\\n\tuniform sampler2D displacementMap;\\n\tuniform float displacementScale;\\n\tuniform float displacementBias;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'emissivemap_fragment' ] = \"#ifdef USE_EMISSIVEMAP\\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'emissivemap_pars_fragment' ] = \"#ifdef USE_EMISSIVEMAP\\n\tuniform sampler2D emissiveMap;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/encodings_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'encodings_pars_fragment' ] = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n  return value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n  float maxComponent = max( max( value.r, value.g ), value.b );\\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n  float maxRGB = max( value.x, max( value.g, value.b ) );\\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n  M            = ceil( M * 255.0 ) / 255.0;\\n  return vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n    float maxRGB = max( value.x, max( value.g, value.b ) );\\n    float D      = max( maxRange / maxRGB, 1.0 );\\n    D            = min( floor( D ) / 255.0, 1.0 );\\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\n  vec4 vResult;\\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n  vResult.w = fract(Le);\\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\n  return vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n  float Le = value.z * 255.0 + value.w;\\n  vec3 Xp_Y_XYZp;\\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\n  return vec4( max(vRGB, 0.0), 1.0 );\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/encodings_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'encodings_fragment' ] = \"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'envmap_fragment' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\t\t#endif\\n\t#else\\n\t\tvec3 reflectVec = vReflect;\\n\t#endif\\n\t#ifdef DOUBLE_SIDED\\n\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\t#else\\n\t\tfloat flipNormal = 1.0;\\n\t#endif\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\tvec2 sampleUV;\\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\\n\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\t#endif\\n\tenvColor = envMapTexelToLinear( envColor );\\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_MIX )\\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_ADD )\\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'envmap_pars_fragment' ] = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\tuniform float reflectivity;\\n\tuniform float envMapIntenstiy;\\n#endif\\n#ifdef USE_ENVMAP\\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\t\tvarying vec3 vWorldPosition;\\n\t#endif\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tuniform samplerCube envMap;\\n\t#else\\n\t\tuniform sampler2D envMap;\\n\t#endif\\n\tuniform float flipEnvMap;\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\t\tuniform float refractionRatio;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'envmap_pars_vertex' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvarying vec3 vWorldPosition;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t\tuniform float refractionRatio;\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'envmap_vertex' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvWorldPosition = worldPosition.xyz;\\n\t#else\\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\\n\t\t#else\\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\t\t#endif\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'fog_fragment' ] = \"#ifdef USE_FOG\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\t#else\\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\t#endif\\n\t#ifdef FOG_EXP2\\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\\n\t#else\\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n\t#endif\\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'fog_pars_fragment' ] = \"#ifdef USE_FOG\\n\tuniform vec3 fogColor;\\n\t#ifdef FOG_EXP2\\n\t\tuniform float fogDensity;\\n\t#else\\n\t\tuniform float fogNear;\\n\t\tuniform float fogFar;\\n\t#endif\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lightmap_fragment' ] = \"#ifdef USE_LIGHTMAP\\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lightmap_pars_fragment' ] = \"#ifdef USE_LIGHTMAP\\n\tuniform sampler2D lightMap;\\n\tuniform float lightMapIntensity;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_lambert_vertex' ] = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\tvLightBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\t\t#endif\\n\t}\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_pars.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_pars' ] = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\tvec3 irradiance = ambientLightColor;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\tstruct DirectionalLight {\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\t\tdirectLight.color = directionalLight.color;\\n\t\tdirectLight.direction = directionalLight.direction;\\n\t\tdirectLight.visible = true;\\n\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\tstruct PointLight {\\n\t\tvec3 position;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\t\tvec3 lVector = pointLight.position - geometry.position;\\n\t\tdirectLight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\\n\t\t\tdirectLight.color = pointLight.color;\\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\t\t\tdirectLight.visible = true;\\n\t\t} else {\\n\t\t\tdirectLight.color = vec3( 0.0 );\\n\t\t\tdirectLight.visible = false;\\n\t\t}\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tstruct SpotLight {\\n\t\tvec3 position;\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tfloat coneCos;\\n\t\tfloat penumbraCos;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\t\tvec3 lVector = spotLight.position - geometry.position;\\n\t\tdirectLight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\t\t\tdirectLight.color = spotLight.color;\\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\t\t\tdirectLight.visible = true;\\n\t\t} else {\\n\t\t\tdirectLight.color = vec3( 0.0 );\\n\t\t\tdirectLight.visible = false;\\n\t\t}\\n\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tstruct HemisphereLight {\\n\t\tvec3 direction;\\n\t\tvec3 skyColor;\\n\t\tvec3 groundColor;\\n\t};\\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tirradiance *= PI;\\n\t\t#endif\\n\t\treturn irradiance;\\n\t}\\n#endif\\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\t\t#else\\n\t\t\tfloat flipNormal = 1.0;\\n\t\t#endif\\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\t\t#ifdef ENVMAP_TYPE_CUBE\\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\n\t\t#else\\n\t\t\tvec4 envMapColor = vec4( 0.0 );\\n\t\t#endif\\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\\n\t}\\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\t}\\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\t\t#endif\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\t\t#else\\n\t\t\tfloat flipNormal = 1.0;\\n\t\t#endif\\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\t\t#ifdef ENVMAP_TYPE_CUBE\\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\t\tvec2 sampleUV;\\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#endif\\n\t\treturn envMapColor.rgb * envMapIntensity;\\n\t}\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_phong_fragment' ] = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_phong_pars_fragment' ] = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\tvec3\tdiffuseColor;\\n\tvec3\tspecularColor;\\n\tfloat\tspecularShininess;\\n\tfloat\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\t(0)\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_physical_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_physical_fragment' ] = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\tmaterial.specularColor = mix( vec3( 0.16 * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_physical_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_physical_pars_fragment' ] = \"struct PhysicalMaterial {\\n\tvec3\tdiffuseColor;\\n\tfloat\tspecularRoughness;\\n\tvec3\tspecularColor;\\n\t#ifndef STANDARD\\n\t#endif\\n};\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_Physical\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/lights_template.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'lights_template' ] = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tPointLight pointLight;\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i ];\\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tSpotLight spotLight;\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tspotLight = spotLights[ i ];\\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\tDirectionalLight directionalLight;\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectionalLight = directionalLights[ i ];\\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\t#ifdef USE_LIGHTMAP\\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tlightMapIrradiance *= PI;\\n\t\t#endif\\n\t\tirradiance += lightMapIrradiance;\\n\t#endif\\n\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\t\t}\\n\t#endif\\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\n\t#endif\\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\n\tRE_IndirectSpecular( radiance, geometry, material, reflectedLight );\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'logdepthbuf_fragment' ] = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'logdepthbuf_pars_fragment' ] = \"#ifdef USE_LOGDEPTHBUF\\n\tuniform float logDepthBufFC;\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvarying float vFragDepth;\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'logdepthbuf_pars_vertex' ] = \"#ifdef USE_LOGDEPTHBUF\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvarying float vFragDepth;\\n\t#endif\\n\tuniform float logDepthBufFC;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'logdepthbuf_vertex' ] = \"#ifdef USE_LOGDEPTHBUF\\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvFragDepth = 1.0 + gl_Position.w;\\n\t#else\\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'map_fragment' ] = \"#ifdef USE_MAP\\n\tvec4 texelColor = texture2D( map, vUv );\\n\ttexelColor = mapTexelToLinear( texelColor );\\n\tdiffuseColor *= texelColor;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'map_pars_fragment' ] = \"#ifdef USE_MAP\\n\tuniform sampler2D map;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'map_particle_fragment' ] = \"#ifdef USE_MAP\\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'map_particle_pars_fragment' ] = \"#ifdef USE_MAP\\n\tuniform vec4 offsetRepeat;\\n\tuniform sampler2D map;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/metalnessmap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'metalnessmap_fragment' ] = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\tmetalnessFactor *= texelMetalness.r;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/metalnessmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'metalnessmap_pars_fragment' ] = \"#ifdef USE_METALNESSMAP\\n\tuniform sampler2D metalnessMap;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'morphnormal_vertex' ] = \"#ifdef USE_MORPHNORMALS\\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'morphtarget_pars_vertex' ] = \"#ifdef USE_MORPHTARGETS\\n\t#ifndef USE_MORPHNORMALS\\n\tuniform float morphTargetInfluences[ 8 ];\\n\t#else\\n\tuniform float morphTargetInfluences[ 4 ];\\n\t#endif\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'morphtarget_vertex' ] = \"#ifdef USE_MORPHTARGETS\\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\t#ifndef USE_MORPHNORMALS\\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/normal_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'normal_fragment' ] = \"#ifdef FLAT_SHADED\\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\tvec3 normal = normalize( vNormal );\\n\t#ifdef DOUBLE_SIDED\\n\t\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\\n\t#endif\\n#endif\\n#ifdef USE_NORMALMAP\\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'normalmap_pars_fragment' ] = \"#ifdef USE_NORMALMAP\\n\tuniform sampler2D normalMap;\\n\tuniform vec2 normalScale;\\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\\n\t\tvec2 st0 = dFdx( vUv.st );\\n\t\tvec2 st1 = dFdy( vUv.st );\\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\t\tvec3 N = normalize( surf_norm );\\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\t\tmapN.xy = normalScale * mapN.xy;\\n\t\tmat3 tsn = mat3( S, T, N );\\n\t\treturn normalize( tsn * mapN );\\n\t}\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/packing.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'packing' ] = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n  return normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n  return 1.0 - 2.0 * rgb.xyz;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthoDepth( const in float viewZ, const in float near, const in float far ) {\\n  return ( viewZ + near ) / ( near - far );\\n}\\nfloat OrthoDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n  return linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/premultiplied_alpha_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'premultiplied_alpha_fragment' ] = \"#ifdef PREMULTIPLIED_ALPHA\\n\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'project_vertex' ] = \"#ifdef USE_SKINNING\\n\tvec4 mvPosition = modelViewMatrix * skinned;\\n#else\\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/roughnessmap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'roughnessmap_fragment' ] = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\troughnessFactor *= texelRoughness.r;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/roughnessmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'roughnessmap_pars_fragment' ] = \"#ifdef USE_ROUGHNESSMAP\\n\tuniform sampler2D roughnessMap;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'shadowmap_pars_fragment' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\t#endif\\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\t}\\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\t\tvec2 f = fract( uv * size + 0.5 );\\n\t\tfloat a = mix( lb, lt, f.y );\\n\t\tfloat b = mix( rb, rt, f.y );\\n\t\tfloat c = mix( a, b, f.x );\\n\t\treturn c;\\n\t}\\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\t\tshadowCoord.xyz /= shadowCoord.w;\\n\t\tshadowCoord.z += shadowBias;\\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\t\tbool inFrustum = all( inFrustumVec );\\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\t\tbool frustumTest = all( frustumTestVec );\\n\t\tif ( frustumTest ) {\\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\\n\t\t\treturn (\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\\n\t\t\treturn (\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#else\\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\t\t#endif\\n\t\t}\\n\t\treturn 1.0;\\n\t}\\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\t\tvec3 absV = abs( v );\\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\t\tabsV *= scaleToCube;\\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\t\tvec2 planar = v.xy;\\n\t\tfloat almostATexel = 1.5 * texelSizeY;\\n\t\tfloat almostOne = 1.0 - almostATexel;\\n\t\tif ( absV.z >= almostOne ) {\\n\t\t\tif ( v.z > 0.0 )\\n\t\t\t\tplanar.x = 4.0 - v.x;\\n\t\t} else if ( absV.x >= almostOne ) {\\n\t\t\tfloat signX = sign( v.x );\\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\\n\t\t} else if ( absV.y >= almostOne ) {\\n\t\t\tfloat signY = sign( v.y );\\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\t\t\tplanar.y = v.z * signY - 2.0;\\n\t\t}\\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\t}\\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\t\tvec3 lightToPosition = shadowCoord.xyz;\\n\t\tvec3 bd3D = normalize( lightToPosition );\\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\t\t\treturn (\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#else\\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\t\t#endif\\n\t}\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'shadowmap_pars_vertex' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'shadowmap_vertex' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/shadowmask_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'shadowmask_pars_fragment' ] = \"float getShadowMask() {\\n\tfloat shadow = 1.0;\\n\t#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\tDirectionalLight directionalLight;\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectionalLight = directionalLights[ i ];\\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\tSpotLight spotLight;\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tspotLight = spotLights[ i ];\\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\tPointLight pointLight;\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i ];\\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#endif\\n\treturn shadow;\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'skinbase_vertex' ] = \"#ifdef USE_SKINNING\\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'skinning_pars_vertex' ] = \"#ifdef USE_SKINNING\\n\tuniform mat4 bindMatrix;\\n\tuniform mat4 bindMatrixInverse;\\n\t#ifdef BONE_TEXTURE\\n\t\tuniform sampler2D boneTexture;\\n\t\tuniform int boneTextureWidth;\\n\t\tuniform int boneTextureHeight;\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\t\t\tfloat j = i * 4.0;\\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\\n\t\t\ty = dy * ( y + 0.5 );\\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\t\t\treturn bone;\\n\t\t}\\n\t#else\\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\\n\t\t\treturn bone;\\n\t\t}\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'skinning_vertex' ] = \"#ifdef USE_SKINNING\\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\tvec4 skinned = vec4( 0.0 );\\n\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\tskinned  = bindMatrixInverse * skinned;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'skinnormal_vertex' ] = \"#ifdef USE_SKINNING\\n\tmat4 skinMatrix = mat4( 0.0 );\\n\tskinMatrix += skinWeight.x * boneMatX;\\n\tskinMatrix += skinWeight.y * boneMatY;\\n\tskinMatrix += skinWeight.z * boneMatZ;\\n\tskinMatrix += skinWeight.w * boneMatW;\\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'specularmap_fragment' ] = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\tspecularStrength = texelSpecular.r;\\n#else\\n\tspecularStrength = 1.0;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'specularmap_pars_fragment' ] = \"#ifdef USE_SPECULARMAP\\n\tuniform sampler2D specularMap;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/tonemapping_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'tonemapping_fragment' ] = \"#if defined( TONE_MAPPING )\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/tonemapping_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'tonemapping_pars_fragment' ] = \"#define saturate(a) clamp( a, 0.0, 1.0 )\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n  return toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  color = max( vec3( 0.0 ), color - 0.004 );\\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'uv2_pars_fragment' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tvarying vec2 vUv2;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'uv2_pars_vertex' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tattribute vec2 uv2;\\n\tvarying vec2 vUv2;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'uv2_vertex' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tvUv2 = uv2;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'uv_pars_fragment' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvarying vec2 vUv;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'uv_pars_vertex' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvarying vec2 vUv;\\n\tuniform vec4 offsetRepeat;\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'uv_vertex' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n#endif\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'worldpos_vertex' ] = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\t#ifdef USE_SKINNING\\n\t\tvec4 worldPosition = modelMatrix * skinned;\\n\t#else\\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\t#endif\\n#endif\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/UniformsUtils.js\r\n\t\r\n\t/**\r\n\t * Uniform Utilities\r\n\t */\r\n\t\r\n\tTHREE.UniformsUtils = {\r\n\t\r\n\t\tmerge: function ( uniforms ) {\r\n\t\r\n\t\t\tvar merged = {};\r\n\t\r\n\t\t\tfor ( var u = 0; u < uniforms.length; u ++ ) {\r\n\t\r\n\t\t\t\tvar tmp = this.clone( uniforms[ u ] );\r\n\t\r\n\t\t\t\tfor ( var p in tmp ) {\r\n\t\r\n\t\t\t\t\tmerged[ p ] = tmp[ p ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn merged;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function ( uniforms_src ) {\r\n\t\r\n\t\t\tvar uniforms_dst = {};\r\n\t\r\n\t\t\tfor ( var u in uniforms_src ) {\r\n\t\r\n\t\t\t\tuniforms_dst[ u ] = {};\r\n\t\r\n\t\t\t\tfor ( var p in uniforms_src[ u ] ) {\r\n\t\r\n\t\t\t\t\tvar parameter_src = uniforms_src[ u ][ p ];\r\n\t\r\n\t\t\t\t\tif ( parameter_src instanceof THREE.Color ||\r\n\t\t\t\t\t\t parameter_src instanceof THREE.Vector2 ||\r\n\t\t\t\t\t\t parameter_src instanceof THREE.Vector3 ||\r\n\t\t\t\t\t\t parameter_src instanceof THREE.Vector4 ||\r\n\t\t\t\t\t\t parameter_src instanceof THREE.Matrix3 ||\r\n\t\t\t\t\t\t parameter_src instanceof THREE.Matrix4 ||\r\n\t\t\t\t\t\t parameter_src instanceof THREE.Texture ) {\r\n\t\r\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\r\n\t\r\n\t\t\t\t\t} else if ( Array.isArray( parameter_src ) ) {\r\n\t\r\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn uniforms_dst;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/shaders/UniformsLib.js\r\n\t\r\n\t/**\r\n\t * Uniforms library for shared webgl shaders\r\n\t */\r\n\t\r\n\tTHREE.UniformsLib = {\r\n\t\r\n\t\tcommon: {\r\n\t\r\n\t\t\t\"diffuse\": { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n\t\t\t\"opacity\": { type: \"1f\", value: 1.0 },\r\n\t\r\n\t\t\t\"map\": { type: \"t\", value: null },\r\n\t\t\t\"offsetRepeat\": { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\r\n\t\r\n\t\t\t\"specularMap\": { type: \"t\", value: null },\r\n\t\t\t\"alphaMap\": { type: \"t\", value: null },\r\n\t\r\n\t\t\t\"envMap\": { type: \"t\", value: null },\r\n\t\t\t\"flipEnvMap\": { type: \"1f\", value: - 1 },\r\n\t\t\t\"reflectivity\": { type: \"1f\", value: 1.0 },\r\n\t\t\t\"refractionRatio\": { type: \"1f\", value: 0.98 }\r\n\t\r\n\t\t},\r\n\t\r\n\t\taomap: {\r\n\t\r\n\t\t\t\"aoMap\": { type: \"t\", value: null },\r\n\t\t\t\"aoMapIntensity\": { type: \"1f\", value: 1 }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlightmap: {\r\n\t\r\n\t\t\t\"lightMap\": { type: \"t\", value: null },\r\n\t\t\t\"lightMapIntensity\": { type: \"1f\", value: 1 }\r\n\t\r\n\t\t},\r\n\t\r\n\t\temissivemap: {\r\n\t\r\n\t\t\t\"emissiveMap\": { type: \"t\", value: null }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tbumpmap: {\r\n\t\r\n\t\t\t\"bumpMap\": { type: \"t\", value: null },\r\n\t\t\t\"bumpScale\": { type: \"1f\", value: 1 }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tnormalmap: {\r\n\t\r\n\t\t\t\"normalMap\": { type: \"t\", value: null },\r\n\t\t\t\"normalScale\": { type: \"v2\", value: new THREE.Vector2( 1, 1 ) }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdisplacementmap: {\r\n\t\r\n\t\t\t\"displacementMap\": { type: \"t\", value: null },\r\n\t\t\t\"displacementScale\": { type: \"1f\", value: 1 },\r\n\t\t\t\"displacementBias\": { type: \"1f\", value: 0 }\r\n\t\r\n\t\t},\r\n\t\r\n\t\troughnessmap: {\r\n\t\r\n\t\t\t\"roughnessMap\": { type: \"t\", value: null }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmetalnessmap: {\r\n\t\r\n\t\t\t\"metalnessMap\": { type: \"t\", value: null }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfog: {\r\n\t\r\n\t\t\t\"fogDensity\": { type: \"1f\", value: 0.00025 },\r\n\t\t\t\"fogNear\": { type: \"1f\", value: 1 },\r\n\t\t\t\"fogFar\": { type: \"1f\", value: 2000 },\r\n\t\t\t\"fogColor\": { type: \"c\", value: new THREE.Color( 0xffffff ) }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlights: {\r\n\t\r\n\t\t\t\"ambientLightColor\": { type: \"3fv\", value: [] },\r\n\t\r\n\t\t\t\"directionalLights\": { type: \"sa\", value: [], properties: {\r\n\t\t\t\t\"direction\": { type: \"v3\" },\r\n\t\t\t\t\"color\": { type: \"c\" },\r\n\t\r\n\t\t\t\t\"shadow\": { type: \"1i\" },\r\n\t\t\t\t\"shadowBias\": { type: \"1f\" },\r\n\t\t\t\t\"shadowRadius\": { type: \"1f\" },\r\n\t\t\t\t\"shadowMapSize\": { type: \"v2\" }\r\n\t\t\t} },\r\n\t\r\n\t\t\t\"directionalShadowMap\": { type: \"tv\", value: [] },\r\n\t\t\t\"directionalShadowMatrix\": { type: \"m4v\", value: [] },\r\n\t\r\n\t\t\t\"spotLights\": { type: \"sa\", value: [], properties: {\r\n\t\t\t\t\"color\": { type: \"c\" },\r\n\t\t\t\t\"position\": { type: \"v3\" },\r\n\t\t\t\t\"direction\": { type: \"v3\" },\r\n\t\t\t\t\"distance\": { type: \"1f\" },\r\n\t\t\t\t\"coneCos\": { type: \"1f\" },\r\n\t\t\t\t\"penumbraCos\": { type: \"1f\" },\r\n\t\t\t\t\"decay\": { type: \"1f\" },\r\n\t\r\n\t\t\t\t\"shadow\": { type: \"1i\" },\r\n\t\t\t\t\"shadowBias\": { type: \"1f\" },\r\n\t\t\t\t\"shadowRadius\": { type: \"1f\" },\r\n\t\t\t\t\"shadowMapSize\": { type: \"v2\" }\r\n\t\t\t} },\r\n\t\r\n\t\t\t\"spotShadowMap\": { type: \"tv\", value: [] },\r\n\t\t\t\"spotShadowMatrix\": { type: \"m4v\", value: [] },\r\n\t\r\n\t\t\t\"pointLights\": { type: \"sa\", value: [], properties: {\r\n\t\t\t\t\"color\": { type: \"c\" },\r\n\t\t\t\t\"position\": { type: \"v3\" },\r\n\t\t\t\t\"decay\": { type: \"1f\" },\r\n\t\t\t\t\"distance\": { type: \"1f\" },\r\n\t\r\n\t\t\t\t\"shadow\": { type: \"1i\" },\r\n\t\t\t\t\"shadowBias\": { type: \"1f\" },\r\n\t\t\t\t\"shadowRadius\": { type: \"1f\" },\r\n\t\t\t\t\"shadowMapSize\": { type: \"v2\" }\r\n\t\t\t} },\r\n\t\r\n\t\t\t\"pointShadowMap\": { type: \"tv\", value: [] },\r\n\t\t\t\"pointShadowMatrix\": { type: \"m4v\", value: [] },\r\n\t\r\n\t\t\t\"hemisphereLights\": { type: \"sa\", value: [], properties: {\r\n\t\t\t\t\"direction\": { type: \"v3\" },\r\n\t\t\t\t\"skyColor\": { type: \"c\" },\r\n\t\t\t\t\"groundColor\": { type: \"c\" }\r\n\t\t\t} }\r\n\t\r\n\t\t},\r\n\t\r\n\t\tpoints: {\r\n\t\r\n\t\t\t\"diffuse\": { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n\t\t\t\"opacity\": { type: \"1f\", value: 1.0 },\r\n\t\t\t\"size\": { type: \"1f\", value: 1.0 },\r\n\t\t\t\"scale\": { type: \"1f\", value: 1.0 },\r\n\t\t\t\"map\": { type: \"t\", value: null },\r\n\t\t\t\"offsetRepeat\": { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) }\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/cube_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'cube_frag' ] = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/cube_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'cube_vert' ] = \"varying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvWorldPosition = transformDirection( position, modelMatrix );\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/depth_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'depth_frag' ] = \"#if DEPTH_PACKING == 3200\\n\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( 1.0 );\\n\t#if DEPTH_PACKING == 3200\\n\t\tdiffuseColor.a = opacity;\\n\t#endif\\n\t#include <map_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <logdepthbuf_fragment>\\n\t#if DEPTH_PACKING == 3200\\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\\n\t#elif DEPTH_PACKING == 3201\\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\t#endif\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/depth_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'depth_vert' ] = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/distanceRGBA_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'distanceRGBA_frag' ] = \"uniform vec3 lightPos;\\nvarying vec4 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/distanceRGBA_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'distanceRGBA_vert' ] = \"varying vec4 vWorldPosition;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <skinbase_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvWorldPosition = worldPosition;\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/equirect_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'equirect_frag' ] = \"uniform sampler2D tEquirect;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec3 direction = normalize( vWorldPosition );\\n\tvec2 sampleUV;\\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/equirect_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'equirect_vert' ] = \"varying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvWorldPosition = transformDirection( position, modelMatrix );\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/linedashed_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'linedashed_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\t\tdiscard;\\n\t}\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <color_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/linedashed_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'linedashed_vert' ] = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <color_vertex>\\n\tvLineDistance = scale * lineDistance;\\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\tgl_Position = projectionMatrix * mvPosition;\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/meshbasic_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'meshbasic_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\tReflectedLight reflectedLight;\\n\treflectedLight.directDiffuse = vec3( 0.0 );\\n\treflectedLight.directSpecular = vec3( 0.0 );\\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\\n\treflectedLight.indirectSpecular = vec3( 0.0 );\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/meshbasic_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'meshbasic_vert' ] = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <skinbase_vertex>\\n\t#ifdef USE_ENVMAP\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#endif\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <envmap_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/meshlambert_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'meshlambert_frag' ] = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <emissivemap_fragment>\\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\t#include <lightmap_fragment>\\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\t#ifdef DOUBLE_SIDED\\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\t#else\\n\t\treflectedLight.directDiffuse = vLightFront;\\n\t#endif\\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/meshlambert_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'meshlambert_vert' ] = \"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <lights_lambert_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/meshphong_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'meshphong_frag' ] = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <normal_fragment>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_phong_fragment>\\n\t#include <lights_template>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/meshphong_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'meshphong_vert' ] = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n#endif\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/meshphysical_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'meshphysical_frag' ] = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\nuniform float envMapIntensity;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <lights_pars>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <roughnessmap_fragment>\\n\t#include <metalnessmap_fragment>\\n\t#include <normal_fragment>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_physical_fragment>\\n\t#include <lights_template>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/meshphysical_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'meshphysical_vert' ] = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n#endif\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/normal_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'normal_frag' ] = \"uniform float opacity;\\nvarying vec3 vNormal;\\n#include <common>\\n#include <packing>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/normal_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'normal_vert' ] = \"varying vec3 vNormal;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvNormal = normalize( normalMatrix * normal );\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/points_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'points_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_particle_fragment>\\n\t#include <color_fragment>\\n\t#include <alphatest_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/points_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'points_vert' ] = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <color_vertex>\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#ifdef USE_SIZEATTENUATION\\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\\n\t#else\\n\t\tgl_PointSize = size;\\n\t#endif\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/shadow_frag.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'shadow_frag' ] = \"uniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib/shadow_vert.glsl\r\n\t\r\n\tTHREE.ShaderChunk[ 'shadow_vert' ] = \"#include <shadowmap_pars_vertex>\\nvoid main() {\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\r\n\t\r\n\t// File:src/renderers/shaders/ShaderLib.js\r\n\t\r\n\t/**\r\n\t * Webgl Shader Library for three.js\r\n\t *\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t */\r\n\t\r\n\t\r\n\tTHREE.ShaderLib = {\r\n\t\r\n\t\t'basic': {\r\n\t\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\t\tTHREE.UniformsLib[ 'common' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'aomap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'fog' ]\r\n\t\r\n\t\t\t] ),\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk[ 'meshbasic_vert' ],\r\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'meshbasic_frag' ]\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'lambert': {\r\n\t\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\t\tTHREE.UniformsLib[ 'common' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'aomap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'lightmap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'fog' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'lights' ],\r\n\t\r\n\t\t\t\t{\r\n\t\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) }\r\n\t\t\t\t}\r\n\t\r\n\t\t\t] ),\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk[ 'meshlambert_vert' ],\r\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'meshlambert_frag' ]\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'phong': {\r\n\t\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\t\tTHREE.UniformsLib[ 'common' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'aomap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'lightmap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'bumpmap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'normalmap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'displacementmap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'fog' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'lights' ],\r\n\t\r\n\t\t\t\t{\r\n\t\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n\t\t\t\t\t\"specular\" : { type: \"c\", value: new THREE.Color( 0x111111 ) },\r\n\t\t\t\t\t\"shininess\": { type: \"1f\", value: 30 }\r\n\t\t\t\t}\r\n\t\r\n\t\t\t] ),\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk[ 'meshphong_vert' ],\r\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'meshphong_frag' ]\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'standard': {\r\n\t\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\t\tTHREE.UniformsLib[ 'common' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'aomap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'lightmap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'bumpmap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'normalmap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'displacementmap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'roughnessmap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'metalnessmap' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'fog' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'lights' ],\r\n\t\r\n\t\t\t\t{\r\n\t\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n\t\t\t\t\t\"roughness\": { type: \"1f\", value: 0.5 },\r\n\t\t\t\t\t\"metalness\": { type: \"1f\", value: 0 },\r\n\t\t\t\t\t\"envMapIntensity\" : { type: \"1f\", value: 1 } // temporary\r\n\t\t\t\t}\r\n\t\r\n\t\t\t] ),\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk[ 'meshphysical_vert' ],\r\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'meshphysical_frag' ]\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'points': {\r\n\t\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\t\tTHREE.UniformsLib[ 'points' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'fog' ]\r\n\t\r\n\t\t\t] ),\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk[ 'points_vert' ],\r\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'points_frag' ]\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'dashed': {\r\n\t\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\t\tTHREE.UniformsLib[ 'common' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'fog' ],\r\n\t\r\n\t\t\t\t{\r\n\t\t\t\t\t\"scale\"    : { type: \"1f\", value: 1 },\r\n\t\t\t\t\t\"dashSize\" : { type: \"1f\", value: 1 },\r\n\t\t\t\t\t\"totalSize\": { type: \"1f\", value: 2 }\r\n\t\t\t\t}\r\n\t\r\n\t\t\t] ),\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk[ 'linedashed_vert' ],\r\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'linedashed_frag' ]\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'depth': {\r\n\t\r\n\t\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\t\tTHREE.UniformsLib[ 'common' ],\r\n\t\t\t\tTHREE.UniformsLib[ 'displacementmap' ]\r\n\t\r\n\t\t\t] ),\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk[ 'depth_vert' ],\r\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'depth_frag' ]\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'normal': {\r\n\t\r\n\t\t\tuniforms: {\r\n\t\r\n\t\t\t\t\"opacity\" : { type: \"1f\", value: 1.0 }\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk[ 'normal_vert' ],\r\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'normal_frag' ]\r\n\t\r\n\t\t},\r\n\t\r\n\t\t/* -------------------------------------------------------------------------\r\n\t\t//\tCube map shader\r\n\t\t ------------------------------------------------------------------------- */\r\n\t\r\n\t\t'cube': {\r\n\t\r\n\t\t\tuniforms: {\r\n\t\t\t\t\"tCube\": { type: \"t\", value: null },\r\n\t\t\t\t\"tFlip\": { type: \"1f\", value: - 1 }\r\n\t\t\t},\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk[ 'cube_vert' ],\r\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'cube_frag' ]\r\n\t\r\n\t\t},\r\n\t\r\n\t\t/* -------------------------------------------------------------------------\r\n\t\t//\tCube map shader\r\n\t\t ------------------------------------------------------------------------- */\r\n\t\r\n\t\t'equirect': {\r\n\t\r\n\t\t\tuniforms: {\r\n\t\t\t\t\"tEquirect\": { type: \"t\", value: null },\r\n\t\t\t\t\"tFlip\": { type: \"1f\", value: - 1 }\r\n\t\t\t},\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk[ 'equirect_vert' ],\r\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'equirect_frag' ]\r\n\t\r\n\t\t},\r\n\t\r\n\t\t'distanceRGBA': {\r\n\t\r\n\t\t\tuniforms: {\r\n\t\r\n\t\t\t\t\"lightPos\": { type: \"v3\", value: new THREE.Vector3() }\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tvertexShader: THREE.ShaderChunk[ 'distanceRGBA_vert' ],\r\n\t\t\tfragmentShader: THREE.ShaderChunk[ 'distanceRGBA_frag' ]\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ShaderLib[ 'physical' ] = {\r\n\t\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\r\n\t\t\tTHREE.ShaderLib[ 'standard' ].uniforms,\r\n\t\r\n\t\t\t{\r\n\t\t\t\t// future\r\n\t\t\t}\r\n\t\r\n\t\t] ),\r\n\t\r\n\t\tvertexShader: THREE.ShaderChunk[ 'meshphysical_vert' ],\r\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshphysical_frag' ]\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t// File:src/renderers/WebGLRenderer.js\r\n\t\r\n\t/**\r\n\t * @author supereggbert / http://www.paulbrunt.co.uk/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author szimek / https://github.com/szimek/\r\n\t * @author tschw\r\n\t */\r\n\t\r\n\tTHREE.WebGLRenderer = function ( parameters ) {\r\n\t\r\n\t\tconsole.log( 'THREE.WebGLRenderer', THREE.REVISION );\r\n\t\r\n\t\tparameters = parameters || {};\r\n\t\r\n\t\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),\r\n\t\t_context = parameters.context !== undefined ? parameters.context : null,\r\n\t\r\n\t\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\r\n\t\t_depth = parameters.depth !== undefined ? parameters.depth : true,\r\n\t\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\r\n\t\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\r\n\t\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\r\n\t\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;\r\n\t\r\n\t\tvar lights = [];\r\n\t\r\n\t\tvar opaqueObjects = [];\r\n\t\tvar opaqueObjectsLastIndex = - 1;\r\n\t\tvar transparentObjects = [];\r\n\t\tvar transparentObjectsLastIndex = - 1;\r\n\t\r\n\t\tvar morphInfluences = new Float32Array( 8 );\r\n\t\r\n\t\tvar sprites = [];\r\n\t\tvar lensFlares = [];\r\n\t\r\n\t\t// public properties\r\n\t\r\n\t\tthis.domElement = _canvas;\r\n\t\tthis.context = null;\r\n\t\r\n\t\t// clearing\r\n\t\r\n\t\tthis.autoClear = true;\r\n\t\tthis.autoClearColor = true;\r\n\t\tthis.autoClearDepth = true;\r\n\t\tthis.autoClearStencil = true;\r\n\t\r\n\t\t// scene graph\r\n\t\r\n\t\tthis.sortObjects = true;\r\n\t\r\n\t\t// user-defined clipping\r\n\t\r\n\t\tthis.clippingPlanes = [];\r\n\t\tthis.localClippingEnabled = false;\r\n\t\r\n\t\t// physically based shading\r\n\t\r\n\t\tthis.gammaFactor = 2.0;\t// for backwards compatibility\r\n\t\tthis.gammaInput = false;\r\n\t\tthis.gammaOutput = false;\r\n\t\r\n\t\t// physical lights\r\n\t\r\n\t\tthis.physicallyCorrectLights = false;\r\n\t\r\n\t\t// tone mapping\r\n\t\r\n\t\tthis.toneMapping = THREE.LinearToneMapping;\r\n\t\tthis.toneMappingExposure = 1.0;\r\n\t\tthis.toneMappingWhitePoint = 1.0;\r\n\t\r\n\t\t// morphs\r\n\t\r\n\t\tthis.maxMorphTargets = 8;\r\n\t\tthis.maxMorphNormals = 4;\r\n\t\r\n\t\t// flags\r\n\t\r\n\t\tthis.autoScaleCubemaps = true;\r\n\t\r\n\t\t// internal properties\r\n\t\r\n\t\tvar _this = this,\r\n\t\r\n\t\t// internal state cache\r\n\t\r\n\t\t_currentProgram = null,\r\n\t\t_currentRenderTarget = null,\r\n\t\t_currentFramebuffer = null,\r\n\t\t_currentMaterialId = - 1,\r\n\t\t_currentGeometryProgram = '',\r\n\t\t_currentCamera = null,\r\n\t\r\n\t\t_currentScissor = new THREE.Vector4(),\r\n\t\t_currentScissorTest = null,\r\n\t\r\n\t\t_currentViewport = new THREE.Vector4(),\r\n\t\r\n\t\t//\r\n\t\r\n\t\t_usedTextureUnits = 0,\r\n\t\r\n\t\t//\r\n\t\r\n\t\t_clearColor = new THREE.Color( 0x000000 ),\r\n\t\t_clearAlpha = 0,\r\n\t\r\n\t\t_width = _canvas.width,\r\n\t\t_height = _canvas.height,\r\n\t\r\n\t\t_pixelRatio = 1,\r\n\t\r\n\t\t_scissor = new THREE.Vector4( 0, 0, _width, _height ),\r\n\t\t_scissorTest = false,\r\n\t\r\n\t\t_viewport = new THREE.Vector4( 0, 0, _width, _height ),\r\n\t\r\n\t\t// frustum\r\n\t\r\n\t\t_frustum = new THREE.Frustum(),\r\n\t\r\n\t\t// clipping\r\n\t\r\n\t\t_clipping = new THREE.WebGLClipping(),\r\n\t\t_clippingEnabled = false,\r\n\t\t_localClippingEnabled = false,\r\n\t\r\n\t\t_sphere = new THREE.Sphere(),\r\n\t\r\n\t\t// camera matrices cache\r\n\t\r\n\t\t_projScreenMatrix = new THREE.Matrix4(),\r\n\t\r\n\t\t_vector3 = new THREE.Vector3(),\r\n\t\r\n\t\t// light arrays cache\r\n\t\r\n\t\t_lights = {\r\n\t\r\n\t\t\thash: '',\r\n\t\r\n\t\t\tambient: [ 0, 0, 0 ],\r\n\t\t\tdirectional: [],\r\n\t\t\tdirectionalShadowMap: [],\r\n\t\t\tdirectionalShadowMatrix: [],\r\n\t\t\tspot: [],\r\n\t\t\tspotShadowMap: [],\r\n\t\t\tspotShadowMatrix: [],\r\n\t\t\tpoint: [],\r\n\t\t\tpointShadowMap: [],\r\n\t\t\tpointShadowMatrix: [],\r\n\t\t\themi: [],\r\n\t\r\n\t\t\tshadows: []\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// info\r\n\t\r\n\t\t_infoMemory = {\r\n\t\r\n\t\t\tgeometries: 0,\r\n\t\t\ttextures: 0\r\n\t\r\n\t\t},\r\n\t\r\n\t\t_infoRender = {\r\n\t\r\n\t\t\tcalls: 0,\r\n\t\t\tvertices: 0,\r\n\t\t\tfaces: 0,\r\n\t\t\tpoints: 0\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.info = {\r\n\t\r\n\t\t\trender: _infoRender,\r\n\t\t\tmemory: _infoMemory,\r\n\t\t\tprograms: null\r\n\t\r\n\t\t};\r\n\t\r\n\t\r\n\t\t// initialize\r\n\t\r\n\t\tvar _gl;\r\n\t\r\n\t\ttry {\r\n\t\r\n\t\t\tvar attributes = {\r\n\t\t\t\talpha: _alpha,\r\n\t\t\t\tdepth: _depth,\r\n\t\t\t\tstencil: _stencil,\r\n\t\t\t\tantialias: _antialias,\r\n\t\t\t\tpremultipliedAlpha: _premultipliedAlpha,\r\n\t\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer\r\n\t\t\t};\r\n\t\r\n\t\t\t_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\r\n\t\r\n\t\t\tif ( _gl === null ) {\r\n\t\r\n\t\t\t\tif ( _canvas.getContext( 'webgl' ) !== null ) {\r\n\t\r\n\t\t\t\t\tthrow 'Error creating WebGL context with your selected attributes.';\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tthrow 'Error creating WebGL context.';\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\r\n\t\r\n\t\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\r\n\t\r\n\t\t\t\t_gl.getShaderPrecisionFormat = function () {\r\n\t\r\n\t\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\r\n\t\r\n\t\t\t\t};\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\r\n\t\r\n\t\t} catch ( error ) {\r\n\t\r\n\t\t\tconsole.error( 'THREE.WebGLRenderer: ' + error );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar _isWebGL2 = (typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext);\r\n\t\tvar extensions = new THREE.WebGLExtensions( _gl );\r\n\t\r\n\t\textensions.get( 'WEBGL_depth_texture' );\r\n\t\textensions.get( 'OES_texture_float' );\r\n\t\textensions.get( 'OES_texture_float_linear' );\r\n\t\textensions.get( 'OES_texture_half_float' );\r\n\t\textensions.get( 'OES_texture_half_float_linear' );\r\n\t\textensions.get( 'OES_standard_derivatives' );\r\n\t\textensions.get( 'ANGLE_instanced_arrays' );\r\n\t\r\n\t\tif ( extensions.get( 'OES_element_index_uint' ) ) {\r\n\t\r\n\t\t\tTHREE.BufferGeometry.MaxIndex = 4294967296;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );\r\n\t\r\n\t\tvar state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );\r\n\t\tvar properties = new THREE.WebGLProperties();\r\n\t\tvar objects = new THREE.WebGLObjects( _gl, properties, this.info );\r\n\t\tvar programCache = new THREE.WebGLPrograms( this, capabilities );\r\n\t\tvar lightCache = new THREE.WebGLLights();\r\n\t\r\n\t\tthis.info.programs = programCache.programs;\r\n\t\r\n\t\tvar bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );\r\n\t\tvar indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\r\n\t\r\n\t\t//\r\n\t\r\n\t\tfunction getTargetPixelRatio() {\r\n\t\r\n\t\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction glClearColor( r, g, b, a ) {\r\n\t\r\n\t\t\tif ( _premultipliedAlpha === true ) {\r\n\t\r\n\t\t\t\tr *= a; g *= a; b *= a;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tstate.clearColor( r, g, b, a );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setDefaultGLState() {\r\n\t\r\n\t\t\tstate.init();\r\n\t\r\n\t\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\r\n\t\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\r\n\t\r\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction resetGLState() {\r\n\t\r\n\t\t\t_currentProgram = null;\r\n\t\t\t_currentCamera = null;\r\n\t\r\n\t\t\t_currentGeometryProgram = '';\r\n\t\t\t_currentMaterialId = - 1;\r\n\t\r\n\t\t\tstate.reset();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tsetDefaultGLState();\r\n\t\r\n\t\tthis.context = _gl;\r\n\t\tthis.capabilities = capabilities;\r\n\t\tthis.extensions = extensions;\r\n\t\tthis.properties = properties;\r\n\t\tthis.state = state;\r\n\t\r\n\t\t// shadow map\r\n\t\r\n\t\tvar shadowMap = new THREE.WebGLShadowMap( this, _lights, objects );\r\n\t\r\n\t\tthis.shadowMap = shadowMap;\r\n\t\r\n\t\r\n\t\t// Plugins\r\n\t\r\n\t\tvar spritePlugin = new THREE.SpritePlugin( this, sprites );\r\n\t\tvar lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );\r\n\t\r\n\t\t// API\r\n\t\r\n\t\tthis.getContext = function () {\r\n\t\r\n\t\t\treturn _gl;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getContextAttributes = function () {\r\n\t\r\n\t\t\treturn _gl.getContextAttributes();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.forceContextLoss = function () {\r\n\t\r\n\t\t\textensions.get( 'WEBGL_lose_context' ).loseContext();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getMaxAnisotropy = ( function () {\r\n\t\r\n\t\t\tvar value;\r\n\t\r\n\t\t\treturn function getMaxAnisotropy() {\r\n\t\r\n\t\t\t\tif ( value !== undefined ) return value;\r\n\t\r\n\t\t\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\r\n\t\r\n\t\t\t\tif ( extension !== null ) {\r\n\t\r\n\t\t\t\t\tvalue = _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tvalue = 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn value;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )();\r\n\t\r\n\t\tthis.getPrecision = function () {\r\n\t\r\n\t\t\treturn capabilities.precision;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getPixelRatio = function () {\r\n\t\r\n\t\t\treturn _pixelRatio;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setPixelRatio = function ( value ) {\r\n\t\r\n\t\t\tif ( value === undefined ) return;\r\n\t\r\n\t\t\t_pixelRatio = value;\r\n\t\r\n\t\t\tthis.setSize( _viewport.z, _viewport.w, false );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getSize = function () {\r\n\t\r\n\t\t\treturn {\r\n\t\t\t\twidth: _width,\r\n\t\t\t\theight: _height\r\n\t\t\t};\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setSize = function ( width, height, updateStyle ) {\r\n\t\r\n\t\t\t_width = width;\r\n\t\t\t_height = height;\r\n\t\r\n\t\t\t_canvas.width = width * _pixelRatio;\r\n\t\t\t_canvas.height = height * _pixelRatio;\r\n\t\r\n\t\t\tif ( updateStyle !== false ) {\r\n\t\r\n\t\t\t\t_canvas.style.width = width + 'px';\r\n\t\t\t\t_canvas.style.height = height + 'px';\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.setViewport( 0, 0, width, height );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setViewport = function ( x, y, width, height ) {\r\n\t\r\n\t\t\tstate.viewport( _viewport.set( x, y, width, height ) );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setScissor = function ( x, y, width, height ) {\r\n\t\r\n\t\t\tstate.scissor( _scissor.set( x, y, width, height ) );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setScissorTest = function ( boolean ) {\r\n\t\r\n\t\t\tstate.setScissorTest( _scissorTest = boolean );\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Clearing\r\n\t\r\n\t\tthis.getClearColor = function () {\r\n\t\r\n\t\t\treturn _clearColor;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setClearColor = function ( color, alpha ) {\r\n\t\r\n\t\t\t_clearColor.set( color );\r\n\t\r\n\t\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\r\n\t\r\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getClearAlpha = function () {\r\n\t\r\n\t\t\treturn _clearAlpha;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setClearAlpha = function ( alpha ) {\r\n\t\r\n\t\t\t_clearAlpha = alpha;\r\n\t\r\n\t\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clear = function ( color, depth, stencil ) {\r\n\t\r\n\t\t\tvar bits = 0;\r\n\t\r\n\t\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\r\n\t\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\r\n\t\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\r\n\t\r\n\t\t\t_gl.clear( bits );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clearColor = function () {\r\n\t\r\n\t\t\tthis.clear( true, false, false );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clearDepth = function () {\r\n\t\r\n\t\t\tthis.clear( false, true, false );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clearStencil = function () {\r\n\t\r\n\t\t\tthis.clear( false, false, true );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\r\n\t\r\n\t\t\tthis.setRenderTarget( renderTarget );\r\n\t\t\tthis.clear( color, depth, stencil );\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Reset\r\n\t\r\n\t\tthis.resetGLState = resetGLState;\r\n\t\r\n\t\tthis.dispose = function() {\r\n\t\r\n\t\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Events\r\n\t\r\n\t\tfunction onContextLost( event ) {\r\n\t\r\n\t\t\tevent.preventDefault();\r\n\t\r\n\t\t\tresetGLState();\r\n\t\t\tsetDefaultGLState();\r\n\t\r\n\t\t\tproperties.clear();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction onTextureDispose( event ) {\r\n\t\r\n\t\t\tvar texture = event.target;\r\n\t\r\n\t\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\r\n\t\r\n\t\t\tdeallocateTexture( texture );\r\n\t\r\n\t\t\t_infoMemory.textures --;\r\n\t\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction onRenderTargetDispose( event ) {\r\n\t\r\n\t\t\tvar renderTarget = event.target;\r\n\t\r\n\t\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\r\n\t\r\n\t\t\tdeallocateRenderTarget( renderTarget );\r\n\t\r\n\t\t\t_infoMemory.textures --;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction onMaterialDispose( event ) {\r\n\t\r\n\t\t\tvar material = event.target;\r\n\t\r\n\t\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\r\n\t\r\n\t\t\tdeallocateMaterial( material );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Buffer deallocation\r\n\t\r\n\t\tfunction deallocateTexture( texture ) {\r\n\t\r\n\t\t\tvar textureProperties = properties.get( texture );\r\n\t\r\n\t\t\tif ( texture.image && textureProperties.__image__webglTextureCube ) {\r\n\t\r\n\t\t\t\t// cube texture\r\n\t\r\n\t\t\t\t_gl.deleteTexture( textureProperties.__image__webglTextureCube );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// 2D texture\r\n\t\r\n\t\t\t\tif ( textureProperties.__webglInit === undefined ) return;\r\n\t\r\n\t\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// remove all webgl properties\r\n\t\t\tproperties.delete( texture );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction deallocateRenderTarget( renderTarget ) {\r\n\t\r\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\r\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\r\n\t\r\n\t\t\tif ( ! renderTarget ) return;\r\n\t\r\n\t\t\tif ( textureProperties.__webglTexture !== undefined ) {\r\n\t\r\n\t\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( renderTarget.depthTexture ) {\r\n\t\r\n\t\t\t\trenderTarget.depthTexture.dispose();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\r\n\t\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\r\n\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tproperties.delete( renderTarget.texture );\r\n\t\t\tproperties.delete( renderTarget );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction deallocateMaterial( material ) {\r\n\t\r\n\t\t\treleaseMaterialProgramReference( material );\r\n\t\r\n\t\t\tproperties.delete( material );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\tfunction releaseMaterialProgramReference( material ) {\r\n\t\r\n\t\t\tvar programInfo = properties.get( material ).program;\r\n\t\r\n\t\t\tmaterial.program = undefined;\r\n\t\r\n\t\t\tif ( programInfo !== undefined ) {\r\n\t\r\n\t\t\t\tprogramCache.releaseProgram( programInfo );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Buffer rendering\r\n\t\r\n\t\tthis.renderBufferImmediate = function ( object, program, material ) {\r\n\t\r\n\t\t\tstate.initAttributes();\r\n\t\r\n\t\t\tvar buffers = properties.get( object );\r\n\t\r\n\t\t\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\r\n\t\t\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\r\n\t\t\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\r\n\t\t\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\r\n\t\r\n\t\t\tvar attributes = program.getAttributes();\r\n\t\r\n\t\t\tif ( object.hasPositions ) {\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\r\n\t\r\n\t\t\t\tstate.enableAttribute( attributes.position );\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( object.hasNormals ) {\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\r\n\t\r\n\t\t\t\tif ( material.type !== 'MeshPhongMaterial' && material.type !== 'MeshStandardMaterial' && material.type !== 'MeshPhysicalMaterial' && material.shading === THREE.FlatShading ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\r\n\t\r\n\t\t\t\t\t\tvar array = object.normalArray;\r\n\t\r\n\t\t\t\t\t\tvar nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\r\n\t\t\t\t\t\tvar ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\r\n\t\t\t\t\t\tvar nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\r\n\t\r\n\t\t\t\t\t\tarray[ i + 0 ] = nx;\r\n\t\t\t\t\t\tarray[ i + 1 ] = ny;\r\n\t\t\t\t\t\tarray[ i + 2 ] = nz;\r\n\t\r\n\t\t\t\t\t\tarray[ i + 3 ] = nx;\r\n\t\t\t\t\t\tarray[ i + 4 ] = ny;\r\n\t\t\t\t\t\tarray[ i + 5 ] = nz;\r\n\t\r\n\t\t\t\t\t\tarray[ i + 6 ] = nx;\r\n\t\t\t\t\t\tarray[ i + 7 ] = ny;\r\n\t\t\t\t\t\tarray[ i + 8 ] = nz;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\r\n\t\r\n\t\t\t\tstate.enableAttribute( attributes.normal );\r\n\t\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( object.hasUvs && material.map ) {\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\r\n\t\r\n\t\t\t\tstate.enableAttribute( attributes.uv );\r\n\t\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( object.hasColors && material.vertexColors !== THREE.NoColors ) {\r\n\t\r\n\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\r\n\t\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\r\n\t\r\n\t\t\t\tstate.enableAttribute( attributes.color );\r\n\t\r\n\t\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tstate.disableUnusedAttributes();\r\n\t\r\n\t\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\r\n\t\r\n\t\t\tobject.count = 0;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\r\n\t\r\n\t\t\tsetMaterial( material );\r\n\t\r\n\t\t\tvar program = setProgram( camera, fog, material, object );\r\n\t\r\n\t\t\tvar updateBuffers = false;\r\n\t\t\tvar geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;\r\n\t\r\n\t\t\tif ( geometryProgram !== _currentGeometryProgram ) {\r\n\t\r\n\t\t\t\t_currentGeometryProgram = geometryProgram;\r\n\t\t\t\tupdateBuffers = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// morph targets\r\n\t\r\n\t\t\tvar morphTargetInfluences = object.morphTargetInfluences;\r\n\t\r\n\t\t\tif ( morphTargetInfluences !== undefined ) {\r\n\t\r\n\t\t\t\tvar activeInfluences = [];\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar influence = morphTargetInfluences[ i ];\r\n\t\t\t\t\tactiveInfluences.push( [ influence, i ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tactiveInfluences.sort( absNumericalSort );\r\n\t\r\n\t\t\t\tif ( activeInfluences.length > 8 ) {\r\n\t\r\n\t\t\t\t\tactiveInfluences.length = 8;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar morphAttributes = geometry.morphAttributes;\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar influence = activeInfluences[ i ];\r\n\t\t\t\t\tmorphInfluences[ i ] = influence[ 0 ];\r\n\t\r\n\t\t\t\t\tif ( influence[ 0 ] !== 0 ) {\r\n\t\r\n\t\t\t\t\t\tvar index = influence[ 1 ];\r\n\t\r\n\t\t\t\t\t\tif ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );\r\n\t\t\t\t\t\tif ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tif ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );\r\n\t\t\t\t\t\tif ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tprogram.getUniforms().setValue(\r\n\t\t\t\t\t\t_gl, 'morphTargetInfluences', morphInfluences );\r\n\t\r\n\t\t\t\tupdateBuffers = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tvar index = geometry.index;\r\n\t\t\tvar position = geometry.attributes.position;\r\n\t\r\n\t\t\tif ( material.wireframe === true ) {\r\n\t\r\n\t\t\t\tindex = objects.getWireframeAttribute( geometry );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar renderer;\r\n\t\r\n\t\t\tif ( index !== null ) {\r\n\t\r\n\t\t\t\trenderer = indexedBufferRenderer;\r\n\t\t\t\trenderer.setIndex( index );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\trenderer = bufferRenderer;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( updateBuffers ) {\r\n\t\r\n\t\t\t\tsetupVertexAttributes( material, program, geometry );\r\n\t\r\n\t\t\t\tif ( index !== null ) {\r\n\t\r\n\t\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tvar dataStart = 0;\r\n\t\t\tvar dataCount = Infinity;\r\n\t\r\n\t\t\tif ( index !== null ) {\r\n\t\r\n\t\t\t\tdataCount = index.count;\r\n\t\r\n\t\t\t} else if ( position !== undefined ) {\r\n\t\r\n\t\t\t\tdataCount = position.count;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar rangeStart = geometry.drawRange.start;\r\n\t\t\tvar rangeCount = geometry.drawRange.count;\r\n\t\r\n\t\t\tvar groupStart = group !== null ? group.start : 0;\r\n\t\t\tvar groupCount = group !== null ? group.count : Infinity;\r\n\t\r\n\t\t\tvar drawStart = Math.max( dataStart, rangeStart, groupStart );\r\n\t\t\tvar drawEnd = Math.min( dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\r\n\t\r\n\t\t\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tif ( object instanceof THREE.Mesh ) {\r\n\t\r\n\t\t\t\tif ( material.wireframe === true ) {\r\n\t\r\n\t\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\r\n\t\t\t\t\trenderer.setMode( _gl.LINES );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tswitch ( object.drawMode ) {\r\n\t\r\n\t\t\t\t\t\tcase THREE.TrianglesDrawMode:\r\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLES );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase THREE.TriangleStripDrawMode:\r\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_STRIP );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase THREE.TriangleFanDrawMode:\r\n\t\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_FAN );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t} else if ( object instanceof THREE.Line ) {\r\n\t\r\n\t\t\t\tvar lineWidth = material.linewidth;\r\n\t\r\n\t\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\r\n\t\r\n\t\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\r\n\t\r\n\t\t\t\tif ( object instanceof THREE.LineSegments ) {\r\n\t\r\n\t\t\t\t\trenderer.setMode( _gl.LINES );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( object instanceof THREE.Points ) {\r\n\t\r\n\t\t\t\trenderer.setMode( _gl.POINTS );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.InstancedBufferGeometry ) {\r\n\t\r\n\t\t\t\tif ( geometry.maxInstancedCount > 0 ) {\r\n\t\r\n\t\t\t\t\trenderer.renderInstances( geometry, drawStart, drawCount );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\trenderer.render( drawStart, drawCount );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\r\n\t\r\n\t\t\tvar extension;\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.InstancedBufferGeometry ) {\r\n\t\r\n\t\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\t\r\n\t\t\t\tif ( extension === null ) {\r\n\t\r\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\r\n\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( startIndex === undefined ) startIndex = 0;\r\n\t\r\n\t\t\tstate.initAttributes();\r\n\t\r\n\t\t\tvar geometryAttributes = geometry.attributes;\r\n\t\r\n\t\t\tvar programAttributes = program.getAttributes();\r\n\t\r\n\t\t\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\r\n\t\r\n\t\t\tfor ( var name in programAttributes ) {\r\n\t\r\n\t\t\t\tvar programAttribute = programAttributes[ name ];\r\n\t\r\n\t\t\t\tif ( programAttribute >= 0 ) {\r\n\t\r\n\t\t\t\t\tvar geometryAttribute = geometryAttributes[ name ];\r\n\t\r\n\t\t\t\t\tif ( geometryAttribute !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tvar type = _gl.FLOAT;\r\n\t\t\t\t\t\tvar array = geometryAttribute.array;\r\n\t\t\t\t\t\tvar normalized = geometryAttribute.normalized;\r\n\t\r\n\t\t\t\t\t\tif ( array instanceof Float32Array ) {\r\n\t\r\n\t\t\t\t\t\t\ttype = _gl.FLOAT;\r\n\t\r\n\t\t\t\t\t\t} else if ( array instanceof Float64Array ) {\r\n\t\r\n\t\t\t\t\t\t\tconsole.warn(\"Unsupported data buffer format: Float64Array\");\r\n\t\r\n\t\t\t\t\t\t} else if ( array instanceof Uint16Array ) {\r\n\t\r\n\t\t\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\r\n\t\r\n\t\t\t\t\t\t} else if ( array instanceof Int16Array ) {\r\n\t\r\n\t\t\t\t\t\t\ttype = _gl.SHORT;\r\n\t\r\n\t\t\t\t\t\t} else if ( array instanceof Uint32Array ) {\r\n\t\r\n\t\t\t\t\t\t\ttype = _gl.UNSIGNED_INT;\r\n\t\r\n\t\t\t\t\t\t} else if ( array instanceof Int32Array ) {\r\n\t\r\n\t\t\t\t\t\t\ttype = _gl.INT;\r\n\t\r\n\t\t\t\t\t\t} else if ( array instanceof Int8Array ) {\r\n\t\r\n\t\t\t\t\t\t\ttype = _gl.BYTE;\r\n\t\r\n\t\t\t\t\t\t} else if ( array instanceof Uint8Array ) {\r\n\t\r\n\t\t\t\t\t\t\ttype = _gl.UNSIGNED_BYTE;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tvar size = geometryAttribute.itemSize;\r\n\t\t\t\t\t\tvar buffer = objects.getAttributeBuffer( geometryAttribute );\r\n\t\r\n\t\t\t\t\t\tif ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\t\r\n\t\t\t\t\t\t\tvar data = geometryAttribute.data;\r\n\t\t\t\t\t\t\tvar stride = data.stride;\r\n\t\t\t\t\t\t\tvar offset = geometryAttribute.offset;\r\n\t\r\n\t\t\t\t\t\t\tif ( data instanceof THREE.InstancedInterleavedBuffer ) {\r\n\t\r\n\t\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );\r\n\t\r\n\t\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\r\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tif ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {\r\n\t\r\n\t\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );\r\n\t\r\n\t\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\r\n\t\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tvar value = materialDefaultAttributeValues[ name ];\r\n\t\r\n\t\t\t\t\t\tif ( value !== undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tswitch ( value.length ) {\r\n\t\r\n\t\t\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, value );\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, value );\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib4fv( programAttribute, value );\r\n\t\t\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\t\t_gl.vertexAttrib1fv( programAttribute, value );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tstate.disableUnusedAttributes();\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Sorting\r\n\t\r\n\t\tfunction absNumericalSort( a, b ) {\r\n\t\r\n\t\t\treturn Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction painterSortStable ( a, b ) {\r\n\t\r\n\t\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\r\n\t\r\n\t\t\t\treturn a.object.renderOrder - b.object.renderOrder;\r\n\t\r\n\t\t\t} else if ( a.material.id !== b.material.id ) {\r\n\t\r\n\t\t\t\treturn a.material.id - b.material.id;\r\n\t\r\n\t\t\t} else if ( a.z !== b.z ) {\r\n\t\r\n\t\t\t\treturn a.z - b.z;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\treturn a.id - b.id;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction reversePainterSortStable ( a, b ) {\r\n\t\r\n\t\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\r\n\t\r\n\t\t\t\treturn a.object.renderOrder - b.object.renderOrder;\r\n\t\r\n\t\t\t} if ( a.z !== b.z ) {\r\n\t\r\n\t\t\t\treturn b.z - a.z;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\treturn a.id - b.id;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Rendering\r\n\t\r\n\t\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\r\n\t\r\n\t\t\tif ( camera instanceof THREE.Camera === false ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar fog = scene.fog;\r\n\t\r\n\t\t\t// reset caching for this frame\r\n\t\r\n\t\t\t_currentGeometryProgram = '';\r\n\t\t\t_currentMaterialId = - 1;\r\n\t\t\t_currentCamera = null;\r\n\t\r\n\t\t\t// update scene graph\r\n\t\r\n\t\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\r\n\t\r\n\t\t\t// update camera matrices and frustum\r\n\t\r\n\t\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\r\n\t\r\n\t\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\r\n\t\r\n\t\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\r\n\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\t\r\n\t\t\tlights.length = 0;\r\n\t\r\n\t\t\topaqueObjectsLastIndex = - 1;\r\n\t\t\ttransparentObjectsLastIndex = - 1;\r\n\t\r\n\t\t\tsprites.length = 0;\r\n\t\t\tlensFlares.length = 0;\r\n\t\r\n\t\t\t_localClippingEnabled = this.localClippingEnabled;\r\n\t\t\t_clippingEnabled = _clipping.init(\r\n\t\t\t\t\tthis.clippingPlanes, _localClippingEnabled, camera );\r\n\t\r\n\t\t\tprojectObject( scene, camera );\r\n\t\r\n\t\r\n\t\t\topaqueObjects.length = opaqueObjectsLastIndex + 1;\r\n\t\t\ttransparentObjects.length = transparentObjectsLastIndex + 1;\r\n\t\r\n\t\t\tif ( _this.sortObjects === true ) {\r\n\t\r\n\t\t\t\topaqueObjects.sort( painterSortStable );\r\n\t\t\t\ttransparentObjects.sort( reversePainterSortStable );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tif ( _clippingEnabled ) _clipping.beginShadows();\r\n\t\r\n\t\t\tsetupShadows( lights );\r\n\t\r\n\t\t\tshadowMap.render( scene, camera );\r\n\t\r\n\t\t\tsetupLights( lights, camera );\r\n\t\r\n\t\t\tif ( _clippingEnabled ) _clipping.endShadows();\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\t_infoRender.calls = 0;\r\n\t\t\t_infoRender.vertices = 0;\r\n\t\t\t_infoRender.faces = 0;\r\n\t\t\t_infoRender.points = 0;\r\n\t\r\n\t\t\tif ( renderTarget === undefined ) {\r\n\t\r\n\t\t\t\trenderTarget = null;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.setRenderTarget( renderTarget );\r\n\t\r\n\t\t\tif ( this.autoClear || forceClear ) {\r\n\t\r\n\t\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tif ( scene.overrideMaterial ) {\r\n\t\r\n\t\t\t\tvar overrideMaterial = scene.overrideMaterial;\r\n\t\r\n\t\t\t\trenderObjects( opaqueObjects, camera, fog, overrideMaterial );\r\n\t\t\t\trenderObjects( transparentObjects, camera, fog, overrideMaterial );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// opaque pass (front-to-back order)\r\n\t\r\n\t\t\t\tstate.setBlending( THREE.NoBlending );\r\n\t\t\t\trenderObjects( opaqueObjects, camera, fog );\r\n\t\r\n\t\t\t\t// transparent pass (back-to-front order)\r\n\t\r\n\t\t\t\trenderObjects( transparentObjects, camera, fog );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// custom render plugins (post pass)\r\n\t\r\n\t\t\tspritePlugin.render( scene, camera );\r\n\t\t\tlensFlarePlugin.render( scene, camera, _currentViewport );\r\n\t\r\n\t\t\t// Generate mipmap if we're using any kind of mipmap filtering\r\n\t\r\n\t\t\tif ( renderTarget ) {\r\n\t\r\n\t\t\t\tvar texture = renderTarget.texture;\r\n\t\r\n\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&\r\n\t\t\t\t\t\ttexture.minFilter !== THREE.NearestFilter &&\r\n\t\t\t\t\t\ttexture.minFilter !== THREE.LinearFilter ) {\r\n\t\r\n\t\t\t\t\tupdateRenderTargetMipmap( renderTarget );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\r\n\t\r\n\t\t\tstate.setDepthTest( true );\r\n\t\t\tstate.setDepthWrite( true );\r\n\t\t\tstate.setColorWrite( true );\r\n\t\r\n\t\t\t// _gl.finish();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction pushRenderItem( object, geometry, material, z, group ) {\r\n\t\r\n\t\t\tvar array, index;\r\n\t\r\n\t\t\t// allocate the next position in the appropriate array\r\n\t\r\n\t\t\tif ( material.transparent ) {\r\n\t\r\n\t\t\t\tarray = transparentObjects;\r\n\t\t\t\tindex = ++ transparentObjectsLastIndex;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tarray = opaqueObjects;\r\n\t\t\t\tindex = ++ opaqueObjectsLastIndex;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// recycle existing render item or grow the array\r\n\t\r\n\t\t\tvar renderItem = array[ index ];\r\n\t\r\n\t\t\tif ( renderItem !== undefined ) {\r\n\t\r\n\t\t\t\trenderItem.id = object.id;\r\n\t\t\t\trenderItem.object = object;\r\n\t\t\t\trenderItem.geometry = geometry;\r\n\t\t\t\trenderItem.material = material;\r\n\t\t\t\trenderItem.z = _vector3.z;\r\n\t\t\t\trenderItem.group = group;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\trenderItem = {\r\n\t\t\t\t\tid: object.id,\r\n\t\t\t\t\tobject: object,\r\n\t\t\t\t\tgeometry: geometry,\r\n\t\t\t\t\tmaterial: material,\r\n\t\t\t\t\tz: _vector3.z,\r\n\t\t\t\t\tgroup: group\r\n\t\t\t\t};\r\n\t\r\n\t\t\t\t// assert( index === array.length );\r\n\t\t\t\tarray.push( renderItem );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// TODO Duplicated code (Frustum)\r\n\t\r\n\t\tfunction isObjectViewable( object ) {\r\n\t\r\n\t\t\tvar geometry = object.geometry;\r\n\t\r\n\t\t\tif ( geometry.boundingSphere === null )\r\n\t\t\t\tgeometry.computeBoundingSphere();\r\n\t\r\n\t\t\t_sphere.copy( geometry.boundingSphere ).\r\n\t\t\t\tapplyMatrix4( object.matrixWorld );\r\n\t\r\n\t\t\treturn isSphereViewable( _sphere );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction isSpriteViewable( sprite ) {\r\n\t\r\n\t\t\t_sphere.center.set( 0, 0, 0 );\r\n\t\t\t_sphere.radius = 0.7071067811865476;\r\n\t\t\t_sphere.applyMatrix4( sprite.matrixWorld );\r\n\t\r\n\t\t\treturn isSphereViewable( _sphere );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction isSphereViewable( sphere ) {\r\n\t\r\n\t\t\tif ( ! _frustum.intersectsSphere( sphere ) ) return false;\r\n\t\r\n\t\t\tvar numPlanes = _clipping.numPlanes;\r\n\t\r\n\t\t\tif ( numPlanes === 0 ) return true;\r\n\t\r\n\t\t\tvar planes = _this.clippingPlanes,\r\n\t\r\n\t\t\t\tcenter = sphere.center,\r\n\t\t\t\tnegRad = - sphere.radius,\r\n\t\t\t\ti = 0;\r\n\t\r\n\t\t\tdo {\r\n\t\r\n\t\t\t\t// out when deeper than radius in the negative halfspace\r\n\t\t\t\tif ( planes[ i ].distanceToPoint( center ) < negRad ) return false;\r\n\t\r\n\t\t\t} while ( ++ i !== numPlanes );\r\n\t\r\n\t\t\treturn true;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction projectObject( object, camera ) {\r\n\t\r\n\t\t\tif ( object.visible === false ) return;\r\n\t\r\n\t\t\tif ( object.layers.test( camera.layers ) ) {\r\n\t\r\n\t\t\t\tif ( object instanceof THREE.Light ) {\r\n\t\r\n\t\t\t\t\tlights.push( object );\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.Sprite ) {\r\n\t\r\n\t\t\t\t\tif ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {\r\n\t\r\n\t\t\t\t\t\tsprites.push( object );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.LensFlare ) {\r\n\t\r\n\t\t\t\t\tlensFlares.push( object );\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.ImmediateRenderObject ) {\r\n\t\r\n\t\t\t\t\tif ( _this.sortObjects === true ) {\r\n\t\r\n\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\r\n\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tpushRenderItem( object, null, object.material, _vector3.z, null );\r\n\t\r\n\t\t\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {\r\n\t\r\n\t\t\t\t\tif ( object instanceof THREE.SkinnedMesh ) {\r\n\t\r\n\t\t\t\t\t\tobject.skeleton.update();\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( object.frustumCulled === false || isObjectViewable( object ) === true ) {\r\n\t\r\n\t\t\t\t\t\tvar material = object.material;\r\n\t\r\n\t\t\t\t\t\tif ( material.visible === true ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( _this.sortObjects === true ) {\r\n\t\r\n\t\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\r\n\t\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\tvar geometry = objects.update( object );\r\n\t\r\n\t\t\t\t\t\t\tif ( material instanceof THREE.MultiMaterial ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvar groups = geometry.groups;\r\n\t\t\t\t\t\t\t\tvar materials = material.materials;\r\n\t\r\n\t\t\t\t\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tvar group = groups[ i ];\r\n\t\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\r\n\t\r\n\t\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, groupMaterial, _vector3.z, group );\r\n\t\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, material, _vector3.z, null );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar children = object.children;\r\n\t\r\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tprojectObject( children[ i ], camera );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction renderObjects( renderList, camera, fog, overrideMaterial ) {\r\n\t\r\n\t\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar renderItem = renderList[ i ];\r\n\t\r\n\t\t\t\tvar object = renderItem.object;\r\n\t\t\t\tvar geometry = renderItem.geometry;\r\n\t\t\t\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\r\n\t\t\t\tvar group = renderItem.group;\r\n\t\r\n\t\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\r\n\t\t\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\r\n\t\r\n\t\t\t\tif ( object instanceof THREE.ImmediateRenderObject ) {\r\n\t\r\n\t\t\t\t\tsetMaterial( material );\r\n\t\r\n\t\t\t\t\tvar program = setProgram( camera, fog, material, object );\r\n\t\r\n\t\t\t\t\t_currentGeometryProgram = '';\r\n\t\r\n\t\t\t\t\tobject.render( function ( object ) {\r\n\t\r\n\t\t\t\t\t\t_this.renderBufferImmediate( object, program, material );\r\n\t\r\n\t\t\t\t\t} );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t_this.renderBufferDirect( camera, fog, geometry, material, object, group );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction initMaterial( material, fog, object ) {\r\n\t\r\n\t\t\tvar materialProperties = properties.get( material );\r\n\t\r\n\t\t\tvar parameters = programCache.getParameters(\r\n\t\t\t\t\tmaterial, _lights, fog, _clipping.numPlanes, object );\r\n\t\r\n\t\t\tvar code = programCache.getProgramCode( material, parameters );\r\n\t\r\n\t\t\tvar program = materialProperties.program;\r\n\t\t\tvar programChange = true;\r\n\t\r\n\t\t\tif ( program === undefined ) {\r\n\t\r\n\t\t\t\t// new material\r\n\t\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\r\n\t\r\n\t\t\t} else if ( program.code !== code ) {\r\n\t\r\n\t\t\t\t// changed glsl or parameters\r\n\t\t\t\treleaseMaterialProgramReference( material );\r\n\t\r\n\t\t\t} else if ( parameters.shaderID !== undefined ) {\r\n\t\r\n\t\t\t\t// same glsl and uniform list\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// only rebuild uniform list\r\n\t\t\t\tprogramChange = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( programChange ) {\r\n\t\r\n\t\t\t\tif ( parameters.shaderID ) {\r\n\t\r\n\t\t\t\t\tvar shader = THREE.ShaderLib[ parameters.shaderID ];\r\n\t\r\n\t\t\t\t\tmaterialProperties.__webglShader = {\r\n\t\t\t\t\t\tname: material.type,\r\n\t\t\t\t\t\tuniforms: THREE.UniformsUtils.clone( shader.uniforms ),\r\n\t\t\t\t\t\tvertexShader: shader.vertexShader,\r\n\t\t\t\t\t\tfragmentShader: shader.fragmentShader\r\n\t\t\t\t\t};\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tmaterialProperties.__webglShader = {\r\n\t\t\t\t\t\tname: material.type,\r\n\t\t\t\t\t\tuniforms: material.uniforms,\r\n\t\t\t\t\t\tvertexShader: material.vertexShader,\r\n\t\t\t\t\t\tfragmentShader: material.fragmentShader\r\n\t\t\t\t\t};\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tmaterial.__webglShader = materialProperties.__webglShader;\r\n\t\r\n\t\t\t\tprogram = programCache.acquireProgram( material, parameters, code );\r\n\t\r\n\t\t\t\tmaterialProperties.program = program;\r\n\t\t\t\tmaterial.program = program;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar attributes = program.getAttributes();\r\n\t\r\n\t\t\tif ( material.morphTargets ) {\r\n\t\r\n\t\t\t\tmaterial.numSupportedMorphTargets = 0;\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\r\n\t\r\n\t\t\t\t\tif ( attributes[ 'morphTarget' + i ] >= 0 ) {\r\n\t\r\n\t\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.morphNormals ) {\r\n\t\r\n\t\t\t\tmaterial.numSupportedMorphNormals = 0;\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\r\n\t\r\n\t\t\t\t\tif ( attributes[ 'morphNormal' + i ] >= 0 ) {\r\n\t\r\n\t\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar uniforms = materialProperties.__webglShader.uniforms;\r\n\t\r\n\t\t\tif ( ! ( material instanceof THREE.ShaderMaterial ) &&\r\n\t\t\t\t\t! ( material instanceof THREE.RawShaderMaterial ) ||\r\n\t\t\t\t\tmaterial.clipping === true ) {\r\n\t\r\n\t\t\t\tmaterialProperties.numClippingPlanes = _clipping.numPlanes;\r\n\t\t\t\tuniforms.clippingPlanes = _clipping.uniform;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.lights ) {\r\n\t\r\n\t\t\t\t// store the light setup it was created for\r\n\t\r\n\t\t\t\tmaterialProperties.lightsHash = _lights.hash;\r\n\t\r\n\t\t\t\t// wire up the material to this renderer's lighting state\r\n\t\r\n\t\t\t\tuniforms.ambientLightColor.value = _lights.ambient;\r\n\t\t\t\tuniforms.directionalLights.value = _lights.directional;\r\n\t\t\t\tuniforms.spotLights.value = _lights.spot;\r\n\t\t\t\tuniforms.pointLights.value = _lights.point;\r\n\t\t\t\tuniforms.hemisphereLights.value = _lights.hemi;\r\n\t\r\n\t\t\t\tuniforms.directionalShadowMap.value = _lights.directionalShadowMap;\r\n\t\t\t\tuniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;\r\n\t\t\t\tuniforms.spotShadowMap.value = _lights.spotShadowMap;\r\n\t\t\t\tuniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;\r\n\t\t\t\tuniforms.pointShadowMap.value = _lights.pointShadowMap;\r\n\t\t\t\tuniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar progUniforms = materialProperties.program.getUniforms(),\r\n\t\t\t\tuniformsList =\r\n\t\t\t\t\t\tTHREE.WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\r\n\t\r\n\t\t\tmaterialProperties.uniformsList = uniformsList;\r\n\t\t\tmaterialProperties.dynamicUniforms =\r\n\t\t\t\t\tTHREE.WebGLUniforms.splitDynamic( uniformsList, uniforms );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setMaterial( material ) {\r\n\t\r\n\t\t\tif ( material.side !== THREE.DoubleSide )\r\n\t\t\t\tstate.enable( _gl.CULL_FACE );\r\n\t\t\telse\r\n\t\t\t\tstate.disable( _gl.CULL_FACE );\r\n\t\r\n\t\t\tstate.setFlipSided( material.side === THREE.BackSide );\r\n\t\r\n\t\t\tif ( material.transparent === true ) {\r\n\t\r\n\t\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tstate.setBlending( THREE.NoBlending );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tstate.setDepthFunc( material.depthFunc );\r\n\t\t\tstate.setDepthTest( material.depthTest );\r\n\t\t\tstate.setDepthWrite( material.depthWrite );\r\n\t\t\tstate.setColorWrite( material.colorWrite );\r\n\t\t\tstate.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setProgram( camera, fog, material, object ) {\r\n\t\r\n\t\t\t_usedTextureUnits = 0;\r\n\t\r\n\t\t\tvar materialProperties = properties.get( material );\r\n\t\r\n\t\t\tif ( _clippingEnabled ) {\r\n\t\r\n\t\t\t\tif ( _localClippingEnabled || camera !== _currentCamera ) {\r\n\t\r\n\t\t\t\t\tvar useCache =\r\n\t\t\t\t\t\t\tcamera === _currentCamera &&\r\n\t\t\t\t\t\t\tmaterial.id === _currentMaterialId;\r\n\t\r\n\t\t\t\t\t// we might want to call this function with some ClippingGroup\r\n\t\t\t\t\t// object instead of the material, once it becomes feasible\r\n\t\t\t\t\t// (#8465, #8379)\r\n\t\t\t\t\t_clipping.setState(\r\n\t\t\t\t\t\t\tmaterial.clippingPlanes, material.clipShadows,\r\n\t\t\t\t\t\t\tcamera, materialProperties, useCache );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( materialProperties.numClippingPlanes !== undefined &&\r\n\t\t\t\t\tmaterialProperties.numClippingPlanes !== _clipping.numPlanes ) {\r\n\t\r\n\t\t\t\t\tmaterial.needsUpdate = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( materialProperties.program === undefined ) {\r\n\t\r\n\t\t\t\tmaterial.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( materialProperties.lightsHash !== undefined &&\r\n\t\t\t\tmaterialProperties.lightsHash !== _lights.hash ) {\r\n\t\r\n\t\t\t\tmaterial.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.needsUpdate ) {\r\n\t\r\n\t\t\t\tinitMaterial( material, fog, object );\r\n\t\t\t\tmaterial.needsUpdate = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar refreshProgram = false;\r\n\t\t\tvar refreshMaterial = false;\r\n\t\t\tvar refreshLights = false;\r\n\t\r\n\t\t\tvar program = materialProperties.program,\r\n\t\t\t\tp_uniforms = program.getUniforms(),\r\n\t\t\t\tm_uniforms = materialProperties.__webglShader.uniforms;\r\n\t\r\n\t\t\tif ( program.id !== _currentProgram ) {\r\n\t\r\n\t\t\t\t_gl.useProgram( program.program );\r\n\t\t\t\t_currentProgram = program.id;\r\n\t\r\n\t\t\t\trefreshProgram = true;\r\n\t\t\t\trefreshMaterial = true;\r\n\t\t\t\trefreshLights = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.id !== _currentMaterialId ) {\r\n\t\r\n\t\t\t\t_currentMaterialId = material.id;\r\n\t\r\n\t\t\t\trefreshMaterial = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( refreshProgram || camera !== _currentCamera ) {\r\n\t\r\n\t\t\t\tp_uniforms.set( _gl, camera, 'projectionMatrix' );\r\n\t\r\n\t\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\r\n\t\r\n\t\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\r\n\t\t\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\tif ( camera !== _currentCamera ) {\r\n\t\r\n\t\t\t\t\t_currentCamera = camera;\r\n\t\r\n\t\t\t\t\t// lighting uniforms depend on the camera so enforce an update\r\n\t\t\t\t\t// now, in case this material supports lights - or later, when\r\n\t\t\t\t\t// the next material that does gets activated:\r\n\t\r\n\t\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\r\n\t\t\t\t\trefreshLights = true;\t\t// remains set until update done\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// load material specific uniforms\r\n\t\t\t\t// (shader material also gets them for the sake of genericity)\r\n\t\r\n\t\t\t\tif ( material instanceof THREE.ShaderMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\r\n\t\t\t\t\t material.envMap ) {\r\n\t\r\n\t\t\t\t\tvar uCamPos = p_uniforms.map.cameraPosition;\r\n\t\r\n\t\t\t\t\tif ( uCamPos !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tuCamPos.setValue( _gl,\r\n\t\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshBasicMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\r\n\t\t\t\t\t material instanceof THREE.ShaderMaterial ||\r\n\t\t\t\t\t material.skinning ) {\r\n\t\r\n\t\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tp_uniforms.set( _gl, _this, 'toneMappingExposure' );\r\n\t\t\t\tp_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// skinning uniforms must be set even if material didn't change\r\n\t\t\t// auto-setting of texture unit for bone texture must go before other textures\r\n\t\t\t// not sure why, but otherwise weird things happen\r\n\t\r\n\t\t\tif ( material.skinning ) {\r\n\t\r\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\r\n\t\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\r\n\t\r\n\t\t\t\tvar skeleton = object.skeleton;\r\n\t\r\n\t\t\t\tif ( skeleton ) {\r\n\t\r\n\t\t\t\t\tif ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {\r\n\t\r\n\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTexture' );\r\n\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureWidth' );\r\n\t\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureHeight' );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( refreshMaterial ) {\r\n\t\r\n\t\t\t\tif ( material.lights ) {\r\n\t\r\n\t\t\t\t\t// the current material requires lighting info\r\n\t\r\n\t\t\t\t\t// note: all lighting uniforms are always set correctly\r\n\t\t\t\t\t// they simply reference the renderer's state for their\r\n\t\t\t\t\t// values\r\n\t\t\t\t\t//\r\n\t\t\t\t\t// use the current material's .needsUpdate flags to set\r\n\t\t\t\t\t// the GL state when required\r\n\t\r\n\t\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// refresh uniforms common to several materials\r\n\t\r\n\t\t\t\tif ( fog && material.fog ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsFog( m_uniforms, fog );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( material instanceof THREE.MeshBasicMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\r\n\t\t\t\t\t material instanceof THREE.MeshDepthMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsCommon( m_uniforms, material );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// refresh single material specific uniforms\r\n\t\r\n\t\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsLine( m_uniforms, material );\r\n\t\t\t\t\trefreshUniformsDash( m_uniforms, material );\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.PointsMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsPoints( m_uniforms, material );\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsLambert( m_uniforms, material );\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsPhong( m_uniforms, material );\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.MeshPhysicalMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsPhysical( m_uniforms, material );\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.MeshStandardMaterial ) {\r\n\t\r\n\t\t\t\t\trefreshUniformsStandard( m_uniforms, material );\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\r\n\t\r\n\t\t\t\t\tif ( material.displacementMap ) {\r\n\t\r\n\t\t\t\t\t\tm_uniforms.displacementMap.value = material.displacementMap;\r\n\t\t\t\t\t\tm_uniforms.displacementScale.value = material.displacementScale;\r\n\t\t\t\t\t\tm_uniforms.displacementBias.value = material.displacementBias;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\r\n\t\r\n\t\t\t\t\tm_uniforms.opacity.value = material.opacity;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tTHREE.WebGLUniforms.upload(\r\n\t\t\t\t\t\t_gl, materialProperties.uniformsList, m_uniforms, _this );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\t// common matrices\r\n\t\r\n\t\t\tp_uniforms.set( _gl, object, 'modelViewMatrix' );\r\n\t\t\tp_uniforms.set( _gl, object, 'normalMatrix' );\r\n\t\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\r\n\t\r\n\t\r\n\t\t\t// dynamic uniforms\r\n\t\r\n\t\t\tvar dynUniforms = materialProperties.dynamicUniforms;\r\n\t\r\n\t\t\tif ( dynUniforms !== null ) {\r\n\t\r\n\t\t\t\tTHREE.WebGLUniforms.evalDynamic(\r\n\t\t\t\t\t\tdynUniforms, m_uniforms, object, camera );\r\n\t\r\n\t\t\t\tTHREE.WebGLUniforms.upload( _gl, dynUniforms, m_uniforms, _this );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn program;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Uniforms (refresh uniforms objects)\r\n\t\r\n\t\tfunction refreshUniformsCommon ( uniforms, material ) {\r\n\t\r\n\t\t\tuniforms.opacity.value = material.opacity;\r\n\t\r\n\t\t\tuniforms.diffuse.value = material.color;\r\n\t\r\n\t\t\tif ( material.emissive ) {\r\n\t\r\n\t\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tuniforms.map.value = material.map;\r\n\t\t\tuniforms.specularMap.value = material.specularMap;\r\n\t\t\tuniforms.alphaMap.value = material.alphaMap;\r\n\t\r\n\t\t\tif ( material.aoMap ) {\r\n\t\r\n\t\t\t\tuniforms.aoMap.value = material.aoMap;\r\n\t\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// uv repeat and offset setting priorities\r\n\t\t\t// 1. color map\r\n\t\t\t// 2. specular map\r\n\t\t\t// 3. normal map\r\n\t\t\t// 4. bump map\r\n\t\t\t// 5. alpha map\r\n\t\t\t// 6. emissive map\r\n\t\r\n\t\t\tvar uvScaleMap;\r\n\t\r\n\t\t\tif ( material.map ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.map;\r\n\t\r\n\t\t\t} else if ( material.specularMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.specularMap;\r\n\t\r\n\t\t\t} else if ( material.displacementMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.displacementMap;\r\n\t\r\n\t\t\t} else if ( material.normalMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.normalMap;\r\n\t\r\n\t\t\t} else if ( material.bumpMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.bumpMap;\r\n\t\r\n\t\t\t} else if ( material.roughnessMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.roughnessMap;\r\n\t\r\n\t\t\t} else if ( material.metalnessMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.metalnessMap;\r\n\t\r\n\t\t\t} else if ( material.alphaMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.alphaMap;\r\n\t\r\n\t\t\t} else if ( material.emissiveMap ) {\r\n\t\r\n\t\t\t\tuvScaleMap = material.emissiveMap;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( uvScaleMap !== undefined ) {\r\n\t\r\n\t\t\t\t// backwards compatibility\r\n\t\t\t\tif ( uvScaleMap instanceof THREE.WebGLRenderTarget ) {\r\n\t\r\n\t\t\t\t\tuvScaleMap = uvScaleMap.texture;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar offset = uvScaleMap.offset;\r\n\t\t\t\tvar repeat = uvScaleMap.repeat;\r\n\t\r\n\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tuniforms.envMap.value = material.envMap;\r\n\t\r\n\t\t\t// don't flip CubeTexture envMaps, flip everything else:\r\n\t\t\t//  WebGLRenderTargetCube will be flipped for backwards compatibility\r\n\t\t\t//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\r\n\t\t\t// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\r\n\t\t\tuniforms.flipEnvMap.value = ( ! ( material.envMap instanceof THREE.CubeTexture ) ) ? 1 : - 1;\r\n\t\r\n\t\t\tuniforms.reflectivity.value = material.reflectivity;\r\n\t\t\tuniforms.refractionRatio.value = material.refractionRatio;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsLine ( uniforms, material ) {\r\n\t\r\n\t\t\tuniforms.diffuse.value = material.color;\r\n\t\t\tuniforms.opacity.value = material.opacity;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsDash ( uniforms, material ) {\r\n\t\r\n\t\t\tuniforms.dashSize.value = material.dashSize;\r\n\t\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\r\n\t\t\tuniforms.scale.value = material.scale;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsPoints ( uniforms, material ) {\r\n\t\r\n\t\t\tuniforms.diffuse.value = material.color;\r\n\t\t\tuniforms.opacity.value = material.opacity;\r\n\t\t\tuniforms.size.value = material.size * _pixelRatio;\r\n\t\t\tuniforms.scale.value = _canvas.clientHeight * 0.5;\r\n\t\r\n\t\t\tuniforms.map.value = material.map;\r\n\t\r\n\t\t\tif ( material.map !== null ) {\r\n\t\r\n\t\t\t\tvar offset = material.map.offset;\r\n\t\t\t\tvar repeat = material.map.repeat;\r\n\t\r\n\t\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsFog ( uniforms, fog ) {\r\n\t\r\n\t\t\tuniforms.fogColor.value = fog.color;\r\n\t\r\n\t\t\tif ( fog instanceof THREE.Fog ) {\r\n\t\r\n\t\t\t\tuniforms.fogNear.value = fog.near;\r\n\t\t\t\tuniforms.fogFar.value = fog.far;\r\n\t\r\n\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\r\n\t\r\n\t\t\t\tuniforms.fogDensity.value = fog.density;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsLambert ( uniforms, material ) {\r\n\t\r\n\t\t\tif ( material.lightMap ) {\r\n\t\r\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\r\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.emissiveMap ) {\r\n\t\r\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsPhong ( uniforms, material ) {\r\n\t\r\n\t\t\tuniforms.specular.value = material.specular;\r\n\t\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\r\n\t\r\n\t\t\tif ( material.lightMap ) {\r\n\t\r\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\r\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.emissiveMap ) {\r\n\t\r\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.bumpMap ) {\r\n\t\r\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\r\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.normalMap ) {\r\n\t\r\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\r\n\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.displacementMap ) {\r\n\t\r\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\r\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\r\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsStandard ( uniforms, material ) {\r\n\t\r\n\t\t\tuniforms.roughness.value = material.roughness;\r\n\t\t\tuniforms.metalness.value = material.metalness;\r\n\t\r\n\t\t\tif ( material.roughnessMap ) {\r\n\t\r\n\t\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.metalnessMap ) {\r\n\t\r\n\t\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.lightMap ) {\r\n\t\r\n\t\t\t\tuniforms.lightMap.value = material.lightMap;\r\n\t\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.emissiveMap ) {\r\n\t\r\n\t\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.bumpMap ) {\r\n\t\r\n\t\t\t\tuniforms.bumpMap.value = material.bumpMap;\r\n\t\t\t\tuniforms.bumpScale.value = material.bumpScale;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.normalMap ) {\r\n\t\r\n\t\t\t\tuniforms.normalMap.value = material.normalMap;\r\n\t\t\t\tuniforms.normalScale.value.copy( material.normalScale );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.displacementMap ) {\r\n\t\r\n\t\t\t\tuniforms.displacementMap.value = material.displacementMap;\r\n\t\t\t\tuniforms.displacementScale.value = material.displacementScale;\r\n\t\t\t\tuniforms.displacementBias.value = material.displacementBias;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.envMap ) {\r\n\t\r\n\t\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\r\n\t\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction refreshUniformsPhysical ( uniforms, material ) {\r\n\t\r\n\t\t\trefreshUniformsStandard( uniforms, material );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\r\n\t\r\n\t\tfunction markUniformsLightsNeedsUpdate ( uniforms, value ) {\r\n\t\r\n\t\t\tuniforms.ambientLightColor.needsUpdate = value;\r\n\t\r\n\t\t\tuniforms.directionalLights.needsUpdate = value;\r\n\t\t\tuniforms.pointLights.needsUpdate = value;\r\n\t\t\tuniforms.spotLights.needsUpdate = value;\r\n\t\t\tuniforms.hemisphereLights.needsUpdate = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Lighting\r\n\t\r\n\t\tfunction setupShadows ( lights ) {\r\n\t\r\n\t\t\tvar lightShadowsLength = 0;\r\n\t\r\n\t\t\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar light = lights[ i ];\r\n\t\r\n\t\t\t\tif ( light.castShadow ) {\r\n\t\r\n\t\t\t\t\t_lights.shadows[ lightShadowsLength ++ ] = light;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_lights.shadows.length = lightShadowsLength;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setupLights ( lights, camera ) {\r\n\t\r\n\t\t\tvar l, ll, light,\r\n\t\t\tr = 0, g = 0, b = 0,\r\n\t\t\tcolor,\r\n\t\t\tintensity,\r\n\t\t\tdistance,\r\n\t\t\tshadowMap,\r\n\t\r\n\t\t\tviewMatrix = camera.matrixWorldInverse,\r\n\t\r\n\t\t\tdirectionalLength = 0,\r\n\t\t\tpointLength = 0,\r\n\t\t\tspotLength = 0,\r\n\t\t\themiLength = 0;\r\n\t\r\n\t\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\t\r\n\t\t\t\tlight = lights[ l ];\r\n\t\r\n\t\t\t\tcolor = light.color;\r\n\t\t\t\tintensity = light.intensity;\r\n\t\t\t\tdistance = light.distance;\r\n\t\r\n\t\t\t\tshadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\r\n\t\r\n\t\t\t\tif ( light instanceof THREE.AmbientLight ) {\r\n\t\r\n\t\t\t\t\tr += color.r * intensity;\r\n\t\t\t\t\tg += color.g * intensity;\r\n\t\t\t\t\tb += color.b * intensity;\r\n\t\r\n\t\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\r\n\t\r\n\t\t\t\t\tvar uniforms = lightCache.get( light );\r\n\t\r\n\t\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\r\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\t\tuniforms.direction.sub( _vector3 );\r\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\r\n\t\r\n\t\t\t\t\tuniforms.shadow = light.castShadow;\r\n\t\r\n\t\t\t\t\tif ( light.castShadow ) {\r\n\t\r\n\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\r\n\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\r\n\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t_lights.directionalShadowMap[ directionalLength ] = shadowMap;\r\n\t\t\t\t\t_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\r\n\t\t\t\t\t_lights.directional[ directionalLength ++ ] = uniforms;\r\n\t\r\n\t\t\t\t} else if ( light instanceof THREE.SpotLight ) {\r\n\t\r\n\t\t\t\t\tvar uniforms = lightCache.get( light );\r\n\t\r\n\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\r\n\t\r\n\t\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\r\n\t\t\t\t\tuniforms.distance = distance;\r\n\t\r\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\t\tuniforms.direction.sub( _vector3 );\r\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\r\n\t\r\n\t\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\r\n\t\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\r\n\t\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\r\n\t\r\n\t\t\t\t\tuniforms.shadow = light.castShadow;\r\n\t\r\n\t\t\t\t\tif ( light.castShadow ) {\r\n\t\r\n\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\r\n\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\r\n\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t_lights.spotShadowMap[ spotLength ] = shadowMap;\r\n\t\t\t\t\t_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\r\n\t\t\t\t\t_lights.spot[ spotLength ++ ] = uniforms;\r\n\t\r\n\t\t\t\t} else if ( light instanceof THREE.PointLight ) {\r\n\t\r\n\t\t\t\t\tvar uniforms = lightCache.get( light );\r\n\t\r\n\t\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\r\n\t\r\n\t\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\r\n\t\t\t\t\tuniforms.distance = light.distance;\r\n\t\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\r\n\t\r\n\t\t\t\t\tuniforms.shadow = light.castShadow;\r\n\t\r\n\t\t\t\t\tif ( light.castShadow ) {\r\n\t\r\n\t\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\r\n\t\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\r\n\t\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t_lights.pointShadowMap[ pointLength ] = shadowMap;\r\n\t\r\n\t\t\t\t\tif ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ] = new THREE.Matrix4();\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// for point lights we set the shadow matrix to be a translation-only matrix\r\n\t\t\t\t\t// equal to inverse of the light's position\r\n\t\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld ).negate();\r\n\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );\r\n\t\r\n\t\t\t\t\t_lights.point[ pointLength ++ ] = uniforms;\r\n\t\r\n\t\t\t\t} else if ( light instanceof THREE.HemisphereLight ) {\r\n\t\r\n\t\t\t\t\tvar uniforms = lightCache.get( light );\r\n\t\r\n\t\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\r\n\t\t\t\t\tuniforms.direction.normalize();\r\n\t\r\n\t\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\r\n\t\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\r\n\t\r\n\t\t\t\t\t_lights.hemi[ hemiLength ++ ] = uniforms;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_lights.ambient[ 0 ] = r;\r\n\t\t\t_lights.ambient[ 1 ] = g;\r\n\t\t\t_lights.ambient[ 2 ] = b;\r\n\t\r\n\t\t\t_lights.directional.length = directionalLength;\r\n\t\t\t_lights.spot.length = spotLength;\r\n\t\t\t_lights.point.length = pointLength;\r\n\t\t\t_lights.hemi.length = hemiLength;\r\n\t\r\n\t\t\t_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// GL state setting\r\n\t\r\n\t\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\r\n\t\r\n\t\t\tstate.setCullFace( cullFace );\r\n\t\t\tstate.setFlipSided( frontFaceDirection === THREE.FrontFaceDirectionCW );\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Textures\r\n\t\r\n\t\tfunction allocTextureUnit() {\r\n\t\r\n\t\t\tvar textureUnit = _usedTextureUnits;\r\n\t\r\n\t\t\tif ( textureUnit >= capabilities.maxTextures ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_usedTextureUnits += 1;\r\n\t\r\n\t\t\treturn textureUnit;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setTextureParameters ( textureType, texture, isPowerOfTwoImage ) {\r\n\t\r\n\t\t\tvar extension;\r\n\t\r\n\t\t\tif ( isPowerOfTwoImage ) {\r\n\t\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\r\n\t\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\r\n\t\r\n\t\t\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\r\n\t\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\r\n\t\r\n\t\t\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\r\n\t\r\n\t\t\tif ( extension ) {\r\n\t\r\n\t\t\t\tif ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\r\n\t\t\t\tif ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\r\n\t\r\n\t\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\r\n\t\r\n\t\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );\r\n\t\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction uploadTexture( textureProperties, texture, slot ) {\r\n\t\r\n\t\t\tif ( textureProperties.__webglInit === undefined ) {\r\n\t\r\n\t\t\t\ttextureProperties.__webglInit = true;\r\n\t\r\n\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\r\n\t\r\n\t\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\r\n\t\r\n\t\t\t\t_infoMemory.textures ++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\r\n\t\r\n\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\t\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\r\n\t\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\r\n\t\r\n\t\t\tvar image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\r\n\t\r\n\t\t\tif ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\r\n\t\r\n\t\t\t\timage = makePowerOfTwo( image );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar isPowerOfTwoImage = isPowerOfTwo( image ),\r\n\t\t\tglFormat = paramThreeToGL( texture.format ),\r\n\t\t\tglType = paramThreeToGL( texture.type );\r\n\t\r\n\t\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\r\n\t\r\n\t\t\tvar mipmap, mipmaps = texture.mipmaps;\r\n\t\r\n\t\t\tif ( texture instanceof THREE.DepthTexture ) {\r\n\t\r\n\t\t\t\t// populate depth texture with dummy data\r\n\t\r\n\t\t\t\tvar internalFormat = _gl.DEPTH_COMPONENT;\r\n\t\r\n\t\t\t\tif ( texture.type === THREE.FloatType ) {\r\n\t\r\n\t\t\t\t\tif ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');\r\n\t\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT32F;\r\n\t\r\n\t\t\t\t} else if ( _isWebGL2 ) {\r\n\t\r\n\t\t\t\t\t// WebGL 2.0 requires signed internalformat for glTexImage2D\r\n\t\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT16;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );\r\n\t\r\n\t\t\t} else if ( texture instanceof THREE.DataTexture ) {\r\n\t\r\n\t\t\t\t// use manually created mipmaps if available\r\n\t\t\t\t// if there are no manual mipmaps\r\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\t\r\n\t\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttexture.generateMipmaps = false;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( texture instanceof THREE.CompressedTexture ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\r\n\t\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\r\n\t\r\n\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\r\n\t\r\n\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\" );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// regular Texture (image, video, canvas)\r\n\t\r\n\t\t\t\t// use manually created mipmaps if available\r\n\t\t\t\t// if there are no manual mipmaps\r\n\t\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\t\r\n\t\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttexture.generateMipmaps = false;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n\t\r\n\t\t\ttextureProperties.__version = texture.version;\r\n\t\r\n\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setTexture2D( texture, slot ) {\r\n\t\r\n\t\t\tvar textureProperties = properties.get( texture );\r\n\t\r\n\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\r\n\t\r\n\t\t\t\tvar image = texture.image;\r\n\t\r\n\t\t\t\tif ( image === undefined ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\r\n\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( image.complete === false ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\r\n\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tuploadTexture( textureProperties, texture, slot );\r\n\t\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction clampToMaxSize ( image, maxSize ) {\r\n\t\r\n\t\t\tif ( image.width > maxSize || image.height > maxSize ) {\r\n\t\r\n\t\t\t\t// Warning: Scaling through the canvas will only work with images that use\r\n\t\t\t\t// premultiplied alpha.\r\n\t\r\n\t\t\t\tvar scale = maxSize / Math.max( image.width, image.height );\r\n\t\r\n\t\t\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\t\t\tcanvas.width = Math.floor( image.width * scale );\r\n\t\t\t\tcanvas.height = Math.floor( image.height * scale );\r\n\t\r\n\t\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\r\n\t\r\n\t\t\t\treturn canvas;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn image;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction isPowerOfTwo( image ) {\r\n\t\r\n\t\t\treturn THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction textureNeedsPowerOfTwo( texture ) {\r\n\t\r\n\t\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) return true;\r\n\t\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) return true;\r\n\t\r\n\t\t\treturn false;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction makePowerOfTwo( image ) {\r\n\t\r\n\t\t\tif ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {\r\n\t\r\n\t\t\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\t\t\tcanvas.width = THREE.Math.nearestPowerOfTwo( image.width );\r\n\t\t\t\tcanvas.height = THREE.Math.nearestPowerOfTwo( image.height );\r\n\t\r\n\t\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\t\tcontext.drawImage( image, 0, 0, canvas.width, canvas.height );\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\r\n\t\r\n\t\t\t\treturn canvas;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn image;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setTextureCube ( texture, slot ) {\r\n\t\r\n\t\t\tvar textureProperties = properties.get( texture );\r\n\t\r\n\t\t\tif ( texture.image.length === 6 ) {\r\n\t\r\n\t\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\r\n\t\r\n\t\t\t\t\tif ( ! textureProperties.__image__webglTextureCube ) {\r\n\t\r\n\t\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\r\n\t\r\n\t\t\t\t\t\ttextureProperties.__image__webglTextureCube = _gl.createTexture();\r\n\t\r\n\t\t\t\t\t\t_infoMemory.textures ++;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\r\n\t\r\n\t\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\t\r\n\t\t\t\t\tvar isCompressed = texture instanceof THREE.CompressedTexture;\r\n\t\t\t\t\tvar isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;\r\n\t\r\n\t\t\t\t\tvar cubeImage = [];\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tif ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {\r\n\t\r\n\t\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tvar image = cubeImage[ 0 ],\r\n\t\t\t\t\tisPowerOfTwoImage = isPowerOfTwo( image ),\r\n\t\t\t\t\tglFormat = paramThreeToGL( texture.format ),\r\n\t\t\t\t\tglType = paramThreeToGL( texture.type );\r\n\t\r\n\t\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tif ( ! isCompressed ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( isDataTexture ) {\r\n\t\r\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\r\n\t\r\n\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\r\n\t\r\n\t\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\r\n\t\r\n\t\t\t\t\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\t\r\n\t\t\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()\" );\r\n\t\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) {\r\n\t\r\n\t\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttextureProperties.__version = texture.version;\r\n\t\r\n\t\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction setTextureCubeDynamic ( texture, slot ) {\r\n\t\r\n\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.allocTextureUnit = allocTextureUnit;\r\n\t\r\n\t\t//this.setTexture2D = setTexture2D;\r\n\t\tthis.setTexture2D = ( function() {\r\n\t\r\n\t\t\tvar warned = false;\r\n\t\r\n\t\t\t// backwards compatibility: peel texture.texture\r\n\t\t\treturn function( texture, slot ) {\r\n\t\r\n\t\t\t\tif ( texture instanceof THREE.WebGLRenderTarget ) {\r\n\t\r\n\t\t\t\t\tif ( ! warned ) {\r\n\t\r\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\" );\r\n\t\t\t\t\t\twarned = true;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttexture = texture.texture;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tsetTexture2D( texture, slot );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}() );\r\n\t\r\n\t\tthis.setTexture = ( function() {\r\n\t\r\n\t\t\tvar warned = false;\r\n\t\r\n\t\t\treturn function( texture, slot ) {\r\n\t\r\n\t\t\t\tif ( ! warned ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\" );\r\n\t\t\t\t\twarned = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_this.setTexture2D( texture, slot );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}() );\r\n\t\r\n\t\tthis.setTextureCube = ( function() {\r\n\t\r\n\t\t\tvar warned = false;\r\n\t\r\n\t\t\treturn function( texture, slot ) {\r\n\t\r\n\t\t\t\t// backwards compatibility: peel texture.texture\r\n\t\t\t\tif ( texture instanceof THREE.WebGLRenderTargetCube ) {\r\n\t\r\n\t\t\t\t\tif ( ! warned ) {\r\n\t\r\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\" );\r\n\t\t\t\t\t\twarned = true;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\ttexture = texture.texture;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture\r\n\t\t\t\t// TODO: unify these code paths\r\n\t\t\t\tif ( texture instanceof THREE.CubeTexture ||\r\n\t\t\t\t\t ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\r\n\t\r\n\t\t\t\t\t// CompressedTexture can have Array in image :/\r\n\t\r\n\t\t\t\t\t// this function alone should take care of cube textures\r\n\t\t\t\t\tsetTextureCube( texture, slot );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// assumed: texture property of THREE.WebGLRenderTargetCube\r\n\t\r\n\t\t\t\t\tsetTextureCubeDynamic( texture, slot );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t}() );\r\n\t\r\n\t\t// Render targets\r\n\t\r\n\t\t// Setup storage for target texture and bind it to correct framebuffer\r\n\t\tfunction setupFrameBufferTexture ( framebuffer, renderTarget, attachment, textureTarget ) {\r\n\t\r\n\t\t\tvar glFormat = paramThreeToGL( renderTarget.texture.format );\r\n\t\t\tvar glType = paramThreeToGL( renderTarget.texture.type );\r\n\t\t\tstate.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\r\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\r\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\r\n\t\tfunction setupRenderBufferStorage ( renderbuffer, renderTarget ) {\r\n\t\r\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\r\n\t\r\n\t\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\r\n\t\r\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\r\n\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\t\r\n\t\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\t\r\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\r\n\t\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// FIXME: We don't support !depth !stencil\r\n\t\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Setup resources for a Depth Texture for a FBO (needs an extension)\r\n\t\tfunction setupDepthTexture ( framebuffer, renderTarget ) {\r\n\t\r\n\t\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\t\t\tif ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');\r\n\t\r\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\r\n\t\t\tif ( !( renderTarget.depthTexture instanceof THREE.DepthTexture ) ) {\r\n\t\r\n\t\t\t\tthrow new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// upload an empty depth texture with framebuffer size\r\n\t\t\tif ( !properties.get( renderTarget.depthTexture ).__webglTexture ||\r\n\t\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\r\n\t\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\r\n\t\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\r\n\t\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\r\n\t\t\t\trenderTarget.depthTexture.needsUpdate = true;\r\n\t\t\t}\r\n\t\r\n\t\t\t_this.setTexture2D( renderTarget.depthTexture, 0 );\r\n\t\r\n\t\t\tvar webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\r\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Setup GL resources for a non-texture depth buffer\r\n\t\tfunction setupDepthRenderbuffer( renderTarget ) {\r\n\t\r\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\r\n\t\r\n\t\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\t\r\n\t\t\tif ( renderTarget.depthTexture ) {\r\n\t\r\n\t\t\t\tif ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');\r\n\t\r\n\t\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tif ( isCube ) {\r\n\t\r\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\r\n\t\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\r\n\t\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\r\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\r\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Set up GL resources for the render target\r\n\t\tfunction setupRenderTarget( renderTarget ) {\r\n\t\r\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\r\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\r\n\t\r\n\t\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\r\n\t\r\n\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\r\n\t\r\n\t\t\t_infoMemory.textures ++;\r\n\t\r\n\t\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\t\t\tvar isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height );\r\n\t\r\n\t\t\t// Setup framebuffer\r\n\t\r\n\t\t\tif ( isCube ) {\r\n\t\r\n\t\t\t\trenderTargetProperties.__webglFramebuffer = [];\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// Setup color buffer\r\n\t\r\n\t\t\tif ( isCube ) {\r\n\t\r\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\r\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\t\r\n\t\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\r\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\r\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\r\n\t\r\n\t\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_2D, null );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// Setup depth and stencil buffers\r\n\t\r\n\t\t\tif ( renderTarget.depthBuffer ) {\r\n\t\r\n\t\t\t\tsetupDepthRenderbuffer( renderTarget );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.getCurrentRenderTarget = function() {\r\n\t\r\n\t\t\treturn _currentRenderTarget;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setRenderTarget = function ( renderTarget ) {\r\n\t\r\n\t\t\t_currentRenderTarget = renderTarget;\r\n\t\r\n\t\t\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\r\n\t\r\n\t\t\t\tsetupRenderTarget( renderTarget );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\t\t\tvar framebuffer;\r\n\t\r\n\t\t\tif ( renderTarget ) {\r\n\t\r\n\t\t\t\tvar renderTargetProperties = properties.get( renderTarget );\r\n\t\r\n\t\t\t\tif ( isCube ) {\r\n\t\r\n\t\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t_currentScissor.copy( renderTarget.scissor );\r\n\t\t\t\t_currentScissorTest = renderTarget.scissorTest;\r\n\t\r\n\t\t\t\t_currentViewport.copy( renderTarget.viewport );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tframebuffer = null;\r\n\t\r\n\t\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\r\n\t\t\t\t_currentScissorTest = _scissorTest;\r\n\t\r\n\t\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( _currentFramebuffer !== framebuffer ) {\r\n\t\r\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\t\t\t_currentFramebuffer = framebuffer;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tstate.scissor( _currentScissor );\r\n\t\t\tstate.setScissorTest( _currentScissorTest );\r\n\t\r\n\t\t\tstate.viewport( _currentViewport );\r\n\t\r\n\t\t\tif ( isCube ) {\r\n\t\r\n\t\t\t\tvar textureProperties = properties.get( renderTarget.texture );\r\n\t\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\r\n\t\r\n\t\t\tif ( renderTarget instanceof THREE.WebGLRenderTarget === false ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\r\n\t\r\n\t\t\tif ( framebuffer ) {\r\n\t\r\n\t\t\t\tvar restore = false;\r\n\t\r\n\t\t\t\tif ( framebuffer !== _currentFramebuffer ) {\r\n\t\r\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\r\n\t\t\t\t\trestore = true;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\ttry {\r\n\t\r\n\t\t\t\t\tvar texture = renderTarget.texture;\r\n\t\r\n\t\t\t\t\tif ( texture.format !== THREE.RGBAFormat && paramThreeToGL( texture.format ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\r\n\t\r\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\r\n\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( texture.type !== THREE.UnsignedByteType &&\r\n\t\t\t\t\t     paramThreeToGL( texture.type ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) &&\r\n\t\t\t\t\t     ! ( texture.type === THREE.FloatType && extensions.get( 'WEBGL_color_buffer_float' ) ) &&\r\n\t\t\t\t\t     ! ( texture.type === THREE.HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {\r\n\t\r\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\r\n\t\t\t\t\t\treturn;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\r\n\t\r\n\t\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\r\n\t\r\n\t\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\r\n\t\r\n\t\t\t\t\t\t\t_gl.readPixels( x, y, width, height, paramThreeToGL( texture.format ), paramThreeToGL( texture.type ), buffer );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} finally {\r\n\t\r\n\t\t\t\t\tif ( restore ) {\r\n\t\r\n\t\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction updateRenderTargetMipmap( renderTarget ) {\r\n\t\r\n\t\t\tvar target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\r\n\t\t\tvar texture = properties.get( renderTarget.texture ).__webglTexture;\r\n\t\r\n\t\t\tstate.bindTexture( target, texture );\r\n\t\t\t_gl.generateMipmap( target );\r\n\t\t\tstate.bindTexture( target, null );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Fallback filters for non-power-of-2 textures\r\n\t\r\n\t\tfunction filterFallback ( f ) {\r\n\t\r\n\t\t\tif ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {\r\n\t\r\n\t\t\t\treturn _gl.NEAREST;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn _gl.LINEAR;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Map three.js constants to WebGL constants\r\n\t\r\n\t\tfunction paramThreeToGL ( p ) {\r\n\t\r\n\t\t\tvar extension;\r\n\t\r\n\t\t\tif ( p === THREE.RepeatWrapping ) return _gl.REPEAT;\r\n\t\t\tif ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\r\n\t\t\tif ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\r\n\t\r\n\t\t\tif ( p === THREE.NearestFilter ) return _gl.NEAREST;\r\n\t\t\tif ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\r\n\t\t\tif ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\r\n\t\r\n\t\t\tif ( p === THREE.LinearFilter ) return _gl.LINEAR;\r\n\t\t\tif ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\r\n\t\t\tif ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\r\n\t\r\n\t\t\tif ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;\r\n\t\t\tif ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\r\n\t\t\tif ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\r\n\t\t\tif ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\r\n\t\r\n\t\t\tif ( p === THREE.ByteType ) return _gl.BYTE;\r\n\t\t\tif ( p === THREE.ShortType ) return _gl.SHORT;\r\n\t\t\tif ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;\r\n\t\t\tif ( p === THREE.IntType ) return _gl.INT;\r\n\t\t\tif ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;\r\n\t\t\tif ( p === THREE.FloatType ) return _gl.FLOAT;\r\n\t\r\n\t\t\textension = extensions.get( 'OES_texture_half_float' );\r\n\t\r\n\t\t\tif ( extension !== null ) {\r\n\t\r\n\t\t\t\tif ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( p === THREE.AlphaFormat ) return _gl.ALPHA;\r\n\t\t\tif ( p === THREE.RGBFormat ) return _gl.RGB;\r\n\t\t\tif ( p === THREE.RGBAFormat ) return _gl.RGBA;\r\n\t\t\tif ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;\r\n\t\t\tif ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\r\n\t\t\tif ( p === THREE.DepthFormat ) return _gl.DEPTH_COMPONENT;\r\n\t\r\n\t\t\tif ( p === THREE.AddEquation ) return _gl.FUNC_ADD;\r\n\t\t\tif ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;\r\n\t\t\tif ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\r\n\t\r\n\t\t\tif ( p === THREE.ZeroFactor ) return _gl.ZERO;\r\n\t\t\tif ( p === THREE.OneFactor ) return _gl.ONE;\r\n\t\t\tif ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;\r\n\t\t\tif ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\r\n\t\t\tif ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;\r\n\t\t\tif ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\r\n\t\t\tif ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;\r\n\t\t\tif ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\r\n\t\r\n\t\t\tif ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;\r\n\t\t\tif ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\r\n\t\t\tif ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\r\n\t\r\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\r\n\t\r\n\t\t\tif ( extension !== null ) {\r\n\t\r\n\t\t\t\tif ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\r\n\t\t\t\tif ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\r\n\t\t\t\tif ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\r\n\t\t\t\tif ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\r\n\t\r\n\t\t\tif ( extension !== null ) {\r\n\t\r\n\t\t\t\tif ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\r\n\t\t\t\tif ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\r\n\t\t\t\tif ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\r\n\t\t\t\tif ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\r\n\t\r\n\t\t\tif ( extension !== null ) {\r\n\t\r\n\t\t\t\tif ( p === THREE.RGB_ETC1_Format ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\textension = extensions.get( 'EXT_blend_minmax' );\r\n\t\r\n\t\t\tif ( extension !== null ) {\r\n\t\r\n\t\t\t\tif ( p === THREE.MinEquation ) return extension.MIN_EXT;\r\n\t\t\t\tif ( p === THREE.MaxEquation ) return extension.MAX_EXT;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn 0;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/WebGLRenderTarget.js\r\n\t\r\n\t/**\r\n\t * @author szimek / https://github.com/szimek/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author Marius Kintel / https://github.com/kintel\r\n\t */\r\n\t\r\n\t/*\r\n\t In options, we can specify:\r\n\t * Texture parameters for an auto-generated target texture\r\n\t * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\r\n\t*/\r\n\tTHREE.WebGLRenderTarget = function ( width, height, options ) {\r\n\t\r\n\t\tthis.uuid = THREE.Math.generateUUID();\r\n\t\r\n\t\tthis.width = width;\r\n\t\tthis.height = height;\r\n\t\r\n\t\tthis.scissor = new THREE.Vector4( 0, 0, width, height );\r\n\t\tthis.scissorTest = false;\r\n\t\r\n\t\tthis.viewport = new THREE.Vector4( 0, 0, width, height );\r\n\t\r\n\t\toptions = options || {};\r\n\t\r\n\t\tif ( options.minFilter === undefined ) options.minFilter = THREE.LinearFilter;\r\n\t\r\n\t\tthis.texture = new THREE.Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\r\n\t\r\n\t\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\r\n\t\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\r\n\t\tthis.depthTexture = null;\r\n\t\r\n\t};\r\n\t\r\n\tObject.assign( THREE.WebGLRenderTarget.prototype, THREE.EventDispatcher.prototype, {\r\n\t\r\n\t\tsetSize: function ( width, height ) {\r\n\t\r\n\t\t\tif ( this.width !== width || this.height !== height ) {\r\n\t\r\n\t\t\t\tthis.width = width;\r\n\t\t\t\tthis.height = height;\r\n\t\r\n\t\t\t\tthis.dispose();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.viewport.set( 0, 0, width, height );\r\n\t\t\tthis.scissor.set( 0, 0, width, height );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclone: function () {\r\n\t\r\n\t\t\treturn new this.constructor().copy( this );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcopy: function ( source ) {\r\n\t\r\n\t\t\tthis.width = source.width;\r\n\t\t\tthis.height = source.height;\r\n\t\r\n\t\t\tthis.viewport.copy( source.viewport );\r\n\t\r\n\t\t\tthis.texture = source.texture.clone();\r\n\t\r\n\t\t\tthis.depthBuffer = source.depthBuffer;\r\n\t\t\tthis.stencilBuffer = source.stencilBuffer;\r\n\t\t\tthis.depthTexture = source.depthTexture;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdispose: function () {\r\n\t\r\n\t\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/renderers/WebGLRenderTargetCube.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com\r\n\t */\r\n\t\r\n\tTHREE.WebGLRenderTargetCube = function ( width, height, options ) {\r\n\t\r\n\t\tTHREE.WebGLRenderTarget.call( this, width, height, options );\r\n\t\r\n\t\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\r\n\t\tthis.activeMipMapLevel = 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );\r\n\tTHREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;\r\n\t\r\n\t// File:src/renderers/webgl/WebGLBufferRenderer.js\r\n\t\r\n\t/**\r\n\t* @author mrdoob / http://mrdoob.com/\r\n\t*/\r\n\t\r\n\tTHREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {\r\n\t\r\n\t\tvar mode;\r\n\t\r\n\t\tfunction setMode( value ) {\r\n\t\r\n\t\t\tmode = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction render( start, count ) {\r\n\t\r\n\t\t\t_gl.drawArrays( mode, start, count );\r\n\t\r\n\t\t\t_infoRender.calls ++;\r\n\t\t\t_infoRender.vertices += count;\r\n\t\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction renderInstances( geometry ) {\r\n\t\r\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\t\r\n\t\t\tif ( extension === null ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar position = geometry.attributes.position;\r\n\t\r\n\t\t\tvar count = 0;\r\n\t\r\n\t\t\tif ( position instanceof THREE.InterleavedBufferAttribute ) {\r\n\t\r\n\t\t\t\tcount = position.data.count;\r\n\t\r\n\t\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tcount = position.count;\r\n\t\r\n\t\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t_infoRender.calls ++;\r\n\t\t\t_infoRender.vertices += count * geometry.maxInstancedCount;\r\n\t\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.setMode = setMode;\r\n\t\tthis.render = render;\r\n\t\tthis.renderInstances = renderInstances;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLClipping.js\r\n\t\r\n\tTHREE.WebGLClipping = function() {\r\n\t\r\n\t\tvar scope = this,\r\n\t\r\n\t\t\tglobalState = null,\r\n\t\t\tnumGlobalPlanes = 0,\r\n\t\t\tlocalClippingEnabled = false,\r\n\t\t\trenderingShadows = false,\r\n\t\r\n\t\t\tplane = new THREE.Plane(),\r\n\t\t\tviewNormalMatrix = new THREE.Matrix3(),\r\n\t\r\n\t\t\tuniform = { value: null, needsUpdate: false };\r\n\t\r\n\t\tthis.uniform = uniform;\r\n\t\tthis.numPlanes = 0;\r\n\t\r\n\t\tthis.init = function( planes, enableLocalClipping, camera ) {\r\n\t\r\n\t\t\tvar enabled =\r\n\t\t\t\tplanes.length !== 0 ||\r\n\t\t\t\tenableLocalClipping ||\r\n\t\t\t\t// enable state of previous frame - the clipping code has to\r\n\t\t\t\t// run another frame in order to reset the state:\r\n\t\t\t\tnumGlobalPlanes !== 0 ||\r\n\t\t\t\tlocalClippingEnabled;\r\n\t\r\n\t\t\tlocalClippingEnabled = enableLocalClipping;\r\n\t\r\n\t\t\tglobalState = projectPlanes( planes, camera, 0 );\r\n\t\t\tnumGlobalPlanes = planes.length;\r\n\t\r\n\t\t\treturn enabled;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.beginShadows = function() {\r\n\t\r\n\t\t\trenderingShadows = true;\r\n\t\t\tprojectPlanes( null );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.endShadows = function() {\r\n\t\r\n\t\t\trenderingShadows = false;\r\n\t\t\tresetGlobalState();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setState = function( planes, clipShadows, camera, cache, fromCache ) {\r\n\t\r\n\t\t\tif ( ! localClippingEnabled ||\r\n\t\t\t\t\tplanes === null || planes.length === 0 ||\r\n\t\t\t\t\trenderingShadows && ! clipShadows ) {\r\n\t\t\t\t// there's no local clipping\r\n\t\r\n\t\t\t\tif ( renderingShadows ) {\r\n\t\t\t\t\t// there's no global clipping\r\n\t\r\n\t\t\t\t\tprojectPlanes( null );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tresetGlobalState();\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tvar nGlobal = renderingShadows ? 0 : numGlobalPlanes,\r\n\t\t\t\t\tlGlobal = nGlobal * 4,\r\n\t\r\n\t\t\t\t\tdstArray = cache.clippingState || null;\r\n\t\r\n\t\t\t\tuniform.value = dstArray; // ensure unique state\r\n\t\r\n\t\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, fromCache );\r\n\t\r\n\t\t\t\tfor ( var i = 0; i !== lGlobal; ++ i ) {\r\n\t\r\n\t\t\t\t\tdstArray[ i ] = globalState[ i ];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tcache.clippingState = dstArray;\r\n\t\t\t\tthis.numPlanes += nGlobal;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction resetGlobalState() {\r\n\t\r\n\t\t\tif ( uniform.value !== globalState ) {\r\n\t\r\n\t\t\t\tuniform.value = globalState;\r\n\t\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tscope.numPlanes = numGlobalPlanes;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\r\n\t\r\n\t\t\tvar nPlanes = planes !== null ? planes.length : 0,\r\n\t\t\t\tdstArray = null;\r\n\t\r\n\t\t\tif ( nPlanes !== 0 ) {\r\n\t\r\n\t\t\t\tdstArray = uniform.value;\r\n\t\r\n\t\t\t\tif ( skipTransform !== true || dstArray === null ) {\r\n\t\r\n\t\t\t\t\tvar flatSize = dstOffset + nPlanes * 4,\r\n\t\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\r\n\t\r\n\t\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\r\n\t\r\n\t\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\r\n\t\r\n\t\t\t\t\t\tdstArray = new Float32Array( flatSize );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, i4 = dstOffset;\r\n\t\t\t\t\t\t\t\t\t\ti !== nPlanes; ++ i, i4 += 4 ) {\r\n\t\r\n\t\t\t\t\t\tplane.copy( planes[ i ] ).\r\n\t\t\t\t\t\t\t\tapplyMatrix4( viewMatrix, viewNormalMatrix );\r\n\t\r\n\t\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\r\n\t\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tuniform.value = dstArray;\r\n\t\t\t\tuniform.needsUpdate = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tscope.numPlanes = nPlanes;\r\n\t\t\treturn dstArray;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\t// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js\r\n\t\r\n\t/**\r\n\t* @author mrdoob / http://mrdoob.com/\r\n\t*/\r\n\t\r\n\tTHREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {\r\n\t\r\n\t\tvar mode;\r\n\t\r\n\t\tfunction setMode( value ) {\r\n\t\r\n\t\t\tmode = value;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar type, size;\r\n\t\r\n\t\tfunction setIndex( index ) {\r\n\t\r\n\t\t\tif ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\r\n\t\r\n\t\t\t\ttype = _gl.UNSIGNED_INT;\r\n\t\t\t\tsize = 4;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\ttype = _gl.UNSIGNED_SHORT;\r\n\t\t\t\tsize = 2;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction render( start, count ) {\r\n\t\r\n\t\t\t_gl.drawElements( mode, count, type, start * size );\r\n\t\r\n\t\t\t_infoRender.calls ++;\r\n\t\t\t_infoRender.vertices += count;\r\n\t\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction renderInstances( geometry, start, count ) {\r\n\t\r\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\t\r\n\t\t\tif ( extension === null ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\textension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );\r\n\t\r\n\t\t\t_infoRender.calls ++;\r\n\t\t\t_infoRender.vertices += count * geometry.maxInstancedCount;\r\n\t\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;\r\n\t\t}\r\n\t\r\n\t\tthis.setMode = setMode;\r\n\t\tthis.setIndex = setIndex;\r\n\t\tthis.render = render;\r\n\t\tthis.renderInstances = renderInstances;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLExtensions.js\r\n\t\r\n\t/**\r\n\t* @author mrdoob / http://mrdoob.com/\r\n\t*/\r\n\t\r\n\tTHREE.WebGLExtensions = function ( gl ) {\r\n\t\r\n\t\tvar extensions = {};\r\n\t\r\n\t\tthis.get = function ( name ) {\r\n\t\r\n\t\t\tif ( extensions[ name ] !== undefined ) {\r\n\t\r\n\t\t\t\treturn extensions[ name ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar extension;\r\n\t\r\n\t\t\tswitch ( name ) {\r\n\t\r\n\t\t\t\tcase 'WEBGL_depth_texture':\r\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 'EXT_texture_filter_anisotropic':\r\n\t\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 'WEBGL_compressed_texture_s3tc':\r\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\r\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 'WEBGL_compressed_texture_etc1':\r\n\t\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tdefault:\r\n\t\t\t\t\textension = gl.getExtension( name );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( extension === null ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\textensions[ name ] = extension;\r\n\t\r\n\t\t\treturn extension;\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLCapabilities.js\r\n\t\r\n\tTHREE.WebGLCapabilities = function ( gl, extensions, parameters ) {\r\n\t\r\n\t\tfunction getMaxPrecision( precision ) {\r\n\t\r\n\t\t\tif ( precision === 'highp' ) {\r\n\t\r\n\t\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\r\n\t\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\r\n\t\r\n\t\t\t\t\treturn 'highp';\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tprecision = 'mediump';\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( precision === 'mediump' ) {\r\n\t\r\n\t\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\r\n\t\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\r\n\t\r\n\t\t\t\t\treturn 'mediump';\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn 'lowp';\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.getMaxPrecision = getMaxPrecision;\r\n\t\r\n\t\tthis.precision = parameters.precision !== undefined ? parameters.precision : 'highp';\r\n\t\tthis.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;\r\n\t\r\n\t\tthis.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\r\n\t\tthis.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\r\n\t\tthis.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\r\n\t\tthis.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\r\n\t\r\n\t\tthis.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\r\n\t\tthis.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\r\n\t\tthis.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\r\n\t\tthis.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\r\n\t\r\n\t\tthis.vertexTextures = this.maxVertexTextures > 0;\r\n\t\tthis.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\r\n\t\tthis.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;\r\n\t\r\n\t\tvar _maxPrecision = getMaxPrecision( this.precision );\r\n\t\r\n\t\tif ( _maxPrecision !== this.precision ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );\r\n\t\t\tthis.precision = _maxPrecision;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tif ( this.logarithmicDepthBuffer ) {\r\n\t\r\n\t\t\tthis.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLGeometries.js\r\n\t\r\n\t/**\r\n\t* @author mrdoob / http://mrdoob.com/\r\n\t*/\r\n\t\r\n\tTHREE.WebGLGeometries = function ( gl, properties, info ) {\r\n\t\r\n\t\tvar geometries = {};\r\n\t\r\n\t\tfunction get( object ) {\r\n\t\r\n\t\t\tvar geometry = object.geometry;\r\n\t\r\n\t\t\tif ( geometries[ geometry.id ] !== undefined ) {\r\n\t\r\n\t\t\t\treturn geometries[ geometry.id ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\r\n\t\r\n\t\t\tvar buffergeometry;\r\n\t\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\tbuffergeometry = geometry;\r\n\t\r\n\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\t\tif ( geometry._bufferGeometry === undefined ) {\r\n\t\r\n\t\t\t\t\tgeometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tbuffergeometry = geometry._bufferGeometry;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgeometries[ geometry.id ] = buffergeometry;\r\n\t\r\n\t\t\tinfo.memory.geometries ++;\r\n\t\r\n\t\t\treturn buffergeometry;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction onGeometryDispose( event ) {\r\n\t\r\n\t\t\tvar geometry = event.target;\r\n\t\t\tvar buffergeometry = geometries[ geometry.id ];\r\n\t\r\n\t\t\tif ( buffergeometry.index !== null ) {\r\n\t\r\n\t\t\t\tdeleteAttribute( buffergeometry.index );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tdeleteAttributes( buffergeometry.attributes );\r\n\t\r\n\t\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\r\n\t\r\n\t\t\tdelete geometries[ geometry.id ];\r\n\t\r\n\t\t\t// TODO\r\n\t\r\n\t\t\tvar property = properties.get( geometry );\r\n\t\r\n\t\t\tif ( property.wireframe ) {\r\n\t\r\n\t\t\t\tdeleteAttribute( property.wireframe );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tproperties.delete( geometry );\r\n\t\r\n\t\t\tvar bufferproperty = properties.get( buffergeometry );\r\n\t\r\n\t\t\tif ( bufferproperty.wireframe ) {\r\n\t\r\n\t\t\t\tdeleteAttribute( bufferproperty.wireframe );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tproperties.delete( buffergeometry );\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tinfo.memory.geometries --;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction getAttributeBuffer( attribute ) {\r\n\t\r\n\t\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\t\r\n\t\t\t\treturn properties.get( attribute.data ).__webglBuffer;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn properties.get( attribute ).__webglBuffer;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction deleteAttribute( attribute ) {\r\n\t\r\n\t\t\tvar buffer = getAttributeBuffer( attribute );\r\n\t\r\n\t\t\tif ( buffer !== undefined ) {\r\n\t\r\n\t\t\t\tgl.deleteBuffer( buffer );\r\n\t\t\t\tremoveAttributeBuffer( attribute );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction deleteAttributes( attributes ) {\r\n\t\r\n\t\t\tfor ( var name in attributes ) {\r\n\t\r\n\t\t\t\tdeleteAttribute( attributes[ name ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction removeAttributeBuffer( attribute ) {\r\n\t\r\n\t\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\t\r\n\t\t\t\tproperties.delete( attribute.data );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tproperties.delete( attribute );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.get = get;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLLights.js\r\n\t\r\n\t/**\r\n\t* @author mrdoob / http://mrdoob.com/\r\n\t*/\r\n\t\r\n\tTHREE.WebGLLights = function () {\r\n\t\r\n\t\tvar lights = {};\r\n\t\r\n\t\tthis.get = function ( light ) {\r\n\t\r\n\t\t\tif ( lights[ light.id ] !== undefined ) {\r\n\t\r\n\t\t\t\treturn lights[ light.id ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar uniforms;\r\n\t\r\n\t\t\tswitch ( light.type ) {\r\n\t\r\n\t\t\t\tcase 'DirectionalLight':\r\n\t\t\t\t\tuniforms = {\r\n\t\t\t\t\t\tdirection: new THREE.Vector3(),\r\n\t\t\t\t\t\tcolor: new THREE.Color(),\r\n\t\r\n\t\t\t\t\t\tshadow: false,\r\n\t\t\t\t\t\tshadowBias: 0,\r\n\t\t\t\t\t\tshadowRadius: 1,\r\n\t\t\t\t\t\tshadowMapSize: new THREE.Vector2()\r\n\t\t\t\t\t};\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 'SpotLight':\r\n\t\t\t\t\tuniforms = {\r\n\t\t\t\t\t\tposition: new THREE.Vector3(),\r\n\t\t\t\t\t\tdirection: new THREE.Vector3(),\r\n\t\t\t\t\t\tcolor: new THREE.Color(),\r\n\t\t\t\t\t\tdistance: 0,\r\n\t\t\t\t\t\tconeCos: 0,\r\n\t\t\t\t\t\tpenumbraCos: 0,\r\n\t\t\t\t\t\tdecay: 0,\r\n\t\r\n\t\t\t\t\t\tshadow: false,\r\n\t\t\t\t\t\tshadowBias: 0,\r\n\t\t\t\t\t\tshadowRadius: 1,\r\n\t\t\t\t\t\tshadowMapSize: new THREE.Vector2()\r\n\t\t\t\t\t};\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 'PointLight':\r\n\t\t\t\t\tuniforms = {\r\n\t\t\t\t\t\tposition: new THREE.Vector3(),\r\n\t\t\t\t\t\tcolor: new THREE.Color(),\r\n\t\t\t\t\t\tdistance: 0,\r\n\t\t\t\t\t\tdecay: 0,\r\n\t\r\n\t\t\t\t\t\tshadow: false,\r\n\t\t\t\t\t\tshadowBias: 0,\r\n\t\t\t\t\t\tshadowRadius: 1,\r\n\t\t\t\t\t\tshadowMapSize: new THREE.Vector2()\r\n\t\t\t\t\t};\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 'HemisphereLight':\r\n\t\t\t\t\tuniforms = {\r\n\t\t\t\t\t\tdirection: new THREE.Vector3(),\r\n\t\t\t\t\t\tskyColor: new THREE.Color(),\r\n\t\t\t\t\t\tgroundColor: new THREE.Color()\r\n\t\t\t\t\t};\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tlights[ light.id ] = uniforms;\r\n\t\r\n\t\t\treturn uniforms;\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLObjects.js\r\n\t\r\n\t/**\r\n\t* @author mrdoob / http://mrdoob.com/\r\n\t*/\r\n\t\r\n\tTHREE.WebGLObjects = function ( gl, properties, info ) {\r\n\t\r\n\t\tvar geometries = new THREE.WebGLGeometries( gl, properties, info );\r\n\t\r\n\t\t//\r\n\t\r\n\t\tfunction update( object ) {\r\n\t\r\n\t\t\t// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.\r\n\t\r\n\t\t\tvar geometry = geometries.get( object );\r\n\t\r\n\t\t\tif ( object.geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\t\tgeometry.updateFromObject( object );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar index = geometry.index;\r\n\t\t\tvar attributes = geometry.attributes;\r\n\t\r\n\t\t\tif ( index !== null ) {\r\n\t\r\n\t\t\t\tupdateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var name in attributes ) {\r\n\t\r\n\t\t\t\tupdateAttribute( attributes[ name ], gl.ARRAY_BUFFER );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// morph targets\r\n\t\r\n\t\t\tvar morphAttributes = geometry.morphAttributes;\r\n\t\r\n\t\t\tfor ( var name in morphAttributes ) {\r\n\t\r\n\t\t\t\tvar array = morphAttributes[ name ];\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tupdateAttribute( array[ i ], gl.ARRAY_BUFFER );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn geometry;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction updateAttribute( attribute, bufferType ) {\r\n\t\r\n\t\t\tvar data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;\r\n\t\r\n\t\t\tvar attributeProperties = properties.get( data );\r\n\t\r\n\t\t\tif ( attributeProperties.__webglBuffer === undefined ) {\r\n\t\r\n\t\t\t\tcreateBuffer( attributeProperties, data, bufferType );\r\n\t\r\n\t\t\t} else if ( attributeProperties.version !== data.version ) {\r\n\t\r\n\t\t\t\tupdateBuffer( attributeProperties, data, bufferType );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction createBuffer( attributeProperties, data, bufferType ) {\r\n\t\r\n\t\t\tattributeProperties.__webglBuffer = gl.createBuffer();\r\n\t\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\r\n\t\r\n\t\t\tvar usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\r\n\t\r\n\t\t\tgl.bufferData( bufferType, data.array, usage );\r\n\t\r\n\t\t\tattributeProperties.version = data.version;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction updateBuffer( attributeProperties, data, bufferType ) {\r\n\t\r\n\t\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\r\n\t\r\n\t\t\tif ( data.dynamic === false || data.updateRange.count === - 1 ) {\r\n\t\r\n\t\t\t\t// Not using update ranges\r\n\t\r\n\t\t\t\tgl.bufferSubData( bufferType, 0, data.array );\r\n\t\r\n\t\t\t} else if ( data.updateRange.count === 0 ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tgl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,\r\n\t\t\t\t\t\t\t\t  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );\r\n\t\r\n\t\t\t\tdata.updateRange.count = 0; // reset range\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tattributeProperties.version = data.version;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction getAttributeBuffer( attribute ) {\r\n\t\r\n\t\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\t\r\n\t\t\t\treturn properties.get( attribute.data ).__webglBuffer;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn properties.get( attribute ).__webglBuffer;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction getWireframeAttribute( geometry ) {\r\n\t\r\n\t\t\tvar property = properties.get( geometry );\r\n\t\r\n\t\t\tif ( property.wireframe !== undefined ) {\r\n\t\r\n\t\t\t\treturn property.wireframe;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar indices = [];\r\n\t\r\n\t\t\tvar index = geometry.index;\r\n\t\t\tvar attributes = geometry.attributes;\r\n\t\t\tvar position = attributes.position;\r\n\t\r\n\t\t\t// console.time( 'wireframe' );\r\n\t\r\n\t\t\tif ( index !== null ) {\r\n\t\r\n\t\t\t\tvar edges = {};\r\n\t\t\t\tvar array = index.array;\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\r\n\t\r\n\t\t\t\t\tvar a = array[ i + 0 ];\r\n\t\t\t\t\tvar b = array[ i + 1 ];\r\n\t\t\t\t\tvar c = array[ i + 2 ];\r\n\t\r\n\t\t\t\t\tif ( checkEdge( edges, a, b ) ) indices.push( a, b );\r\n\t\t\t\t\tif ( checkEdge( edges, b, c ) ) indices.push( b, c );\r\n\t\t\t\t\tif ( checkEdge( edges, c, a ) ) indices.push( c, a );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tvar array = attributes.position.array;\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\r\n\t\r\n\t\t\t\t\tvar a = i + 0;\r\n\t\t\t\t\tvar b = i + 1;\r\n\t\t\t\t\tvar c = i + 2;\r\n\t\r\n\t\t\t\t\tindices.push( a, b, b, c, c, a );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// console.timeEnd( 'wireframe' );\r\n\t\r\n\t\t\tvar TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;\r\n\t\t\tvar attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );\r\n\t\r\n\t\t\tupdateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\r\n\t\r\n\t\t\tproperty.wireframe = attribute;\r\n\t\r\n\t\t\treturn attribute;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction checkEdge( edges, a, b ) {\r\n\t\r\n\t\t\tif ( a > b ) {\r\n\t\r\n\t\t\t\tvar tmp = a;\r\n\t\t\t\ta = b;\r\n\t\t\t\tb = tmp;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar list = edges[ a ];\r\n\t\r\n\t\t\tif ( list === undefined ) {\r\n\t\r\n\t\t\t\tedges[ a ] = [ b ];\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t} else if ( list.indexOf( b ) === -1 ) {\r\n\t\r\n\t\t\t\tlist.push( b );\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn false;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.getAttributeBuffer = getAttributeBuffer;\r\n\t\tthis.getWireframeAttribute = getWireframeAttribute;\r\n\t\r\n\t\tthis.update = update;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLProgram.js\r\n\t\r\n\tTHREE.WebGLProgram = ( function () {\r\n\t\r\n\t\tvar programIdCount = 0;\r\n\t\r\n\t\tfunction getEncodingComponents( encoding ) {\r\n\t\r\n\t\t\tswitch ( encoding ) {\r\n\t\r\n\t\t\t\tcase THREE.LinearEncoding:\r\n\t\t\t\t\treturn [ 'Linear','( value )' ];\r\n\t\t\t\tcase THREE.sRGBEncoding:\r\n\t\t\t\t\treturn [ 'sRGB','( value )' ];\r\n\t\t\t\tcase THREE.RGBEEncoding:\r\n\t\t\t\t\treturn [ 'RGBE','( value )' ];\r\n\t\t\t\tcase THREE.RGBM7Encoding:\r\n\t\t\t\t\treturn [ 'RGBM','( value, 7.0 )' ];\r\n\t\t\t\tcase THREE.RGBM16Encoding:\r\n\t\t\t\t\treturn [ 'RGBM','( value, 16.0 )' ];\r\n\t\t\t\tcase THREE.RGBDEncoding:\r\n\t\t\t\t\treturn [ 'RGBD','( value, 256.0 )' ];\r\n\t\t\t\tcase THREE.GammaEncoding:\r\n\t\t\t\t\treturn [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error( 'unsupported encoding: ' + encoding );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction getTexelDecodingFunction( functionName, encoding ) {\r\n\t\r\n\t\t\tvar components = getEncodingComponents( encoding );\r\n\t\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return \" + components[ 0 ] + \"ToLinear\" + components[ 1 ] + \"; }\";\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction getTexelEncodingFunction( functionName, encoding ) {\r\n\t\r\n\t\t\tvar components = getEncodingComponents( encoding );\r\n\t\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return LinearTo\" + components[ 0 ] + components[ 1 ] + \"; }\";\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction getToneMappingFunction( functionName, toneMapping ) {\r\n\t\r\n\t\t\tvar toneMappingName;\r\n\t\r\n\t\t\tswitch ( toneMapping ) {\r\n\t\r\n\t\t\t\tcase THREE.LinearToneMapping:\r\n\t\t\t\t\ttoneMappingName = \"Linear\";\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase THREE.ReinhardToneMapping:\r\n\t\t\t\t\ttoneMappingName = \"Reinhard\";\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase THREE.Uncharted2ToneMapping:\r\n\t\t\t\t\ttoneMappingName = \"Uncharted2\";\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase THREE.CineonToneMapping:\r\n\t\t\t\t\ttoneMappingName = \"OptimizedCineon\";\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn \"vec3 \" + functionName + \"( vec3 color ) { return \" + toneMappingName + \"ToneMapping( color ); }\";\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction generateExtensions( extensions, parameters, rendererExtensions ) {\r\n\t\r\n\t\t\textensions = extensions || {};\r\n\t\r\n\t\t\tvar chunks = [\r\n\t\t\t\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\r\n\t\t\t\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\r\n\t\t\t\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\r\n\t\t\t\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',\r\n\t\t\t];\r\n\t\r\n\t\t\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction generateDefines( defines ) {\r\n\t\r\n\t\t\tvar chunks = [];\r\n\t\r\n\t\t\tfor ( var name in defines ) {\r\n\t\r\n\t\t\t\tvar value = defines[ name ];\r\n\t\r\n\t\t\t\tif ( value === false ) continue;\r\n\t\r\n\t\t\t\tchunks.push( '#define ' + name + ' ' + value );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn chunks.join( '\\n' );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction fetchAttributeLocations( gl, program, identifiers ) {\r\n\t\r\n\t\t\tvar attributes = {};\r\n\t\r\n\t\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\r\n\t\r\n\t\t\tfor ( var i = 0; i < n; i ++ ) {\r\n\t\r\n\t\t\t\tvar info = gl.getActiveAttrib( program, i );\r\n\t\t\t\tvar name = info.name;\r\n\t\r\n\t\t\t\t// console.log(\"THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:\", name, i );\r\n\t\r\n\t\t\t\tattributes[ name ] = gl.getAttribLocation( program, name );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn attributes;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction filterEmptyLine( string ) {\r\n\t\r\n\t\t\treturn string !== '';\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction replaceLightNums( string, parameters ) {\r\n\t\r\n\t\t\treturn string\r\n\t\t\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\r\n\t\t\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\r\n\t\t\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\r\n\t\t\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction parseIncludes( string ) {\r\n\t\r\n\t\t\tvar pattern = /#include +<([\\w\\d.]+)>/g;\r\n\t\r\n\t\t\tfunction replace( match, include ) {\r\n\t\r\n\t\t\t\tvar replace = THREE.ShaderChunk[ include ];\r\n\t\r\n\t\t\t\tif ( replace === undefined ) {\r\n\t\r\n\t\t\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn parseIncludes( replace );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn string.replace( pattern, replace );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction unrollLoops( string ) {\r\n\t\r\n\t\t\tvar pattern = /for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\r\n\t\r\n\t\t\tfunction replace( match, start, end, snippet ) {\r\n\t\r\n\t\t\t\tvar unroll = '';\r\n\t\r\n\t\t\t\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\r\n\t\r\n\t\t\t\t\tunroll += snippet.replace( /\\[ i \\]/g, '[ ' + i + ' ]' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn unroll;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn string.replace( pattern, replace );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn function WebGLProgram( renderer, code, material, parameters ) {\r\n\t\r\n\t\t\tvar gl = renderer.context;\r\n\t\r\n\t\t\tvar extensions = material.extensions;\r\n\t\t\tvar defines = material.defines;\r\n\t\r\n\t\t\tvar vertexShader = material.__webglShader.vertexShader;\r\n\t\t\tvar fragmentShader = material.__webglShader.fragmentShader;\r\n\t\r\n\t\t\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\r\n\t\r\n\t\t\tif ( parameters.shadowMapType === THREE.PCFShadowMap ) {\r\n\t\r\n\t\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\r\n\t\r\n\t\t\t} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {\r\n\t\r\n\t\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\r\n\t\t\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\r\n\t\t\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\r\n\t\r\n\t\t\tif ( parameters.envMap ) {\r\n\t\r\n\t\t\t\tswitch ( material.envMap.mapping ) {\r\n\t\r\n\t\t\t\t\tcase THREE.CubeReflectionMapping:\r\n\t\t\t\t\tcase THREE.CubeRefractionMapping:\r\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.CubeUVReflectionMapping:\r\n\t\t\t\t\tcase THREE.CubeUVRefractionMapping:\r\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.EquirectangularReflectionMapping:\r\n\t\t\t\t\tcase THREE.EquirectangularRefractionMapping:\r\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.SphericalReflectionMapping:\r\n\t\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tswitch ( material.envMap.mapping ) {\r\n\t\r\n\t\t\t\t\tcase THREE.CubeRefractionMapping:\r\n\t\t\t\t\tcase THREE.EquirectangularRefractionMapping:\r\n\t\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tswitch ( material.combine ) {\r\n\t\r\n\t\t\t\t\tcase THREE.MultiplyOperation:\r\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.MixOperation:\r\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\tcase THREE.AddOperation:\r\n\t\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\r\n\t\r\n\t\t\t// console.log( 'building new program ' );\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tvar customExtensions = generateExtensions( extensions, parameters, renderer.extensions );\r\n\t\r\n\t\t\tvar customDefines = generateDefines( defines );\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tvar program = gl.createProgram();\r\n\t\r\n\t\t\tvar prefixVertex, prefixFragment;\r\n\t\r\n\t\t\tif ( material instanceof THREE.RawShaderMaterial ) {\r\n\t\r\n\t\t\t\tprefixVertex = '';\r\n\t\t\t\tprefixFragment = '';\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tprefixVertex = [\r\n\t\r\n\t\t\t\t\t'precision ' + parameters.precision + ' float;',\r\n\t\t\t\t\t'precision ' + parameters.precision + ' int;',\r\n\t\r\n\t\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\r\n\t\r\n\t\t\t\t\tcustomDefines,\r\n\t\r\n\t\t\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\r\n\t\r\n\t\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\r\n\t\r\n\t\t\t\t\t'#define MAX_BONES ' + parameters.maxBones,\r\n\t\r\n\t\t\t\t\tparameters.map ? '#define USE_MAP' : '',\r\n\t\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\r\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\r\n\t\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\r\n\t\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\r\n\t\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\r\n\t\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\r\n\t\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\r\n\t\t\t\t\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\r\n\t\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\r\n\t\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\r\n\t\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\r\n\t\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\r\n\t\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\r\n\t\r\n\t\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\r\n\t\r\n\t\t\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\r\n\t\t\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\r\n\t\r\n\t\t\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\r\n\t\t\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\r\n\t\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\r\n\t\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\r\n\t\r\n\t\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\r\n\t\r\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\r\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\r\n\t\r\n\t\t\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\r\n\t\r\n\t\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\r\n\t\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\r\n\t\r\n\t\t\t\t\t'uniform mat4 modelMatrix;',\r\n\t\t\t\t\t'uniform mat4 modelViewMatrix;',\r\n\t\t\t\t\t'uniform mat4 projectionMatrix;',\r\n\t\t\t\t\t'uniform mat4 viewMatrix;',\r\n\t\t\t\t\t'uniform mat3 normalMatrix;',\r\n\t\t\t\t\t'uniform vec3 cameraPosition;',\r\n\t\r\n\t\t\t\t\t'attribute vec3 position;',\r\n\t\t\t\t\t'attribute vec3 normal;',\r\n\t\t\t\t\t'attribute vec2 uv;',\r\n\t\r\n\t\t\t\t\t'#ifdef USE_COLOR',\r\n\t\r\n\t\t\t\t\t'\tattribute vec3 color;',\r\n\t\r\n\t\t\t\t\t'#endif',\r\n\t\r\n\t\t\t\t\t'#ifdef USE_MORPHTARGETS',\r\n\t\r\n\t\t\t\t\t'\tattribute vec3 morphTarget0;',\r\n\t\t\t\t\t'\tattribute vec3 morphTarget1;',\r\n\t\t\t\t\t'\tattribute vec3 morphTarget2;',\r\n\t\t\t\t\t'\tattribute vec3 morphTarget3;',\r\n\t\r\n\t\t\t\t\t'\t#ifdef USE_MORPHNORMALS',\r\n\t\r\n\t\t\t\t\t'\t\tattribute vec3 morphNormal0;',\r\n\t\t\t\t\t'\t\tattribute vec3 morphNormal1;',\r\n\t\t\t\t\t'\t\tattribute vec3 morphNormal2;',\r\n\t\t\t\t\t'\t\tattribute vec3 morphNormal3;',\r\n\t\r\n\t\t\t\t\t'\t#else',\r\n\t\r\n\t\t\t\t\t'\t\tattribute vec3 morphTarget4;',\r\n\t\t\t\t\t'\t\tattribute vec3 morphTarget5;',\r\n\t\t\t\t\t'\t\tattribute vec3 morphTarget6;',\r\n\t\t\t\t\t'\t\tattribute vec3 morphTarget7;',\r\n\t\r\n\t\t\t\t\t'\t#endif',\r\n\t\r\n\t\t\t\t\t'#endif',\r\n\t\r\n\t\t\t\t\t'#ifdef USE_SKINNING',\r\n\t\r\n\t\t\t\t\t'\tattribute vec4 skinIndex;',\r\n\t\t\t\t\t'\tattribute vec4 skinWeight;',\r\n\t\r\n\t\t\t\t\t'#endif',\r\n\t\r\n\t\t\t\t\t'\\n'\r\n\t\r\n\t\t\t\t].filter( filterEmptyLine ).join( '\\n' );\r\n\t\r\n\t\t\t\tprefixFragment = [\r\n\t\r\n\t\t\t\t\tcustomExtensions,\r\n\t\r\n\t\t\t\t\t'precision ' + parameters.precision + ' float;',\r\n\t\t\t\t\t'precision ' + parameters.precision + ' int;',\r\n\t\r\n\t\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\r\n\t\r\n\t\t\t\t\tcustomDefines,\r\n\t\r\n\t\t\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\r\n\t\r\n\t\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\r\n\t\r\n\t\t\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\r\n\t\t\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\r\n\t\r\n\t\t\t\t\tparameters.map ? '#define USE_MAP' : '',\r\n\t\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\r\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\r\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\r\n\t\t\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\r\n\t\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\r\n\t\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\r\n\t\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\r\n\t\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\r\n\t\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\r\n\t\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\r\n\t\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\r\n\t\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\r\n\t\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\r\n\t\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\r\n\t\r\n\t\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\r\n\t\r\n\t\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\r\n\t\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\r\n\t\r\n\t\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\r\n\t\r\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\r\n\t\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\r\n\t\r\n\t\t\t\t\tparameters.premultipliedAlpha ? \"#define PREMULTIPLIED_ALPHA\" : '',\r\n\t\r\n\t\t\t\t\tparameters.physicallyCorrectLights ? \"#define PHYSICALLY_CORRECT_LIGHTS\" : '',\r\n\t\r\n\t\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\r\n\t\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\r\n\t\r\n\t\t\t\t\tparameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',\r\n\t\r\n\t\t\t\t\t'uniform mat4 viewMatrix;',\r\n\t\t\t\t\t'uniform vec3 cameraPosition;',\r\n\t\r\n\t\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? \"#define TONE_MAPPING\" : '',\r\n\t\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? THREE.ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below\r\n\t\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? getToneMappingFunction( \"toneMapping\", parameters.toneMapping ) : '',\r\n\t\r\n\t\t\t\t\t( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? THREE.ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\r\n\t\t\t\t\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\r\n\t\t\t\t\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\r\n\t\t\t\t\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\r\n\t\t\t\t\tparameters.outputEncoding ? getTexelEncodingFunction( \"linearToOutputTexel\", parameters.outputEncoding ) : '',\r\n\t\r\n\t\t\t\t\tparameters.depthPacking ? \"#define DEPTH_PACKING \" + material.depthPacking : '',\r\n\t\r\n\t\t\t\t\t'\\n'\r\n\t\r\n\t\t\t\t].filter( filterEmptyLine ).join( '\\n' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvertexShader = parseIncludes( vertexShader, parameters );\r\n\t\t\tvertexShader = replaceLightNums( vertexShader, parameters );\r\n\t\r\n\t\t\tfragmentShader = parseIncludes( fragmentShader, parameters );\r\n\t\t\tfragmentShader = replaceLightNums( fragmentShader, parameters );\r\n\t\r\n\t\t\tif ( material instanceof THREE.ShaderMaterial === false ) {\r\n\t\r\n\t\t\t\tvertexShader = unrollLoops( vertexShader );\r\n\t\t\t\tfragmentShader = unrollLoops( fragmentShader );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar vertexGlsl = prefixVertex + vertexShader;\r\n\t\t\tvar fragmentGlsl = prefixFragment + fragmentShader;\r\n\t\r\n\t\t\t// console.log( '*VERTEX*', vertexGlsl );\r\n\t\t\t// console.log( '*FRAGMENT*', fragmentGlsl );\r\n\t\r\n\t\t\tvar glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\r\n\t\t\tvar glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\r\n\t\r\n\t\t\tgl.attachShader( program, glVertexShader );\r\n\t\t\tgl.attachShader( program, glFragmentShader );\r\n\t\r\n\t\t\t// Force a particular attribute to index 0.\r\n\t\r\n\t\t\tif ( material.index0AttributeName !== undefined ) {\r\n\t\r\n\t\t\t\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\r\n\t\r\n\t\t\t} else if ( parameters.morphTargets === true ) {\r\n\t\r\n\t\t\t\t// programs with morphTargets displace position out of attribute 0\r\n\t\t\t\tgl.bindAttribLocation( program, 0, 'position' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgl.linkProgram( program );\r\n\t\r\n\t\t\tvar programLog = gl.getProgramInfoLog( program );\r\n\t\t\tvar vertexLog = gl.getShaderInfoLog( glVertexShader );\r\n\t\t\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader );\r\n\t\r\n\t\t\tvar runnable = true;\r\n\t\t\tvar haveDiagnostics = true;\r\n\t\r\n\t\t\t// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\r\n\t\t\t// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\r\n\t\r\n\t\t\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\r\n\t\r\n\t\t\t\trunnable = false;\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\r\n\t\r\n\t\t\t} else if ( programLog !== '' ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\r\n\t\r\n\t\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\r\n\t\r\n\t\t\t\thaveDiagnostics = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( haveDiagnostics ) {\r\n\t\r\n\t\t\t\tthis.diagnostics = {\r\n\t\r\n\t\t\t\t\trunnable: runnable,\r\n\t\t\t\t\tmaterial: material,\r\n\t\r\n\t\t\t\t\tprogramLog: programLog,\r\n\t\r\n\t\t\t\t\tvertexShader: {\r\n\t\r\n\t\t\t\t\t\tlog: vertexLog,\r\n\t\t\t\t\t\tprefix: prefixVertex\r\n\t\r\n\t\t\t\t\t},\r\n\t\r\n\t\t\t\t\tfragmentShader: {\r\n\t\r\n\t\t\t\t\t\tlog: fragmentLog,\r\n\t\t\t\t\t\tprefix: prefixFragment\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t};\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// clean up\r\n\t\r\n\t\t\tgl.deleteShader( glVertexShader );\r\n\t\t\tgl.deleteShader( glFragmentShader );\r\n\t\r\n\t\t\t// set up caching for uniform locations\r\n\t\r\n\t\t\tvar cachedUniforms;\r\n\t\r\n\t\t\tthis.getUniforms = function() {\r\n\t\r\n\t\t\t\tif ( cachedUniforms === undefined ) {\r\n\t\r\n\t\t\t\t\tcachedUniforms =\r\n\t\t\t\t\t\t\tnew THREE.WebGLUniforms( gl, program, renderer );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn cachedUniforms;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\t// set up caching for attribute locations\r\n\t\r\n\t\t\tvar cachedAttributes;\r\n\t\r\n\t\t\tthis.getAttributes = function() {\r\n\t\r\n\t\t\t\tif ( cachedAttributes === undefined ) {\r\n\t\r\n\t\t\t\t\tcachedAttributes = fetchAttributeLocations( gl, program );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn cachedAttributes;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\t// free resource\r\n\t\r\n\t\t\tthis.destroy = function() {\r\n\t\r\n\t\t\t\tgl.deleteProgram( program );\r\n\t\t\t\tthis.program = undefined;\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\t// DEPRECATED\r\n\t\r\n\t\t\tObject.defineProperties( this, {\r\n\t\r\n\t\t\t\tuniforms: {\r\n\t\t\t\t\tget: function() {\r\n\t\r\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\r\n\t\t\t\t\t\treturn this.getUniforms();\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t},\r\n\t\r\n\t\t\t\tattributes: {\r\n\t\t\t\t\tget: function() {\r\n\t\r\n\t\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\r\n\t\t\t\t\t\treturn this.getAttributes();\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} );\r\n\t\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tthis.id = programIdCount ++;\r\n\t\t\tthis.code = code;\r\n\t\t\tthis.usedTimes = 1;\r\n\t\t\tthis.program = program;\r\n\t\t\tthis.vertexShader = glVertexShader;\r\n\t\t\tthis.fragmentShader = glFragmentShader;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t};\r\n\t\r\n\t} )();\r\n\t\r\n\t// File:src/renderers/webgl/WebGLPrograms.js\r\n\t\r\n\tTHREE.WebGLPrograms = function ( renderer, capabilities ) {\r\n\t\r\n\t\tvar programs = [];\r\n\t\r\n\t\tvar shaderIDs = {\r\n\t\t\tMeshDepthMaterial: 'depth',\r\n\t\t\tMeshNormalMaterial: 'normal',\r\n\t\t\tMeshBasicMaterial: 'basic',\r\n\t\t\tMeshLambertMaterial: 'lambert',\r\n\t\t\tMeshPhongMaterial: 'phong',\r\n\t\t\tMeshStandardMaterial: 'physical',\r\n\t\t\tMeshPhysicalMaterial: 'physical',\r\n\t\t\tLineBasicMaterial: 'basic',\r\n\t\t\tLineDashedMaterial: 'dashed',\r\n\t\t\tPointsMaterial: 'points'\r\n\t\t};\r\n\t\r\n\t\tvar parameterNames = [\r\n\t\t\t\"precision\", \"supportsVertexTextures\", \"map\", \"mapEncoding\", \"envMap\", \"envMapMode\", \"envMapEncoding\",\r\n\t\t\t\"lightMap\", \"aoMap\", \"emissiveMap\", \"emissiveMapEncoding\", \"bumpMap\", \"normalMap\", \"displacementMap\", \"specularMap\",\r\n\t\t\t\"roughnessMap\", \"metalnessMap\",\r\n\t\t\t\"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\",\r\n\t\t\t\"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\r\n\t\t\t\"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\r\n\t\t\t\"maxMorphTargets\", \"maxMorphNormals\", \"premultipliedAlpha\",\r\n\t\t\t\"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\",\r\n\t\t\t\"shadowMapEnabled\", \"shadowMapType\", \"toneMapping\", 'physicallyCorrectLights',\r\n\t\t\t\"alphaTest\", \"doubleSided\", \"flipSided\", \"numClippingPlanes\", \"depthPacking\"\r\n\t\t];\r\n\t\r\n\t\r\n\t\tfunction allocateBones ( object ) {\r\n\t\r\n\t\t\tif ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {\r\n\t\r\n\t\t\t\treturn 1024;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// default for when object is not specified\r\n\t\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\r\n\t\t\t\t//\r\n\t\t\t\t//  - leave some extra space for other uniforms\r\n\t\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\r\n\t\t\t\t//    (up to 54 should be safe)\r\n\t\r\n\t\t\t\tvar nVertexUniforms = capabilities.maxVertexUniforms;\r\n\t\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\r\n\t\r\n\t\t\t\tvar maxBones = nVertexMatrices;\r\n\t\r\n\t\t\t\tif ( object !== undefined && object instanceof THREE.SkinnedMesh ) {\r\n\t\r\n\t\t\t\t\tmaxBones = Math.min( object.skeleton.bones.length, maxBones );\r\n\t\r\n\t\t\t\t\tif ( maxBones < object.skeleton.bones.length ) {\r\n\t\r\n\t\t\t\t\t\tconsole.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn maxBones;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\r\n\t\r\n\t\t\tvar encoding;\r\n\t\r\n\t\t\tif ( ! map ) {\r\n\t\r\n\t\t\t\tencoding = THREE.LinearEncoding;\r\n\t\r\n\t\t\t} else if ( map instanceof THREE.Texture ) {\r\n\t\r\n\t\t\t\tencoding = map.encoding;\r\n\t\r\n\t\t\t} else if ( map instanceof THREE.WebGLRenderTarget ) {\r\n\t\r\n\t\t\t\tconsole.warn( \"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\" );\r\n\t\t\t\tencoding = map.texture.encoding;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\r\n\t\t\tif ( encoding === THREE.LinearEncoding && gammaOverrideLinear ) {\r\n\t\r\n\t\t\t\tencoding = THREE.GammaEncoding;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn encoding;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.getParameters = function ( material, lights, fog, nClipPlanes, object ) {\r\n\t\r\n\t\t\tvar shaderID = shaderIDs[ material.type ];\r\n\t\r\n\t\t\t// heuristics to create shader parameters according to lights in the scene\r\n\t\t\t// (not to blow over maxLights budget)\r\n\t\r\n\t\t\tvar maxBones = allocateBones( object );\r\n\t\t\tvar precision = renderer.getPrecision();\r\n\t\r\n\t\t\tif ( material.precision !== null ) {\r\n\t\r\n\t\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\r\n\t\r\n\t\t\t\tif ( precision !== material.precision ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar currentRenderTarget = renderer.getCurrentRenderTarget();\r\n\t\r\n\t\t\tvar parameters = {\r\n\t\r\n\t\t\t\tshaderID: shaderID,\r\n\t\r\n\t\t\t\tprecision: precision,\r\n\t\t\t\tsupportsVertexTextures: capabilities.vertexTextures,\r\n\t\t\t\toutputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),\r\n\t\t\t\tmap: !! material.map,\r\n\t\t\t\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\r\n\t\t\t\tenvMap: !! material.envMap,\r\n\t\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\r\n\t\t\t\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\r\n\t\t\t\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === THREE.CubeUVReflectionMapping ) || ( material.envMap.mapping === THREE.CubeUVRefractionMapping ) ),\r\n\t\t\t\tlightMap: !! material.lightMap,\r\n\t\t\t\taoMap: !! material.aoMap,\r\n\t\t\t\temissiveMap: !! material.emissiveMap,\r\n\t\t\t\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\r\n\t\t\t\tbumpMap: !! material.bumpMap,\r\n\t\t\t\tnormalMap: !! material.normalMap,\r\n\t\t\t\tdisplacementMap: !! material.displacementMap,\r\n\t\t\t\troughnessMap: !! material.roughnessMap,\r\n\t\t\t\tmetalnessMap: !! material.metalnessMap,\r\n\t\t\t\tspecularMap: !! material.specularMap,\r\n\t\t\t\talphaMap: !! material.alphaMap,\r\n\t\r\n\t\t\t\tcombine: material.combine,\r\n\t\r\n\t\t\t\tvertexColors: material.vertexColors,\r\n\t\r\n\t\t\t\tfog: fog,\r\n\t\t\t\tuseFog: material.fog,\r\n\t\t\t\tfogExp: fog instanceof THREE.FogExp2,\r\n\t\r\n\t\t\t\tflatShading: material.shading === THREE.FlatShading,\r\n\t\r\n\t\t\t\tsizeAttenuation: material.sizeAttenuation,\r\n\t\t\t\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\r\n\t\r\n\t\t\t\tskinning: material.skinning,\r\n\t\t\t\tmaxBones: maxBones,\r\n\t\t\t\tuseVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,\r\n\t\r\n\t\t\t\tmorphTargets: material.morphTargets,\r\n\t\t\t\tmorphNormals: material.morphNormals,\r\n\t\t\t\tmaxMorphTargets: renderer.maxMorphTargets,\r\n\t\t\t\tmaxMorphNormals: renderer.maxMorphNormals,\r\n\t\r\n\t\t\t\tnumDirLights: lights.directional.length,\r\n\t\t\t\tnumPointLights: lights.point.length,\r\n\t\t\t\tnumSpotLights: lights.spot.length,\r\n\t\t\t\tnumHemiLights: lights.hemi.length,\r\n\t\r\n\t\t\t\tnumClippingPlanes: nClipPlanes,\r\n\t\r\n\t\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,\r\n\t\t\t\tshadowMapType: renderer.shadowMap.type,\r\n\t\r\n\t\t\t\ttoneMapping: renderer.toneMapping,\r\n\t\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\r\n\t\r\n\t\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\r\n\t\r\n\t\t\t\talphaTest: material.alphaTest,\r\n\t\t\t\tdoubleSided: material.side === THREE.DoubleSide,\r\n\t\t\t\tflipSided: material.side === THREE.BackSide,\r\n\t\r\n\t\t\t\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\treturn parameters;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getProgramCode = function ( material, parameters ) {\r\n\t\r\n\t\t\tvar array = [];\r\n\t\r\n\t\t\tif ( parameters.shaderID ) {\r\n\t\r\n\t\t\t\tarray.push( parameters.shaderID );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tarray.push( material.fragmentShader );\r\n\t\t\t\tarray.push( material.vertexShader );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( material.defines !== undefined ) {\r\n\t\r\n\t\t\t\tfor ( var name in material.defines ) {\r\n\t\r\n\t\t\t\t\tarray.push( name );\r\n\t\t\t\t\tarray.push( material.defines[ name ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\r\n\t\r\n\t\t\t\tarray.push( parameters[ parameterNames[ i ] ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn array.join();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.acquireProgram = function ( material, parameters, code ) {\r\n\t\r\n\t\t\tvar program;\r\n\t\r\n\t\t\t// Check if code has been already compiled\r\n\t\t\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\r\n\t\r\n\t\t\t\tvar programInfo = programs[ p ];\r\n\t\r\n\t\t\t\tif ( programInfo.code === code ) {\r\n\t\r\n\t\t\t\t\tprogram = programInfo;\r\n\t\t\t\t\t++ program.usedTimes;\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( program === undefined ) {\r\n\t\r\n\t\t\t\tprogram = new THREE.WebGLProgram( renderer, code, material, parameters );\r\n\t\t\t\tprograms.push( program );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn program;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.releaseProgram = function( program ) {\r\n\t\r\n\t\t\tif ( -- program.usedTimes === 0 ) {\r\n\t\r\n\t\t\t\t// Remove from unordered set\r\n\t\t\t\tvar i = programs.indexOf( program );\r\n\t\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\r\n\t\t\t\tprograms.pop();\r\n\t\r\n\t\t\t\t// Free WebGL resources\r\n\t\t\t\tprogram.destroy();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Exposed for resource monitoring & error feedback via renderer.info:\r\n\t\tthis.programs = programs;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLProperties.js\r\n\t\r\n\t/**\r\n\t* @author fordacious / fordacious.github.io\r\n\t*/\r\n\t\r\n\tTHREE.WebGLProperties = function () {\r\n\t\r\n\t\tvar properties = {};\r\n\t\r\n\t\tthis.get = function ( object ) {\r\n\t\r\n\t\t\tvar uuid = object.uuid;\r\n\t\t\tvar map = properties[ uuid ];\r\n\t\r\n\t\t\tif ( map === undefined ) {\r\n\t\r\n\t\t\t\tmap = {};\r\n\t\t\t\tproperties[ uuid ] = map;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn map;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.delete = function ( object ) {\r\n\t\r\n\t\t\tdelete properties[ object.uuid ];\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clear = function () {\r\n\t\r\n\t\t\tproperties = {};\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLShader.js\r\n\t\r\n\tTHREE.WebGLShader = ( function () {\r\n\t\r\n\t\tfunction addLineNumbers( string ) {\r\n\t\r\n\t\t\tvar lines = string.split( '\\n' );\r\n\t\r\n\t\t\tfor ( var i = 0; i < lines.length; i ++ ) {\r\n\t\r\n\t\t\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn lines.join( '\\n' );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn function WebGLShader( gl, type, string ) {\r\n\t\r\n\t\t\tvar shader = gl.createShader( type );\r\n\t\r\n\t\t\tgl.shaderSource( shader, string );\r\n\t\t\tgl.compileShader( shader );\r\n\t\r\n\t\t\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\r\n\t\r\n\t\t\t\tconsole.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\r\n\t\r\n\t\t\t\tconsole.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// --enable-privileged-webgl-extension\r\n\t\t\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\r\n\t\r\n\t\t\treturn shader;\r\n\t\r\n\t\t};\r\n\t\r\n\t} )();\r\n\t\r\n\t// File:src/renderers/webgl/WebGLShadowMap.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.WebGLShadowMap = function ( _renderer, _lights, _objects ) {\r\n\t\r\n\t\tvar _gl = _renderer.context,\r\n\t\t_state = _renderer.state,\r\n\t\t_frustum = new THREE.Frustum(),\r\n\t\t_projScreenMatrix = new THREE.Matrix4(),\r\n\t\r\n\t\t_lightShadows = _lights.shadows,\r\n\t\r\n\t\t_shadowMapSize = new THREE.Vector2(),\r\n\t\r\n\t\t_lookTarget = new THREE.Vector3(),\r\n\t\t_lightPositionWorld = new THREE.Vector3(),\r\n\t\r\n\t\t_renderList = [],\r\n\t\r\n\t\t_MorphingFlag = 1,\r\n\t\t_SkinningFlag = 2,\r\n\t\r\n\t\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\r\n\t\r\n\t\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\r\n\t\t_distanceMaterials = new Array( _NumberOfMaterialVariants ),\r\n\t\r\n\t\t_materialCache = {};\r\n\t\r\n\t\tvar cubeDirections = [\r\n\t\t\tnew THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( - 1, 0, 0 ), new THREE.Vector3( 0, 0, 1 ),\r\n\t\t\tnew THREE.Vector3( 0, 0, - 1 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, - 1, 0 )\r\n\t\t];\r\n\t\r\n\t\tvar cubeUps = [\r\n\t\t\tnew THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ),\r\n\t\t\tnew THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 1 ),\tnew THREE.Vector3( 0, 0, - 1 )\r\n\t\t];\r\n\t\r\n\t\tvar cube2DViewPorts = [\r\n\t\t\tnew THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(),\r\n\t\t\tnew THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()\r\n\t\t];\r\n\t\r\n\t\t// init\r\n\t\r\n\t\tvar depthMaterialTemplate = new THREE.MeshDepthMaterial();\r\n\t\tdepthMaterialTemplate.depthPacking = THREE.RGBADepthPacking;\r\n\t\tdepthMaterialTemplate.clipping = true;\r\n\t\r\n\t\tvar distanceShader = THREE.ShaderLib[ \"distanceRGBA\" ];\r\n\t\tvar distanceUniforms = THREE.UniformsUtils.clone( distanceShader.uniforms );\r\n\t\r\n\t\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\r\n\t\r\n\t\t\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\r\n\t\t\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\r\n\t\r\n\t\t\tvar depthMaterial = depthMaterialTemplate.clone();\r\n\t\t\tdepthMaterial.morphTargets = useMorphing;\r\n\t\t\tdepthMaterial.skinning = useSkinning;\r\n\t\r\n\t\t\t_depthMaterials[ i ] = depthMaterial;\r\n\t\r\n\t\t\tvar distanceMaterial = new THREE.ShaderMaterial( {\r\n\t\t\t\tdefines: {\r\n\t\t\t\t\t'USE_SHADOWMAP': ''\r\n\t\t\t\t},\r\n\t\t\t\tuniforms: distanceUniforms,\r\n\t\t\t\tvertexShader: distanceShader.vertexShader,\r\n\t\t\t\tfragmentShader: distanceShader.fragmentShader,\r\n\t\t\t\tmorphTargets: useMorphing,\r\n\t\t\t\tskinning: useSkinning,\r\n\t\t\t\tclipping: true\r\n\t\t\t} );\r\n\t\r\n\t\t\t_distanceMaterials[ i ] = distanceMaterial;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvar scope = this;\r\n\t\r\n\t\tthis.enabled = false;\r\n\t\r\n\t\tthis.autoUpdate = true;\r\n\t\tthis.needsUpdate = false;\r\n\t\r\n\t\tthis.type = THREE.PCFShadowMap;\r\n\t\r\n\t\tthis.renderReverseSided = true;\r\n\t\tthis.renderSingleSided = true;\r\n\t\r\n\t\tthis.render = function ( scene, camera ) {\r\n\t\r\n\t\t\tif ( scope.enabled === false ) return;\r\n\t\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\r\n\t\r\n\t\t\tif ( _lightShadows.length === 0 ) return;\r\n\t\r\n\t\t\t// Set GL state for depth map.\r\n\t\t\t_state.clearColor( 1, 1, 1, 1 );\r\n\t\t\t_state.disable( _gl.BLEND );\r\n\t\t\t_state.setDepthTest( true );\r\n\t\t\t_state.setScissorTest( false );\r\n\t\r\n\t\t\t// render depth map\r\n\t\r\n\t\t\tvar faceCount, isPointLight;\r\n\t\r\n\t\t\tfor ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvar light = _lightShadows[ i ];\r\n\t\t\t\tvar shadow = light.shadow;\r\n\t\r\n\t\t\t\tif ( shadow === undefined ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\r\n\t\t\t\t\tcontinue;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar shadowCamera = shadow.camera;\r\n\t\r\n\t\t\t\t_shadowMapSize.copy( shadow.mapSize );\r\n\t\r\n\t\t\t\tif ( light instanceof THREE.PointLight ) {\r\n\t\r\n\t\t\t\t\tfaceCount = 6;\r\n\t\t\t\t\tisPointLight = true;\r\n\t\r\n\t\t\t\t\tvar vpWidth = _shadowMapSize.x;\r\n\t\t\t\t\tvar vpHeight = _shadowMapSize.y;\r\n\t\r\n\t\t\t\t\t// These viewports map a cube-map onto a 2D texture with the\r\n\t\t\t\t\t// following orientation:\r\n\t\t\t\t\t//\r\n\t\t\t\t\t//  xzXZ\r\n\t\t\t\t\t//   y Y\r\n\t\t\t\t\t//\r\n\t\t\t\t\t// X - Positive x direction\r\n\t\t\t\t\t// x - Negative x direction\r\n\t\t\t\t\t// Y - Positive y direction\r\n\t\t\t\t\t// y - Negative y direction\r\n\t\t\t\t\t// Z - Positive z direction\r\n\t\t\t\t\t// z - Negative z direction\r\n\t\r\n\t\t\t\t\t// positive X\r\n\t\t\t\t\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\r\n\t\t\t\t\t// negative X\r\n\t\t\t\t\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\r\n\t\t\t\t\t// positive Z\r\n\t\t\t\t\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\r\n\t\t\t\t\t// negative Z\r\n\t\t\t\t\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\r\n\t\t\t\t\t// positive Y\r\n\t\t\t\t\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\r\n\t\t\t\t\t// negative Y\r\n\t\t\t\t\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\r\n\t\r\n\t\t\t\t\t_shadowMapSize.x *= 4.0;\r\n\t\t\t\t\t_shadowMapSize.y *= 2.0;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tfaceCount = 1;\r\n\t\t\t\t\tisPointLight = false;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( shadow.map === null ) {\r\n\t\r\n\t\t\t\t\tvar pars = { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };\r\n\t\r\n\t\t\t\t\tshadow.map = new THREE.WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\r\n\t\r\n\t\t\t\t\tshadowCamera.updateProjectionMatrix();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( shadow instanceof THREE.SpotLightShadow ) {\r\n\t\r\n\t\t\t\t\tshadow.update( light );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar shadowMap = shadow.map;\r\n\t\t\t\tvar shadowMatrix = shadow.matrix;\r\n\t\r\n\t\t\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\tshadowCamera.position.copy( _lightPositionWorld );\r\n\t\r\n\t\t\t\t_renderer.setRenderTarget( shadowMap );\r\n\t\t\t\t_renderer.clear();\r\n\t\r\n\t\t\t\t// render shadow map for each cube face (if omni-directional) or\r\n\t\t\t\t// run a single pass if not\r\n\t\r\n\t\t\t\tfor ( var face = 0; face < faceCount; face ++ ) {\r\n\t\r\n\t\t\t\t\tif ( isPointLight ) {\r\n\t\r\n\t\t\t\t\t\t_lookTarget.copy( shadowCamera.position );\r\n\t\t\t\t\t\t_lookTarget.add( cubeDirections[ face ] );\r\n\t\t\t\t\t\tshadowCamera.up.copy( cubeUps[ face ] );\r\n\t\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\r\n\t\r\n\t\t\t\t\t\tvar vpDimensions = cube2DViewPorts[ face ];\r\n\t\t\t\t\t\t_state.viewport( vpDimensions );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tshadowCamera.updateMatrixWorld();\r\n\t\t\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\r\n\t\r\n\t\t\t\t\t// compute shadow matrix\r\n\t\r\n\t\t\t\t\tshadowMatrix.set(\r\n\t\t\t\t\t\t0.5, 0.0, 0.0, 0.5,\r\n\t\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\r\n\t\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\r\n\t\t\t\t\t\t0.0, 0.0, 0.0, 1.0\r\n\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\r\n\t\t\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\r\n\t\r\n\t\t\t\t\t// update camera matrices and frustum\r\n\t\r\n\t\t\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\r\n\t\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\t\r\n\t\t\t\t\t// set object matrices & frustum culling\r\n\t\r\n\t\t\t\t\t_renderList.length = 0;\r\n\t\r\n\t\t\t\t\tprojectObject( scene, camera, shadowCamera );\r\n\t\r\n\t\t\t\t\t// render shadow map\r\n\t\t\t\t\t// render regular objects\r\n\t\r\n\t\t\t\t\tfor ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar object = _renderList[ j ];\r\n\t\t\t\t\t\tvar geometry = _objects.update( object );\r\n\t\t\t\t\t\tvar material = object.material;\r\n\t\r\n\t\t\t\t\t\tif ( material instanceof THREE.MultiMaterial ) {\r\n\t\r\n\t\t\t\t\t\t\tvar groups = geometry.groups;\r\n\t\t\t\t\t\t\tvar materials = material.materials;\r\n\t\r\n\t\t\t\t\t\t\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tvar group = groups[ k ];\r\n\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\r\n\t\r\n\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );\r\n\t\t\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );\r\n\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// Restore GL state.\r\n\t\t\tvar clearColor = _renderer.getClearColor(),\r\n\t\t\tclearAlpha = _renderer.getClearAlpha();\r\n\t\t\t_renderer.setClearColor( clearColor, clearAlpha );\r\n\t\r\n\t\t\tscope.needsUpdate = false;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {\r\n\t\r\n\t\t\tvar geometry = object.geometry;\r\n\t\r\n\t\t\tvar result = null;\r\n\t\r\n\t\t\tvar materialVariants = _depthMaterials;\r\n\t\t\tvar customMaterial = object.customDepthMaterial;\r\n\t\r\n\t\t\tif ( isPointLight ) {\r\n\t\r\n\t\t\t\tmaterialVariants = _distanceMaterials;\r\n\t\t\t\tcustomMaterial = object.customDistanceMaterial;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( ! customMaterial ) {\r\n\t\r\n\t\t\t\tvar useMorphing = geometry.morphTargets !== undefined &&\r\n\t\t\t\t\t\tgeometry.morphTargets.length > 0 && material.morphTargets;\r\n\t\r\n\t\t\t\tvar useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;\r\n\t\r\n\t\t\t\tvar variantIndex = 0;\r\n\t\r\n\t\t\t\tif ( useMorphing ) variantIndex |= _MorphingFlag;\r\n\t\t\t\tif ( useSkinning ) variantIndex |= _SkinningFlag;\r\n\t\r\n\t\t\t\tresult = materialVariants[ variantIndex ];\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tresult = customMaterial;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( _renderer.localClippingEnabled &&\r\n\t\t\t\t material.clipShadows === true &&\r\n\t\t\t\t\tmaterial.clippingPlanes.length !== 0 ) {\r\n\t\r\n\t\t\t\t// in this case we need a unique material instance reflecting the\r\n\t\t\t\t// appropriate state\r\n\t\r\n\t\t\t\tvar keyA = result.uuid, keyB = material.uuid;\r\n\t\r\n\t\t\t\tvar materialsForVariant = _materialCache[ keyA ];\r\n\t\r\n\t\t\t\tif ( materialsForVariant === undefined ) {\r\n\t\r\n\t\t\t\t\tmaterialsForVariant = {};\r\n\t\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar cachedMaterial = materialsForVariant[ keyB ];\r\n\t\r\n\t\t\t\tif ( cachedMaterial === undefined ) {\r\n\t\r\n\t\t\t\t\tcachedMaterial = result.clone();\r\n\t\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tresult = cachedMaterial;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tresult.visible = material.visible;\r\n\t\t\tresult.wireframe = material.wireframe;\r\n\t\r\n\t\t\tvar side = material.side;\r\n\t\r\n\t\t\tif ( scope.renderSingleSided && side == THREE.DoubleSide ) {\r\n\t\r\n\t\t\t\tside = THREE.FrontSide;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( scope.renderReverseSided ) {\r\n\t\r\n\t\t\t\tif ( side === THREE.FrontSide ) side = THREE.BackSide;\r\n\t\t\t\telse if ( side === THREE.BackSide ) side = THREE.FrontSide;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tresult.side = side;\r\n\t\r\n\t\t\tresult.clipShadows = material.clipShadows;\r\n\t\t\tresult.clippingPlanes = material.clippingPlanes;\r\n\t\r\n\t\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\r\n\t\t\tresult.linewidth = material.linewidth;\r\n\t\r\n\t\t\tif ( isPointLight && result.uniforms.lightPos !== undefined ) {\r\n\t\r\n\t\t\t\tresult.uniforms.lightPos.value.copy( lightPositionWorld );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn result;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction projectObject( object, camera, shadowCamera ) {\r\n\t\r\n\t\t\tif ( object.visible === false ) return;\r\n\t\r\n\t\t\tif ( object.layers.test( camera.layers ) && ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) ) {\r\n\t\r\n\t\t\t\tif ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {\r\n\t\r\n\t\t\t\t\tvar material = object.material;\r\n\t\r\n\t\t\t\t\tif ( material.visible === true ) {\r\n\t\r\n\t\t\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\r\n\t\t\t\t\t\t_renderList.push( object );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar children = object.children;\r\n\t\r\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tprojectObject( children[ i ], camera, shadowCamera );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLState.js\r\n\t\r\n\t/**\r\n\t* @author mrdoob / http://mrdoob.com/\r\n\t*/\r\n\t\r\n\tTHREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {\r\n\t\r\n\t\tvar _this = this;\r\n\t\r\n\t\tthis.buffers = {\r\n\t\t\tcolor: new THREE.WebGLColorBuffer( gl, this ),\r\n\t\t\tdepth: new THREE.WebGLDepthBuffer( gl, this ),\r\n\t\t\tstencil: new THREE.WebGLStencilBuffer( gl, this )\r\n\t\t};\r\n\t\r\n\t\tvar maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\r\n\t\tvar newAttributes = new Uint8Array( maxVertexAttributes );\r\n\t\tvar enabledAttributes = new Uint8Array( maxVertexAttributes );\r\n\t\tvar attributeDivisors = new Uint8Array( maxVertexAttributes );\r\n\t\r\n\t\tvar capabilities = {};\r\n\t\r\n\t\tvar compressedTextureFormats = null;\r\n\t\r\n\t\tvar currentBlending = null;\r\n\t\tvar currentBlendEquation = null;\r\n\t\tvar currentBlendSrc = null;\r\n\t\tvar currentBlendDst = null;\r\n\t\tvar currentBlendEquationAlpha = null;\r\n\t\tvar currentBlendSrcAlpha = null;\r\n\t\tvar currentBlendDstAlpha = null;\r\n\t\tvar currentPremultipledAlpha = false;\r\n\t\r\n\t\tvar currentFlipSided = null;\r\n\t\tvar currentCullFace = null;\r\n\t\r\n\t\tvar currentLineWidth = null;\r\n\t\r\n\t\tvar currentPolygonOffsetFactor = null;\r\n\t\tvar currentPolygonOffsetUnits = null;\r\n\t\r\n\t\tvar currentScissorTest = null;\r\n\t\r\n\t\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\r\n\t\r\n\t\tvar currentTextureSlot = null;\r\n\t\tvar currentBoundTextures = {};\r\n\t\r\n\t\tvar currentScissor = new THREE.Vector4();\r\n\t\tvar currentViewport = new THREE.Vector4();\r\n\t\r\n\t\tfunction createTexture( type, target, count ) {\r\n\t\r\n\t\t\tvar data = new Uint8Array( 3 );\r\n\t\t\tvar texture = gl.createTexture();\r\n\t\r\n\t\t\tgl.bindTexture( type, texture );\r\n\t\t\tgl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\r\n\t\t\tgl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\r\n\t\r\n\t\t\tfor ( var i = 0; i < count; i ++ ) {\r\n\t\r\n\t\t\t\tgl.texImage2D( target + i, 0, gl.RGB, 1, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, data );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar emptyTextures = {};\r\n\t\temptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );\r\n\t\temptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );\r\n\t\r\n\t\t//\r\n\t\r\n\t\tthis.init = function () {\r\n\t\r\n\t\t\tthis.clearColor( 0, 0, 0, 1 );\r\n\t\t\tthis.clearDepth( 1 );\r\n\t\t\tthis.clearStencil( 0 );\r\n\t\r\n\t\t\tthis.enable( gl.DEPTH_TEST );\r\n\t\t\tthis.setDepthFunc( THREE.LessEqualDepth );\r\n\t\r\n\t\t\tthis.setFlipSided( false );\r\n\t\t\tthis.setCullFace( THREE.CullFaceBack );\r\n\t\t\tthis.enable( gl.CULL_FACE );\r\n\t\r\n\t\t\tthis.enable( gl.BLEND );\r\n\t\t\tthis.setBlending( THREE.NormalBlending );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.initAttributes = function () {\r\n\t\r\n\t\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tnewAttributes[ i ] = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.enableAttribute = function ( attribute ) {\r\n\t\r\n\t\t\tnewAttributes[ attribute ] = 1;\r\n\t\r\n\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\r\n\t\r\n\t\t\t\tgl.enableVertexAttribArray( attribute );\r\n\t\t\t\tenabledAttributes[ attribute ] = 1;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( attributeDivisors[ attribute ] !== 0 ) {\r\n\t\r\n\t\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\t\r\n\t\t\t\textension.vertexAttribDivisorANGLE( attribute, 0 );\r\n\t\t\t\tattributeDivisors[ attribute ] = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.enableAttributeAndDivisor = function ( attribute, meshPerAttribute, extension ) {\r\n\t\r\n\t\t\tnewAttributes[ attribute ] = 1;\r\n\t\r\n\t\t\tif ( enabledAttributes[ attribute ] === 0 ) {\r\n\t\r\n\t\t\t\tgl.enableVertexAttribArray( attribute );\r\n\t\t\t\tenabledAttributes[ attribute ] = 1;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\r\n\t\r\n\t\t\t\textension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );\r\n\t\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.disableUnusedAttributes = function () {\r\n\t\r\n\t\t\tfor ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {\r\n\t\r\n\t\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\r\n\t\r\n\t\t\t\t\tgl.disableVertexAttribArray( i );\r\n\t\t\t\t\tenabledAttributes[ i ] = 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.enable = function ( id ) {\r\n\t\r\n\t\t\tif ( capabilities[ id ] !== true ) {\r\n\t\r\n\t\t\t\tgl.enable( id );\r\n\t\t\t\tcapabilities[ id ] = true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.disable = function ( id ) {\r\n\t\r\n\t\t\tif ( capabilities[ id ] !== false ) {\r\n\t\r\n\t\t\t\tgl.disable( id );\r\n\t\t\t\tcapabilities[ id ] = false;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getCompressedTextureFormats = function () {\r\n\t\r\n\t\t\tif ( compressedTextureFormats === null ) {\r\n\t\r\n\t\t\t\tcompressedTextureFormats = [];\r\n\t\r\n\t\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\r\n\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\r\n\t\t\t\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {\r\n\t\r\n\t\t\t\t\tvar formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\r\n\t\r\n\t\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\r\n\t\r\n\t\t\t\t\t\tcompressedTextureFormats.push( formats[ i ] );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn compressedTextureFormats;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\r\n\t\r\n\t\t\tif ( blending !== THREE.NoBlending ) {\r\n\t\r\n\t\t\t\tthis.enable( gl.BLEND );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.disable( gl.BLEND );\r\n\t\t\t\tcurrentBlending = blending; // no blending, that is\r\n\t\t\t\treturn;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\r\n\t\r\n\t\t\t\tif ( blending === THREE.AdditiveBlending ) {\r\n\t\r\n\t\t\t\t\tif ( premultipliedAlpha ) {\r\n\t\r\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( blending === THREE.SubtractiveBlending ) {\r\n\t\r\n\t\t\t\t\tif ( premultipliedAlpha ) {\r\n\t\r\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else if ( blending === THREE.MultiplyBlending ) {\r\n\t\r\n\t\t\t\t\tif ( premultipliedAlpha ) {\r\n\t\r\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tif ( premultipliedAlpha ) {\r\n\t\r\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tcurrentBlending = blending;\r\n\t\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( blending === THREE.CustomBlending ) {\r\n\t\r\n\t\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\r\n\t\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\r\n\t\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\r\n\t\r\n\t\t\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\r\n\t\r\n\t\t\t\t\tgl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );\r\n\t\r\n\t\t\t\t\tcurrentBlendEquation = blendEquation;\r\n\t\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\r\n\t\r\n\t\t\t\t\tgl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );\r\n\t\r\n\t\t\t\t\tcurrentBlendSrc = blendSrc;\r\n\t\t\t\t\tcurrentBlendDst = blendDst;\r\n\t\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\r\n\t\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tcurrentBlendEquation = null;\r\n\t\t\t\tcurrentBlendSrc = null;\r\n\t\t\t\tcurrentBlendDst = null;\r\n\t\t\t\tcurrentBlendEquationAlpha = null;\r\n\t\t\t\tcurrentBlendSrcAlpha = null;\r\n\t\t\t\tcurrentBlendDstAlpha = null;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// TODO Deprecate\r\n\t\r\n\t\tthis.setColorWrite = function ( colorWrite ) {\r\n\t\r\n\t\t\tthis.buffers.color.setMask( colorWrite );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setDepthTest = function ( depthTest ) {\r\n\t\r\n\t\t\tthis.buffers.depth.setTest( depthTest );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setDepthWrite = function ( depthWrite ) {\r\n\t\r\n\t\t\tthis.buffers.depth.setMask( depthWrite );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setDepthFunc = function ( depthFunc ) {\r\n\t\r\n\t\t\tthis.buffers.depth.setFunc( depthFunc );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setStencilTest = function ( stencilTest ) {\r\n\t\r\n\t\t\tthis.buffers.stencil.setTest( stencilTest );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setStencilWrite = function ( stencilWrite ) {\r\n\t\r\n\t\t\tthis.buffers.stencil.setMask( stencilWrite );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setStencilFunc = function ( stencilFunc, stencilRef, stencilMask ) {\r\n\t\r\n\t\t\tthis.buffers.stencil.setFunc( stencilFunc, stencilRef, stencilMask );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setStencilOp = function ( stencilFail, stencilZFail, stencilZPass ) {\r\n\t\r\n\t\t\tthis.buffers.stencil.setOp( stencilFail, stencilZFail, stencilZPass );\r\n\t\r\n\t\t};\r\n\t\r\n\t\t//\r\n\t\r\n\t\tthis.setFlipSided = function ( flipSided ) {\r\n\t\r\n\t\t\tif ( currentFlipSided !== flipSided ) {\r\n\t\r\n\t\t\t\tif ( flipSided ) {\r\n\t\r\n\t\t\t\t\tgl.frontFace( gl.CW );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tgl.frontFace( gl.CCW );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tcurrentFlipSided = flipSided;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setCullFace = function ( cullFace ) {\r\n\t\r\n\t\t\tif ( cullFace !== THREE.CullFaceNone ) {\r\n\t\r\n\t\t\t\tthis.enable( gl.CULL_FACE );\r\n\t\r\n\t\t\t\tif ( cullFace !== currentCullFace ) {\r\n\t\r\n\t\t\t\t\tif ( cullFace === THREE.CullFaceBack ) {\r\n\t\r\n\t\t\t\t\t\tgl.cullFace( gl.BACK );\r\n\t\r\n\t\t\t\t\t} else if ( cullFace === THREE.CullFaceFront ) {\r\n\t\r\n\t\t\t\t\t\tgl.cullFace( gl.FRONT );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tgl.cullFace( gl.FRONT_AND_BACK );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.disable( gl.CULL_FACE );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tcurrentCullFace = cullFace;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setLineWidth = function ( width ) {\r\n\t\r\n\t\t\tif ( width !== currentLineWidth ) {\r\n\t\r\n\t\t\t\tgl.lineWidth( width );\r\n\t\r\n\t\t\t\tcurrentLineWidth = width;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setPolygonOffset = function ( polygonOffset, factor, units ) {\r\n\t\r\n\t\t\tif ( polygonOffset ) {\r\n\t\r\n\t\t\t\tthis.enable( gl.POLYGON_OFFSET_FILL );\r\n\t\r\n\t\t\t\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\r\n\t\r\n\t\t\t\t\tgl.polygonOffset( factor, units );\r\n\t\r\n\t\t\t\t\tcurrentPolygonOffsetFactor = factor;\r\n\t\t\t\t\tcurrentPolygonOffsetUnits = units;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.disable( gl.POLYGON_OFFSET_FILL );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.getScissorTest = function () {\r\n\t\r\n\t\t\treturn currentScissorTest;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setScissorTest = function ( scissorTest ) {\r\n\t\r\n\t\t\tcurrentScissorTest = scissorTest;\r\n\t\r\n\t\t\tif ( scissorTest ) {\r\n\t\r\n\t\t\t\tthis.enable( gl.SCISSOR_TEST );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.disable( gl.SCISSOR_TEST );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// texture\r\n\t\r\n\t\tthis.activeTexture = function ( webglSlot ) {\r\n\t\r\n\t\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\r\n\t\r\n\t\t\tif ( currentTextureSlot !== webglSlot ) {\r\n\t\r\n\t\t\t\tgl.activeTexture( webglSlot );\r\n\t\t\t\tcurrentTextureSlot = webglSlot;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.bindTexture = function ( webglType, webglTexture ) {\r\n\t\r\n\t\t\tif ( currentTextureSlot === null ) {\r\n\t\r\n\t\t\t\t_this.activeTexture();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\r\n\t\r\n\t\t\tif ( boundTexture === undefined ) {\r\n\t\r\n\t\t\t\tboundTexture = { type: undefined, texture: undefined };\r\n\t\t\t\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\r\n\t\r\n\t\t\t\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\r\n\t\r\n\t\t\t\tboundTexture.type = webglType;\r\n\t\t\t\tboundTexture.texture = webglTexture;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.compressedTexImage2D = function () {\r\n\t\r\n\t\t\ttry {\r\n\t\r\n\t\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\r\n\t\r\n\t\t\t} catch ( error ) {\r\n\t\r\n\t\t\t\tconsole.error( error );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.texImage2D = function () {\r\n\t\r\n\t\t\ttry {\r\n\t\r\n\t\t\t\tgl.texImage2D.apply( gl, arguments );\r\n\t\r\n\t\t\t} catch ( error ) {\r\n\t\r\n\t\t\t\tconsole.error( error );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// TODO Deprecate\r\n\t\r\n\t\tthis.clearColor = function ( r, g, b, a ) {\r\n\t\r\n\t\t\tthis.buffers.color.setClear( r, g, b, a );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clearDepth = function ( depth ) {\r\n\t\r\n\t\t\tthis.buffers.depth.setClear( depth );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.clearStencil = function ( stencil ) {\r\n\t\r\n\t\t\tthis.buffers.stencil.setClear( stencil );\r\n\t\r\n\t\t};\r\n\t\r\n\t\t//\r\n\t\r\n\t\tthis.scissor = function ( scissor ) {\r\n\t\r\n\t\t\tif ( currentScissor.equals( scissor ) === false ) {\r\n\t\r\n\t\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\r\n\t\t\t\tcurrentScissor.copy( scissor );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.viewport = function ( viewport ) {\r\n\t\r\n\t\t\tif ( currentViewport.equals( viewport ) === false ) {\r\n\t\r\n\t\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\r\n\t\t\t\tcurrentViewport.copy( viewport );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\t//\r\n\t\r\n\t\tthis.reset = function () {\r\n\t\r\n\t\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\r\n\t\r\n\t\t\t\tif ( enabledAttributes[ i ] === 1 ) {\r\n\t\r\n\t\t\t\t\tgl.disableVertexAttribArray( i );\r\n\t\t\t\t\tenabledAttributes[ i ] = 0;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tcapabilities = {};\r\n\t\r\n\t\t\tcompressedTextureFormats = null;\r\n\t\r\n\t\t\tcurrentTextureSlot = null;\r\n\t\t\tcurrentBoundTextures = {};\r\n\t\r\n\t\t\tcurrentBlending = null;\r\n\t\r\n\t\t\tcurrentFlipSided = null;\r\n\t\t\tcurrentCullFace = null;\r\n\t\r\n\t\t\tthis.buffers.color.reset();\r\n\t\t\tthis.buffers.depth.reset();\r\n\t\t\tthis.buffers.stencil.reset();\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.WebGLColorBuffer = function ( gl, state ) {\r\n\t\r\n\t\tvar locked = false;\r\n\t\r\n\t\tvar color = new THREE.Vector4();\r\n\t\tvar currentColorMask = null;\r\n\t\tvar currentColorClear = new THREE.Vector4();\r\n\t\r\n\t\tthis.setMask = function ( colorMask ) {\r\n\t\r\n\t\t\tif ( currentColorMask !== colorMask && ! locked ) {\r\n\t\r\n\t\t\t\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\r\n\t\t\t\tcurrentColorMask = colorMask;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setLocked = function ( lock ) {\r\n\t\r\n\t\t\tlocked = lock;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setClear = function ( r, g, b, a ) {\r\n\t\r\n\t\t\tcolor.set( r, g, b, a );\r\n\t\r\n\t\t\tif ( currentColorClear.equals( color ) === false ) {\r\n\t\r\n\t\t\t\tgl.clearColor( r, g, b, a );\r\n\t\t\t\tcurrentColorClear.copy( color );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.reset = function () {\r\n\t\r\n\t\t\tlocked = false;\r\n\t\r\n\t\t\tcurrentColorMask = null;\r\n\t\t\tcurrentColorClear = new THREE.Vector4();\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.WebGLDepthBuffer = function( gl, state ) {\r\n\t\r\n\t\tvar locked = false;\r\n\t\r\n\t\tvar currentDepthMask = null;\r\n\t\tvar currentDepthFunc = null;\r\n\t\tvar currentDepthClear = null;\r\n\t\r\n\t\tthis.setTest = function ( depthTest ) {\r\n\t\r\n\t\t\tif ( depthTest ) {\r\n\t\r\n\t\t\t\tstate.enable( gl.DEPTH_TEST );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tstate.disable( gl.DEPTH_TEST );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setMask = function( depthMask ){\r\n\t\r\n\t\t\tif ( currentDepthMask !== depthMask && ! locked ) {\r\n\t\r\n\t\t\t\tgl.depthMask( depthMask );\r\n\t\t\t\tcurrentDepthMask = depthMask;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setFunc = function ( depthFunc ) {\r\n\t\r\n\t\t\tif ( currentDepthFunc !== depthFunc ) {\r\n\t\r\n\t\t\t\tif ( depthFunc ) {\r\n\t\r\n\t\t\t\t\tswitch ( depthFunc ) {\r\n\t\r\n\t\t\t\t\t\tcase THREE.NeverDepth:\r\n\t\r\n\t\t\t\t\t\t\tgl.depthFunc( gl.NEVER );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase THREE.AlwaysDepth:\r\n\t\r\n\t\t\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase THREE.LessDepth:\r\n\t\r\n\t\t\t\t\t\t\tgl.depthFunc( gl.LESS );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase THREE.LessEqualDepth:\r\n\t\r\n\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase THREE.EqualDepth:\r\n\t\r\n\t\t\t\t\t\t\tgl.depthFunc( gl.EQUAL );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase THREE.GreaterEqualDepth:\r\n\t\r\n\t\t\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase THREE.GreaterDepth:\r\n\t\r\n\t\t\t\t\t\t\tgl.depthFunc( gl.GREATER );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tcase THREE.NotEqualDepth:\r\n\t\r\n\t\t\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\r\n\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\tdefault:\r\n\t\r\n\t\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tcurrentDepthFunc = depthFunc;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setLocked = function ( lock ) {\r\n\t\r\n\t\t\tlocked = lock;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setClear = function ( depth ) {\r\n\t\r\n\t\t\tif ( currentDepthClear !== depth ) {\r\n\t\r\n\t\t\t\tgl.clearDepth( depth );\r\n\t\t\t\tcurrentDepthClear = depth;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.reset = function () {\r\n\t\r\n\t\t\tlocked = false;\r\n\t\r\n\t\t\tcurrentDepthMask = null;\r\n\t\t\tcurrentDepthFunc = null;\r\n\t\t\tcurrentDepthClear = null;\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.WebGLStencilBuffer = function ( gl, state ) {\r\n\t\r\n\t\tvar locked = false;\r\n\t\r\n\t\tvar currentStencilMask = null;\r\n\t\tvar currentStencilFunc = null;\r\n\t\tvar currentStencilRef = null;\r\n\t\tvar currentStencilFuncMask = null;\r\n\t\tvar currentStencilFail  = null;\r\n\t\tvar currentStencilZFail = null;\r\n\t\tvar currentStencilZPass = null;\r\n\t\tvar currentStencilClear = null;\r\n\t\r\n\t\tthis.setTest = function ( stencilTest ) {\r\n\t\r\n\t\t\tif ( stencilTest ) {\r\n\t\r\n\t\t\t\tstate.enable( gl.STENCIL_TEST );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tstate.disable( gl.STENCIL_TEST );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setMask = function ( stencilMask ) {\r\n\t\r\n\t\t\tif ( currentStencilMask !== stencilMask && ! locked ) {\r\n\t\r\n\t\t\t\tgl.stencilMask( stencilMask );\r\n\t\t\t\tcurrentStencilMask = stencilMask;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setFunc = function ( stencilFunc, stencilRef, stencilMask ) {\r\n\t\r\n\t\t\tif ( currentStencilFunc !== stencilFunc ||\r\n\t\t\t     currentStencilRef \t!== stencilRef \t||\r\n\t\t\t     currentStencilFuncMask !== stencilMask ) {\r\n\t\r\n\t\t\t\tgl.stencilFunc( stencilFunc,  stencilRef, stencilMask );\r\n\t\r\n\t\t\t\tcurrentStencilFunc = stencilFunc;\r\n\t\t\t\tcurrentStencilRef  = stencilRef;\r\n\t\t\t\tcurrentStencilFuncMask = stencilMask;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setOp\t = function ( stencilFail, stencilZFail, stencilZPass ) {\r\n\t\r\n\t\t\tif ( currentStencilFail\t !== stencilFail \t||\r\n\t\t\t     currentStencilZFail !== stencilZFail ||\r\n\t\t\t     currentStencilZPass !== stencilZPass ) {\r\n\t\r\n\t\t\t\tgl.stencilOp( stencilFail,  stencilZFail, stencilZPass );\r\n\t\r\n\t\t\t\tcurrentStencilFail  = stencilFail;\r\n\t\t\t\tcurrentStencilZFail = stencilZFail;\r\n\t\t\t\tcurrentStencilZPass = stencilZPass;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setLocked = function ( lock ) {\r\n\t\r\n\t\t\tlocked = lock;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.setClear = function ( stencil ) {\r\n\t\r\n\t\t\tif ( currentStencilClear !== stencil ) {\r\n\t\r\n\t\t\t\tgl.clearStencil( stencil );\r\n\t\t\t\tcurrentStencilClear = stencil;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.reset = function () {\r\n\t\r\n\t\t\tlocked = false;\r\n\t\r\n\t\t\tcurrentStencilMask = null;\r\n\t\t\tcurrentStencilFunc = null;\r\n\t\t\tcurrentStencilRef = null;\r\n\t\t\tcurrentStencilFuncMask = null;\r\n\t\t\tcurrentStencilFail = null;\r\n\t\t\tcurrentStencilZFail = null;\r\n\t\t\tcurrentStencilZPass = null;\r\n\t\t\tcurrentStencilClear = null;\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/WebGLUniforms.js\r\n\t\r\n\t/**\r\n\t *\r\n\t * Uniforms of a program.\r\n\t * Those form a tree structure with a special top-level container for the root,\r\n\t * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.\r\n\t *\r\n\t *\r\n\t * Properties of inner nodes including the top-level container:\r\n\t *\r\n\t * .seq - array of nested uniforms\r\n\t * .map - nested uniforms by name\r\n\t *\r\n\t *\r\n\t * Methods of all nodes except the top-level container:\r\n\t *\r\n\t * .setValue( gl, value, [renderer] )\r\n\t *\r\n\t * \t\tuploads a uniform value(s)\r\n\t *  \tthe 'renderer' parameter is needed for sampler uniforms\r\n\t *\r\n\t *\r\n\t * Static methods of the top-level container (renderer factorizations):\r\n\t *\r\n\t * .upload( gl, seq, values, renderer )\r\n\t *\r\n\t * \t\tsets uniforms in 'seq' to 'values[id].value'\r\n\t *\r\n\t * .seqWithValue( seq, values ) : filteredSeq\r\n\t *\r\n\t * \t\tfilters 'seq' entries with corresponding entry in values\r\n\t *\r\n\t * .splitDynamic( seq, values ) : filteredSeq\r\n\t *\r\n\t * \t\tfilters 'seq' entries with dynamic entry and removes them from 'seq'\r\n\t *\r\n\t *\r\n\t * Methods of the top-level container (renderer factorizations):\r\n\t *\r\n\t * .setValue( gl, name, value )\r\n\t *\r\n\t * \t\tsets uniform with  name 'name' to 'value'\r\n\t *\r\n\t * .set( gl, obj, prop )\r\n\t *\r\n\t * \t\tsets uniform from object and property with same name than uniform\r\n\t *\r\n\t * .setOptional( gl, obj, prop )\r\n\t *\r\n\t * \t\tlike .set for an optional property of the object\r\n\t *\r\n\t *\r\n\t * @author tschw\r\n\t *\r\n\t */\r\n\t\r\n\tTHREE.WebGLUniforms = ( function() { // scope\r\n\t\r\n\t\t// --- Base for inner nodes (including the root) ---\r\n\t\r\n\t\tvar UniformContainer = function() {\r\n\t\r\n\t\t\t\tthis.seq = [];\r\n\t\t\t\tthis.map = {};\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t// --- Utilities ---\r\n\t\r\n\t\t// Array Caches (provide typed arrays for temporary by size)\r\n\t\r\n\t\t\tarrayCacheF32 = [],\r\n\t\t\tarrayCacheI32 = [],\r\n\t\r\n\t\t\tuncacheTemporaryArrays = function() {\r\n\t\r\n\t\t\t\tarrayCacheF32.length = 0;\r\n\t\t\t\tarrayCacheI32.length = 0;\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t// Flattening for arrays of vectors and matrices\r\n\t\r\n\t\t\tflatten = function( array, nBlocks, blockSize ) {\r\n\t\r\n\t\t\t\tvar firstElem = array[ 0 ];\r\n\t\r\n\t\t\t\tif ( firstElem <= 0 || firstElem > 0 ) return array;\r\n\t\t\t\t// unoptimized: ! isNaN( firstElem )\r\n\t\t\t\t// see http://jacksondunstan.com/articles/983\r\n\t\r\n\t\t\t\tvar n = nBlocks * blockSize,\r\n\t\t\t\t\tr = arrayCacheF32[ n ];\r\n\t\r\n\t\t\t\tif ( r === undefined ) {\r\n\t\r\n\t\t\t\t\tr = new Float32Array( n );\r\n\t\t\t\t\tarrayCacheF32[ n ] = r;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( nBlocks !== 0 ) {\r\n\t\r\n\t\t\t\t\tfirstElem.toArray( r, 0 );\r\n\t\r\n\t\t\t\t\tfor ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\r\n\t\r\n\t\t\t\t\t\toffset += blockSize;\r\n\t\t\t\t\t\tarray[ i ].toArray( r, offset );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn r;\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t// Texture unit allocation\r\n\t\r\n\t\t\tallocTexUnits = function( renderer, n ) {\r\n\t\r\n\t\t\t\tvar r = arrayCacheI32[ n ];\r\n\t\r\n\t\t\t\tif ( r === undefined ) {\r\n\t\r\n\t\t\t\t\tr = new Int32Array( n );\r\n\t\t\t\t\tarrayCacheI32[ n ] = r;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var i = 0; i !== n; ++ i )\r\n\t\t\t\t\tr[ i ] = renderer.allocTextureUnit();\r\n\t\r\n\t\t\t\treturn r;\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t// --- Setters ---\r\n\t\r\n\t\t// Note: Defining these methods externally, because they come in a bunch\r\n\t\t// and this way their names minify.\r\n\t\r\n\t\t\t// Single scalar\r\n\t\r\n\t\t\tsetValue1f = function( gl, v ) { gl.uniform1f( this.addr, v ); },\r\n\t\t\tsetValue1i = function( gl, v ) { gl.uniform1i( this.addr, v ); },\r\n\t\r\n\t\t\t// Single float vector (from flat array or THREE.VectorN)\r\n\t\r\n\t\t\tsetValue2fv = function( gl, v ) {\r\n\t\r\n\t\t\t\tif ( v.x === undefined ) gl.uniform2fv( this.addr, v );\r\n\t\t\t\telse gl.uniform2f( this.addr, v.x, v.y );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tsetValue3fv = function( gl, v ) {\r\n\t\r\n\t\t\t\tif ( v.x !== undefined )\r\n\t\t\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\r\n\t\t\t\telse if ( v.r !== undefined )\r\n\t\t\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\r\n\t\t\t\telse\r\n\t\t\t\t\tgl.uniform3fv( this.addr, v );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tsetValue4fv = function( gl, v ) {\r\n\t\r\n\t\t\t\tif ( v.x === undefined ) gl.uniform4fv( this.addr, v );\r\n\t\t\t\telse gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\t// Single matrix (from flat array or MatrixN)\r\n\t\r\n\t\t\tsetValue2fm = function( gl, v ) {\r\n\t\r\n\t\t\t\tgl.uniformMatrix2fv( this.addr, false, v.elements || v );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tsetValue3fm = function( gl, v ) {\r\n\t\r\n\t\t\t\tgl.uniformMatrix3fv( this.addr, false, v.elements || v );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tsetValue4fm = function( gl, v ) {\r\n\t\r\n\t\t\t\tgl.uniformMatrix4fv( this.addr, false, v.elements || v );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\t// Single texture (2D / Cube)\r\n\t\r\n\t\t\tsetValueT1 = function( gl, v, renderer ) {\r\n\t\r\n\t\t\t\tvar unit = renderer.allocTextureUnit();\r\n\t\t\t\tgl.uniform1i( this.addr, unit );\r\n\t\t\t\tif ( v ) renderer.setTexture2D( v, unit );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tsetValueT6 = function( gl, v, renderer ) {\r\n\t\r\n\t\t\t\tvar unit = renderer.allocTextureUnit();\r\n\t\t\t\tgl.uniform1i( this.addr, unit );\r\n\t\t\t\tif ( v ) renderer.setTextureCube( v, unit );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\t// Integer / Boolean vectors or arrays thereof (always flat arrays)\r\n\t\r\n\t\t\tsetValue2iv = function( gl, v ) { gl.uniform2iv( this.addr, v ); },\r\n\t\t\tsetValue3iv = function( gl, v ) { gl.uniform3iv( this.addr, v ); },\r\n\t\t\tsetValue4iv = function( gl, v ) { gl.uniform4iv( this.addr, v ); },\r\n\t\r\n\t\t\t// Helper to pick the right setter for the singular case\r\n\t\r\n\t\t\tgetSingularSetter = function( type ) {\r\n\t\r\n\t\t\t\tswitch ( type ) {\r\n\t\r\n\t\t\t\t\tcase 0x1406: return setValue1f; // FLOAT\r\n\t\t\t\t\tcase 0x8b50: return setValue2fv; // _VEC2\r\n\t\t\t\t\tcase 0x8b51: return setValue3fv; // _VEC3\r\n\t\t\t\t\tcase 0x8b52: return setValue4fv; // _VEC4\r\n\t\r\n\t\t\t\t\tcase 0x8b5a: return setValue2fm; // _MAT2\r\n\t\t\t\t\tcase 0x8b5b: return setValue3fm; // _MAT3\r\n\t\t\t\t\tcase 0x8b5c: return setValue4fm; // _MAT4\r\n\t\r\n\t\t\t\t\tcase 0x8b5e: return setValueT1; // SAMPLER_2D\r\n\t\t\t\t\tcase 0x8b60: return setValueT6; // SAMPLER_CUBE\r\n\t\r\n\t\t\t\t\tcase 0x1404: case 0x8b56: return setValue1i; // INT, BOOL\r\n\t\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\r\n\t\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\r\n\t\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\t// Array of scalars\r\n\t\r\n\t\t\tsetValue1fv = function( gl, v ) { gl.uniform1fv( this.addr, v ); },\r\n\t\t\tsetValue1iv = function( gl, v ) { gl.uniform1iv( this.addr, v ); },\r\n\t\r\n\t\t\t// Array of vectors (flat or from THREE classes)\r\n\t\r\n\t\t\tsetValueV2a = function( gl, v ) {\r\n\t\r\n\t\t\t\tgl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tsetValueV3a = function( gl, v ) {\r\n\t\r\n\t\t\t\tgl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tsetValueV4a = function( gl, v ) {\r\n\t\r\n\t\t\t\tgl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\t// Array of matrices (flat or from THREE clases)\r\n\t\r\n\t\t\tsetValueM2a = function( gl, v ) {\r\n\t\r\n\t\t\t\tgl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tsetValueM3a = function( gl, v ) {\r\n\t\r\n\t\t\t\tgl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tsetValueM4a = function( gl, v ) {\r\n\t\r\n\t\t\t\tgl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\t// Array of textures (2D / Cube)\r\n\t\r\n\t\t\tsetValueT1a = function( gl, v, renderer ) {\r\n\t\r\n\t\t\t\tvar n = v.length,\r\n\t\t\t\t\tunits = allocTexUnits( renderer, n );\r\n\t\r\n\t\t\t\tgl.uniform1iv( this.addr, units );\r\n\t\r\n\t\t\t\tfor ( var i = 0; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\tvar tex = v[ i ];\r\n\t\t\t\t\tif ( tex ) renderer.setTexture2D( tex, units[ i ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tsetValueT6a = function( gl, v, renderer ) {\r\n\t\r\n\t\t\t\tvar n = v.length,\r\n\t\t\t\t\tunits = allocTexUnits( renderer, n );\r\n\t\r\n\t\t\t\tgl.uniform1iv( this.addr, units );\r\n\t\r\n\t\t\t\tfor ( var i = 0; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\tvar tex = v[ i ];\r\n\t\t\t\t\tif ( tex ) renderer.setTextureCube( tex, units[ i ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\r\n\t\t\t// Helper to pick the right setter for a pure (bottom-level) array\r\n\t\r\n\t\t\tgetPureArraySetter = function( type ) {\r\n\t\r\n\t\t\t\tswitch ( type ) {\r\n\t\r\n\t\t\t\t\tcase 0x1406: return setValue1fv; // FLOAT\r\n\t\t\t\t\tcase 0x8b50: return setValueV2a; // _VEC2\r\n\t\t\t\t\tcase 0x8b51: return setValueV3a; // _VEC3\r\n\t\t\t\t\tcase 0x8b52: return setValueV4a; // _VEC4\r\n\t\r\n\t\t\t\t\tcase 0x8b5a: return setValueM2a; // _MAT2\r\n\t\t\t\t\tcase 0x8b5b: return setValueM3a; // _MAT3\r\n\t\t\t\t\tcase 0x8b5c: return setValueM4a; // _MAT4\r\n\t\r\n\t\t\t\t\tcase 0x8b5e: return setValueT1a; // SAMPLER_2D\r\n\t\t\t\t\tcase 0x8b60: return setValueT6a; // SAMPLER_CUBE\r\n\t\r\n\t\t\t\t\tcase 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL\r\n\t\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\r\n\t\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\r\n\t\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t// --- Uniform Classes ---\r\n\t\r\n\t\t\tSingleUniform = function SingleUniform( id, activeInfo, addr ) {\r\n\t\r\n\t\t\t\tthis.id = id;\r\n\t\t\t\tthis.addr = addr;\r\n\t\t\t\tthis.setValue = getSingularSetter( activeInfo.type );\r\n\t\r\n\t\t\t\t// this.path = activeInfo.name; // DEBUG\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tPureArrayUniform = function( id, activeInfo, addr ) {\r\n\t\r\n\t\t\t\tthis.id = id;\r\n\t\t\t\tthis.addr = addr;\r\n\t\t\t\tthis.size = activeInfo.size;\r\n\t\t\t\tthis.setValue = getPureArraySetter( activeInfo.type );\r\n\t\r\n\t\t\t\t// this.path = activeInfo.name; // DEBUG\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tStructuredUniform = function( id ) {\r\n\t\r\n\t\t\t\tthis.id = id;\r\n\t\r\n\t\t\t\tUniformContainer.call( this ); // mix-in\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\tStructuredUniform.prototype.setValue = function( gl, value ) {\r\n\t\r\n\t\t\t// Note: Don't need an extra 'renderer' parameter, since samplers\r\n\t\t\t// are not allowed in structured uniforms.\r\n\t\r\n\t\t\tvar seq = this.seq;\r\n\t\r\n\t\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tvar u = seq[ i ];\r\n\t\t\t\tu.setValue( gl, value[ u.id ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// --- Top-level ---\r\n\t\r\n\t\t// Parser - builds up the property tree from the path strings\r\n\t\r\n\t\tvar RePathPart = /([\\w\\d_]+)(\\])?(\\[|\\.)?/g,\r\n\t\t\t// extracts\r\n\t\t\t// \t- the identifier (member name or array index)\r\n\t\t\t//  - followed by an optional right bracket (found when array index)\r\n\t\t\t//  - followed by an optional left bracket or dot (type of subscript)\r\n\t\t\t//\r\n\t\t\t// Note: These portions can be read in a non-overlapping fashion and\r\n\t\t\t// allow straightforward parsing of the hierarchy that WebGL encodes\r\n\t\t\t// in the uniform names.\r\n\t\r\n\t\t\taddUniform = function( container, uniformObject ) {\r\n\t\r\n\t\t\t\tcontainer.seq.push( uniformObject );\r\n\t\t\t\tcontainer.map[ uniformObject.id ] = uniformObject;\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tparseUniform = function( activeInfo, addr, container ) {\r\n\t\r\n\t\t\t\tvar path = activeInfo.name,\r\n\t\t\t\t\tpathLength = path.length;\r\n\t\r\n\t\t\t\t// reset RegExp object, because of the early exit of a previous run\r\n\t\t\t\tRePathPart.lastIndex = 0;\r\n\t\r\n\t\t\t\tfor (; ;) {\r\n\t\r\n\t\t\t\t\tvar match = RePathPart.exec( path ),\r\n\t\t\t\t\t\tmatchEnd = RePathPart.lastIndex,\r\n\t\r\n\t\t\t\t\t\tid = match[ 1 ],\r\n\t\t\t\t\t\tidIsIndex = match[ 2 ] === ']',\r\n\t\t\t\t\t\tsubscript = match[ 3 ];\r\n\t\r\n\t\t\t\t\tif ( idIsIndex ) id = id | 0; // convert to integer\r\n\t\r\n\t\t\t\t\tif ( subscript === undefined ||\r\n\t\t\t\t\t\t\tsubscript === '[' && matchEnd + 2 === pathLength ) {\r\n\t\t\t\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\r\n\t\r\n\t\t\t\t\t\taddUniform( container, subscript === undefined ?\r\n\t\t\t\t\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\r\n\t\t\t\t\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\r\n\t\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// step into inner node / create it in case it doesn't exist\r\n\t\r\n\t\t\t\t\t\tvar map = container.map,\r\n\t\t\t\t\t\t\tnext = map[ id ];\r\n\t\r\n\t\t\t\t\t\tif ( next === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\tnext = new StructuredUniform( id );\r\n\t\t\t\t\t\t\taddUniform( container, next );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tcontainer = next;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t// Root Container\r\n\t\r\n\t\t\tWebGLUniforms = function WebGLUniforms( gl, program, renderer ) {\r\n\t\r\n\t\t\t\tUniformContainer.call( this );\r\n\t\r\n\t\t\t\tthis.renderer = renderer;\r\n\t\r\n\t\t\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\r\n\t\r\n\t\t\t\tfor ( var i = 0; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\t\tvar info = gl.getActiveUniform( program, i ),\r\n\t\t\t\t\t\tpath = info.name,\r\n\t\t\t\t\t\taddr = gl.getUniformLocation( program, path );\r\n\t\r\n\t\t\t\t\tparseUniform( info, addr, this );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\r\n\t\tWebGLUniforms.prototype.setValue = function( gl, name, value ) {\r\n\t\r\n\t\t\tvar u = this.map[ name ];\r\n\t\r\n\t\t\tif ( u !== undefined ) u.setValue( gl, value, this.renderer );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tWebGLUniforms.prototype.set = function( gl, object, name ) {\r\n\t\r\n\t\t\tvar u = this.map[ name ];\r\n\t\r\n\t\t\tif ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tWebGLUniforms.prototype.setOptional = function( gl, object, name ) {\r\n\t\r\n\t\t\tvar v = object[ name ];\r\n\t\r\n\t\t\tif ( v !== undefined ) this.setValue( gl, name, v );\r\n\t\r\n\t\t};\r\n\t\r\n\t\r\n\t\t// Static interface\r\n\t\r\n\t\tWebGLUniforms.upload = function( gl, seq, values, renderer ) {\r\n\t\r\n\t\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tvar u = seq[ i ],\r\n\t\t\t\t\tv = values[ u.id ];\r\n\t\r\n\t\t\t\tif ( v.needsUpdate !== false ) {\r\n\t\t\t\t\t// note: always updating when .needsUpdate is undefined\r\n\t\r\n\t\t\t\t\tu.setValue( gl, v.value, renderer );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\tWebGLUniforms.seqWithValue = function( seq, values ) {\r\n\t\r\n\t\t\tvar r = [];\r\n\t\r\n\t\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tvar u = seq[ i ];\r\n\t\t\t\tif ( u.id in values ) r.push( u );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn r;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tWebGLUniforms.splitDynamic = function( seq, values ) {\r\n\t\r\n\t\t\tvar r = null,\r\n\t\t\t\tn = seq.length,\r\n\t\t\t\tw = 0;\r\n\t\r\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tvar u = seq[ i ],\r\n\t\t\t\t\tv = values[ u.id ];\r\n\t\r\n\t\t\t\tif ( v && v.dynamic === true ) {\r\n\t\r\n\t\t\t\t\tif ( r === null ) r = [];\r\n\t\t\t\t\tr.push( u );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// in-place compact 'seq', removing the matches\r\n\t\t\t\t\tif ( w < i ) seq[ w ] = u;\r\n\t\t\t\t\t++ w;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( w < n ) seq.length = w;\r\n\t\r\n\t\t\treturn r;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tWebGLUniforms.evalDynamic = function( seq, values, object, camera ) {\r\n\t\r\n\t\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\r\n\t\r\n\t\t\t\tvar v = values[ seq[ i ].id ],\r\n\t\t\t\t\tf = v.onUpdateCallback;\r\n\t\r\n\t\t\t\tif ( f !== undefined ) f.call( v, object, camera );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t\treturn WebGLUniforms;\r\n\t\r\n\t} )();\r\n\t\r\n\t\r\n\t// File:src/renderers/webgl/plugins/LensFlarePlugin.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.LensFlarePlugin = function ( renderer, flares ) {\r\n\t\r\n\t\tvar gl = renderer.context;\r\n\t\tvar state = renderer.state;\r\n\t\r\n\t\tvar vertexBuffer, elementBuffer;\r\n\t\tvar shader, program, attributes, uniforms;\r\n\t\r\n\t\tvar tempTexture, occlusionTexture;\r\n\t\r\n\t\tfunction init() {\r\n\t\r\n\t\t\tvar vertices = new Float32Array( [\r\n\t\t\t\t- 1, - 1,  0, 0,\r\n\t\t\t\t 1, - 1,  1, 0,\r\n\t\t\t\t 1,  1,  1, 1,\r\n\t\t\t\t- 1,  1,  0, 1\r\n\t\t\t] );\r\n\t\r\n\t\t\tvar faces = new Uint16Array( [\r\n\t\t\t\t0, 1, 2,\r\n\t\t\t\t0, 2, 3\r\n\t\t\t] );\r\n\t\r\n\t\t\t// buffers\r\n\t\r\n\t\t\tvertexBuffer     = gl.createBuffer();\r\n\t\t\telementBuffer    = gl.createBuffer();\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\r\n\t\r\n\t\t\t// textures\r\n\t\r\n\t\t\ttempTexture      = gl.createTexture();\r\n\t\t\tocclusionTexture = gl.createTexture();\r\n\t\r\n\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n\t\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\r\n\t\r\n\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\r\n\t\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\r\n\t\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\r\n\t\r\n\t\t\tshader = {\r\n\t\r\n\t\t\t\tvertexShader: [\r\n\t\r\n\t\t\t\t\t\"uniform lowp int renderType;\",\r\n\t\r\n\t\t\t\t\t\"uniform vec3 screenPosition;\",\r\n\t\t\t\t\t\"uniform vec2 scale;\",\r\n\t\t\t\t\t\"uniform float rotation;\",\r\n\t\r\n\t\t\t\t\t\"uniform sampler2D occlusionMap;\",\r\n\t\r\n\t\t\t\t\t\"attribute vec2 position;\",\r\n\t\t\t\t\t\"attribute vec2 uv;\",\r\n\t\r\n\t\t\t\t\t\"varying vec2 vUV;\",\r\n\t\t\t\t\t\"varying float vVisibility;\",\r\n\t\r\n\t\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\t\t\"vUV = uv;\",\r\n\t\r\n\t\t\t\t\t\t\"vec2 pos = position;\",\r\n\t\r\n\t\t\t\t\t\t\"if ( renderType == 2 ) {\",\r\n\t\r\n\t\t\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\r\n\t\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\r\n\t\r\n\t\t\t\t\t\t\t\"vVisibility =        visibility.r / 9.0;\",\r\n\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.g / 9.0;\",\r\n\t\t\t\t\t\t\t\"vVisibility *=       visibility.b / 9.0;\",\r\n\t\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.a / 9.0;\",\r\n\t\r\n\t\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\r\n\t\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\r\n\t\r\n\t\t\t\t\t\t\"}\",\r\n\t\r\n\t\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\r\n\t\r\n\t\t\t\t\t\"}\"\r\n\t\r\n\t\t\t\t].join( \"\\n\" ),\r\n\t\r\n\t\t\t\tfragmentShader: [\r\n\t\r\n\t\t\t\t\t\"uniform lowp int renderType;\",\r\n\t\r\n\t\t\t\t\t\"uniform sampler2D map;\",\r\n\t\t\t\t\t\"uniform float opacity;\",\r\n\t\t\t\t\t\"uniform vec3 color;\",\r\n\t\r\n\t\t\t\t\t\"varying vec2 vUV;\",\r\n\t\t\t\t\t\"varying float vVisibility;\",\r\n\t\r\n\t\t\t\t\t\"void main() {\",\r\n\t\r\n\t\t\t\t\t\t// pink square\r\n\t\r\n\t\t\t\t\t\t\"if ( renderType == 0 ) {\",\r\n\t\r\n\t\t\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\r\n\t\r\n\t\t\t\t\t\t// restore\r\n\t\r\n\t\t\t\t\t\t\"} else if ( renderType == 1 ) {\",\r\n\t\r\n\t\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\r\n\t\r\n\t\t\t\t\t\t// flare\r\n\t\r\n\t\t\t\t\t\t\"} else {\",\r\n\t\r\n\t\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\r\n\t\t\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\r\n\t\t\t\t\t\t\t\"gl_FragColor = texture;\",\r\n\t\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\r\n\t\r\n\t\t\t\t\t\t\"}\",\r\n\t\r\n\t\t\t\t\t\"}\"\r\n\t\r\n\t\t\t\t].join( \"\\n\" )\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t\tprogram = createProgram( shader );\r\n\t\r\n\t\t\tattributes = {\r\n\t\t\t\tvertex: gl.getAttribLocation ( program, \"position\" ),\r\n\t\t\t\tuv:     gl.getAttribLocation ( program, \"uv\" )\r\n\t\t\t};\r\n\t\r\n\t\t\tuniforms = {\r\n\t\t\t\trenderType:     gl.getUniformLocation( program, \"renderType\" ),\r\n\t\t\t\tmap:            gl.getUniformLocation( program, \"map\" ),\r\n\t\t\t\tocclusionMap:   gl.getUniformLocation( program, \"occlusionMap\" ),\r\n\t\t\t\topacity:        gl.getUniformLocation( program, \"opacity\" ),\r\n\t\t\t\tcolor:          gl.getUniformLocation( program, \"color\" ),\r\n\t\t\t\tscale:          gl.getUniformLocation( program, \"scale\" ),\r\n\t\t\t\trotation:       gl.getUniformLocation( program, \"rotation\" ),\r\n\t\t\t\tscreenPosition: gl.getUniformLocation( program, \"screenPosition\" )\r\n\t\t\t};\r\n\t\r\n\t\t}\r\n\t\r\n\t\t/*\r\n\t\t * Render lens flares\r\n\t\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\r\n\t\t *         reads these back and calculates occlusion.\r\n\t\t */\r\n\t\r\n\t\tthis.render = function ( scene, camera, viewport ) {\r\n\t\r\n\t\t\tif ( flares.length === 0 ) return;\r\n\t\r\n\t\t\tvar tempPosition = new THREE.Vector3();\r\n\t\r\n\t\t\tvar invAspect = viewport.w / viewport.z,\r\n\t\t\t\thalfViewportWidth = viewport.z * 0.5,\r\n\t\t\t\thalfViewportHeight = viewport.w * 0.5;\r\n\t\r\n\t\t\tvar size = 16 / viewport.w,\r\n\t\t\t\tscale = new THREE.Vector2( size * invAspect, size );\r\n\t\r\n\t\t\tvar screenPosition = new THREE.Vector3( 1, 1, 0 ),\r\n\t\t\t\tscreenPositionPixels = new THREE.Vector2( 1, 1 );\r\n\t\r\n\t\t\tvar validArea = new THREE.Box2();\r\n\t\r\n\t\t\tvalidArea.min.set( 0, 0 );\r\n\t\t\tvalidArea.max.set( viewport.z - 16, viewport.w - 16 );\r\n\t\r\n\t\t\tif ( program === undefined ) {\r\n\t\r\n\t\t\t\tinit();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgl.useProgram( program );\r\n\t\r\n\t\t\tstate.initAttributes();\r\n\t\t\tstate.enableAttribute( attributes.vertex );\r\n\t\t\tstate.enableAttribute( attributes.uv );\r\n\t\t\tstate.disableUnusedAttributes();\r\n\t\r\n\t\t\t// loop through all lens flares to update their occlusion and positions\r\n\t\t\t// setup gl and common used attribs/uniforms\r\n\t\r\n\t\t\tgl.uniform1i( uniforms.occlusionMap, 0 );\r\n\t\t\tgl.uniform1i( uniforms.map, 1 );\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\t\tgl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\r\n\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\r\n\t\t\tstate.disable( gl.CULL_FACE );\r\n\t\t\tstate.setDepthWrite( false );\r\n\t\r\n\t\t\tfor ( var i = 0, l = flares.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tsize = 16 / viewport.w;\r\n\t\t\t\tscale.set( size * invAspect, size );\r\n\t\r\n\t\t\t\t// calc object screen position\r\n\t\r\n\t\t\t\tvar flare = flares[ i ];\r\n\t\r\n\t\t\t\ttempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );\r\n\t\r\n\t\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\r\n\t\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\r\n\t\r\n\t\t\t\t// setup arrays for gl programs\r\n\t\r\n\t\t\t\tscreenPosition.copy( tempPosition );\r\n\t\r\n\t\t\t\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\r\n\t\r\n\t\t\t\tscreenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;\r\n\t\t\t\tscreenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;\r\n\t\r\n\t\t\t\t// screen cull\r\n\t\r\n\t\t\t\tif ( validArea.containsPoint( screenPositionPixels ) === true ) {\r\n\t\r\n\t\t\t\t\t// save current RGB to temp texture\r\n\t\r\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\r\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, null );\r\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\r\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n\t\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\r\n\t\r\n\t\r\n\t\t\t\t\t// render pink quad\r\n\t\r\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 0 );\r\n\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n\t\r\n\t\t\t\t\tstate.disable( gl.BLEND );\r\n\t\t\t\t\tstate.enable( gl.DEPTH_TEST );\r\n\t\r\n\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\t\r\n\t\r\n\t\t\t\t\t// copy result to occlusionMap\r\n\t\r\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\r\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\r\n\t\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\r\n\t\r\n\t\r\n\t\t\t\t\t// restore graphics\r\n\t\r\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 1 );\r\n\t\t\t\t\tstate.disable( gl.DEPTH_TEST );\r\n\t\r\n\t\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\r\n\t\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\t\r\n\t\r\n\t\t\t\t\t// update object positions\r\n\t\r\n\t\t\t\t\tflare.positionScreen.copy( screenPosition );\r\n\t\r\n\t\t\t\t\tif ( flare.customUpdateCallback ) {\r\n\t\r\n\t\t\t\t\t\tflare.customUpdateCallback( flare );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tflare.updateLensFlares();\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// render flares\r\n\t\r\n\t\t\t\t\tgl.uniform1i( uniforms.renderType, 2 );\r\n\t\t\t\t\tstate.enable( gl.BLEND );\r\n\t\r\n\t\t\t\t\tfor ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar sprite = flare.lensFlares[ j ];\r\n\t\r\n\t\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\r\n\t\r\n\t\t\t\t\t\t\tscreenPosition.x = sprite.x;\r\n\t\t\t\t\t\t\tscreenPosition.y = sprite.y;\r\n\t\t\t\t\t\t\tscreenPosition.z = sprite.z;\r\n\t\r\n\t\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewport.w;\r\n\t\r\n\t\t\t\t\t\t\tscale.x = size * invAspect;\r\n\t\t\t\t\t\t\tscale.y = size;\r\n\t\r\n\t\t\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n\t\t\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n\t\t\t\t\t\t\tgl.uniform1f( uniforms.rotation, sprite.rotation );\r\n\t\r\n\t\t\t\t\t\t\tgl.uniform1f( uniforms.opacity, sprite.opacity );\r\n\t\t\t\t\t\t\tgl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\r\n\t\r\n\t\t\t\t\t\t\tstate.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\r\n\t\t\t\t\t\t\trenderer.setTexture2D( sprite.texture, 1 );\r\n\t\r\n\t\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// restore gl\r\n\t\r\n\t\t\tstate.enable( gl.CULL_FACE );\r\n\t\t\tstate.enable( gl.DEPTH_TEST );\r\n\t\t\tstate.setDepthWrite( true );\r\n\t\r\n\t\t\trenderer.resetGLState();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction createProgram ( shader ) {\r\n\t\r\n\t\t\tvar program = gl.createProgram();\r\n\t\r\n\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\r\n\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\r\n\t\r\n\t\t\tvar prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\r\n\t\r\n\t\t\tgl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\r\n\t\t\tgl.shaderSource( vertexShader, prefix + shader.vertexShader );\r\n\t\r\n\t\t\tgl.compileShader( fragmentShader );\r\n\t\t\tgl.compileShader( vertexShader );\r\n\t\r\n\t\t\tgl.attachShader( program, fragmentShader );\r\n\t\t\tgl.attachShader( program, vertexShader );\r\n\t\r\n\t\t\tgl.linkProgram( program );\r\n\t\r\n\t\t\treturn program;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/renderers/webgl/plugins/SpritePlugin.js\r\n\t\r\n\t/**\r\n\t * @author mikael emtinger / http://gomo.se/\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.SpritePlugin = function ( renderer, sprites ) {\r\n\t\r\n\t\tvar gl = renderer.context;\r\n\t\tvar state = renderer.state;\r\n\t\r\n\t\tvar vertexBuffer, elementBuffer;\r\n\t\tvar program, attributes, uniforms;\r\n\t\r\n\t\tvar texture;\r\n\t\r\n\t\t// decompose matrixWorld\r\n\t\r\n\t\tvar spritePosition = new THREE.Vector3();\r\n\t\tvar spriteRotation = new THREE.Quaternion();\r\n\t\tvar spriteScale = new THREE.Vector3();\r\n\t\r\n\t\tfunction init() {\r\n\t\r\n\t\t\tvar vertices = new Float32Array( [\r\n\t\t\t\t- 0.5, - 0.5,  0, 0,\r\n\t\t\t\t  0.5, - 0.5,  1, 0,\r\n\t\t\t\t  0.5,   0.5,  1, 1,\r\n\t\t\t\t- 0.5,   0.5,  0, 1\r\n\t\t\t] );\r\n\t\r\n\t\t\tvar faces = new Uint16Array( [\r\n\t\t\t\t0, 1, 2,\r\n\t\t\t\t0, 2, 3\r\n\t\t\t] );\r\n\t\r\n\t\t\tvertexBuffer  = gl.createBuffer();\r\n\t\t\telementBuffer = gl.createBuffer();\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\r\n\t\r\n\t\t\tprogram = createProgram();\r\n\t\r\n\t\t\tattributes = {\r\n\t\t\t\tposition:\t\t\tgl.getAttribLocation ( program, 'position' ),\r\n\t\t\t\tuv:\t\t\t\t\tgl.getAttribLocation ( program, 'uv' )\r\n\t\t\t};\r\n\t\r\n\t\t\tuniforms = {\r\n\t\t\t\tuvOffset:\t\t\tgl.getUniformLocation( program, 'uvOffset' ),\r\n\t\t\t\tuvScale:\t\t\tgl.getUniformLocation( program, 'uvScale' ),\r\n\t\r\n\t\t\t\trotation:\t\t\tgl.getUniformLocation( program, 'rotation' ),\r\n\t\t\t\tscale:\t\t\t\tgl.getUniformLocation( program, 'scale' ),\r\n\t\r\n\t\t\t\tcolor:\t\t\t\tgl.getUniformLocation( program, 'color' ),\r\n\t\t\t\tmap:\t\t\t\tgl.getUniformLocation( program, 'map' ),\r\n\t\t\t\topacity:\t\t\tgl.getUniformLocation( program, 'opacity' ),\r\n\t\r\n\t\t\t\tmodelViewMatrix: \tgl.getUniformLocation( program, 'modelViewMatrix' ),\r\n\t\t\t\tprojectionMatrix:\tgl.getUniformLocation( program, 'projectionMatrix' ),\r\n\t\r\n\t\t\t\tfogType:\t\t\tgl.getUniformLocation( program, 'fogType' ),\r\n\t\t\t\tfogDensity:\t\t\tgl.getUniformLocation( program, 'fogDensity' ),\r\n\t\t\t\tfogNear:\t\t\tgl.getUniformLocation( program, 'fogNear' ),\r\n\t\t\t\tfogFar:\t\t\t\tgl.getUniformLocation( program, 'fogFar' ),\r\n\t\t\t\tfogColor:\t\t\tgl.getUniformLocation( program, 'fogColor' ),\r\n\t\r\n\t\t\t\talphaTest:\t\t\tgl.getUniformLocation( program, 'alphaTest' )\r\n\t\t\t};\r\n\t\r\n\t\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\t\tcanvas.width = 8;\r\n\t\t\tcanvas.height = 8;\r\n\t\r\n\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\tcontext.fillStyle = 'white';\r\n\t\t\tcontext.fillRect( 0, 0, 8, 8 );\r\n\t\r\n\t\t\ttexture = new THREE.Texture( canvas );\r\n\t\t\ttexture.needsUpdate = true;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.render = function ( scene, camera ) {\r\n\t\r\n\t\t\tif ( sprites.length === 0 ) return;\r\n\t\r\n\t\t\t// setup gl\r\n\t\r\n\t\t\tif ( program === undefined ) {\r\n\t\r\n\t\t\t\tinit();\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgl.useProgram( program );\r\n\t\r\n\t\t\tstate.initAttributes();\r\n\t\t\tstate.enableAttribute( attributes.position );\r\n\t\t\tstate.enableAttribute( attributes.uv );\r\n\t\t\tstate.disableUnusedAttributes();\r\n\t\r\n\t\t\tstate.disable( gl.CULL_FACE );\r\n\t\t\tstate.enable( gl.BLEND );\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\t\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\r\n\t\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\r\n\t\r\n\t\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\r\n\t\t\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\r\n\t\r\n\t\t\tstate.activeTexture( gl.TEXTURE0 );\r\n\t\t\tgl.uniform1i( uniforms.map, 0 );\r\n\t\r\n\t\t\tvar oldFogType = 0;\r\n\t\t\tvar sceneFogType = 0;\r\n\t\t\tvar fog = scene.fog;\r\n\t\r\n\t\t\tif ( fog ) {\r\n\t\r\n\t\t\t\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\r\n\t\r\n\t\t\t\tif ( fog instanceof THREE.Fog ) {\r\n\t\r\n\t\t\t\t\tgl.uniform1f( uniforms.fogNear, fog.near );\r\n\t\t\t\t\tgl.uniform1f( uniforms.fogFar, fog.far );\r\n\t\r\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, 1 );\r\n\t\t\t\t\toldFogType = 1;\r\n\t\t\t\t\tsceneFogType = 1;\r\n\t\r\n\t\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\r\n\t\r\n\t\t\t\t\tgl.uniform1f( uniforms.fogDensity, fog.density );\r\n\t\r\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, 2 );\r\n\t\t\t\t\toldFogType = 2;\r\n\t\t\t\t\tsceneFogType = 2;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tgl.uniform1i( uniforms.fogType, 0 );\r\n\t\t\t\toldFogType = 0;\r\n\t\t\t\tsceneFogType = 0;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\t// update positions and sort\r\n\t\r\n\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar sprite = sprites[ i ];\r\n\t\r\n\t\t\t\tsprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\r\n\t\t\t\tsprite.z = - sprite.modelViewMatrix.elements[ 14 ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tsprites.sort( painterSortStable );\r\n\t\r\n\t\t\t// render all sprites\r\n\t\r\n\t\t\tvar scale = [];\r\n\t\r\n\t\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar sprite = sprites[ i ];\r\n\t\t\t\tvar material = sprite.material;\r\n\t\r\n\t\t\t\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\r\n\t\t\t\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\r\n\t\r\n\t\t\t\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\r\n\t\r\n\t\t\t\tscale[ 0 ] = spriteScale.x;\r\n\t\t\t\tscale[ 1 ] = spriteScale.y;\r\n\t\r\n\t\t\t\tvar fogType = 0;\r\n\t\r\n\t\t\t\tif ( scene.fog && material.fog ) {\r\n\t\r\n\t\t\t\t\tfogType = sceneFogType;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( oldFogType !== fogType ) {\r\n\t\r\n\t\t\t\t\tgl.uniform1i( uniforms.fogType, fogType );\r\n\t\t\t\t\toldFogType = fogType;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( material.map !== null ) {\r\n\t\r\n\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\r\n\t\t\t\t\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\r\n\t\t\t\t\tgl.uniform2f( uniforms.uvScale, 1, 1 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgl.uniform1f( uniforms.opacity, material.opacity );\r\n\t\t\t\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\r\n\t\r\n\t\t\t\tgl.uniform1f( uniforms.rotation, material.rotation );\r\n\t\t\t\tgl.uniform2fv( uniforms.scale, scale );\r\n\t\r\n\t\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\r\n\t\t\t\tstate.setDepthTest( material.depthTest );\r\n\t\t\t\tstate.setDepthWrite( material.depthWrite );\r\n\t\r\n\t\t\t\tif ( material.map ) {\r\n\t\r\n\t\t\t\t\trenderer.setTexture2D( material.map, 0 );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\trenderer.setTexture2D( texture, 0 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// restore gl\r\n\t\r\n\t\t\tstate.enable( gl.CULL_FACE );\r\n\t\r\n\t\t\trenderer.resetGLState();\r\n\t\r\n\t\t};\r\n\t\r\n\t\tfunction createProgram () {\r\n\t\r\n\t\t\tvar program = gl.createProgram();\r\n\t\r\n\t\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\r\n\t\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\r\n\t\r\n\t\t\tgl.shaderSource( vertexShader, [\r\n\t\r\n\t\t\t\t'precision ' + renderer.getPrecision() + ' float;',\r\n\t\r\n\t\t\t\t'uniform mat4 modelViewMatrix;',\r\n\t\t\t\t'uniform mat4 projectionMatrix;',\r\n\t\t\t\t'uniform float rotation;',\r\n\t\t\t\t'uniform vec2 scale;',\r\n\t\t\t\t'uniform vec2 uvOffset;',\r\n\t\t\t\t'uniform vec2 uvScale;',\r\n\t\r\n\t\t\t\t'attribute vec2 position;',\r\n\t\t\t\t'attribute vec2 uv;',\r\n\t\r\n\t\t\t\t'varying vec2 vUV;',\r\n\t\r\n\t\t\t\t'void main() {',\r\n\t\r\n\t\t\t\t\t'vUV = uvOffset + uv * uvScale;',\r\n\t\r\n\t\t\t\t\t'vec2 alignedPosition = position * scale;',\r\n\t\r\n\t\t\t\t\t'vec2 rotatedPosition;',\r\n\t\t\t\t\t'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\r\n\t\t\t\t\t'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\r\n\t\r\n\t\t\t\t\t'vec4 finalPosition;',\r\n\t\r\n\t\t\t\t\t'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\r\n\t\t\t\t\t'finalPosition.xy += rotatedPosition;',\r\n\t\t\t\t\t'finalPosition = projectionMatrix * finalPosition;',\r\n\t\r\n\t\t\t\t\t'gl_Position = finalPosition;',\r\n\t\r\n\t\t\t\t'}'\r\n\t\r\n\t\t\t].join( '\\n' ) );\r\n\t\r\n\t\t\tgl.shaderSource( fragmentShader, [\r\n\t\r\n\t\t\t\t'precision ' + renderer.getPrecision() + ' float;',\r\n\t\r\n\t\t\t\t'uniform vec3 color;',\r\n\t\t\t\t'uniform sampler2D map;',\r\n\t\t\t\t'uniform float opacity;',\r\n\t\r\n\t\t\t\t'uniform int fogType;',\r\n\t\t\t\t'uniform vec3 fogColor;',\r\n\t\t\t\t'uniform float fogDensity;',\r\n\t\t\t\t'uniform float fogNear;',\r\n\t\t\t\t'uniform float fogFar;',\r\n\t\t\t\t'uniform float alphaTest;',\r\n\t\r\n\t\t\t\t'varying vec2 vUV;',\r\n\t\r\n\t\t\t\t'void main() {',\r\n\t\r\n\t\t\t\t\t'vec4 texture = texture2D( map, vUV );',\r\n\t\r\n\t\t\t\t\t'if ( texture.a < alphaTest ) discard;',\r\n\t\r\n\t\t\t\t\t'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\r\n\t\r\n\t\t\t\t\t'if ( fogType > 0 ) {',\r\n\t\r\n\t\t\t\t\t\t'float depth = gl_FragCoord.z / gl_FragCoord.w;',\r\n\t\t\t\t\t\t'float fogFactor = 0.0;',\r\n\t\r\n\t\t\t\t\t\t'if ( fogType == 1 ) {',\r\n\t\r\n\t\t\t\t\t\t\t'fogFactor = smoothstep( fogNear, fogFar, depth );',\r\n\t\r\n\t\t\t\t\t\t'} else {',\r\n\t\r\n\t\t\t\t\t\t\t'const float LOG2 = 1.442695;',\r\n\t\t\t\t\t\t\t'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\r\n\t\t\t\t\t\t\t'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\r\n\t\r\n\t\t\t\t\t\t'}',\r\n\t\r\n\t\t\t\t\t\t'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\r\n\t\r\n\t\t\t\t\t'}',\r\n\t\r\n\t\t\t\t'}'\r\n\t\r\n\t\t\t].join( '\\n' ) );\r\n\t\r\n\t\t\tgl.compileShader( vertexShader );\r\n\t\t\tgl.compileShader( fragmentShader );\r\n\t\r\n\t\t\tgl.attachShader( program, vertexShader );\r\n\t\t\tgl.attachShader( program, fragmentShader );\r\n\t\r\n\t\t\tgl.linkProgram( program );\r\n\t\r\n\t\t\treturn program;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction painterSortStable ( a, b ) {\r\n\t\t\t\r\n\t\t\tif ( a.renderOrder !== b.renderOrder ) {\r\n\t\r\n\t\t\t\treturn a.renderOrder - b.renderOrder;\r\n\t\r\n\t\t\t} else if ( a.z !== b.z ) {\r\n\t\r\n\t\t\t\treturn b.z - a.z;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\treturn b.id - a.id;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/Three.Legacy.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tObject.assign( THREE, {\r\n\t\tFace4: function ( a, b, c, d, normal, color, materialIndex ) {\r\n\t\t\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\r\n\t\t\treturn new THREE.Face3( a, b, c, normal, color, materialIndex );\r\n\t\t},\r\n\t\tLineStrip: 0,\r\n\t\tLinePieces: 1,\r\n\t\tMeshFaceMaterial: THREE.MultiMaterial,\r\n\t\tPointCloud: function ( geometry, material ) {\r\n\t\t\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\r\n\t\t\treturn new THREE.Points( geometry, material );\r\n\t\t},\r\n\t\tParticle: THREE.Sprite,\r\n\t\tParticleSystem: function ( geometry, material ) {\r\n\t\t\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\r\n\t\t\treturn new THREE.Points( geometry, material );\r\n\t\t},\r\n\t\tPointCloudMaterial: function ( parameters ) {\r\n\t\t\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\r\n\t\t\treturn new THREE.PointsMaterial( parameters );\r\n\t\t},\r\n\t\tParticleBasicMaterial: function ( parameters ) {\r\n\t\t\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\r\n\t\t\treturn new THREE.PointsMaterial( parameters );\r\n\t\t},\r\n\t\tParticleSystemMaterial: function ( parameters ) {\r\n\t\t\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\r\n\t\t\treturn new THREE.PointsMaterial( parameters );\r\n\t\t},\r\n\t\tVertex: function ( x, y, z ) {\r\n\t\t\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\r\n\t\t\treturn new THREE.Vector3( x, y, z );\r\n\t\t}\r\n\t} );\r\n\t\r\n\t//\r\n\t\r\n\tObject.assign( THREE.Box2.prototype, {\r\n\t\tempty: function () {\r\n\t\t\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\r\n\t\t\treturn this.isEmpty();\r\n\t\t},\r\n\t\tisIntersectionBox: function ( box ) {\r\n\t\t\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\r\n\t\t\treturn this.intersectsBox( box );\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.assign( THREE.Box3.prototype, {\r\n\t\tempty: function () {\r\n\t\t\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\r\n\t\t\treturn this.isEmpty();\r\n\t\t},\r\n\t\tisIntersectionBox: function ( box ) {\r\n\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\r\n\t\t\treturn this.intersectsBox( box );\r\n\t\t},\r\n\t\tisIntersectionSphere: function ( sphere ) {\r\n\t\t\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\r\n\t\t\treturn this.intersectsSphere( sphere );\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.assign( THREE.Matrix3.prototype, {\r\n\t\tmultiplyVector3: function ( vector ) {\r\n\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\r\n\t\t\treturn vector.applyMatrix3( this );\r\n\t\t},\r\n\t\tmultiplyVector3Array: function ( a ) {\r\n\t\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\r\n\t\t\treturn this.applyToVector3Array( a );\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.assign( THREE.Matrix4.prototype, {\r\n\t\textractPosition: function ( m ) {\r\n\t\t\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\r\n\t\t\treturn this.copyPosition( m );\r\n\t\t},\r\n\t\tsetRotationFromQuaternion: function ( q ) {\r\n\t\t\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\r\n\t\t\treturn this.makeRotationFromQuaternion( q );\r\n\t\t},\r\n\t\tmultiplyVector3: function ( vector ) {\r\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\r\n\t\t\treturn vector.applyProjection( this );\r\n\t\t},\r\n\t\tmultiplyVector4: function ( vector ) {\r\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\r\n\t\t\treturn vector.applyMatrix4( this );\r\n\t\t},\r\n\t\tmultiplyVector3Array: function ( a ) {\r\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\r\n\t\t\treturn this.applyToVector3Array( a );\r\n\t\t},\r\n\t\trotateAxis: function ( v ) {\r\n\t\t\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\r\n\t\t\tv.transformDirection( this );\r\n\t\t},\r\n\t\tcrossVector: function ( vector ) {\r\n\t\t\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\r\n\t\t\treturn vector.applyMatrix4( this );\r\n\t\t},\r\n\t\ttranslate: function ( v ) {\r\n\t\t\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\r\n\t\t},\r\n\t\trotateX: function ( angle ) {\r\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\r\n\t\t},\r\n\t\trotateY: function ( angle ) {\r\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\r\n\t\t},\r\n\t\trotateZ: function ( angle ) {\r\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\r\n\t\t},\r\n\t\trotateByAxis: function ( axis, angle ) {\r\n\t\t\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.assign( THREE.Plane.prototype, {\r\n\t\tisIntersectionLine: function ( line ) {\r\n\t\t\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\r\n\t\t\treturn this.intersectsLine( line );\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.assign( THREE.Quaternion.prototype, {\r\n\t\tmultiplyVector3: function ( vector ) {\r\n\t\t\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\r\n\t\t\treturn vector.applyQuaternion( this );\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.assign( THREE.Ray.prototype, {\r\n\t\tisIntersectionBox: function ( box ) {\r\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\r\n\t\t\treturn this.intersectsBox( box );\r\n\t\t},\r\n\t\tisIntersectionPlane: function ( plane ) {\r\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\r\n\t\t\treturn this.intersectsPlane( plane );\r\n\t\t},\r\n\t\tisIntersectionSphere: function ( sphere ) {\r\n\t\t\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\r\n\t\t\treturn this.intersectsSphere( sphere );\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.assign( THREE.Vector3.prototype, {\r\n\t\tsetEulerFromRotationMatrix: function () {\r\n\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\r\n\t\t},\r\n\t\tsetEulerFromQuaternion: function () {\r\n\t\t\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\r\n\t\t},\r\n\t\tgetPositionFromMatrix: function ( m ) {\r\n\t\t\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\r\n\t\t\treturn this.setFromMatrixPosition( m );\r\n\t\t},\r\n\t\tgetScaleFromMatrix: function ( m ) {\r\n\t\t\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\r\n\t\t\treturn this.setFromMatrixScale( m );\r\n\t\t},\r\n\t\tgetColumnFromMatrix: function ( index, matrix ) {\r\n\t\t\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\r\n\t\t\treturn this.setFromMatrixColumn( matrix, index );\r\n\t\t}\r\n\t} );\r\n\t\r\n\t//\r\n\t\r\n\tObject.assign( THREE.Object3D.prototype, {\r\n\t\tgetChildByName: function ( name ) {\r\n\t\t\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\r\n\t\t\treturn this.getObjectByName( name );\r\n\t\t},\r\n\t\trenderDepth: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\r\n\t\t},\r\n\t\ttranslate: function ( distance, axis ) {\r\n\t\t\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\r\n\t\t\treturn this.translateOnAxis( axis, distance );\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.defineProperties( THREE.Object3D.prototype, {\r\n\t\teulerOrder: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\r\n\t\t\t\treturn this.rotation.order;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\r\n\t\t\t\tthis.rotation.order = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tuseQuaternion: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.defineProperties( THREE.LOD.prototype, {\r\n\t\tobjects: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\r\n\t\t\t\treturn this.levels;\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\t//\r\n\t\r\n\tTHREE.PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {\r\n\t\r\n\t\tconsole.warn( \"THREE.PerspectiveCamera.setLens is deprecated. \" +\r\n\t\t\t\t\"Use .setFocalLength and .filmGauge for a photographic setup.\" );\r\n\t\r\n\t\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\r\n\t\tthis.setFocalLength( focalLength );\r\n\t\r\n\t};\r\n\t\r\n\t//\r\n\t\r\n\tObject.defineProperties( THREE.Light.prototype, {\r\n\t\tonlyShadow: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowCameraFov: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\r\n\t\t\t\tthis.shadow.camera.fov = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowCameraLeft: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\r\n\t\t\t\tthis.shadow.camera.left = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowCameraRight: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\r\n\t\t\t\tthis.shadow.camera.right = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowCameraTop: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\r\n\t\t\t\tthis.shadow.camera.top = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowCameraBottom: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\r\n\t\t\t\tthis.shadow.camera.bottom = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowCameraNear: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\r\n\t\t\t\tthis.shadow.camera.near = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowCameraFar: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\r\n\t\t\t\tthis.shadow.camera.far = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowCameraVisible: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowBias: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\r\n\t\t\t\tthis.shadow.bias = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowDarkness: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowMapWidth: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\r\n\t\t\t\tthis.shadow.mapSize.width = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowMapHeight: {\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\r\n\t\t\t\tthis.shadow.mapSize.height = value;\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\t//\r\n\t\r\n\tObject.defineProperties( THREE.BufferAttribute.prototype, {\r\n\t\tlength: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\r\n\t\t\t\treturn this.array.length;\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.assign( THREE.BufferGeometry.prototype, {\r\n\t\taddIndex: function ( index ) {\r\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\r\n\t\t\tthis.setIndex( index );\r\n\t\t},\r\n\t\taddDrawCall: function ( start, count, indexOffset ) {\r\n\t\t\tif ( indexOffset !== undefined ) {\r\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\r\n\t\t\t}\r\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\r\n\t\t\tthis.addGroup( start, count );\r\n\t\t},\r\n\t\tclearDrawCalls: function () {\r\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\r\n\t\t\tthis.clearGroups();\r\n\t\t},\r\n\t\tcomputeTangents: function () {\r\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\r\n\t\t},\r\n\t\tcomputeOffsets: function () {\r\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.defineProperties( THREE.BufferGeometry.prototype, {\r\n\t\tdrawcalls: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\r\n\t\t\t\treturn this.groups;\r\n\t\t\t}\r\n\t\t},\r\n\t\toffsets: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\r\n\t\t\t\treturn this.groups;\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\t//\r\n\t\r\n\tObject.defineProperties( THREE.Material.prototype, {\r\n\t\twrapAround: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\r\n\t\t\t}\r\n\t\t},\r\n\t\twrapRGB: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );\r\n\t\t\t\treturn new THREE.Color();\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.defineProperties( THREE.MeshPhongMaterial.prototype, {\r\n\t\tmetal: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\r\n\t\t\t\treturn false;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.defineProperties( THREE.ShaderMaterial.prototype, {\r\n\t\tderivatives: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\r\n\t\t\t\treturn this.extensions.derivatives;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\r\n\t\t\t\tthis.extensions.derivatives = value;\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\t//\r\n\t\r\n\tTHREE.EventDispatcher.prototype = Object.assign( Object.create( {\r\n\t\r\n\t\t// Note: Extra base ensures these properties are not 'assign'ed.\r\n\t\r\n\t\tconstructor: THREE.EventDispatcher,\r\n\t\r\n\t\tapply: function ( target ) {\r\n\t\r\n\t\t\tconsole.warn( \"THREE.EventDispatcher: .apply is deprecated, \" +\r\n\t\t\t\t\t\"just inherit or Object.assign the prototype to mix-in.\" );\r\n\t\r\n\t\t\tObject.assign( target, this );\r\n\t\r\n\t\t}\r\n\t\r\n\t} ), THREE.EventDispatcher.prototype );\r\n\t\r\n\t//\r\n\t\r\n\tObject.assign( THREE.WebGLRenderer.prototype, {\r\n\t\tsupportsFloatTextures: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\r\n\t\t\treturn this.extensions.get( 'OES_texture_float' );\r\n\t\t},\r\n\t\tsupportsHalfFloatTextures: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\r\n\t\t\treturn this.extensions.get( 'OES_texture_half_float' );\r\n\t\t},\r\n\t\tsupportsStandardDerivatives: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\r\n\t\t\treturn this.extensions.get( 'OES_standard_derivatives' );\r\n\t\t},\r\n\t\tsupportsCompressedTextureS3TC: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\r\n\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\r\n\t\t},\r\n\t\tsupportsCompressedTexturePVRTC: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\r\n\t\t\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\r\n\t\t},\r\n\t\tsupportsBlendMinMax: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\r\n\t\t\treturn this.extensions.get( 'EXT_blend_minmax' );\r\n\t\t},\r\n\t\tsupportsVertexTextures: function () {\r\n\t\t\treturn this.capabilities.vertexTextures;\r\n\t\t},\r\n\t\tsupportsInstancedArrays: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\r\n\t\t\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\r\n\t\t},\r\n\t\tenableScissorTest: function ( boolean ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\r\n\t\t\tthis.setScissorTest( boolean );\r\n\t\t},\r\n\t\tinitMaterial: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\r\n\t\t},\r\n\t\taddPrePlugin: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\r\n\t\t},\r\n\t\taddPostPlugin: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\r\n\t\t},\r\n\t\tupdateShadowMap: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.defineProperties( THREE.WebGLRenderer.prototype, {\r\n\t\tshadowMapEnabled: {\r\n\t\t\tget: function () {\r\n\t\t\t\treturn this.shadowMap.enabled;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\r\n\t\t\t\tthis.shadowMap.enabled = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowMapType: {\r\n\t\t\tget: function () {\r\n\t\t\t\treturn this.shadowMap.type;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\r\n\t\t\t\tthis.shadowMap.type = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tshadowMapCullFace: {\r\n\t\t\tget: function () {\r\n\t\t\t\treturn this.shadowMap.cullFace;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );\r\n\t\t\t\tthis.shadowMap.cullFace = value;\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.defineProperties( THREE.WebGLShadowMap.prototype, {\r\n\t\tcullFace: {\r\n\t\t\tget: function () {\r\n\t\t\t\treturn this.renderReverseSided ? THREE.CullFaceFront : THREE.CullFaceBack;\r\n\t\t\t},\r\n\t\t\tset: function ( cullFace ) {\r\n\t\t\t\tvar value = ( cullFace !== THREE.CullFaceBack );\r\n\t\t\t\tconsole.warn( \"WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to \" + value + \".\" );\r\n\t\t\t\tthis.renderReverseSided = value;\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\t//\r\n\t\r\n\tObject.defineProperties( THREE.WebGLRenderTarget.prototype, {\r\n\t\twrapS: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\r\n\t\t\t\treturn this.texture.wrapS;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\r\n\t\t\t\tthis.texture.wrapS = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\twrapT: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\r\n\t\t\t\treturn this.texture.wrapT;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\r\n\t\t\t\tthis.texture.wrapT = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tmagFilter: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\r\n\t\t\t\treturn this.texture.magFilter;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\r\n\t\t\t\tthis.texture.magFilter = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tminFilter: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\r\n\t\t\t\treturn this.texture.minFilter;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\r\n\t\t\t\tthis.texture.minFilter = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tanisotropy: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\r\n\t\t\t\treturn this.texture.anisotropy;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\r\n\t\t\t\tthis.texture.anisotropy = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\toffset: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\r\n\t\t\t\treturn this.texture.offset;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\r\n\t\t\t\tthis.texture.offset = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\trepeat: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\r\n\t\t\t\treturn this.texture.repeat;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\r\n\t\t\t\tthis.texture.repeat = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tformat: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\r\n\t\t\t\treturn this.texture.format;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\r\n\t\t\t\tthis.texture.format = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\ttype: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\r\n\t\t\t\treturn this.texture.type;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\r\n\t\t\t\tthis.texture.type = value;\r\n\t\t\t}\r\n\t\t},\r\n\t\tgenerateMipmaps: {\r\n\t\t\tget: function () {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\r\n\t\t\t\treturn this.texture.generateMipmaps;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\r\n\t\t\t\tthis.texture.generateMipmaps = value;\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\t\r\n\t//\r\n\t\r\n\tObject.assign( THREE.Audio.prototype, {\r\n\t\tload: function ( file ) {\r\n\t\t\tconsole.warn( 'THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.' );\r\n\t\t\tvar scope = this;\r\n\t\t\tvar audioLoader = new THREE.AudioLoader();\r\n\t\t\taudioLoader.load( file, function ( buffer ) {\r\n\t\t\t\tscope.setBuffer( buffer );\r\n\t\t\t} );\r\n\t\t\treturn this;\r\n\t\t}\r\n\t} );\r\n\t\r\n\tObject.assign( THREE.AudioAnalyser.prototype, {\r\n\t\tgetData: function ( file ) {\r\n\t\t\tconsole.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );\r\n\t\t\treturn this.getFrequencyData();\r\n\t\t}\r\n\t} );\r\n\t\r\n\t//\r\n\t\r\n\tTHREE.GeometryUtils = {\r\n\t\r\n\t\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\r\n\t\r\n\t\t\tvar matrix;\r\n\t\r\n\t\t\tif ( geometry2 instanceof THREE.Mesh ) {\r\n\t\r\n\t\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\r\n\t\r\n\t\t\t\tmatrix = geometry2.matrix;\r\n\t\t\t\tgeometry2 = geometry2.geometry;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcenter: function ( geometry ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\r\n\t\t\treturn geometry.center();\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ImageUtils = {\r\n\t\r\n\t\tcrossOrigin: undefined,\r\n\t\r\n\t\tloadTexture: function ( url, mapping, onLoad, onError ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\r\n\t\r\n\t\t\tvar loader = new THREE.TextureLoader();\r\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\r\n\t\t\tvar texture = loader.load( url, onLoad, undefined, onError );\r\n\t\r\n\t\t\tif ( mapping ) texture.mapping = mapping;\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tloadTextureCube: function ( urls, mapping, onLoad, onError ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\r\n\t\r\n\t\t\tvar loader = new THREE.CubeTextureLoader();\r\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\r\n\t\t\tvar texture = loader.load( urls, onLoad, undefined, onError );\r\n\t\r\n\t\t\tif ( mapping ) texture.mapping = mapping;\r\n\t\r\n\t\t\treturn texture;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tloadCompressedTexture: function () {\r\n\t\r\n\t\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tloadCompressedTextureCube: function () {\r\n\t\r\n\t\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t//\r\n\t\r\n\tTHREE.Projector = function () {\r\n\t\r\n\t\tconsole.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\r\n\t\r\n\t\tthis.projectVector = function ( vector, camera ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\r\n\t\t\tvector.project( camera );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.unprojectVector = function ( vector, camera ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\r\n\t\t\tvector.unproject( camera );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.pickingRay = function ( vector, camera ) {\r\n\t\r\n\t\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\r\n\t\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\t//\r\n\t\r\n\tTHREE.CanvasRenderer = function () {\r\n\t\r\n\t\tconsole.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\r\n\t\r\n\t\tthis.domElement = document.createElement( 'canvas' );\r\n\t\tthis.clear = function () {};\r\n\t\tthis.render = function () {};\r\n\t\tthis.setClearColor = function () {};\r\n\t\tthis.setSize = function () {};\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/CurveUtils.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t */\r\n\t\r\n\tTHREE.CurveUtils = {\r\n\t\r\n\t\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\r\n\t\r\n\t\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Puay Bing, thanks for helping with this derivative!\r\n\t\r\n\t\ttangentCubicBezier: function ( t, p0, p1, p2, p3 ) {\r\n\t\r\n\t\t\treturn - 3 * p0 * ( 1 - t ) * ( 1 - t )  +\r\n\t\t\t\t3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +\r\n\t\t\t\t6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +\r\n\t\t\t\t3 * t * t * p3;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\r\n\t\r\n\t\t\t// To check if my formulas are correct\r\n\t\r\n\t\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3 − 3t^2 + 1\r\n\t\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t\r\n\t\t\tvar h01 = - 6 * t * t + 6 * t; \t// − 2t3 + 3t2\r\n\t\t\tvar h11 = 3 * t * t - 2 * t;\t// t3 − t2\r\n\t\r\n\t\t\treturn h00 + h10 + h01 + h11;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Catmull-Rom\r\n\t\r\n\t\tinterpolate: function( p0, p1, p2, p3, t ) {\r\n\t\r\n\t\t\tvar v0 = ( p2 - p0 ) * 0.5;\r\n\t\t\tvar v1 = ( p3 - p1 ) * 0.5;\r\n\t\t\tvar t2 = t * t;\r\n\t\t\tvar t3 = t * t2;\r\n\t\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/SceneUtils.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.SceneUtils = {\r\n\t\r\n\t\tcreateMultiMaterialObject: function ( geometry, materials ) {\r\n\t\r\n\t\t\tvar group = new THREE.Group();\r\n\t\r\n\t\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tgroup.add( new THREE.Mesh( geometry, materials[ i ] ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn group;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tdetach: function ( child, parent, scene ) {\r\n\t\r\n\t\t\tchild.applyMatrix( parent.matrixWorld );\r\n\t\t\tparent.remove( child );\r\n\t\t\tscene.add( child );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tattach: function ( child, scene, parent ) {\r\n\t\r\n\t\t\tvar matrixWorldInverse = new THREE.Matrix4();\r\n\t\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\r\n\t\t\tchild.applyMatrix( matrixWorldInverse );\r\n\t\r\n\t\t\tscene.remove( child );\r\n\t\t\tparent.add( child );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/ShapeUtils.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t */\r\n\t\r\n\tTHREE.ShapeUtils = {\r\n\t\r\n\t\t// calculate area of the contour polygon\r\n\t\r\n\t\tarea: function ( contour ) {\r\n\t\r\n\t\t\tvar n = contour.length;\r\n\t\t\tvar a = 0.0;\r\n\t\r\n\t\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\r\n\t\r\n\t\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn a * 0.5;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttriangulate: ( function () {\r\n\t\r\n\t\t\t/**\r\n\t\t\t * This code is a quick port of code written in C++ which was submitted to\r\n\t\t\t * flipcode.com by John W. Ratcliff  // July 22, 2000\r\n\t\t\t * See original code and more information here:\r\n\t\t\t * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\r\n\t\t\t *\r\n\t\t\t * ported to actionscript by Zevan Rosser\r\n\t\t\t * www.actionsnippet.com\r\n\t\t\t *\r\n\t\t\t * ported to javascript by Joshua Koo\r\n\t\t\t * http://www.lab4games.net/zz85/blog\r\n\t\t\t *\r\n\t\t\t */\r\n\t\r\n\t\t\tfunction snip( contour, u, v, w, n, verts ) {\r\n\t\r\n\t\t\t\tvar p;\r\n\t\t\t\tvar ax, ay, bx, by;\r\n\t\t\t\tvar cx, cy, px, py;\r\n\t\r\n\t\t\t\tax = contour[ verts[ u ] ].x;\r\n\t\t\t\tay = contour[ verts[ u ] ].y;\r\n\t\r\n\t\t\t\tbx = contour[ verts[ v ] ].x;\r\n\t\t\t\tby = contour[ verts[ v ] ].y;\r\n\t\r\n\t\t\t\tcx = contour[ verts[ w ] ].x;\r\n\t\t\t\tcy = contour[ verts[ w ] ].y;\r\n\t\r\n\t\t\t\tif ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;\r\n\t\r\n\t\t\t\tvar aX, aY, bX, bY, cX, cY;\r\n\t\t\t\tvar apx, apy, bpx, bpy, cpx, cpy;\r\n\t\t\t\tvar cCROSSap, bCROSScp, aCROSSbp;\r\n\t\r\n\t\t\t\taX = cx - bx;  aY = cy - by;\r\n\t\t\t\tbX = ax - cx;  bY = ay - cy;\r\n\t\t\t\tcX = bx - ax;  cY = by - ay;\r\n\t\r\n\t\t\t\tfor ( p = 0; p < n; p ++ ) {\r\n\t\r\n\t\t\t\t\tpx = contour[ verts[ p ] ].x;\r\n\t\t\t\t\tpy = contour[ verts[ p ] ].y;\r\n\t\r\n\t\t\t\t\tif ( ( ( px === ax ) && ( py === ay ) ) ||\r\n\t\t\t\t\t\t ( ( px === bx ) && ( py === by ) ) ||\r\n\t\t\t\t\t\t ( ( px === cx ) && ( py === cy ) ) )\tcontinue;\r\n\t\r\n\t\t\t\t\tapx = px - ax;  apy = py - ay;\r\n\t\t\t\t\tbpx = px - bx;  bpy = py - by;\r\n\t\t\t\t\tcpx = px - cx;  cpy = py - cy;\r\n\t\r\n\t\t\t\t\t// see if p is inside triangle abc\r\n\t\r\n\t\t\t\t\taCROSSbp = aX * bpy - aY * bpx;\r\n\t\t\t\t\tcCROSSap = cX * apy - cY * apx;\r\n\t\t\t\t\tbCROSScp = bX * cpy - bY * cpx;\r\n\t\r\n\t\t\t\t\tif ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn true;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// takes in an contour array and returns\r\n\t\r\n\t\t\treturn function ( contour, indices ) {\r\n\t\r\n\t\t\t\tvar n = contour.length;\r\n\t\r\n\t\t\t\tif ( n < 3 ) return null;\r\n\t\r\n\t\t\t\tvar result = [],\r\n\t\t\t\t\tverts = [],\r\n\t\t\t\t\tvertIndices = [];\r\n\t\r\n\t\t\t\t/* we want a counter-clockwise polygon in verts */\r\n\t\r\n\t\t\t\tvar u, v, w;\r\n\t\r\n\t\t\t\tif ( THREE.ShapeUtils.area( contour ) > 0.0 ) {\r\n\t\r\n\t\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = v;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar nv = n;\r\n\t\r\n\t\t\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\r\n\t\r\n\t\t\t\tvar count = 2 * nv;   /* error detection */\r\n\t\r\n\t\t\t\tfor ( v = nv - 1; nv > 2; ) {\r\n\t\r\n\t\t\t\t\t/* if we loop, it is probably a non-simple polygon */\r\n\t\r\n\t\t\t\t\tif ( ( count -- ) <= 0 ) {\r\n\t\r\n\t\t\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\r\n\t\r\n\t\t\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\r\n\t\t\t\t\t\t//return null;\r\n\t\t\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\r\n\t\t\t\t\t\tconsole.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );\r\n\t\r\n\t\t\t\t\t\tif ( indices ) return vertIndices;\r\n\t\t\t\t\t\treturn result;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\r\n\t\r\n\t\t\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\r\n\t\t\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\r\n\t\t\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\r\n\t\r\n\t\t\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\r\n\t\r\n\t\t\t\t\t\tvar a, b, c, s, t;\r\n\t\r\n\t\t\t\t\t\t/* true names of the vertices */\r\n\t\r\n\t\t\t\t\t\ta = verts[ u ];\r\n\t\t\t\t\t\tb = verts[ v ];\r\n\t\t\t\t\t\tc = verts[ w ];\r\n\t\r\n\t\t\t\t\t\t/* output Triangle */\r\n\t\r\n\t\t\t\t\t\tresult.push( [ contour[ a ],\r\n\t\t\t\t\t\t\tcontour[ b ],\r\n\t\t\t\t\t\t\tcontour[ c ] ] );\r\n\t\r\n\t\r\n\t\t\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\r\n\t\r\n\t\t\t\t\t\t/* remove v from the remaining polygon */\r\n\t\r\n\t\t\t\t\t\tfor ( s = v, t = v + 1; t < nv; s ++, t ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tverts[ s ] = verts[ t ];\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tnv --;\r\n\t\r\n\t\t\t\t\t\t/* reset error detection counter */\r\n\t\r\n\t\t\t\t\t\tcount = 2 * nv;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( indices ) return vertIndices;\r\n\t\t\t\treturn result;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t} )(),\r\n\t\r\n\t\ttriangulateShape: function ( contour, holes ) {\r\n\t\r\n\t\t\tfunction point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\r\n\t\r\n\t\t\t\t// inOtherPt needs to be collinear to the inSegment\r\n\t\t\t\tif ( inSegPt1.x !== inSegPt2.x ) {\r\n\t\r\n\t\t\t\t\tif ( inSegPt1.x < inSegPt2.x ) {\r\n\t\r\n\t\t\t\t\t\treturn\t( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\treturn\t( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tif ( inSegPt1.y < inSegPt2.y ) {\r\n\t\r\n\t\t\t\t\t\treturn\t( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\treturn\t( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\r\n\t\r\n\t\t\t\tvar seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\r\n\t\t\t\tvar seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\r\n\t\r\n\t\t\t\tvar seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\r\n\t\t\t\tvar seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\r\n\t\r\n\t\t\t\tvar limit\t\t= seg1dy * seg2dx - seg1dx * seg2dy;\r\n\t\t\t\tvar perpSeg1\t= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\r\n\t\r\n\t\t\t\tif ( Math.abs( limit ) > Number.EPSILON ) {\r\n\t\r\n\t\t\t\t\t// not parallel\r\n\t\r\n\t\t\t\t\tvar perpSeg2;\r\n\t\t\t\t\tif ( limit > 0 ) {\r\n\t\r\n\t\t\t\t\t\tif ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) \t\treturn [];\r\n\t\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\r\n\t\t\t\t\t\tif ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) \t\treturn [];\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tif ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) \t\treturn [];\r\n\t\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\r\n\t\t\t\t\t\tif ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) \t\treturn [];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// i.e. to reduce rounding errors\r\n\t\t\t\t\t// intersection at endpoint of segment#1?\r\n\t\t\t\t\tif ( perpSeg2 === 0 ) {\r\n\t\r\n\t\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\r\n\t\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\r\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( perpSeg2 === limit ) {\r\n\t\r\n\t\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\r\n\t\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\r\n\t\t\t\t\t\treturn [ inSeg1Pt2 ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// intersection at endpoint of segment#2?\r\n\t\t\t\t\tif ( perpSeg1 === 0 )\t\treturn [ inSeg2Pt1 ];\r\n\t\t\t\t\tif ( perpSeg1 === limit )\treturn [ inSeg2Pt2 ];\r\n\t\r\n\t\t\t\t\t// return real intersection point\r\n\t\t\t\t\tvar factorSeg1 = perpSeg2 / limit;\r\n\t\t\t\t\treturn\t[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\r\n\t\t\t\t\t\t\t\ty: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// parallel or collinear\r\n\t\t\t\t\tif ( ( perpSeg1 !== 0 ) ||\r\n\t\t\t\t\t\t ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) \t\t\treturn [];\r\n\t\r\n\t\t\t\t\t// they are collinear or degenerate\r\n\t\t\t\t\tvar seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );\t// segment1 is just a point?\r\n\t\t\t\t\tvar seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );\t// segment2 is just a point?\r\n\t\t\t\t\t// both segments are points\r\n\t\t\t\t\tif ( seg1Pt && seg2Pt ) {\r\n\t\r\n\t\t\t\t\t\tif ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||\r\n\t\t\t\t\t\t\t ( inSeg1Pt1.y !== inSeg2Pt1.y ) )\t\treturn [];\t// they are distinct  points\r\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];                 \t\t\t\t\t\t// they are the same point\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// segment#1  is a single point\r\n\t\t\t\t\tif ( seg1Pt ) {\r\n\t\r\n\t\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )\t\treturn [];\t\t// but not in segment#2\r\n\t\t\t\t\t\treturn [ inSeg1Pt1 ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\t// segment#2  is a single point\r\n\t\t\t\t\tif ( seg2Pt ) {\r\n\t\r\n\t\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )\t\treturn [];\t\t// but not in segment#1\r\n\t\t\t\t\t\treturn [ inSeg2Pt1 ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// they are collinear segments, which might overlap\r\n\t\t\t\t\tvar seg1min, seg1max, seg1minVal, seg1maxVal;\r\n\t\t\t\t\tvar seg2min, seg2max, seg2minVal, seg2maxVal;\r\n\t\t\t\t\tif ( seg1dx !== 0 ) {\r\n\t\r\n\t\t\t\t\t\t// the segments are NOT on a vertical line\r\n\t\t\t\t\t\tif ( inSeg1Pt1.x < inSeg1Pt2.x ) {\r\n\t\r\n\t\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\r\n\t\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\r\n\t\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( inSeg2Pt1.x < inSeg2Pt2.x ) {\r\n\t\r\n\t\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\r\n\t\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\r\n\t\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t// the segments are on a vertical line\r\n\t\t\t\t\t\tif ( inSeg1Pt1.y < inSeg1Pt2.y ) {\r\n\t\r\n\t\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\r\n\t\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\r\n\t\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( inSeg2Pt1.y < inSeg2Pt2.y ) {\r\n\t\r\n\t\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\r\n\t\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\r\n\t\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( seg1minVal <= seg2minVal ) {\r\n\t\r\n\t\t\t\t\t\tif ( seg1maxVal <  seg2minVal )\treturn [];\r\n\t\t\t\t\t\tif ( seg1maxVal === seg2minVal )\t{\r\n\t\r\n\t\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\r\n\t\t\t\t\t\t\treturn [ seg2min ];\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg2min, seg1max ];\r\n\t\t\t\t\t\treturn\t[ seg2min, seg2max ];\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tif ( seg1minVal >  seg2maxVal )\treturn [];\r\n\t\t\t\t\t\tif ( seg1minVal === seg2maxVal )\t{\r\n\t\r\n\t\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\r\n\t\t\t\t\t\t\treturn [ seg1min ];\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg1min, seg1max ];\r\n\t\t\t\t\t\treturn\t[ seg1min, seg2max ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\r\n\t\r\n\t\t\t\t// The order of legs is important\r\n\t\r\n\t\t\t\t// translation of all points, so that Vertex is at (0,0)\r\n\t\t\t\tvar legFromPtX\t= inLegFromPt.x - inVertex.x,  legFromPtY\t= inLegFromPt.y - inVertex.y;\r\n\t\t\t\tvar legToPtX\t= inLegToPt.x\t- inVertex.x,  legToPtY\t\t= inLegToPt.y\t- inVertex.y;\r\n\t\t\t\tvar otherPtX\t= inOtherPt.x\t- inVertex.x,  otherPtY\t\t= inOtherPt.y\t- inVertex.y;\r\n\t\r\n\t\t\t\t// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\r\n\t\t\t\tvar from2toAngle\t= legFromPtX * legToPtY - legFromPtY * legToPtX;\r\n\t\t\t\tvar from2otherAngle\t= legFromPtX * otherPtY - legFromPtY * otherPtX;\r\n\t\r\n\t\t\t\tif ( Math.abs( from2toAngle ) > Number.EPSILON ) {\r\n\t\r\n\t\t\t\t\t// angle != 180 deg.\r\n\t\r\n\t\t\t\t\tvar other2toAngle\t\t= otherPtX * legToPtY - otherPtY * legToPtX;\r\n\t\t\t\t\t// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\r\n\t\r\n\t\t\t\t\tif ( from2toAngle > 0 ) {\r\n\t\r\n\t\t\t\t\t\t// main angle < 180 deg.\r\n\t\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t// main angle > 180 deg.\r\n\t\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// angle == 180 deg.\r\n\t\t\t\t\t// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\r\n\t\t\t\t\treturn\t( from2otherAngle > 0 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\tfunction removeHoles( contour, holes ) {\r\n\t\r\n\t\t\t\tvar shape = contour.concat(); // work on this shape\r\n\t\t\t\tvar hole;\r\n\t\r\n\t\t\t\tfunction isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\r\n\t\r\n\t\t\t\t\t// Check if hole point lies within angle around shape point\r\n\t\t\t\t\tvar lastShapeIdx = shape.length - 1;\r\n\t\r\n\t\t\t\t\tvar prevShapeIdx = inShapeIdx - 1;\r\n\t\t\t\t\tif ( prevShapeIdx < 0 )\t\t\tprevShapeIdx = lastShapeIdx;\r\n\t\r\n\t\t\t\t\tvar nextShapeIdx = inShapeIdx + 1;\r\n\t\t\t\t\tif ( nextShapeIdx > lastShapeIdx )\tnextShapeIdx = 0;\r\n\t\r\n\t\t\t\t\tvar insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );\r\n\t\t\t\t\tif ( ! insideAngle ) {\r\n\t\r\n\t\t\t\t\t\t// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\r\n\t\t\t\t\t\treturn\tfalse;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// Check if shape point lies within angle around hole point\r\n\t\t\t\t\tvar lastHoleIdx = hole.length - 1;\r\n\t\r\n\t\t\t\t\tvar prevHoleIdx = inHoleIdx - 1;\r\n\t\t\t\t\tif ( prevHoleIdx < 0 )\t\t\tprevHoleIdx = lastHoleIdx;\r\n\t\r\n\t\t\t\t\tvar nextHoleIdx = inHoleIdx + 1;\r\n\t\t\t\t\tif ( nextHoleIdx > lastHoleIdx )\tnextHoleIdx = 0;\r\n\t\r\n\t\t\t\t\tinsideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );\r\n\t\t\t\t\tif ( ! insideAngle ) {\r\n\t\r\n\t\t\t\t\t\t// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\r\n\t\t\t\t\t\treturn\tfalse;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\treturn\ttrue;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfunction intersectsShapeEdge( inShapePt, inHolePt ) {\r\n\t\r\n\t\t\t\t\t// checks for intersections with shape edges\r\n\t\t\t\t\tvar sIdx, nextIdx, intersection;\r\n\t\t\t\t\tfor ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {\r\n\t\r\n\t\t\t\t\t\tnextIdx = sIdx + 1; nextIdx %= shape.length;\r\n\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );\r\n\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\treturn\tfalse;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar indepHoles = [];\r\n\t\r\n\t\t\t\tfunction intersectsHoleEdge( inShapePt, inHolePt ) {\r\n\t\r\n\t\t\t\t\t// checks for intersections with hole edges\r\n\t\t\t\t\tvar ihIdx, chkHole,\r\n\t\t\t\t\t\thIdx, nextIdx, intersection;\r\n\t\t\t\t\tfor ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {\r\n\t\r\n\t\t\t\t\t\tchkHole = holes[ indepHoles[ ihIdx ]];\r\n\t\t\t\t\t\tfor ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tnextIdx = hIdx + 1; nextIdx %= chkHole.length;\r\n\t\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );\r\n\t\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn\tfalse;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar holeIndex, shapeIndex,\r\n\t\t\t\t\tshapePt, holePt,\r\n\t\t\t\t\tholeIdx, cutKey, failedCuts = [],\r\n\t\t\t\t\ttmpShape1, tmpShape2,\r\n\t\t\t\t\ttmpHole1, tmpHole2;\r\n\t\r\n\t\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\t\tindepHoles.push( h );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar minShapeIndex = 0;\r\n\t\t\t\tvar counter = indepHoles.length * 2;\r\n\t\t\t\twhile ( indepHoles.length > 0 ) {\r\n\t\r\n\t\t\t\t\tcounter --;\r\n\t\t\t\t\tif ( counter < 0 ) {\r\n\t\r\n\t\t\t\t\t\tconsole.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\r\n\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t// search for shape-vertex and hole-vertex,\r\n\t\t\t\t\t// which can be connected without intersections\r\n\t\t\t\t\tfor ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {\r\n\t\r\n\t\t\t\t\t\tshapePt = shape[ shapeIndex ];\r\n\t\t\t\t\t\tholeIndex\t= - 1;\r\n\t\r\n\t\t\t\t\t\t// search for hole which can be reached without intersections\r\n\t\t\t\t\t\tfor ( var h = 0; h < indepHoles.length; h ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tholeIdx = indepHoles[ h ];\r\n\t\r\n\t\t\t\t\t\t\t// prevent multiple checks\r\n\t\t\t\t\t\t\tcutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\r\n\t\t\t\t\t\t\tif ( failedCuts[ cutKey ] !== undefined )\t\t\tcontinue;\r\n\t\r\n\t\t\t\t\t\t\thole = holes[ holeIdx ];\r\n\t\t\t\t\t\t\tfor ( var h2 = 0; h2 < hole.length; h2 ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\tholePt = hole[ h2 ];\r\n\t\t\t\t\t\t\t\tif ( ! isCutLineInsideAngles( shapeIndex, h2 ) )\t\tcontinue;\r\n\t\t\t\t\t\t\t\tif ( intersectsShapeEdge( shapePt, holePt ) )\t\tcontinue;\r\n\t\t\t\t\t\t\t\tif ( intersectsHoleEdge( shapePt, holePt ) )\t\tcontinue;\r\n\t\r\n\t\t\t\t\t\t\t\tholeIndex = h2;\r\n\t\t\t\t\t\t\t\tindepHoles.splice( h, 1 );\r\n\t\r\n\t\t\t\t\t\t\t\ttmpShape1 = shape.slice( 0, shapeIndex + 1 );\r\n\t\t\t\t\t\t\t\ttmpShape2 = shape.slice( shapeIndex );\r\n\t\t\t\t\t\t\t\ttmpHole1 = hole.slice( holeIndex );\r\n\t\t\t\t\t\t\t\ttmpHole2 = hole.slice( 0, holeIndex + 1 );\r\n\t\r\n\t\t\t\t\t\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\r\n\t\r\n\t\t\t\t\t\t\t\tminShapeIndex = shapeIndex;\r\n\t\r\n\t\t\t\t\t\t\t\t// Debug only, to show the selected cuts\r\n\t\t\t\t\t\t\t\t// glob_CutLines.push( [ shapePt, holePt ] );\r\n\t\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\r\n\t\r\n\t\t\t\t\t\t\tfailedCuts[ cutKey ] = true;\t\t\t// remember failure\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn shape; \t\t\t/* shape with no holes */\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\t\tvar i, il, f, face,\r\n\t\t\t\tkey, index,\r\n\t\t\t\tallPointsMap = {};\r\n\t\r\n\t\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\r\n\t\r\n\t\t\tvar allpoints = contour.concat();\r\n\t\r\n\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tArray.prototype.push.apply( allpoints, holes[ h ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\r\n\t\r\n\t\t\t// prepare all points map\r\n\t\r\n\t\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\r\n\t\r\n\t\t\t\tif ( allPointsMap[ key ] !== undefined ) {\r\n\t\r\n\t\t\t\t\tconsole.warn( \"THREE.Shape: Duplicate point\", key );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tallPointsMap[ key ] = i;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// remove holes by cutting paths to holes and adding them to the shape\r\n\t\t\tvar shapeWithoutHoles = removeHoles( contour, holes );\r\n\t\r\n\t\t\tvar triangles = THREE.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\r\n\t\t\t//console.log( \"triangles\",triangles, triangles.length );\r\n\t\r\n\t\t\t// check all face vertices against all points map\r\n\t\r\n\t\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tface = triangles[ i ];\r\n\t\r\n\t\t\t\tfor ( f = 0; f < 3; f ++ ) {\r\n\t\r\n\t\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\r\n\t\r\n\t\t\t\t\tindex = allPointsMap[ key ];\r\n\t\r\n\t\t\t\t\tif ( index !== undefined ) {\r\n\t\r\n\t\t\t\t\t\tface[ f ] = index;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn triangles.concat();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tisClockWise: function ( pts ) {\r\n\t\r\n\t\t\treturn THREE.ShapeUtils.area( pts ) < 0;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Bezier Curves formulas obtained from\r\n\t\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\r\n\t\r\n\t\t// Quad Bezier Functions\r\n\t\r\n\t\tb2: ( function () {\r\n\t\r\n\t\t\tfunction b2p0( t, p ) {\r\n\t\r\n\t\t\t\tvar k = 1 - t;\r\n\t\t\t\treturn k * k * p;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction b2p1( t, p ) {\r\n\t\r\n\t\t\t\treturn 2 * ( 1 - t ) * t * p;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction b2p2( t, p ) {\r\n\t\r\n\t\t\t\treturn t * t * p;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn function ( t, p0, p1, p2 ) {\r\n\t\r\n\t\t\t\treturn b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )(),\r\n\t\r\n\t\t// Cubic Bezier Functions\r\n\t\r\n\t\tb3: ( function () {\r\n\t\r\n\t\t\tfunction b3p0( t, p ) {\r\n\t\r\n\t\t\t\tvar k = 1 - t;\r\n\t\t\t\treturn k * k * k * p;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction b3p1( t, p ) {\r\n\t\r\n\t\t\t\tvar k = 1 - t;\r\n\t\t\t\treturn 3 * k * k * t * p;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction b3p2( t, p ) {\r\n\t\r\n\t\t\t\tvar k = 1 - t;\r\n\t\t\t\treturn 3 * k * t * t * p;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction b3p3( t, p ) {\r\n\t\r\n\t\t\t\treturn t * t * t * p;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn function ( t, p0, p1, p2, p3 ) {\r\n\t\r\n\t\t\t\treturn b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t} )()\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/core/Curve.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * Extensible curve object\r\n\t *\r\n\t * Some common of Curve methods\r\n\t * .getPoint(t), getTangent(t)\r\n\t * .getPointAt(u), getTagentAt(u)\r\n\t * .getPoints(), .getSpacedPoints()\r\n\t * .getLength()\r\n\t * .updateArcLengths()\r\n\t *\r\n\t * This following classes subclasses THREE.Curve:\r\n\t *\r\n\t * -- 2d classes --\r\n\t * THREE.LineCurve\r\n\t * THREE.QuadraticBezierCurve\r\n\t * THREE.CubicBezierCurve\r\n\t * THREE.SplineCurve\r\n\t * THREE.ArcCurve\r\n\t * THREE.EllipseCurve\r\n\t *\r\n\t * -- 3d classes --\r\n\t * THREE.LineCurve3\r\n\t * THREE.QuadraticBezierCurve3\r\n\t * THREE.CubicBezierCurve3\r\n\t * THREE.SplineCurve3\r\n\t *\r\n\t * A series of curves can be represented as a THREE.CurvePath\r\n\t *\r\n\t **/\r\n\t\r\n\t/**************************************************************\r\n\t *\tAbstract Curve base class\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.Curve = function () {\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Curve.prototype = {\r\n\t\r\n\t\tconstructor: THREE.Curve,\r\n\t\r\n\t\t// Virtual base class method to overwrite and implement in subclasses\r\n\t\t//\t- t [0 .. 1]\r\n\t\r\n\t\tgetPoint: function ( t ) {\r\n\t\r\n\t\t\tconsole.warn( \"THREE.Curve: Warning, getPoint() not implemented!\" );\r\n\t\t\treturn null;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Get point at relative position in curve according to arc length\r\n\t\t// - u [0 .. 1]\r\n\t\r\n\t\tgetPointAt: function ( u ) {\r\n\t\r\n\t\t\tvar t = this.getUtoTmapping( u );\r\n\t\t\treturn this.getPoint( t );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Get sequence of points using getPoint( t )\r\n\t\r\n\t\tgetPoints: function ( divisions ) {\r\n\t\r\n\t\t\tif ( ! divisions ) divisions = 5;\r\n\t\r\n\t\t\tvar d, pts = [];\r\n\t\r\n\t\t\tfor ( d = 0; d <= divisions; d ++ ) {\r\n\t\r\n\t\t\t\tpts.push( this.getPoint( d / divisions ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn pts;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Get sequence of points using getPointAt( u )\r\n\t\r\n\t\tgetSpacedPoints: function ( divisions ) {\r\n\t\r\n\t\t\tif ( ! divisions ) divisions = 5;\r\n\t\r\n\t\t\tvar d, pts = [];\r\n\t\r\n\t\t\tfor ( d = 0; d <= divisions; d ++ ) {\r\n\t\r\n\t\t\t\tpts.push( this.getPointAt( d / divisions ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn pts;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Get total curve arc length\r\n\t\r\n\t\tgetLength: function () {\r\n\t\r\n\t\t\tvar lengths = this.getLengths();\r\n\t\t\treturn lengths[ lengths.length - 1 ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Get list of cumulative segment lengths\r\n\t\r\n\t\tgetLengths: function ( divisions ) {\r\n\t\r\n\t\t\tif ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;\r\n\t\r\n\t\t\tif ( this.cacheArcLengths\r\n\t\t\t\t&& ( this.cacheArcLengths.length === divisions + 1 )\r\n\t\t\t\t&& ! this.needsUpdate ) {\r\n\t\r\n\t\t\t\t//console.log( \"cached\", this.cacheArcLengths );\r\n\t\t\t\treturn this.cacheArcLengths;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.needsUpdate = false;\r\n\t\r\n\t\t\tvar cache = [];\r\n\t\t\tvar current, last = this.getPoint( 0 );\r\n\t\t\tvar p, sum = 0;\r\n\t\r\n\t\t\tcache.push( 0 );\r\n\t\r\n\t\t\tfor ( p = 1; p <= divisions; p ++ ) {\r\n\t\r\n\t\t\t\tcurrent = this.getPoint ( p / divisions );\r\n\t\t\t\tsum += current.distanceTo( last );\r\n\t\t\t\tcache.push( sum );\r\n\t\t\t\tlast = current;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.cacheArcLengths = cache;\r\n\t\r\n\t\t\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\r\n\t\r\n\t\t},\r\n\t\r\n\t\tupdateArcLengths: function() {\r\n\t\r\n\t\t\tthis.needsUpdate = true;\r\n\t\t\tthis.getLengths();\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\r\n\t\r\n\t\tgetUtoTmapping: function ( u, distance ) {\r\n\t\r\n\t\t\tvar arcLengths = this.getLengths();\r\n\t\r\n\t\t\tvar i = 0, il = arcLengths.length;\r\n\t\r\n\t\t\tvar targetArcLength; // The targeted u distance value to get\r\n\t\r\n\t\t\tif ( distance ) {\r\n\t\r\n\t\t\t\ttargetArcLength = distance;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//var time = Date.now();\r\n\t\r\n\t\t\t// binary search for the index with largest value smaller than target u distance\r\n\t\r\n\t\t\tvar low = 0, high = il - 1, comparison;\r\n\t\r\n\t\t\twhile ( low <= high ) {\r\n\t\r\n\t\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\r\n\t\r\n\t\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\r\n\t\r\n\t\t\t\tif ( comparison < 0 ) {\r\n\t\r\n\t\t\t\t\tlow = i + 1;\r\n\t\r\n\t\t\t\t} else if ( comparison > 0 ) {\r\n\t\r\n\t\t\t\t\thigh = i - 1;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\thigh = i;\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t// DONE\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\ti = high;\r\n\t\r\n\t\t\t//console.log('b' , i, low, high, Date.now()- time);\r\n\t\r\n\t\t\tif ( arcLengths[ i ] === targetArcLength ) {\r\n\t\r\n\t\t\t\tvar t = i / ( il - 1 );\r\n\t\t\t\treturn t;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// we could get finer grain at lengths, or use simple interpolation between two points\r\n\t\r\n\t\t\tvar lengthBefore = arcLengths[ i ];\r\n\t\t\tvar lengthAfter = arcLengths[ i + 1 ];\r\n\t\r\n\t\t\tvar segmentLength = lengthAfter - lengthBefore;\r\n\t\r\n\t\t\t// determine where we are between the 'before' and 'after' points\r\n\t\r\n\t\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\r\n\t\r\n\t\t\t// add that fractional amount to t\r\n\t\r\n\t\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\r\n\t\r\n\t\t\treturn t;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Returns a unit vector tangent at t\r\n\t\t// In case any sub curve does not implement its tangent derivation,\r\n\t\t// 2 points a small delta apart will be used to find its gradient\r\n\t\t// which seems to give a reasonable approximation\r\n\t\r\n\t\tgetTangent: function( t ) {\r\n\t\r\n\t\t\tvar delta = 0.0001;\r\n\t\t\tvar t1 = t - delta;\r\n\t\t\tvar t2 = t + delta;\r\n\t\r\n\t\t\t// Capping in case of danger\r\n\t\r\n\t\t\tif ( t1 < 0 ) t1 = 0;\r\n\t\t\tif ( t2 > 1 ) t2 = 1;\r\n\t\r\n\t\t\tvar pt1 = this.getPoint( t1 );\r\n\t\t\tvar pt2 = this.getPoint( t2 );\r\n\t\r\n\t\t\tvar vec = pt2.clone().sub( pt1 );\r\n\t\t\treturn vec.normalize();\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetTangentAt: function ( u ) {\r\n\t\r\n\t\t\tvar t = this.getUtoTmapping( u );\r\n\t\t\treturn this.getTangent( t );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// TODO: Transformation for Curves?\r\n\t\r\n\t/**************************************************************\r\n\t *\t3D Curves\r\n\t **************************************************************/\r\n\t\r\n\t// A Factory method for creating new curve subclasses\r\n\t\r\n\tTHREE.Curve.create = function ( constructor, getPointFunc ) {\r\n\t\r\n\t\tconstructor.prototype = Object.create( THREE.Curve.prototype );\r\n\t\tconstructor.prototype.constructor = constructor;\r\n\t\tconstructor.prototype.getPoint = getPointFunc;\r\n\t\r\n\t\treturn constructor;\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/core/CurvePath.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t *\r\n\t **/\r\n\t\r\n\t/**************************************************************\r\n\t *\tCurved Path - a curve path is simply a array of connected\r\n\t *  curves, but retains the api of a curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.CurvePath = function () {\r\n\t\r\n\t\tthis.curves = [];\r\n\t\r\n\t\tthis.autoClose = false; // Automatically closes the path\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CurvePath.prototype = Object.assign( Object.create( THREE.Curve.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.CurvePath,\r\n\t\r\n\t\tadd: function ( curve ) {\r\n\t\r\n\t\t\tthis.curves.push( curve );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tclosePath: function () {\r\n\t\r\n\t\t\t// TODO Test\r\n\t\t\t// and verify for vector3 (needs to implement equals)\r\n\t\t\t// Add a line curve if start and end of lines are not connected\r\n\t\t\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\r\n\t\t\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\r\n\t\r\n\t\t\tif ( ! startPoint.equals( endPoint ) ) {\r\n\t\r\n\t\t\t\tthis.curves.push( new THREE.LineCurve( endPoint, startPoint ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// To get accurate point with reference to\r\n\t\t// entire path distance at time t,\r\n\t\t// following has to be done:\r\n\t\r\n\t\t// 1. Length of each sub path have to be known\r\n\t\t// 2. Locate and identify type of curve\r\n\t\t// 3. Get t for the curve\r\n\t\t// 4. Return curve.getPointAt(t')\r\n\t\r\n\t\tgetPoint: function ( t ) {\r\n\t\r\n\t\t\tvar d = t * this.getLength();\r\n\t\t\tvar curveLengths = this.getCurveLengths();\r\n\t\t\tvar i = 0;\r\n\t\r\n\t\t\t// To think about boundaries points.\r\n\t\r\n\t\t\twhile ( i < curveLengths.length ) {\r\n\t\r\n\t\t\t\tif ( curveLengths[ i ] >= d ) {\r\n\t\r\n\t\t\t\t\tvar diff = curveLengths[ i ] - d;\r\n\t\t\t\t\tvar curve = this.curves[ i ];\r\n\t\r\n\t\t\t\t\tvar u = 1 - diff / curve.getLength();\r\n\t\r\n\t\t\t\t\treturn curve.getPointAt( u );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\ti ++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn null;\r\n\t\r\n\t\t\t// loop where sum != 0, sum > d , sum+1 <d\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\r\n\t\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\r\n\t\t// getPoint() depends on getLength\r\n\t\r\n\t\tgetLength: function () {\r\n\t\r\n\t\t\tvar lens = this.getCurveLengths();\r\n\t\t\treturn lens[ lens.length - 1 ];\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Compute lengths and cache them\r\n\t\t// We cannot overwrite getLengths() because UtoT mapping uses it.\r\n\t\r\n\t\tgetCurveLengths: function () {\r\n\t\r\n\t\t\t// We use cache values if curves and cache array are same length\r\n\t\r\n\t\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\r\n\t\r\n\t\t\t\treturn this.cacheLengths;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// Get length of sub-curve\r\n\t\t\t// Push sums into cached array\r\n\t\r\n\t\t\tvar lengths = [], sums = 0;\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tsums += this.curves[ i ].getLength();\r\n\t\t\t\tlengths.push( sums );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.cacheLengths = lengths;\r\n\t\r\n\t\t\treturn lengths;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t/**************************************************************\r\n\t\t *\tCreate Geometries Helpers\r\n\t\t **************************************************************/\r\n\t\r\n\t\t/// Generate geometry from path points (for Line or Points objects)\r\n\t\r\n\t\tcreatePointsGeometry: function ( divisions ) {\r\n\t\r\n\t\t\tvar pts = this.getPoints( divisions );\r\n\t\t\treturn this.createGeometry( pts );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Generate geometry from equidistant sampling along the path\r\n\t\r\n\t\tcreateSpacedPointsGeometry: function ( divisions ) {\r\n\t\r\n\t\t\tvar pts = this.getSpacedPoints( divisions );\r\n\t\t\treturn this.createGeometry( pts );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tcreateGeometry: function ( points ) {\r\n\t\r\n\t\t\tvar geometry = new THREE.Geometry();\r\n\t\r\n\t\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar point = points[ i ];\r\n\t\t\t\tgeometry.vertices.push( new THREE.Vector3( point.x, point.y, point.z || 0 ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn geometry;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/extras/core/Font.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.Font = function ( data ) {\r\n\t\r\n\t\tthis.data = data;\r\n\t\r\n\t};\r\n\t\r\n\tObject.assign( THREE.Font.prototype, {\r\n\t\r\n\t\tgenerateShapes: function ( text, size, divisions ) {\r\n\t\r\n\t\t\tfunction createPaths( text ) {\r\n\t\r\n\t\t\t\tvar chars = String( text ).split( '' );\r\n\t\t\t\tvar scale = size / data.resolution;\r\n\t\t\t\tvar offset = 0;\r\n\t\r\n\t\t\t\tvar paths = [];\r\n\t\r\n\t\t\t\tfor ( var i = 0; i < chars.length; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar ret = createPath( chars[ i ], scale, offset );\r\n\t\t\t\t\toffset += ret.offset;\r\n\t\r\n\t\t\t\t\tpaths.push( ret.path );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn paths;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction createPath( c, scale, offset ) {\r\n\t\r\n\t\t\t\tvar glyph = data.glyphs[ c ] || data.glyphs[ '?' ];\r\n\t\r\n\t\t\t\tif ( ! glyph ) return;\r\n\t\r\n\t\t\t\tvar path = new THREE.Path();\r\n\t\r\n\t\t\t\tvar pts = [], b2 = THREE.ShapeUtils.b2, b3 = THREE.ShapeUtils.b3;\r\n\t\t\t\tvar x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;\r\n\t\r\n\t\t\t\tif ( glyph.o ) {\r\n\t\r\n\t\t\t\t\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\r\n\t\r\n\t\t\t\t\tfor ( var i = 0, l = outline.length; i < l; ) {\r\n\t\r\n\t\t\t\t\t\tvar action = outline[ i ++ ];\r\n\t\r\n\t\t\t\t\t\tswitch ( action ) {\r\n\t\r\n\t\t\t\t\t\t\tcase 'm': // moveTo\r\n\t\r\n\t\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\r\n\t\r\n\t\t\t\t\t\t\t\tpath.moveTo( x, y );\r\n\t\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t\tcase 'l': // lineTo\r\n\t\r\n\t\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\r\n\t\r\n\t\t\t\t\t\t\t\tpath.lineTo( x, y );\r\n\t\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t\tcase 'q': // quadraticCurveTo\r\n\t\r\n\t\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\r\n\t\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\r\n\t\r\n\t\t\t\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\r\n\t\r\n\t\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\r\n\t\r\n\t\t\t\t\t\t\t\tif ( laste ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\t\t\t\t\tcpy0 = laste.y;\r\n\t\r\n\t\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\r\n\t\t\t\t\t\t\t\t\t\tb2( t, cpx0, cpx1, cpx );\r\n\t\t\t\t\t\t\t\t\t\tb2( t, cpy0, cpy1, cpy );\r\n\t\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t\tcase 'b': // bezierCurveTo\r\n\t\r\n\t\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\r\n\t\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\r\n\t\t\t\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\t\tcpy2 = outline[ i ++ ] * scale;\r\n\t\r\n\t\t\t\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\r\n\t\r\n\t\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\r\n\t\r\n\t\t\t\t\t\t\t\tif ( laste ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\t\t\t\t\tcpy0 = laste.y;\r\n\t\r\n\t\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\r\n\t\t\t\t\t\t\t\t\t\tb3( t, cpx0, cpx1, cpx2, cpx );\r\n\t\t\t\t\t\t\t\t\t\tb3( t, cpy0, cpy1, cpy2, cpy );\r\n\t\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn { offset: glyph.ha * scale, path: path };\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tif ( size === undefined ) size = 100;\r\n\t\t\tif ( divisions === undefined ) divisions = 4;\r\n\t\r\n\t\t\tvar data = this.data;\r\n\t\r\n\t\t\tvar paths = createPaths( text );\r\n\t\t\tvar shapes = [];\r\n\t\r\n\t\t\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\r\n\t\r\n\t\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn shapes;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/extras/core/Path.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * Creates free form 2d path using series of points, lines or curves.\r\n\t *\r\n\t **/\r\n\t\r\n\tTHREE.Path = function ( points ) {\r\n\t\r\n\t\tTHREE.CurvePath.call( this );\r\n\t\r\n\t\tthis.actions = [];\r\n\t\r\n\t\tif ( points ) {\r\n\t\r\n\t\t\tthis.fromPoints( points );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Path.prototype = Object.assign( Object.create( THREE.CurvePath.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.Path,\r\n\t\r\n\t\t// TODO Clean up PATH API\r\n\t\r\n\t\t// Create path using straight lines to connect all points\r\n\t\t// - vectors: array of Vector2\r\n\t\r\n\t\tfromPoints: function ( vectors ) {\r\n\t\r\n\t\t\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\r\n\t\r\n\t\t\tfor ( var i = 1, l = vectors.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tthis.lineTo( vectors[ i ].x, vectors[ i ].y );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t},\r\n\t\r\n\t\tmoveTo: function ( x, y ) {\r\n\t\r\n\t\t\tthis.actions.push( { action: 'moveTo', args: [ x, y ] } );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tlineTo: function ( x, y ) {\r\n\t\r\n\t\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\t\r\n\t\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\t\r\n\t\t\tvar curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );\r\n\t\t\tthis.curves.push( curve );\r\n\t\r\n\t\t\tthis.actions.push( { action: 'lineTo', args: [ x, y ] } );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\r\n\t\r\n\t\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\t\r\n\t\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\t\r\n\t\t\tvar curve = new THREE.QuadraticBezierCurve(\r\n\t\t\t\tnew THREE.Vector2( x0, y0 ),\r\n\t\t\t\tnew THREE.Vector2( aCPx, aCPy ),\r\n\t\t\t\tnew THREE.Vector2( aX, aY )\r\n\t\t\t);\r\n\t\r\n\t\t\tthis.curves.push( curve );\r\n\t\r\n\t\t\tthis.actions.push( { action: 'quadraticCurveTo', args: [ aCPx, aCPy, aX, aY ] } );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\r\n\t\r\n\t\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\t\r\n\t\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\t\r\n\t\t\tvar curve = new THREE.CubicBezierCurve(\r\n\t\t\t\tnew THREE.Vector2( x0, y0 ),\r\n\t\t\t\tnew THREE.Vector2( aCP1x, aCP1y ),\r\n\t\t\t\tnew THREE.Vector2( aCP2x, aCP2y ),\r\n\t\t\t\tnew THREE.Vector2( aX, aY )\r\n\t\t\t);\r\n\t\r\n\t\t\tthis.curves.push( curve );\r\n\t\r\n\t\t\tthis.actions.push( { action: 'bezierCurveTo', args: [ aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ] } );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tsplineThru: function ( pts /*Array of Vector*/ ) {\r\n\t\r\n\t\t\tvar args = Array.prototype.slice.call( arguments );\r\n\t\r\n\t\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\t\r\n\t\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\t\r\n\t\t\tvar npts = [ new THREE.Vector2( x0, y0 ) ];\r\n\t\t\tArray.prototype.push.apply( npts, pts );\r\n\t\r\n\t\t\tvar curve = new THREE.SplineCurve( npts );\r\n\t\t\tthis.curves.push( curve );\r\n\t\r\n\t\t\tthis.actions.push( { action: 'splineThru', args: args } );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\t\r\n\t\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\t\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\t\r\n\t\t\tthis.absarc( aX + x0, aY + y0, aRadius,\r\n\t\t\t\taStartAngle, aEndAngle, aClockwise );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\t\r\n\t\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\t\r\n\t\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\t\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\t\r\n\t\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\t\r\n\t\t\tvar args = [\r\n\t\t\t\taX, aY,\r\n\t\t\t\txRadius, yRadius,\r\n\t\t\t\taStartAngle, aEndAngle,\r\n\t\t\t\taClockwise,\r\n\t\t\t\taRotation || 0 // aRotation is optional.\r\n\t\t\t];\r\n\t\r\n\t\t\tvar curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\r\n\t\t\tthis.curves.push( curve );\r\n\t\r\n\t\t\tvar lastPoint = curve.getPoint( 1 );\r\n\t\t\targs.push( lastPoint.x );\r\n\t\t\targs.push( lastPoint.y );\r\n\t\r\n\t\t\tthis.actions.push( { action: 'ellipse', args: args } );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetSpacedPoints: function ( divisions ) {\r\n\t\r\n\t\t\tif ( ! divisions ) divisions = 40;\r\n\t\r\n\t\t\tvar points = [];\r\n\t\r\n\t\t\tfor ( var i = 0; i < divisions; i ++ ) {\r\n\t\r\n\t\t\t\tpoints.push( this.getPoint( i / divisions ) );\r\n\t\r\n\t\t\t\t//if ( !this.getPoint( i / divisions ) ) throw \"DIE\";\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( this.autoClose ) {\r\n\t\r\n\t\t\t\tpoints.push( points[ 0 ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn points;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetPoints: function ( divisions ) {\r\n\t\r\n\t\t\tdivisions = divisions || 12;\r\n\t\r\n\t\t\tvar b2 = THREE.ShapeUtils.b2;\r\n\t\t\tvar b3 = THREE.ShapeUtils.b3;\r\n\t\r\n\t\t\tvar points = [];\r\n\t\r\n\t\t\tvar cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,\r\n\t\t\t\tlaste, tx, ty;\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.actions.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar item = this.actions[ i ];\r\n\t\r\n\t\t\t\tvar action = item.action;\r\n\t\t\t\tvar args = item.args;\r\n\t\r\n\t\t\t\tswitch ( action ) {\r\n\t\r\n\t\t\t\tcase 'moveTo':\r\n\t\r\n\t\t\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 'lineTo':\r\n\t\r\n\t\t\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 'quadraticCurveTo':\r\n\t\r\n\t\t\t\t\tcpx  = args[ 2 ];\r\n\t\t\t\t\tcpy  = args[ 3 ];\r\n\t\r\n\t\t\t\t\tcpx1 = args[ 0 ];\r\n\t\t\t\t\tcpy1 = args[ 1 ];\r\n\t\r\n\t\t\t\t\tif ( points.length > 0 ) {\r\n\t\r\n\t\t\t\t\t\tlaste = points[ points.length - 1 ];\r\n\t\r\n\t\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\t\tcpy0 = laste.y;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\t\r\n\t\t\t\t\t\tcpx0 = laste[ laste.length - 2 ];\r\n\t\t\t\t\t\tcpy0 = laste[ laste.length - 1 ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tfor ( var j = 1; j <= divisions; j ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar t = j / divisions;\r\n\t\r\n\t\t\t\t\t\ttx = b2( t, cpx0, cpx1, cpx );\r\n\t\t\t\t\t\tty = b2( t, cpy0, cpy1, cpy );\r\n\t\r\n\t\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 'bezierCurveTo':\r\n\t\r\n\t\t\t\t\tcpx  = args[ 4 ];\r\n\t\t\t\t\tcpy  = args[ 5 ];\r\n\t\r\n\t\t\t\t\tcpx1 = args[ 0 ];\r\n\t\t\t\t\tcpy1 = args[ 1 ];\r\n\t\r\n\t\t\t\t\tcpx2 = args[ 2 ];\r\n\t\t\t\t\tcpy2 = args[ 3 ];\r\n\t\r\n\t\t\t\t\tif ( points.length > 0 ) {\r\n\t\r\n\t\t\t\t\t\tlaste = points[ points.length - 1 ];\r\n\t\r\n\t\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\t\tcpy0 = laste.y;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\t\r\n\t\t\t\t\t\tcpx0 = laste[ laste.length - 2 ];\r\n\t\t\t\t\t\tcpy0 = laste[ laste.length - 1 ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\r\n\t\t\t\t\tfor ( var j = 1; j <= divisions; j ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar t = j / divisions;\r\n\t\r\n\t\t\t\t\t\ttx = b3( t, cpx0, cpx1, cpx2, cpx );\r\n\t\t\t\t\t\tty = b3( t, cpy0, cpy1, cpy2, cpy );\r\n\t\r\n\t\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 'splineThru':\r\n\t\r\n\t\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\t\r\n\t\t\t\t\tvar last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );\r\n\t\t\t\t\tvar spts = [ last ];\r\n\t\r\n\t\t\t\t\tvar n = divisions * args[ 0 ].length;\r\n\t\r\n\t\t\t\t\tspts = spts.concat( args[ 0 ] );\r\n\t\r\n\t\t\t\t\tvar spline = new THREE.SplineCurve( spts );\r\n\t\r\n\t\t\t\t\tfor ( var j = 1; j <= n; j ++ ) {\r\n\t\r\n\t\t\t\t\t\tpoints.push( spline.getPointAt( j / n ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 'arc':\r\n\t\r\n\t\t\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\r\n\t\t\t\t\t\taRadius = args[ 2 ],\r\n\t\t\t\t\t\taStartAngle = args[ 3 ], aEndAngle = args[ 4 ],\r\n\t\t\t\t\t\taClockwise = !! args[ 5 ];\r\n\t\r\n\t\t\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\r\n\t\t\t\t\tvar angle;\r\n\t\t\t\t\tvar tdivisions = divisions * 2;\r\n\t\r\n\t\t\t\t\tfor ( var j = 1; j <= tdivisions; j ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar t = j / tdivisions;\r\n\t\r\n\t\t\t\t\t\tif ( ! aClockwise ) {\r\n\t\r\n\t\t\t\t\t\t\tt = 1 - t;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tangle = aStartAngle + t * deltaAngle;\r\n\t\r\n\t\t\t\t\t\ttx = aX + aRadius * Math.cos( angle );\r\n\t\t\t\t\t\tty = aY + aRadius * Math.sin( angle );\r\n\t\r\n\t\t\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\t\r\n\t\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t//console.log(points);\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\tcase 'ellipse':\r\n\t\r\n\t\t\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\r\n\t\t\t\t\t\txRadius = args[ 2 ],\r\n\t\t\t\t\t\tyRadius = args[ 3 ],\r\n\t\t\t\t\t\taStartAngle = args[ 4 ], aEndAngle = args[ 5 ],\r\n\t\t\t\t\t\taClockwise = !! args[ 6 ],\r\n\t\t\t\t\t\taRotation = args[ 7 ];\r\n\t\r\n\t\r\n\t\t\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\r\n\t\t\t\t\tvar angle;\r\n\t\t\t\t\tvar tdivisions = divisions * 2;\r\n\t\r\n\t\t\t\t\tvar cos, sin;\r\n\t\t\t\t\tif ( aRotation !== 0 ) {\r\n\t\r\n\t\t\t\t\t\tcos = Math.cos( aRotation );\r\n\t\t\t\t\t\tsin = Math.sin( aRotation );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tfor ( var j = 1; j <= tdivisions; j ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar t = j / tdivisions;\r\n\t\r\n\t\t\t\t\t\tif ( ! aClockwise ) {\r\n\t\r\n\t\t\t\t\t\t\tt = 1 - t;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\tangle = aStartAngle + t * deltaAngle;\r\n\t\r\n\t\t\t\t\t\ttx = aX + xRadius * Math.cos( angle );\r\n\t\t\t\t\t\tty = aY + yRadius * Math.sin( angle );\r\n\t\r\n\t\t\t\t\t\tif ( aRotation !== 0 ) {\r\n\t\r\n\t\t\t\t\t\t\tvar x = tx, y = ty;\r\n\t\r\n\t\t\t\t\t\t\t// Rotate the point about the center of the ellipse.\r\n\t\t\t\t\t\t\ttx = ( x - aX ) * cos - ( y - aY ) * sin + aX;\r\n\t\t\t\t\t\t\tty = ( x - aX ) * sin + ( y - aY ) * cos + aY;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\t\r\n\t\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t//console.log(points);\r\n\t\r\n\t\t\t\t\tbreak;\r\n\t\r\n\t\t\t\t} // end switch\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\r\n\t\r\n\t\t\t// Normalize to remove the closing point by default.\r\n\t\t\tvar lastPoint = points[ points.length - 1 ];\r\n\t\t\tif ( Math.abs( lastPoint.x - points[ 0 ].x ) < Number.EPSILON &&\r\n\t\t\t\t\t Math.abs( lastPoint.y - points[ 0 ].y ) < Number.EPSILON )\r\n\t\t\t\tpoints.splice( points.length - 1, 1 );\r\n\t\r\n\t\t\tif ( this.autoClose ) {\r\n\t\r\n\t\t\t\tpoints.push( points[ 0 ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn points;\r\n\t\r\n\t\t},\r\n\t\r\n\t\ttoShapes: function ( isCCW, noHoles ) {\r\n\t\r\n\t\t\tfunction extractSubpaths( inActions ) {\r\n\t\r\n\t\t\t\tvar subPaths = [], lastPath = new THREE.Path();\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = inActions.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar item = inActions[ i ];\r\n\t\r\n\t\t\t\t\tvar args = item.args;\r\n\t\t\t\t\tvar action = item.action;\r\n\t\r\n\t\t\t\t\tif ( action === 'moveTo' ) {\r\n\t\r\n\t\t\t\t\t\tif ( lastPath.actions.length !== 0 ) {\r\n\t\r\n\t\t\t\t\t\t\tsubPaths.push( lastPath );\r\n\t\t\t\t\t\t\tlastPath = new THREE.Path();\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tlastPath[ action ].apply( lastPath, args );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( lastPath.actions.length !== 0 ) {\r\n\t\r\n\t\t\t\t\tsubPaths.push( lastPath );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// console.log(subPaths);\r\n\t\r\n\t\t\t\treturn\tsubPaths;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction toShapesNoHoles( inSubpaths ) {\r\n\t\r\n\t\t\t\tvar shapes = [];\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar tmpPath = inSubpaths[ i ];\r\n\t\r\n\t\t\t\t\tvar tmpShape = new THREE.Shape();\r\n\t\t\t\t\ttmpShape.actions = tmpPath.actions;\r\n\t\t\t\t\ttmpShape.curves = tmpPath.curves;\r\n\t\r\n\t\t\t\t\tshapes.push( tmpShape );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t//console.log(\"shape\", shapes);\r\n\t\r\n\t\t\t\treturn shapes;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\r\n\t\r\n\t\t\t\tvar polyLen = inPolygon.length;\r\n\t\r\n\t\t\t\t// inPt on polygon contour => immediate success    or\r\n\t\t\t\t// toggling of inside/outside at every single! intersection point of an edge\r\n\t\t\t\t//  with the horizontal line through inPt, left of inPt\r\n\t\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\r\n\t\t\t\tvar inside = false;\r\n\t\t\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\r\n\t\r\n\t\t\t\t\tvar edgeLowPt  = inPolygon[ p ];\r\n\t\t\t\t\tvar edgeHighPt = inPolygon[ q ];\r\n\t\r\n\t\t\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\r\n\t\t\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\r\n\t\r\n\t\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\r\n\t\r\n\t\t\t\t\t\t// not parallel\r\n\t\t\t\t\t\tif ( edgeDy < 0 ) {\r\n\t\r\n\t\t\t\t\t\t\tedgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;\r\n\t\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\r\n\t\r\n\t\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\r\n\t\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\r\n\t\r\n\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\r\n\t\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\r\n\t\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\r\n\t\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t// parallel or collinear\r\n\t\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\r\n\t\t\t\t\t\t// edge lies on the same horizontal line as inPt\r\n\t\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\r\n\t\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\r\n\t\t\t\t\t\t// continue;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn\tinside;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar isClockWise = THREE.ShapeUtils.isClockWise;\r\n\t\r\n\t\t\tvar subPaths = extractSubpaths( this.actions );\r\n\t\t\tif ( subPaths.length === 0 ) return [];\r\n\t\r\n\t\t\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\r\n\t\r\n\t\r\n\t\t\tvar solid, tmpPath, tmpShape, shapes = [];\r\n\t\r\n\t\t\tif ( subPaths.length === 1 ) {\r\n\t\r\n\t\t\t\ttmpPath = subPaths[ 0 ];\r\n\t\t\t\ttmpShape = new THREE.Shape();\r\n\t\t\t\ttmpShape.actions = tmpPath.actions;\r\n\t\t\t\ttmpShape.curves = tmpPath.curves;\r\n\t\t\t\tshapes.push( tmpShape );\r\n\t\t\t\treturn shapes;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\r\n\t\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\r\n\t\r\n\t\t\t// console.log(\"Holes first\", holesFirst);\r\n\t\r\n\t\t\tvar betterShapeHoles = [];\r\n\t\t\tvar newShapes = [];\r\n\t\t\tvar newShapeHoles = [];\r\n\t\t\tvar mainIdx = 0;\r\n\t\t\tvar tmpPoints;\r\n\t\r\n\t\t\tnewShapes[ mainIdx ] = undefined;\r\n\t\t\tnewShapeHoles[ mainIdx ] = [];\r\n\t\r\n\t\t\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\ttmpPath = subPaths[ i ];\r\n\t\t\t\ttmpPoints = tmpPath.getPoints();\r\n\t\t\t\tsolid = isClockWise( tmpPoints );\r\n\t\t\t\tsolid = isCCW ? ! solid : solid;\r\n\t\r\n\t\t\t\tif ( solid ) {\r\n\t\r\n\t\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\r\n\t\r\n\t\t\t\t\tnewShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };\r\n\t\t\t\t\tnewShapes[ mainIdx ].s.actions = tmpPath.actions;\r\n\t\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\r\n\t\r\n\t\t\t\t\tif ( holesFirst )\tmainIdx ++;\r\n\t\t\t\t\tnewShapeHoles[ mainIdx ] = [];\r\n\t\r\n\t\t\t\t\t//console.log('cw', i);\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\r\n\t\r\n\t\t\t\t\t//console.log('ccw', i);\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// only Holes? -> probably all Shapes with wrong orientation\r\n\t\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\r\n\t\r\n\t\r\n\t\t\tif ( newShapes.length > 1 ) {\r\n\t\r\n\t\t\t\tvar ambiguous = false;\r\n\t\t\t\tvar toChange = [];\r\n\t\r\n\t\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\r\n\t\r\n\t\t\t\t\tbetterShapeHoles[ sIdx ] = [];\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\r\n\t\r\n\t\t\t\t\tvar sho = newShapeHoles[ sIdx ];\r\n\t\r\n\t\t\t\t\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar ho = sho[ hIdx ];\r\n\t\t\t\t\t\tvar hole_unassigned = true;\r\n\t\r\n\t\t\t\t\t\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\r\n\t\r\n\t\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\r\n\t\t\t\t\t\t\t\tif ( hole_unassigned ) {\r\n\t\r\n\t\t\t\t\t\t\t\t\thole_unassigned = false;\r\n\t\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\r\n\t\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\t\t\t\tambiguous = true;\r\n\t\r\n\t\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( hole_unassigned ) {\r\n\t\r\n\t\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\t\t\t// console.log(\"ambiguous: \", ambiguous);\r\n\t\t\t\tif ( toChange.length > 0 ) {\r\n\t\r\n\t\t\t\t\t// console.log(\"to change: \", toChange);\r\n\t\t\t\t\tif ( ! ambiguous )\tnewShapeHoles = betterShapeHoles;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar tmpHoles;\r\n\t\r\n\t\t\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\ttmpShape = newShapes[ i ].s;\r\n\t\t\t\tshapes.push( tmpShape );\r\n\t\t\t\ttmpHoles = newShapeHoles[ i ];\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t//console.log(\"shape\", shapes);\r\n\t\r\n\t\t\treturn shapes;\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/extras/core/Shape.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * Defines a 2d shape plane using paths.\r\n\t **/\r\n\t\r\n\t// STEP 1 Create a path.\r\n\t// STEP 2 Turn path into shape.\r\n\t// STEP 3 ExtrudeGeometry takes in Shape/Shapes\r\n\t// STEP 3a - Extract points from each shape, turn to vertices\r\n\t// STEP 3b - Triangulate each shape, add faces.\r\n\t\r\n\tTHREE.Shape = function () {\r\n\t\r\n\t\tTHREE.Path.apply( this, arguments );\r\n\t\r\n\t\tthis.holes = [];\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.Shape.prototype = Object.assign( Object.create( THREE.Path.prototype ), {\r\n\t\r\n\t\tconstructor: THREE.Shape,\r\n\t\r\n\t\t// Convenience method to return ExtrudeGeometry\r\n\t\r\n\t\textrude: function ( options ) {\r\n\t\r\n\t\t\treturn new THREE.ExtrudeGeometry( this, options );\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Convenience method to return ShapeGeometry\r\n\t\r\n\t\tmakeGeometry: function ( options ) {\r\n\t\r\n\t\t\treturn new THREE.ShapeGeometry( this, options );\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgetPointsHoles: function ( divisions ) {\r\n\t\r\n\t\t\tvar holesPts = [];\r\n\t\r\n\t\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn holesPts;\r\n\t\r\n\t\t},\r\n\t\r\n\t\t// Get points of shape and holes (keypoints based on segments parameter)\r\n\t\r\n\t\textractAllPoints: function ( divisions ) {\r\n\t\r\n\t\t\treturn {\r\n\t\r\n\t\t\t\tshape: this.getPoints( divisions ),\r\n\t\t\t\tholes: this.getPointsHoles( divisions )\r\n\t\r\n\t\t\t};\r\n\t\r\n\t\t},\r\n\t\r\n\t\textractPoints: function ( divisions ) {\r\n\t\r\n\t\t\treturn this.extractAllPoints( divisions );\r\n\t\r\n\t\t}\r\n\t\r\n\t} );\r\n\t\r\n\t// File:src/extras/curves/LineCurve.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tLine\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.LineCurve = function ( v1, v2 ) {\r\n\t\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\tTHREE.LineCurve.prototype.constructor = THREE.LineCurve;\r\n\t\r\n\tTHREE.LineCurve.prototype.getPoint = function ( t ) {\r\n\t\r\n\t\tvar point = this.v2.clone().sub( this.v1 );\r\n\t\tpoint.multiplyScalar( t ).add( this.v1 );\r\n\t\r\n\t\treturn point;\r\n\t\r\n\t};\r\n\t\r\n\t// Line curve is linear, so we can overwrite default getPointAt\r\n\t\r\n\tTHREE.LineCurve.prototype.getPointAt = function ( u ) {\r\n\t\r\n\t\treturn this.getPoint( u );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LineCurve.prototype.getTangent = function( t ) {\r\n\t\r\n\t\tvar tangent = this.v2.clone().sub( this.v1 );\r\n\t\r\n\t\treturn tangent.normalize();\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/curves/QuadraticBezierCurve.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tQuadratic Bezier curve\r\n\t **************************************************************/\r\n\t\r\n\t\r\n\tTHREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {\r\n\t\r\n\t\tthis.v0 = v0;\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\tTHREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;\r\n\t\r\n\t\r\n\tTHREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {\r\n\t\r\n\t\tvar b2 = THREE.ShapeUtils.b2;\r\n\t\r\n\t\treturn new THREE.Vector2(\r\n\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\r\n\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y )\r\n\t\t);\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {\r\n\t\r\n\t\tvar tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;\r\n\t\r\n\t\treturn new THREE.Vector2(\r\n\t\t\ttangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),\r\n\t\t\ttangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )\r\n\t\t).normalize();\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/curves/CubicBezierCurve.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tCubic Bezier curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {\r\n\t\r\n\t\tthis.v0 = v0;\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\t\tthis.v3 = v3;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\tTHREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;\r\n\t\r\n\tTHREE.CubicBezierCurve.prototype.getPoint = function ( t ) {\r\n\t\r\n\t\tvar b3 = THREE.ShapeUtils.b3;\r\n\t\r\n\t\treturn new THREE.Vector2( \r\n\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\r\n\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\r\n\t\t);\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CubicBezierCurve.prototype.getTangent = function( t ) {\r\n\t\r\n\t\tvar tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;\r\n\t\r\n\t\treturn new THREE.Vector2( \r\n\t\t\ttangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\r\n\t\t\ttangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\r\n\t\t).normalize();\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/curves/SplineCurve.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tSpline curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.SplineCurve = function ( points /* array of Vector2 */ ) {\r\n\t\r\n\t\tthis.points = ( points == undefined ) ? [] : points;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\tTHREE.SplineCurve.prototype.constructor = THREE.SplineCurve;\r\n\t\r\n\tTHREE.SplineCurve.prototype.getPoint = function ( t ) {\r\n\t\r\n\t\tvar points = this.points;\r\n\t\tvar point = ( points.length - 1 ) * t;\r\n\t\r\n\t\tvar intPoint = Math.floor( point );\r\n\t\tvar weight = point - intPoint;\r\n\t\r\n\t\tvar point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\r\n\t\tvar point1 = points[ intPoint ];\r\n\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\r\n\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\r\n\t\r\n\t\tvar interpolate = THREE.CurveUtils.interpolate;\r\n\t\r\n\t\treturn new THREE.Vector2(\r\n\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\r\n\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight )\r\n\t\t);\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/curves/EllipseCurve.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tEllipse curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\t\r\n\t\tthis.aX = aX;\r\n\t\tthis.aY = aY;\r\n\t\r\n\t\tthis.xRadius = xRadius;\r\n\t\tthis.yRadius = yRadius;\r\n\t\r\n\t\tthis.aStartAngle = aStartAngle;\r\n\t\tthis.aEndAngle = aEndAngle;\r\n\t\r\n\t\tthis.aClockwise = aClockwise;\r\n\t\t\r\n\t\tthis.aRotation = aRotation || 0;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );\r\n\tTHREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;\r\n\t\r\n\tTHREE.EllipseCurve.prototype.getPoint = function ( t ) {\r\n\t\r\n\t\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\r\n\t\r\n\t\tif ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;\r\n\t\tif ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;\r\n\t\r\n\t\tvar angle;\r\n\t\r\n\t\tif ( this.aClockwise === true ) {\r\n\t\r\n\t\t\tangle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tangle = this.aStartAngle + t * deltaAngle;\r\n\t\r\n\t\t}\r\n\t\t\r\n\t\tvar x = this.aX + this.xRadius * Math.cos( angle );\r\n\t\tvar y = this.aY + this.yRadius * Math.sin( angle );\r\n\t\r\n\t\tif ( this.aRotation !== 0 ) {\r\n\t\r\n\t\t\tvar cos = Math.cos( this.aRotation );\r\n\t\t\tvar sin = Math.sin( this.aRotation );\r\n\t\r\n\t\t\tvar tx = x, ty = y;\r\n\t\r\n\t\t\t// Rotate the point about the center of the ellipse.\r\n\t\t\tx = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;\r\n\t\t\ty = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn new THREE.Vector2( x, y );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/curves/ArcCurve.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tArc curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\t\r\n\t\tTHREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );\r\n\tTHREE.ArcCurve.prototype.constructor = THREE.ArcCurve;\r\n\t\r\n\t// File:src/extras/curves/LineCurve3.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tLine3D\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.LineCurve3 = THREE.Curve.create(\r\n\t\r\n\t\tfunction ( v1, v2 ) {\r\n\t\r\n\t\t\tthis.v1 = v1;\r\n\t\t\tthis.v2 = v2;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfunction ( t ) {\r\n\t\r\n\t\t\tvar vector = new THREE.Vector3();\r\n\t\r\n\t\t\tvector.subVectors( this.v2, this.v1 ); // diff\r\n\t\t\tvector.multiplyScalar( t );\r\n\t\t\tvector.add( this.v1 );\r\n\t\r\n\t\t\treturn vector;\r\n\t\r\n\t\t}\r\n\t\r\n\t);\r\n\t\r\n\t// File:src/extras/curves/QuadraticBezierCurve3.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tQuadratic Bezier 3D curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.QuadraticBezierCurve3 = THREE.Curve.create(\r\n\t\r\n\t\tfunction ( v0, v1, v2 ) {\r\n\t\r\n\t\t\tthis.v0 = v0;\r\n\t\t\tthis.v1 = v1;\r\n\t\t\tthis.v2 = v2;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfunction ( t ) {\r\n\t\r\n\t\t\tvar b2 = THREE.ShapeUtils.b2;\t\t\r\n\t\r\n\t\t\treturn new THREE.Vector3(\r\n\t\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\r\n\t\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y ),\r\n\t\t\t\tb2( t, this.v0.z, this.v1.z, this.v2.z )\r\n\t\t\t);\r\n\t\r\n\t\t}\r\n\t\r\n\t);\r\n\t\r\n\t// File:src/extras/curves/CubicBezierCurve3.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tCubic Bezier 3D curve\r\n\t **************************************************************/\r\n\t\r\n\tTHREE.CubicBezierCurve3 = THREE.Curve.create(\r\n\t\r\n\t\tfunction ( v0, v1, v2, v3 ) {\r\n\t\r\n\t\t\tthis.v0 = v0;\r\n\t\t\tthis.v1 = v1;\r\n\t\t\tthis.v2 = v2;\r\n\t\t\tthis.v3 = v3;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfunction ( t ) {\r\n\t\r\n\t\t\tvar b3 = THREE.ShapeUtils.b3;\r\n\t\r\n\t\t\treturn new THREE.Vector3(\r\n\t\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\r\n\t\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),\r\n\t\t\t\tb3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )\r\n\t\t\t);\r\n\t\r\n\t\t}\r\n\t\r\n\t);\r\n\t\r\n\t// File:src/extras/curves/SplineCurve3.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tSpline 3D curve\r\n\t **************************************************************/\r\n\t\r\n\t\r\n\tTHREE.SplineCurve3 = THREE.Curve.create(\r\n\t\r\n\t\tfunction ( points /* array of Vector3 */ ) {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );\r\n\t\t\tthis.points = ( points == undefined ) ? [] : points;\r\n\t\r\n\t\t},\r\n\t\r\n\t\tfunction ( t ) {\r\n\t\r\n\t\t\tvar points = this.points;\r\n\t\t\tvar point = ( points.length - 1 ) * t;\r\n\t\r\n\t\t\tvar intPoint = Math.floor( point );\r\n\t\t\tvar weight = point - intPoint;\r\n\t\r\n\t\t\tvar point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];\r\n\t\t\tvar point1 = points[ intPoint ];\r\n\t\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\r\n\t\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\r\n\t\r\n\t\t\tvar interpolate = THREE.CurveUtils.interpolate;\r\n\t\r\n\t\t\treturn new THREE.Vector3(\r\n\t\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\r\n\t\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight ),\r\n\t\t\t\tinterpolate( point0.z, point1.z, point2.z, point3.z, weight )\r\n\t\t\t);\r\n\t\r\n\t\t}\r\n\t\r\n\t);\r\n\t\r\n\t// File:src/extras/curves/CatmullRomCurve3.js\r\n\t\r\n\t/**\r\n\t * @author zz85 https://github.com/zz85\r\n\t *\r\n\t * Centripetal CatmullRom Curve - which is useful for avoiding\r\n\t * cusps and self-intersections in non-uniform catmull rom curves.\r\n\t * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\r\n\t *\r\n\t * curve.type accepts centripetal(default), chordal and catmullrom\r\n\t * curve.tension is used for catmullrom which defaults to 0.5\r\n\t */\r\n\t\r\n\tTHREE.CatmullRomCurve3 = ( function() {\r\n\t\r\n\t\tvar\r\n\t\t\ttmp = new THREE.Vector3(),\r\n\t\t\tpx = new CubicPoly(),\r\n\t\t\tpy = new CubicPoly(),\r\n\t\t\tpz = new CubicPoly();\r\n\t\r\n\t\t/*\r\n\t\tBased on an optimized c++ solution in\r\n\t\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\r\n\t\t - http://ideone.com/NoEbVM\r\n\t\r\n\t\tThis CubicPoly class could be used for reusing some variables and calculations,\r\n\t\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\r\n\t\twhich can be placed in CurveUtils.\r\n\t\t*/\r\n\t\r\n\t\tfunction CubicPoly() {\r\n\t\r\n\t\t}\r\n\t\r\n\t\t/*\r\n\t\t * Compute coefficients for a cubic polynomial\r\n\t\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\r\n\t\t * such that\r\n\t\t *   p(0) = x0, p(1) = x1\r\n\t\t *  and\r\n\t\t *   p'(0) = t0, p'(1) = t1.\r\n\t\t */\r\n\t\tCubicPoly.prototype.init = function( x0, x1, t0, t1 ) {\r\n\t\r\n\t\t\tthis.c0 = x0;\r\n\t\t\tthis.c1 = t0;\r\n\t\t\tthis.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\r\n\t\t\tthis.c3 = 2 * x0 - 2 * x1 + t0 + t1;\r\n\t\r\n\t\t};\r\n\t\r\n\t\tCubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {\r\n\t\r\n\t\t\t// compute tangents when parameterized in [t1,t2]\r\n\t\t\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\r\n\t\t\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\r\n\t\r\n\t\t\t// rescale tangents for parametrization in [0,1]\r\n\t\t\tt1 *= dt1;\r\n\t\t\tt2 *= dt1;\r\n\t\r\n\t\t\t// initCubicPoly\r\n\t\t\tthis.init( x1, x2, t1, t2 );\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4\r\n\t\tCubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {\r\n\t\r\n\t\t\tthis.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\r\n\t\r\n\t\t};\r\n\t\r\n\t\tCubicPoly.prototype.calc = function( t ) {\r\n\t\r\n\t\t\tvar t2 = t * t;\r\n\t\t\tvar t3 = t2 * t;\r\n\t\t\treturn this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;\r\n\t\r\n\t\t};\r\n\t\r\n\t\t// Subclass Three.js curve\r\n\t\treturn THREE.Curve.create(\r\n\t\r\n\t\t\tfunction ( p /* array of Vector3 */ ) {\r\n\t\r\n\t\t\t\tthis.points = p || [];\r\n\t\t\t\tthis.closed = false;\r\n\t\r\n\t\t\t},\r\n\t\r\n\t\t\tfunction ( t ) {\r\n\t\r\n\t\t\t\tvar points = this.points,\r\n\t\t\t\t\tpoint, intPoint, weight, l;\r\n\t\r\n\t\t\t\tl = points.length;\r\n\t\r\n\t\t\t\tif ( l < 2 ) console.log( 'duh, you need at least 2 points' );\r\n\t\r\n\t\t\t\tpoint = ( l - ( this.closed ? 0 : 1 ) ) * t;\r\n\t\t\t\tintPoint = Math.floor( point );\r\n\t\t\t\tweight = point - intPoint;\r\n\t\r\n\t\t\t\tif ( this.closed ) {\r\n\t\r\n\t\t\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\r\n\t\r\n\t\t\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\r\n\t\r\n\t\t\t\t\tintPoint = l - 2;\r\n\t\t\t\t\tweight = 1;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar p0, p1, p2, p3; // 4 points\r\n\t\r\n\t\t\t\tif ( this.closed || intPoint > 0 ) {\r\n\t\r\n\t\t\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// extrapolate first point\r\n\t\t\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\r\n\t\t\t\t\tp0 = tmp;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tp1 = points[ intPoint % l ];\r\n\t\t\t\tp2 = points[ ( intPoint + 1 ) % l ];\r\n\t\r\n\t\t\t\tif ( this.closed || intPoint + 2 < l ) {\r\n\t\r\n\t\t\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// extrapolate last point\r\n\t\t\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\r\n\t\t\t\t\tp3 = tmp;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {\r\n\t\r\n\t\t\t\t\t// init Centripetal / Chordal Catmull-Rom\r\n\t\t\t\t\tvar pow = this.type === 'chordal' ? 0.5 : 0.25;\r\n\t\t\t\t\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\r\n\t\t\t\t\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\r\n\t\t\t\t\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\r\n\t\r\n\t\t\t\t\t// safety check for repeated points\r\n\t\t\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\r\n\t\t\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\r\n\t\t\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\r\n\t\r\n\t\t\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\r\n\t\t\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\r\n\t\t\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\r\n\t\r\n\t\t\t\t} else if ( this.type === 'catmullrom' ) {\r\n\t\r\n\t\t\t\t\tvar tension = this.tension !== undefined ? this.tension : 0.5;\r\n\t\t\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );\r\n\t\t\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );\r\n\t\t\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar v = new THREE.Vector3(\r\n\t\t\t\t\tpx.calc( weight ),\r\n\t\t\t\t\tpy.calc( weight ),\r\n\t\t\t\t\tpz.calc( weight )\r\n\t\t\t\t);\r\n\t\r\n\t\t\t\treturn v;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t);\r\n\t\r\n\t} )();\r\n\t\r\n\t// File:src/extras/curves/ClosedSplineCurve3.js\r\n\t\r\n\t/**************************************************************\r\n\t *\tClosed Spline 3D curve\r\n\t **************************************************************/\r\n\t\r\n\t\r\n\tTHREE.ClosedSplineCurve3 = function ( points ) {\r\n\t\r\n\t\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );\r\n\t\r\n\t\tTHREE.CatmullRomCurve3.call( this, points );\r\n\t\tthis.type = 'catmullrom';\r\n\t\tthis.closed = true;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ClosedSplineCurve3.prototype = Object.create( THREE.CatmullRomCurve3.prototype );\r\n\t\r\n\t// File:src/extras/geometries/BoxGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\r\n\t */\r\n\t\r\n\tTHREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'BoxGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\twidth: width,\r\n\t\t\theight: height,\r\n\t\t\tdepth: depth,\r\n\t\t\twidthSegments: widthSegments,\r\n\t\t\theightSegments: heightSegments,\r\n\t\t\tdepthSegments: depthSegments\r\n\t\t};\r\n\t\r\n\t\tthis.fromBufferGeometry( new THREE.BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\r\n\t\tthis.mergeVertices();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;\r\n\t\r\n\tTHREE.CubeGeometry = THREE.BoxGeometry;\r\n\t\r\n\t// File:src/extras/geometries/BoxBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author Mugen87 / https://github.com/Mugen87\r\n\t */\r\n\t\r\n\tTHREE.BoxBufferGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'BoxBufferGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\twidth: width,\r\n\t\t\theight: height,\r\n\t\t\tdepth: depth,\r\n\t\t\twidthSegments: widthSegments,\r\n\t\t\theightSegments: heightSegments,\r\n\t\t\tdepthSegments: depthSegments\r\n\t\t};\r\n\t\r\n\t\tvar scope = this;\r\n\t\r\n\t\t// segments\r\n\t\twidthSegments = Math.floor( widthSegments ) || 1;\r\n\t\theightSegments = Math.floor( heightSegments ) || 1;\r\n\t\tdepthSegments = Math.floor( depthSegments ) || 1;\r\n\t\r\n\t\t// these are used to calculate buffer length\r\n\t\tvar vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );\r\n\t\tvar indexCount = calculateIndexCount( widthSegments, heightSegments, depthSegments );\r\n\t\r\n\t\t// buffers\r\n\t\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\r\n\t\tvar vertices = new Float32Array( vertexCount * 3 );\r\n\t\tvar normals = new Float32Array( vertexCount * 3 );\r\n\t\tvar uvs = new Float32Array( vertexCount * 2 );\r\n\t\r\n\t\t// offset variables\r\n\t\tvar vertexBufferOffset = 0;\r\n\t\tvar uvBufferOffset = 0;\r\n\t\tvar indexBufferOffset = 0;\r\n\t\tvar numberOfVertices = 0;\r\n\t\r\n\t\t// group variables\r\n\t\tvar groupStart = 0;\r\n\t\r\n\t\t// build each side of the box geometry\r\n\t\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px\r\n\t\tbuildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx\r\n\t\tbuildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py\r\n\t\tbuildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny\r\n\t\tbuildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz\r\n\t\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz\r\n\t\r\n\t\t// build geometry\r\n\t\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\t\r\n\t\t// helper functions\r\n\t\r\n\t\tfunction calculateVertexCount ( w, h, d ) {\r\n\t\r\n\t\t\tvar vertices = 0;\r\n\t\r\n\t\t\t// calculate the amount of vertices for each side (plane)\r\n\t\t\tvertices += (w + 1) * (h + 1) * 2; // xy\r\n\t\t\tvertices += (w + 1) * (d + 1) * 2; // xz\r\n\t\t\tvertices += (d + 1) * (h + 1) * 2; // zy\r\n\t\r\n\t\t\treturn vertices;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction calculateIndexCount ( w, h, d ) {\r\n\t\r\n\t\t\tvar index = 0;\r\n\t\r\n\t\t\t// calculate the amount of squares for each side\r\n\t\t\tindex += w * h * 2; // xy\r\n\t\t\tindex += w * d * 2; // xz\r\n\t\t\tindex += d * h * 2; // zy\r\n\t\r\n\t\t\treturn index * 6; // two triangles per square => six vertices per square\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction buildPlane ( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\r\n\t\r\n\t\t\tvar segmentWidth\t= width / gridX;\r\n\t\t\tvar segmentHeight = height / gridY;\r\n\t\r\n\t\t\tvar widthHalf = width / 2;\r\n\t\t\tvar heightHalf = height / 2;\r\n\t\t\tvar depthHalf = depth / 2;\r\n\t\r\n\t\t\tvar gridX1 = gridX + 1;\r\n\t\t\tvar gridY1 = gridY + 1;\r\n\t\r\n\t\t\tvar vertexCounter = 0;\r\n\t\t\tvar groupCount = 0;\r\n\t\r\n\t\t\tvar vector = new THREE.Vector3();\r\n\t\r\n\t\t\t// generate vertices, normals and uvs\r\n\t\r\n\t\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\r\n\t\r\n\t\t\t\tvar y = iy * segmentHeight - heightHalf;\r\n\t\r\n\t\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\r\n\t\r\n\t\t\t\t\tvar x = ix * segmentWidth - widthHalf;\r\n\t\r\n\t\t\t\t\t// set values to correct vector component\r\n\t\t\t\t\tvector[ u ] = x * udir;\r\n\t\t\t\t\tvector[ v ] = y * vdir;\r\n\t\t\t\t\tvector[ w ] = depthHalf;\r\n\t\r\n\t\t\t\t\t// now apply vector to vertex buffer\r\n\t\t\t\t\tvertices[ vertexBufferOffset ] = vector.x;\r\n\t\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vector.y;\r\n\t\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vector.z;\r\n\t\r\n\t\t\t\t\t// set values to correct vector component\r\n\t\t\t\t\tvector[ u ] = 0;\r\n\t\t\t\t\tvector[ v ] = 0;\r\n\t\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\r\n\t\r\n\t\t\t\t\t// now apply vector to normal buffer\r\n\t\t\t\t\tnormals[ vertexBufferOffset ] = vector.x;\r\n\t\t\t\t\tnormals[ vertexBufferOffset + 1 ] = vector.y;\r\n\t\t\t\t\tnormals[ vertexBufferOffset + 2 ] = vector.z;\r\n\t\r\n\t\t\t\t\t// uvs\r\n\t\t\t\t\tuvs[ uvBufferOffset ] = ix / gridX;\r\n\t\t\t\t\tuvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );\r\n\t\r\n\t\t\t\t\t// update offsets and counters\r\n\t\t\t\t\tvertexBufferOffset += 3;\r\n\t\t\t\t\tuvBufferOffset += 2;\r\n\t\t\t\t\tvertexCounter += 1;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// 1. you need three indices to draw a single face\r\n\t\t\t// 2. a single segment consists of two faces\r\n\t\t\t// 3. so we need to generate six (2*3) indices per segment\r\n\t\r\n\t\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\r\n\t\r\n\t\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\r\n\t\r\n\t\t\t\t\t// indices\r\n\t\t\t\t\tvar a = numberOfVertices + ix + gridX1 * iy;\r\n\t\t\t\t\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\r\n\t\t\t\t\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n\t\t\t\t\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\r\n\t\r\n\t\t\t\t\t// face one\r\n\t\t\t\t\tindices[ indexBufferOffset ] = a;\r\n\t\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\r\n\t\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\r\n\t\r\n\t\t\t\t\t// face two\r\n\t\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\r\n\t\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\r\n\t\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\r\n\t\r\n\t\t\t\t\t// update offsets and counters\r\n\t\t\t\t\tindexBufferOffset += 6;\r\n\t\t\t\t\tgroupCount += 6;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// add a group to the geometry. this will ensure multi material support\r\n\t\t\tscope.addGroup( groupStart, groupCount, materialIndex );\r\n\t\r\n\t\t\t// calculate new start value for groups\r\n\t\t\tgroupStart += groupCount;\r\n\t\r\n\t\t\t// update total number of vertices\r\n\t\t\tnumberOfVertices += vertexCounter;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BoxBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.BoxBufferGeometry.prototype.constructor = THREE.BoxBufferGeometry;\r\n\t\r\n\t// File:src/extras/geometries/CircleGeometry.js\r\n\t\r\n\t/**\r\n\t * @author hughes\r\n\t */\r\n\t\r\n\tTHREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'CircleGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tsegments: segments,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t\tthis.fromBufferGeometry( new THREE.CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;\r\n\t\r\n\t// File:src/extras/geometries/CircleBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author benaadams / https://twitter.com/ben_a_adams\r\n\t */\r\n\t\r\n\tTHREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'CircleBufferGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tsegments: segments,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t\tradius = radius || 50;\r\n\t\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\r\n\t\r\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\t\r\n\t\tvar vertices = segments + 2;\r\n\t\r\n\t\tvar positions = new Float32Array( vertices * 3 );\r\n\t\tvar normals = new Float32Array( vertices * 3 );\r\n\t\tvar uvs = new Float32Array( vertices * 2 );\r\n\t\r\n\t\t// center data is already zero, but need to set a few extras\r\n\t\tnormals[ 2 ] = 1.0;\r\n\t\tuvs[ 0 ] = 0.5;\r\n\t\tuvs[ 1 ] = 0.5;\r\n\t\r\n\t\tfor ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {\r\n\t\r\n\t\t\tvar segment = thetaStart + s / segments * thetaLength;\r\n\t\r\n\t\t\tpositions[ i ] = radius * Math.cos( segment );\r\n\t\t\tpositions[ i + 1 ] = radius * Math.sin( segment );\r\n\t\r\n\t\t\tnormals[ i + 2 ] = 1; // normal z\r\n\t\r\n\t\t\tuvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;\r\n\t\t\tuvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar indices = [];\r\n\t\r\n\t\tfor ( var i = 1; i <= segments; i ++ ) {\r\n\t\r\n\t\t\tindices.push( i, i + 1, 0 );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );\r\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\r\n\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\t\r\n\t\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;\r\n\t\r\n\t// File:src/extras/geometries/CylinderBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author Mugen87 / https://github.com/Mugen87\r\n\t */\r\n\t\r\n\tTHREE.CylinderBufferGeometry = function( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'CylinderBufferGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradiusTop: radiusTop,\r\n\t\t\tradiusBottom: radiusBottom,\r\n\t\t\theight: height,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\theightSegments: heightSegments,\r\n\t\t\topenEnded: openEnded,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t\tvar scope = this;\r\n\t\r\n\t\tradiusTop = radiusTop !== undefined ? radiusTop : 20;\r\n\t\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\r\n\t\theight = height !== undefined ? height : 100;\r\n\t\r\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\r\n\t\theightSegments = Math.floor( heightSegments ) || 1;\r\n\t\r\n\t\topenEnded = openEnded !== undefined ? openEnded : false;\r\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0.0;\r\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;\r\n\t\r\n\t\t// used to calculate buffer length\r\n\t\r\n\t\tvar nbCap = 0;\r\n\t\r\n\t\tif ( openEnded === false ) {\r\n\t\r\n\t\t\tif ( radiusTop > 0 ) nbCap ++;\r\n\t\t\tif ( radiusBottom > 0 ) nbCap ++;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar vertexCount = calculateVertexCount();\r\n\t\tvar indexCount = calculateIndexCount();\r\n\t\r\n\t\t// buffers\r\n\t\r\n\t\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );\r\n\t\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\t\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\t\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\t\r\n\t\t// helper variables\r\n\t\r\n\t\tvar index = 0,\r\n\t\t    indexOffset = 0,\r\n\t\t    indexArray = [],\r\n\t\t    halfHeight = height / 2;\r\n\t\r\n\t\t// group variables\r\n\t\tvar groupStart = 0;\r\n\t\r\n\t\t// generate geometry\r\n\t\r\n\t\tgenerateTorso();\r\n\t\r\n\t\tif ( openEnded === false ) {\r\n\t\r\n\t\t\tif ( radiusTop > 0 ) generateCap( true );\r\n\t\t\tif ( radiusBottom > 0 ) generateCap( false );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// build geometry\r\n\t\r\n\t\tthis.setIndex( indices );\r\n\t\tthis.addAttribute( 'position', vertices );\r\n\t\tthis.addAttribute( 'normal', normals );\r\n\t\tthis.addAttribute( 'uv', uvs );\r\n\t\r\n\t\t// helper functions\r\n\t\r\n\t\tfunction calculateVertexCount() {\r\n\t\r\n\t\t\tvar count = ( radialSegments + 1 ) * ( heightSegments + 1 );\r\n\t\r\n\t\t\tif ( openEnded === false ) {\r\n\t\r\n\t\t\t\tcount += ( ( radialSegments + 1 ) * nbCap ) + ( radialSegments * nbCap );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn count;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction calculateIndexCount() {\r\n\t\r\n\t\t\tvar count = radialSegments * heightSegments * 2 * 3;\r\n\t\r\n\t\t\tif ( openEnded === false ) {\r\n\t\r\n\t\t\t\tcount += radialSegments * nbCap * 3;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn count;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction generateTorso() {\r\n\t\r\n\t\t\tvar x, y;\r\n\t\t\tvar normal = new THREE.Vector3();\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\t\r\n\t\t\tvar groupCount = 0;\r\n\t\r\n\t\t\t// this will be used to calculate the normal\r\n\t\t\tvar tanTheta = ( radiusBottom - radiusTop ) / height;\r\n\t\r\n\t\t\t// generate vertices, normals and uvs\r\n\t\r\n\t\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\r\n\t\r\n\t\t\t\tvar indexRow = [];\r\n\t\r\n\t\t\t\tvar v = y / heightSegments;\r\n\t\r\n\t\t\t\t// calculate the radius of the current row\r\n\t\t\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\r\n\t\r\n\t\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\r\n\t\r\n\t\t\t\t\tvar u = x / radialSegments;\r\n\t\r\n\t\t\t\t\t// vertex\r\n\t\t\t\t\tvertex.x = radius * Math.sin( u * thetaLength + thetaStart );\r\n\t\t\t\t\tvertex.y = - v * height + halfHeight;\r\n\t\t\t\t\tvertex.z = radius * Math.cos( u * thetaLength + thetaStart );\r\n\t\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\r\n\t\r\n\t\t\t\t\t// normal\r\n\t\t\t\t\tnormal.copy( vertex );\r\n\t\r\n\t\t\t\t\t// handle special case if radiusTop/radiusBottom is zero\r\n\t\r\n\t\t\t\t\tif ( ( radiusTop === 0 && y === 0 ) || ( radiusBottom === 0 && y === heightSegments ) ) {\r\n\t\r\n\t\t\t\t\t\tnormal.x = Math.sin( u * thetaLength + thetaStart );\r\n\t\t\t\t\t\tnormal.z = Math.cos( u * thetaLength + thetaStart );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tnormal.setY( Math.sqrt( normal.x * normal.x + normal.z * normal.z ) * tanTheta ).normalize();\r\n\t\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\r\n\t\r\n\t\t\t\t\t// uv\r\n\t\t\t\t\tuvs.setXY( index, u, 1 - v );\r\n\t\r\n\t\t\t\t\t// save index of vertex in respective row\r\n\t\t\t\t\tindexRow.push( index );\r\n\t\r\n\t\t\t\t\t// increase index\r\n\t\t\t\t\tindex ++;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// now save vertices of the row in our index array\r\n\t\t\t\tindexArray.push( indexRow );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// generate indices\r\n\t\r\n\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\r\n\t\r\n\t\t\t\tfor ( y = 0; y < heightSegments; y ++ ) {\r\n\t\r\n\t\t\t\t\t// we use the index array to access the correct indices\r\n\t\t\t\t\tvar i1 = indexArray[ y ][ x ];\r\n\t\t\t\t\tvar i2 = indexArray[ y + 1 ][ x ];\r\n\t\t\t\t\tvar i3 = indexArray[ y + 1 ][ x + 1 ];\r\n\t\t\t\t\tvar i4 = indexArray[ y ][ x + 1 ];\r\n\t\r\n\t\t\t\t\t// face one\r\n\t\t\t\t\tindices.setX( indexOffset, i1 ); indexOffset ++;\r\n\t\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\r\n\t\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\r\n\t\r\n\t\t\t\t\t// face two\r\n\t\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\r\n\t\t\t\t\tindices.setX( indexOffset, i3 ); indexOffset ++;\r\n\t\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\r\n\t\r\n\t\t\t\t\t// update counters\r\n\t\t\t\t\tgroupCount += 6;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// add a group to the geometry. this will ensure multi material support\r\n\t\t\tscope.addGroup( groupStart, groupCount, 0 );\r\n\t\r\n\t\t\t// calculate new start value for groups\r\n\t\t\tgroupStart += groupCount;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction generateCap( top ) {\r\n\t\r\n\t\t\tvar x, centerIndexStart, centerIndexEnd;\r\n\t\r\n\t\t\tvar uv = new THREE.Vector2();\r\n\t\t\tvar vertex = new THREE.Vector3();\r\n\t\r\n\t\t\tvar groupCount = 0;\r\n\t\r\n\t\t\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\r\n\t\t\tvar sign = ( top === true ) ? 1 : - 1;\r\n\t\r\n\t\t\t// save the index of the first center vertex\r\n\t\t\tcenterIndexStart = index;\r\n\t\r\n\t\t\t// first we generate the center vertex data of the cap.\r\n\t\t\t// because the geometry needs one set of uvs per face,\r\n\t\t\t// we must generate a center vertex per face/segment\r\n\t\r\n\t\t\tfor ( x = 1; x <= radialSegments; x ++ ) {\r\n\t\r\n\t\t\t\t// vertex\r\n\t\t\t\tvertices.setXYZ( index, 0, halfHeight * sign, 0 );\r\n\t\r\n\t\t\t\t// normal\r\n\t\t\t\tnormals.setXYZ( index, 0, sign, 0 );\r\n\t\r\n\t\t\t\t// uv\r\n\t\t\t\tuv.x = 0.5;\r\n\t\t\t\tuv.y = 0.5;\r\n\t\r\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\r\n\t\r\n\t\t\t\t// increase index\r\n\t\t\t\tindex ++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// save the index of the last center vertex\r\n\t\t\tcenterIndexEnd = index;\r\n\t\r\n\t\t\t// now we generate the surrounding vertices, normals and uvs\r\n\t\r\n\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\r\n\t\r\n\t\t\t\tvar u = x / radialSegments;\r\n\t\t\t\tvar theta = u * thetaLength + thetaStart;\r\n\t\r\n\t\t\t\tvar cosTheta = Math.cos( theta );\r\n\t\t\t\tvar sinTheta = Math.sin( theta );\r\n\t\r\n\t\t\t\t// vertex\r\n\t\t\t\tvertex.x = radius * sinTheta;\r\n\t\t\t\tvertex.y = halfHeight * sign;\r\n\t\t\t\tvertex.z = radius * cosTheta;\r\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\r\n\t\r\n\t\t\t\t// normal\r\n\t\t\t\tnormals.setXYZ( index, 0, sign, 0 );\r\n\t\r\n\t\t\t\t// uv\r\n\t\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\r\n\t\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\r\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\r\n\t\r\n\t\t\t\t// increase index\r\n\t\t\t\tindex ++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// generate indices\r\n\t\r\n\t\t\tfor ( x = 0; x < radialSegments; x ++ ) {\r\n\t\r\n\t\t\t\tvar c = centerIndexStart + x;\r\n\t\t\t\tvar i = centerIndexEnd + x;\r\n\t\r\n\t\t\t\tif ( top === true ) {\r\n\t\r\n\t\t\t\t\t// face top\r\n\t\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\r\n\t\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\r\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// face bottom\r\n\t\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\r\n\t\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\r\n\t\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// update counters\r\n\t\t\t\tgroupCount += 3;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// add a group to the geometry. this will ensure multi material support\r\n\t\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\r\n\t\r\n\t\t\t// calculate new start value for groups\r\n\t\t\tgroupStart += groupCount;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CylinderBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.CylinderBufferGeometry.prototype.constructor = THREE.CylinderBufferGeometry;\r\n\t\r\n\t// File:src/extras/geometries/CylinderGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'CylinderGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradiusTop: radiusTop,\r\n\t\t\tradiusBottom: radiusBottom,\r\n\t\t\theight: height,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\theightSegments: heightSegments,\r\n\t\t\topenEnded: openEnded,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t\tthis.fromBufferGeometry( new THREE.CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\r\n\t\tthis.mergeVertices();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;\r\n\t\r\n\t// File:src/extras/geometries/ConeBufferGeometry.js\r\n\t\r\n\t/*\r\n\t * @author: abelnation / http://github.com/abelnation\r\n\t */\r\n\t\r\n\tTHREE.ConeBufferGeometry = function (\r\n\t\tradius, height,\r\n\t\tradialSegments, heightSegments,\r\n\t\topenEnded, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.CylinderBufferGeometry.call( this,\r\n\t\t\t0, radius, height,\r\n\t\t\tradialSegments, heightSegments,\r\n\t\t\topenEnded, thetaStart, thetaLength );\r\n\t\r\n\t\tthis.type = 'ConeBufferGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\theight: height,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\theightSegments: heightSegments,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ConeBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.ConeBufferGeometry.prototype.constructor = THREE.ConeBufferGeometry;\r\n\t\r\n\t// File:src/extras/geometries/ConeGeometry.js\r\n\t\r\n\t/**\r\n\t * @author abelnation / http://github.com/abelnation\r\n\t */\r\n\t\r\n\tTHREE.ConeGeometry = function (\r\n\t\tradius, height,\r\n\t\tradialSegments, heightSegments,\r\n\t\topenEnded, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.CylinderGeometry.call( this,\r\n\t\t\t0, radius, height,\r\n\t\t\tradialSegments, heightSegments,\r\n\t\t\topenEnded, thetaStart, thetaLength );\r\n\t\r\n\t\tthis.type = 'ConeGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\theight: height,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\theightSegments: heightSegments,\r\n\t\t\topenEnded: openEnded,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ConeGeometry.prototype = Object.create( THREE.CylinderGeometry.prototype );\r\n\tTHREE.ConeGeometry.prototype.constructor = THREE.ConeGeometry;\r\n\t\r\n\t// File:src/extras/geometries/EdgesGeometry.js\r\n\t\r\n\t/**\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\tTHREE.EdgesGeometry = function ( geometry, thresholdAngle ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\r\n\t\r\n\t\tvar thresholdDot = Math.cos( THREE.Math.DEG2RAD * thresholdAngle );\r\n\t\r\n\t\tvar edge = [ 0, 0 ], hash = {};\r\n\t\r\n\t\tfunction sortFunction( a, b ) {\r\n\t\r\n\t\t\treturn a - b;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar keys = [ 'a', 'b', 'c' ];\r\n\t\r\n\t\tvar geometry2;\r\n\t\r\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\tgeometry2 = new THREE.Geometry();\r\n\t\t\tgeometry2.fromBufferGeometry( geometry );\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tgeometry2 = geometry.clone();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tgeometry2.mergeVertices();\r\n\t\tgeometry2.computeFaceNormals();\r\n\t\r\n\t\tvar vertices = geometry2.vertices;\r\n\t\tvar faces = geometry2.faces;\r\n\t\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\t\r\n\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\r\n\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\r\n\t\t\t\tedge.sort( sortFunction );\r\n\t\r\n\t\t\t\tvar key = edge.toString();\r\n\t\r\n\t\t\t\tif ( hash[ key ] === undefined ) {\r\n\t\r\n\t\t\t\t\thash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\thash[ key ].face2 = i;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar coords = [];\r\n\t\r\n\t\tfor ( var key in hash ) {\r\n\t\r\n\t\t\tvar h = hash[ key ];\r\n\t\r\n\t\t\tif ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {\r\n\t\r\n\t\t\t\tvar vertex = vertices[ h.vert1 ];\r\n\t\t\t\tcoords.push( vertex.x );\r\n\t\t\t\tcoords.push( vertex.y );\r\n\t\t\t\tcoords.push( vertex.z );\r\n\t\r\n\t\t\t\tvertex = vertices[ h.vert2 ];\r\n\t\t\t\tcoords.push( vertex.x );\r\n\t\t\t\tcoords.push( vertex.y );\r\n\t\t\t\tcoords.push( vertex.z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;\r\n\t\r\n\t// File:src/extras/geometries/ExtrudeGeometry.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t *\r\n\t * Creates extruded geometry from a path shape.\r\n\t *\r\n\t * parameters = {\r\n\t *\r\n\t *  curveSegments: <int>, // number of points on the curves\r\n\t *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\r\n\t *  amount: <int>, // Depth to extrude the shape\r\n\t *\r\n\t *  bevelEnabled: <bool>, // turn on bevel\r\n\t *  bevelThickness: <float>, // how deep into the original shape bevel goes\r\n\t *  bevelSize: <float>, // how far from shape outline is bevel\r\n\t *  bevelSegments: <int>, // number of bevel layers\r\n\t *\r\n\t *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\r\n\t *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\r\n\t *\r\n\t *  uvGenerator: <Object> // object that provides UV generator functions\r\n\t *\r\n\t * }\r\n\t **/\r\n\t\r\n\tTHREE.ExtrudeGeometry = function ( shapes, options ) {\r\n\t\r\n\t\tif ( typeof( shapes ) === \"undefined\" ) {\r\n\t\r\n\t\t\tshapes = [];\r\n\t\t\treturn;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'ExtrudeGeometry';\r\n\t\r\n\t\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\r\n\t\r\n\t\tthis.addShapeList( shapes, options );\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\r\n\t\t// can't really use automatic vertex normals\r\n\t\t// as then front and back sides get smoothed too\r\n\t\t// should do separate smoothing just for sides\r\n\t\r\n\t\t//this.computeVertexNormals();\r\n\t\r\n\t\t//console.log( \"took\", ( Date.now() - startTime ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;\r\n\t\r\n\tTHREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\t\r\n\t\tvar sl = shapes.length;\r\n\t\r\n\t\tfor ( var s = 0; s < sl; s ++ ) {\r\n\t\r\n\t\t\tvar shape = shapes[ s ];\r\n\t\t\tthis.addShape( shape, options );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {\r\n\t\r\n\t\tvar amount = options.amount !== undefined ? options.amount : 100;\r\n\t\r\n\t\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\r\n\t\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\r\n\t\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\r\n\t\r\n\t\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\r\n\t\r\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\t\r\n\t\tvar steps = options.steps !== undefined ? options.steps : 1;\r\n\t\r\n\t\tvar extrudePath = options.extrudePath;\r\n\t\tvar extrudePts, extrudeByPath = false;\r\n\t\r\n\t\t// Use default WorldUVGenerator if no UV generators are specified.\r\n\t\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\r\n\t\r\n\t\tvar splineTube, binormal, normal, position2;\r\n\t\tif ( extrudePath ) {\r\n\t\r\n\t\t\textrudePts = extrudePath.getSpacedPoints( steps );\r\n\t\r\n\t\t\textrudeByPath = true;\r\n\t\t\tbevelEnabled = false; // bevels not supported for path extrusion\r\n\t\r\n\t\t\t// SETUP TNB variables\r\n\t\r\n\t\t\t// Reuse TNB from TubeGeomtry for now.\r\n\t\t\t// TODO1 - have a .isClosed in spline?\r\n\t\r\n\t\t\tsplineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );\r\n\t\r\n\t\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\r\n\t\r\n\t\t\tbinormal = new THREE.Vector3();\r\n\t\t\tnormal = new THREE.Vector3();\r\n\t\t\tposition2 = new THREE.Vector3();\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Safeguards if bevels are not enabled\r\n\t\r\n\t\tif ( ! bevelEnabled ) {\r\n\t\r\n\t\t\tbevelSegments = 0;\r\n\t\t\tbevelThickness = 0;\r\n\t\t\tbevelSize = 0;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Variables initialization\r\n\t\r\n\t\tvar ahole, h, hl; // looping of holes\r\n\t\tvar scope = this;\r\n\t\r\n\t\tvar shapesOffset = this.vertices.length;\r\n\t\r\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\r\n\t\r\n\t\tvar vertices = shapePoints.shape;\r\n\t\tvar holes = shapePoints.holes;\r\n\t\r\n\t\tvar reverse = ! THREE.ShapeUtils.isClockWise( vertices );\r\n\t\r\n\t\tif ( reverse ) {\r\n\t\r\n\t\t\tvertices = vertices.reverse();\r\n\t\r\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\r\n\t\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tahole = holes[ h ];\r\n\t\r\n\t\t\t\tif ( THREE.ShapeUtils.isClockWise( ahole ) ) {\r\n\t\r\n\t\t\t\t\tholes[ h ] = ahole.reverse();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\tvar faces = THREE.ShapeUtils.triangulateShape( vertices, holes );\r\n\t\r\n\t\t/* Vertices */\r\n\t\r\n\t\tvar contour = vertices; // vertices has all points but contour has only points of circumference\r\n\t\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\tahole = holes[ h ];\r\n\t\r\n\t\t\tvertices = vertices.concat( ahole );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\tfunction scalePt2 ( pt, vec, size ) {\r\n\t\r\n\t\t\tif ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\r\n\t\r\n\t\t\treturn vec.clone().multiplyScalar( size ).add( pt );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar b, bs, t, z,\r\n\t\t\tvert, vlen = vertices.length,\r\n\t\t\tface, flen = faces.length;\r\n\t\r\n\t\r\n\t\t// Find directions for point movement\r\n\t\r\n\t\r\n\t\tfunction getBevelVec( inPt, inPrev, inNext ) {\r\n\t\r\n\t\t\t// computes for inPt the corresponding point inPt' on a new contour\r\n\t\t\t//   shifted by 1 unit (length of normalized vector) to the left\r\n\t\t\t// if we walk along contour clockwise, this new contour is outside the old one\r\n\t\t\t//\r\n\t\t\t// inPt' is the intersection of the two lines parallel to the two\r\n\t\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\r\n\t\r\n\t\t\tvar v_trans_x, v_trans_y, shrink_by = 1;\t\t// resulting translation vector for inPt\r\n\t\r\n\t\t\t// good reading for geometry algorithms (here: line-line intersection)\r\n\t\t\t// http://geomalgorithms.com/a05-_intersect-1.html\r\n\t\r\n\t\t\tvar v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\r\n\t\t\tvar v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\r\n\t\r\n\t\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\r\n\t\r\n\t\t\t// check for collinear edges\r\n\t\t\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\t\r\n\t\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\r\n\t\r\n\t\t\t\t// not collinear\r\n\t\r\n\t\t\t\t// length of vectors for normalizing\r\n\t\r\n\t\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\r\n\t\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\r\n\t\r\n\t\t\t\t// shift adjacent points by unit vectors to the left\r\n\t\r\n\t\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\r\n\t\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\r\n\t\r\n\t\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\r\n\t\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\r\n\t\r\n\t\t\t\t// scaling factor for v_prev to intersection point\r\n\t\r\n\t\t\t\tvar sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\r\n\t\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\r\n\t\t\t\t\t\t  ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\t\r\n\t\t\t\t// vector from inPt to intersection point\r\n\t\r\n\t\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\r\n\t\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\r\n\t\r\n\t\t\t\t// Don't normalize!, otherwise sharp corners become ugly\r\n\t\t\t\t//  but prevent crazy spikes\r\n\t\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\r\n\t\t\t\tif ( v_trans_lensq <= 2 ) {\r\n\t\r\n\t\t\t\t\treturn\tnew THREE.Vector2( v_trans_x, v_trans_y );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// handle special case of collinear edges\r\n\t\r\n\t\t\t\tvar direction_eq = false;\t\t// assumes: opposite\r\n\t\t\t\tif ( v_prev_x > Number.EPSILON ) {\r\n\t\r\n\t\t\t\t\tif ( v_next_x > Number.EPSILON ) {\r\n\t\r\n\t\t\t\t\t\tdirection_eq = true;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\r\n\t\r\n\t\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\r\n\t\r\n\t\t\t\t\t\t\tdirection_eq = true;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\r\n\t\r\n\t\t\t\t\t\t\tdirection_eq = true;\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tif ( direction_eq ) {\r\n\t\r\n\t\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\r\n\t\t\t\t\tv_trans_x = - v_prev_y;\r\n\t\t\t\t\tv_trans_y =  v_prev_x;\r\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\r\n\t\t\t\t\tv_trans_x = v_prev_x;\r\n\t\t\t\t\tv_trans_y = v_prev_y;\r\n\t\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treturn\tnew THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\tvar contourMovements = [];\r\n\t\r\n\t\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\t\r\n\t\t\tif ( j === il ) j = 0;\r\n\t\t\tif ( k === il ) k = 0;\r\n\t\r\n\t\t\t//  (j)---(i)---(k)\r\n\t\t\t// console.log('i,j,k', i, j , k)\r\n\t\r\n\t\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\r\n\t\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\tahole = holes[ h ];\r\n\t\r\n\t\t\toneHoleMovements = [];\r\n\t\r\n\t\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\t\r\n\t\t\t\tif ( j === il ) j = 0;\r\n\t\t\t\tif ( k === il ) k = 0;\r\n\t\r\n\t\t\t\t//  (j)---(i)---(k)\r\n\t\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tholesMovements.push( oneHoleMovements );\r\n\t\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Loop bevelSegments, 1 for the front, 1 for the back\r\n\t\r\n\t\tfor ( b = 0; b < bevelSegments; b ++ ) {\r\n\t\r\n\t\t\t//for ( b = bevelSegments; b > 0; b -- ) {\r\n\t\r\n\t\t\tt = b / bevelSegments;\r\n\t\t\tz = bevelThickness * ( 1 - t );\r\n\t\r\n\t\t\t//z = bevelThickness * t;\r\n\t\t\tbs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved\r\n\t\t\t//bs = bevelSize * t; // linear\r\n\t\r\n\t\t\t// contract shape\r\n\t\r\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\t\r\n\t\t\t\tv( vert.x, vert.y,  - z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// expand holes\r\n\t\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tahole = holes[ h ];\r\n\t\t\t\toneHoleMovements = holesMovements[ h ];\r\n\t\r\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\t\r\n\t\t\t\t\tv( vert.x, vert.y,  - z );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tbs = bevelSize;\r\n\t\r\n\t\t// Back facing vertices\r\n\t\r\n\t\tfor ( i = 0; i < vlen; i ++ ) {\r\n\t\r\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\t\r\n\t\t\tif ( ! extrudeByPath ) {\r\n\t\r\n\t\t\t\tv( vert.x, vert.y, 0 );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\r\n\t\r\n\t\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\r\n\t\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\r\n\t\r\n\t\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\r\n\t\r\n\t\t\t\tv( position2.x, position2.y, position2.z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Add stepped vertices...\r\n\t\t// Including front facing vertices\r\n\t\r\n\t\tvar s;\r\n\t\r\n\t\tfor ( s = 1; s <= steps; s ++ ) {\r\n\t\r\n\t\t\tfor ( i = 0; i < vlen; i ++ ) {\r\n\t\r\n\t\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\t\r\n\t\t\t\tif ( ! extrudeByPath ) {\r\n\t\r\n\t\t\t\t\tv( vert.x, vert.y, amount / steps * s );\r\n\t\r\n\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\r\n\t\r\n\t\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\r\n\t\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\r\n\t\r\n\t\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\r\n\t\r\n\t\t\t\t\tv( position2.x, position2.y, position2.z );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Add bevel segments planes\r\n\t\r\n\t\t//for ( b = 1; b <= bevelSegments; b ++ ) {\r\n\t\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\r\n\t\r\n\t\t\tt = b / bevelSegments;\r\n\t\t\tz = bevelThickness * ( 1 - t );\r\n\t\t\t//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\r\n\t\t\tbs = bevelSize * Math.sin ( t * Math.PI / 2 );\r\n\t\r\n\t\t\t// contract shape\r\n\t\r\n\t\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\t\t\t\tv( vert.x, vert.y,  amount + z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// expand holes\r\n\t\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tahole = holes[ h ];\r\n\t\t\t\toneHoleMovements = holesMovements[ h ];\r\n\t\r\n\t\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\t\r\n\t\t\t\t\tif ( ! extrudeByPath ) {\r\n\t\r\n\t\t\t\t\t\tv( vert.x, vert.y,  amount + z );\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t/* Faces */\r\n\t\r\n\t\t// Top and bottom faces\r\n\t\r\n\t\tbuildLidFaces();\r\n\t\r\n\t\t// Sides faces\r\n\t\r\n\t\tbuildSideFaces();\r\n\t\r\n\t\r\n\t\t/////  Internal functions\r\n\t\r\n\t\tfunction buildLidFaces() {\r\n\t\r\n\t\t\tif ( bevelEnabled ) {\r\n\t\r\n\t\t\t\tvar layer = 0; // steps + 1\r\n\t\t\t\tvar offset = vlen * layer;\r\n\t\r\n\t\t\t\t// Bottom faces\r\n\t\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\t\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tlayer = steps + bevelSegments * 2;\r\n\t\t\t\toffset = vlen * layer;\r\n\t\r\n\t\t\t\t// Top faces\r\n\t\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\t\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// Bottom faces\r\n\t\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\t\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// Top faces\r\n\t\r\n\t\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\t\r\n\t\t\t\t\tface = faces[ i ];\r\n\t\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// Create faces for the z-sides of the shape\r\n\t\r\n\t\tfunction buildSideFaces() {\r\n\t\r\n\t\t\tvar layeroffset = 0;\r\n\t\t\tsidewalls( contour, layeroffset );\r\n\t\t\tlayeroffset += contour.length;\r\n\t\r\n\t\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\t\r\n\t\t\t\tahole = holes[ h ];\r\n\t\t\t\tsidewalls( ahole, layeroffset );\r\n\t\r\n\t\t\t\t//, true\r\n\t\t\t\tlayeroffset += ahole.length;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction sidewalls( contour, layeroffset ) {\r\n\t\r\n\t\t\tvar j, k;\r\n\t\t\ti = contour.length;\r\n\t\r\n\t\t\twhile ( -- i >= 0 ) {\r\n\t\r\n\t\t\t\tj = i;\r\n\t\t\t\tk = i - 1;\r\n\t\t\t\tif ( k < 0 ) k = contour.length - 1;\r\n\t\r\n\t\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\r\n\t\r\n\t\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\r\n\t\r\n\t\t\t\tfor ( s = 0; s < sl; s ++ ) {\r\n\t\r\n\t\t\t\t\tvar slen1 = vlen * s;\r\n\t\t\t\t\tvar slen2 = vlen * ( s + 1 );\r\n\t\r\n\t\t\t\t\tvar a = layeroffset + j + slen1,\r\n\t\t\t\t\t\tb = layeroffset + k + slen1,\r\n\t\t\t\t\t\tc = layeroffset + k + slen2,\r\n\t\t\t\t\t\td = layeroffset + j + slen2;\r\n\t\r\n\t\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\tfunction v( x, y, z ) {\r\n\t\r\n\t\t\tscope.vertices.push( new THREE.Vector3( x, y, z ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction f3( a, b, c ) {\r\n\t\r\n\t\t\ta += shapesOffset;\r\n\t\t\tb += shapesOffset;\r\n\t\t\tc += shapesOffset;\r\n\t\r\n\t\t\tscope.faces.push( new THREE.Face3( a, b, c, null, null, 0 ) );\r\n\t\r\n\t\t\tvar uvs = uvgen.generateTopUV( scope, a, b, c );\r\n\t\r\n\t\t\tscope.faceVertexUvs[ 0 ].push( uvs );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\r\n\t\r\n\t\t\ta += shapesOffset;\r\n\t\t\tb += shapesOffset;\r\n\t\t\tc += shapesOffset;\r\n\t\t\td += shapesOffset;\r\n\t\r\n\t\t\tscope.faces.push( new THREE.Face3( a, b, d, null, null, 1 ) );\r\n\t\t\tscope.faces.push( new THREE.Face3( b, c, d, null, null, 1 ) );\r\n\t\r\n\t\t\tvar uvs = uvgen.generateSideWallUV( scope, a, b, c, d );\r\n\t\r\n\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\r\n\t\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ExtrudeGeometry.WorldUVGenerator = {\r\n\t\r\n\t\tgenerateTopUV: function ( geometry, indexA, indexB, indexC ) {\r\n\t\r\n\t\t\tvar vertices = geometry.vertices;\r\n\t\r\n\t\t\tvar a = vertices[ indexA ];\r\n\t\t\tvar b = vertices[ indexB ];\r\n\t\t\tvar c = vertices[ indexC ];\r\n\t\r\n\t\t\treturn [\r\n\t\t\t\tnew THREE.Vector2( a.x, a.y ),\r\n\t\t\t\tnew THREE.Vector2( b.x, b.y ),\r\n\t\t\t\tnew THREE.Vector2( c.x, c.y )\r\n\t\t\t];\r\n\t\r\n\t\t},\r\n\t\r\n\t\tgenerateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {\r\n\t\r\n\t\t\tvar vertices = geometry.vertices;\r\n\t\r\n\t\t\tvar a = vertices[ indexA ];\r\n\t\t\tvar b = vertices[ indexB ];\r\n\t\t\tvar c = vertices[ indexC ];\r\n\t\t\tvar d = vertices[ indexD ];\r\n\t\r\n\t\t\tif ( Math.abs( a.y - b.y ) < 0.01 ) {\r\n\t\r\n\t\t\t\treturn [\r\n\t\t\t\t\tnew THREE.Vector2( a.x, 1 - a.z ),\r\n\t\t\t\t\tnew THREE.Vector2( b.x, 1 - b.z ),\r\n\t\t\t\t\tnew THREE.Vector2( c.x, 1 - c.z ),\r\n\t\t\t\t\tnew THREE.Vector2( d.x, 1 - d.z )\r\n\t\t\t\t];\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\treturn [\r\n\t\t\t\t\tnew THREE.Vector2( a.y, 1 - a.z ),\r\n\t\t\t\t\tnew THREE.Vector2( b.y, 1 - b.z ),\r\n\t\t\t\t\tnew THREE.Vector2( c.y, 1 - c.z ),\r\n\t\t\t\t\tnew THREE.Vector2( d.y, 1 - d.z )\r\n\t\t\t\t];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t};\r\n\t\r\n\t// File:src/extras/geometries/ShapeGeometry.js\r\n\t\r\n\t/**\r\n\t * @author jonobr1 / http://jonobr1.com\r\n\t *\r\n\t * Creates a one-sided polygonal geometry from a path shape. Similar to\r\n\t * ExtrudeGeometry.\r\n\t *\r\n\t * parameters = {\r\n\t *\r\n\t *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\r\n\t *\r\n\t *\tmaterial: <int> // material index for front and back faces\r\n\t *\tuvGenerator: <Object> // object that provides UV generator functions\r\n\t *\r\n\t * }\r\n\t **/\r\n\t\r\n\tTHREE.ShapeGeometry = function ( shapes, options ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'ShapeGeometry';\r\n\t\r\n\t\tif ( Array.isArray( shapes ) === false ) shapes = [ shapes ];\r\n\t\r\n\t\tthis.addShapeList( shapes, options );\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;\r\n\t\r\n\t/**\r\n\t * Add an array of shapes to THREE.ShapeGeometry.\r\n\t */\r\n\tTHREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\t\r\n\t\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tthis.addShape( shapes[ i ], options );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn this;\r\n\t\r\n\t};\r\n\t\r\n\t/**\r\n\t * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\r\n\t */\r\n\tTHREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {\r\n\t\r\n\t\tif ( options === undefined ) options = {};\r\n\t\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\t\r\n\t\tvar material = options.material;\r\n\t\tvar uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvar i, l, hole;\r\n\t\r\n\t\tvar shapesOffset = this.vertices.length;\r\n\t\tvar shapePoints = shape.extractPoints( curveSegments );\r\n\t\r\n\t\tvar vertices = shapePoints.shape;\r\n\t\tvar holes = shapePoints.holes;\r\n\t\r\n\t\tvar reverse = ! THREE.ShapeUtils.isClockWise( vertices );\r\n\t\r\n\t\tif ( reverse ) {\r\n\t\r\n\t\t\tvertices = vertices.reverse();\r\n\t\r\n\t\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\r\n\t\r\n\t\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\thole = holes[ i ];\r\n\t\r\n\t\t\t\tif ( THREE.ShapeUtils.isClockWise( hole ) ) {\r\n\t\r\n\t\t\t\t\tholes[ i ] = hole.reverse();\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\treverse = false;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar faces = THREE.ShapeUtils.triangulateShape( vertices, holes );\r\n\t\r\n\t\t// Vertices\r\n\t\r\n\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\r\n\t\r\n\t\t\thole = holes[ i ];\r\n\t\t\tvertices = vertices.concat( hole );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvar vert, vlen = vertices.length;\r\n\t\tvar face, flen = faces.length;\r\n\t\r\n\t\tfor ( i = 0; i < vlen; i ++ ) {\r\n\t\r\n\t\t\tvert = vertices[ i ];\r\n\t\r\n\t\t\tthis.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\t\r\n\t\t\tface = faces[ i ];\r\n\t\r\n\t\t\tvar a = face[ 0 ] + shapesOffset;\r\n\t\t\tvar b = face[ 1 ] + shapesOffset;\r\n\t\t\tvar c = face[ 2 ] + shapesOffset;\r\n\t\r\n\t\t\tthis.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/geometries/LatheBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author Mugen87 / https://github.com/Mugen87\r\n\t */\r\n\t\r\n\t // points - to create a closed torus, one must use a set of points\r\n\t //    like so: [ a, b, c, d, a ], see first is the same as last.\r\n\t // segments - the number of circumference segments to create\r\n\t // phiStart - the starting radian\r\n\t // phiLength - the radian (0 to 2PI) range of the lathed section\r\n\t //    2PI is a closed lathe, less than 2PI is a portion.\r\n\t\r\n\tTHREE.LatheBufferGeometry = function ( points, segments, phiStart, phiLength ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'LatheBufferGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tpoints: points,\r\n\t\t\tsegments: segments,\r\n\t\t\tphiStart: phiStart,\r\n\t\t\tphiLength: phiLength\r\n\t\t};\r\n\t\r\n\t\tsegments = Math.floor( segments ) || 12;\r\n\t\tphiStart = phiStart || 0;\r\n\t\tphiLength = phiLength || Math.PI * 2;\r\n\t\r\n\t\t// clamp phiLength so it's in range of [ 0, 2PI ]\r\n\t\tphiLength = THREE.Math.clamp( phiLength, 0, Math.PI * 2 );\r\n\t\r\n\t\t// these are used to calculate buffer length\r\n\t\tvar vertexCount = ( segments + 1 ) * points.length;\r\n\t\tvar indexCount = segments * points.length * 2 * 3;\r\n\t\r\n\t\t// buffers\r\n\t\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\r\n\t\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\t\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\t\r\n\t\t// helper variables\r\n\t\tvar index = 0, indexOffset = 0, base;\r\n\t\tvar inversePointLength = 1.0 / ( points.length - 1 );\r\n\t\tvar inverseSegments = 1.0 / segments;\r\n\t\tvar vertex = new THREE.Vector3();\r\n\t\tvar uv = new THREE.Vector2();\r\n\t\tvar i, j;\r\n\t\r\n\t\t// generate vertices and uvs\r\n\t\r\n\t\tfor ( i = 0; i <= segments; i ++ ) {\r\n\t\r\n\t\t\tvar phi = phiStart + i * inverseSegments * phiLength;\r\n\t\r\n\t\t\tvar sin = Math.sin( phi );\r\n\t\t\tvar cos = Math.cos( phi );\r\n\t\r\n\t\t\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\r\n\t\r\n\t\t\t\t// vertex\r\n\t\t\t\tvertex.x = points[ j ].x * sin;\r\n\t\t\t\tvertex.y = points[ j ].y;\r\n\t\t\t\tvertex.z = points[ j ].x * cos;\r\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\r\n\t\r\n\t\t\t\t// uv\r\n\t\t\t\tuv.x = i / segments;\r\n\t\t\t\tuv.y = j / ( points.length - 1 );\r\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\r\n\t\r\n\t\t\t\t// increase index\r\n\t\t\t\tindex ++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// generate indices\r\n\t\r\n\t\tfor ( i = 0; i < segments; i ++ ) {\r\n\t\r\n\t\t\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\r\n\t\r\n\t\t\t\tbase = j + i * points.length;\r\n\t\r\n\t\t\t\t// indices\r\n\t\t\t\tvar a = base;\r\n\t\t\t\tvar b = base + points.length;\r\n\t\t\t\tvar c = base + points.length + 1;\r\n\t\t\t\tvar d = base + 1;\r\n\t\r\n\t\t\t\t// face one\r\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\r\n\t\r\n\t\t\t\t// face two\r\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// build geometry\r\n\t\r\n\t\tthis.setIndex( indices );\r\n\t\tthis.addAttribute( 'position', vertices );\r\n\t\tthis.addAttribute( 'uv', uvs );\r\n\t\r\n\t\t// generate normals\r\n\t\r\n\t\tthis.computeVertexNormals();\r\n\t\r\n\t\t// if the geometry is closed, we need to average the normals along the seam.\r\n\t\t// because the corresponding vertices are identical (but still have different UVs).\r\n\t\r\n\t\tif( phiLength === Math.PI * 2 ) {\r\n\t\r\n\t\t\tvar normals = this.attributes.normal.array;\r\n\t\t\tvar n1 = new THREE.Vector3();\r\n\t\t\tvar n2 = new THREE.Vector3();\r\n\t\t\tvar n = new THREE.Vector3();\r\n\t\r\n\t\t\t// this is the buffer offset for the last line of vertices\r\n\t\t\tbase = segments * points.length * 3;\r\n\t\r\n\t\t\tfor( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\r\n\t\r\n\t\t\t\t// select the normal of the vertex in the first line\r\n\t\t\t\tn1.x = normals[ j + 0 ];\r\n\t\t\t\tn1.y = normals[ j + 1 ];\r\n\t\t\t\tn1.z = normals[ j + 2 ];\r\n\t\r\n\t\t\t\t// select the normal of the vertex in the last line\r\n\t\t\t\tn2.x = normals[ base + j + 0 ];\r\n\t\t\t\tn2.y = normals[ base + j + 1 ];\r\n\t\t\t\tn2.z = normals[ base + j + 2 ];\r\n\t\r\n\t\t\t\t// average normals\r\n\t\t\t\tn.addVectors( n1, n2 ).normalize();\r\n\t\r\n\t\t\t\t// assign the new values to both normals\r\n\t\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\r\n\t\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\r\n\t\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\r\n\t\r\n\t\t\t} // next row\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LatheBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.LatheBufferGeometry.prototype.constructor = THREE.LatheBufferGeometry;\r\n\t\r\n\t// File:src/extras/geometries/LatheGeometry.js\r\n\t\r\n\t/**\r\n\t * @author astrodud / http://astrodud.isgreat.org/\r\n\t * @author zz85 / https://github.com/zz85\r\n\t * @author bhouston / http://clara.io\r\n\t */\r\n\t\r\n\t// points - to create a closed torus, one must use a set of points\r\n\t//    like so: [ a, b, c, d, a ], see first is the same as last.\r\n\t// segments - the number of circumference segments to create\r\n\t// phiStart - the starting radian\r\n\t// phiLength - the radian (0 to 2PI) range of the lathed section\r\n\t//    2PI is a closed lathe, less than 2PI is a portion.\r\n\t\r\n\tTHREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'LatheGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tpoints: points,\r\n\t\t\tsegments: segments,\r\n\t\t\tphiStart: phiStart,\r\n\t\t\tphiLength: phiLength\r\n\t\t};\r\n\t\r\n\t\tthis.fromBufferGeometry( new THREE.LatheBufferGeometry( points, segments, phiStart, phiLength ) );\r\n\t\tthis.mergeVertices();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;\r\n\t\r\n\t// File:src/extras/geometries/PlaneGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n\t */\r\n\t\r\n\tTHREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'PlaneGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\twidth: width,\r\n\t\t\theight: height,\r\n\t\t\twidthSegments: widthSegments,\r\n\t\t\theightSegments: heightSegments\r\n\t\t};\r\n\t\r\n\t\tthis.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;\r\n\t\r\n\t// File:src/extras/geometries/PlaneBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n\t */\r\n\t\r\n\tTHREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'PlaneBufferGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\twidth: width,\r\n\t\t\theight: height,\r\n\t\t\twidthSegments: widthSegments,\r\n\t\t\theightSegments: heightSegments\r\n\t\t};\r\n\t\r\n\t\tvar width_half = width / 2;\r\n\t\tvar height_half = height / 2;\r\n\t\r\n\t\tvar gridX = Math.floor( widthSegments ) || 1;\r\n\t\tvar gridY = Math.floor( heightSegments ) || 1;\r\n\t\r\n\t\tvar gridX1 = gridX + 1;\r\n\t\tvar gridY1 = gridY + 1;\r\n\t\r\n\t\tvar segment_width = width / gridX;\r\n\t\tvar segment_height = height / gridY;\r\n\t\r\n\t\tvar vertices = new Float32Array( gridX1 * gridY1 * 3 );\r\n\t\tvar normals = new Float32Array( gridX1 * gridY1 * 3 );\r\n\t\tvar uvs = new Float32Array( gridX1 * gridY1 * 2 );\r\n\t\r\n\t\tvar offset = 0;\r\n\t\tvar offset2 = 0;\r\n\t\r\n\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\r\n\t\r\n\t\t\tvar y = iy * segment_height - height_half;\r\n\t\r\n\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\r\n\t\r\n\t\t\t\tvar x = ix * segment_width - width_half;\r\n\t\r\n\t\t\t\tvertices[ offset ] = x;\r\n\t\t\t\tvertices[ offset + 1 ] = - y;\r\n\t\r\n\t\t\t\tnormals[ offset + 2 ] = 1;\r\n\t\r\n\t\t\t\tuvs[ offset2 ] = ix / gridX;\r\n\t\t\t\tuvs[ offset2 + 1 ] = 1 - ( iy / gridY );\r\n\t\r\n\t\t\t\toffset += 3;\r\n\t\t\t\toffset2 += 2;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\toffset = 0;\r\n\t\r\n\t\tvar indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );\r\n\t\r\n\t\tfor ( var iy = 0; iy < gridY; iy ++ ) {\r\n\t\r\n\t\t\tfor ( var ix = 0; ix < gridX; ix ++ ) {\r\n\t\r\n\t\t\t\tvar a = ix + gridX1 * iy;\r\n\t\t\t\tvar b = ix + gridX1 * ( iy + 1 );\r\n\t\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n\t\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\r\n\t\r\n\t\t\t\tindices[ offset ] = a;\r\n\t\t\t\tindices[ offset + 1 ] = b;\r\n\t\t\t\tindices[ offset + 2 ] = d;\r\n\t\r\n\t\t\t\tindices[ offset + 3 ] = b;\r\n\t\t\t\tindices[ offset + 4 ] = c;\r\n\t\t\t\tindices[ offset + 5 ] = d;\r\n\t\r\n\t\t\t\toffset += 6;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;\r\n\t\r\n\t// File:src/extras/geometries/RingBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author Mugen87 / https://github.com/Mugen87\r\n\t */\r\n\t\r\n\tTHREE.RingBufferGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'RingBufferGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tinnerRadius: innerRadius,\r\n\t\t\touterRadius: outerRadius,\r\n\t\t\tthetaSegments: thetaSegments,\r\n\t\t\tphiSegments: phiSegments,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t\tinnerRadius = innerRadius || 20;\r\n\t\touterRadius = outerRadius || 50;\r\n\t\r\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\t\r\n\t\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\r\n\t\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\r\n\t\r\n\t\t// these are used to calculate buffer length\r\n\t\tvar vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );\r\n\t\tvar indexCount = thetaSegments * phiSegments * 2 * 3;\r\n\t\r\n\t\t// buffers\r\n\t\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\r\n\t\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\t\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\t\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\t\r\n\t\t// some helper variables\r\n\t\tvar index = 0, indexOffset = 0, segment;\r\n\t\tvar radius = innerRadius;\r\n\t\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\r\n\t\tvar vertex = new THREE.Vector3();\r\n\t\tvar uv = new THREE.Vector2();\r\n\t\tvar j, i;\r\n\t\r\n\t\t// generate vertices, normals and uvs\r\n\t\r\n\t\t// values are generate from the inside of the ring to the outside\r\n\t\r\n\t\tfor ( j = 0; j <= phiSegments; j ++ ) {\r\n\t\r\n\t\t\tfor ( i = 0; i <= thetaSegments; i ++ ) {\r\n\t\r\n\t\t\t\tsegment = thetaStart + i / thetaSegments * thetaLength;\r\n\t\r\n\t\t\t\t// vertex\r\n\t\t\t\tvertex.x = radius * Math.cos( segment );\r\n\t\t\t\tvertex.y = radius * Math.sin( segment );\r\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\r\n\t\r\n\t\t\t\t// normal\r\n\t\t\t\tnormals.setXYZ( index, 0, 0, 1 );\r\n\t\r\n\t\t\t\t// uv\r\n\t\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\r\n\t\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\r\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\r\n\t\r\n\t\t\t\t// increase index\r\n\t\t\t\tindex++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// increase the radius for next row of vertices\r\n\t\t\tradius += radiusStep;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// generate indices\r\n\t\r\n\t\tfor ( j = 0; j < phiSegments; j ++ ) {\r\n\t\r\n\t\t\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\r\n\t\r\n\t\t\tfor ( i = 0; i < thetaSegments; i ++ ) {\r\n\t\r\n\t\t\t\tsegment = i + thetaSegmentLevel;\r\n\t\r\n\t\t\t\t// indices\r\n\t\t\t\tvar a = segment;\r\n\t\t\t\tvar b = segment + thetaSegments + 1;\r\n\t\t\t\tvar c = segment + thetaSegments + 2;\r\n\t\t\t\tvar d = segment + 1;\r\n\t\r\n\t\t\t\t// face one\r\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\r\n\t\r\n\t\t\t\t// face two\r\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// build geometry\r\n\t\r\n\t\tthis.setIndex( indices );\r\n\t\tthis.addAttribute( 'position', vertices );\r\n\t\tthis.addAttribute( 'normal', normals );\r\n\t\tthis.addAttribute( 'uv', uvs );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.RingBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.RingBufferGeometry.prototype.constructor = THREE.RingBufferGeometry;\r\n\t\r\n\t// File:src/extras/geometries/RingGeometry.js\r\n\t\r\n\t/**\r\n\t * @author Kaleb Murphy\r\n\t */\r\n\t\r\n\tTHREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'RingGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tinnerRadius: innerRadius,\r\n\t\t\touterRadius: outerRadius,\r\n\t\t\tthetaSegments: thetaSegments,\r\n\t\t\tphiSegments: phiSegments,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t\tthis.fromBufferGeometry( new THREE.RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.RingGeometry.prototype.constructor = THREE.RingGeometry;\r\n\t\r\n\t// File:src/extras/geometries/SphereGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'SphereGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\twidthSegments: widthSegments,\r\n\t\t\theightSegments: heightSegments,\r\n\t\t\tphiStart: phiStart,\r\n\t\t\tphiLength: phiLength,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t\tthis.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;\r\n\t\r\n\t// File:src/extras/geometries/SphereBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author benaadams / https://twitter.com/ben_a_adams\r\n\t * based on THREE.SphereGeometry\r\n\t */\r\n\t\r\n\tTHREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'SphereBufferGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\twidthSegments: widthSegments,\r\n\t\t\theightSegments: heightSegments,\r\n\t\t\tphiStart: phiStart,\r\n\t\t\tphiLength: phiLength,\r\n\t\t\tthetaStart: thetaStart,\r\n\t\t\tthetaLength: thetaLength\r\n\t\t};\r\n\t\r\n\t\tradius = radius || 50;\r\n\t\r\n\t\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\r\n\t\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\r\n\t\r\n\t\tphiStart = phiStart !== undefined ? phiStart : 0;\r\n\t\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\r\n\t\r\n\t\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\t\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\r\n\t\r\n\t\tvar thetaEnd = thetaStart + thetaLength;\r\n\t\r\n\t\tvar vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );\r\n\t\r\n\t\tvar positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\t\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\t\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\t\r\n\t\tvar index = 0, vertices = [], normal = new THREE.Vector3();\r\n\t\r\n\t\tfor ( var y = 0; y <= heightSegments; y ++ ) {\r\n\t\r\n\t\t\tvar verticesRow = [];\r\n\t\r\n\t\t\tvar v = y / heightSegments;\r\n\t\r\n\t\t\tfor ( var x = 0; x <= widthSegments; x ++ ) {\r\n\t\r\n\t\t\t\tvar u = x / widthSegments;\r\n\t\r\n\t\t\t\tvar px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\t\t\t\tvar py = radius * Math.cos( thetaStart + v * thetaLength );\r\n\t\t\t\tvar pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\t\r\n\t\t\t\tnormal.set( px, py, pz ).normalize();\r\n\t\r\n\t\t\t\tpositions.setXYZ( index, px, py, pz );\r\n\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\r\n\t\t\t\tuvs.setXY( index, u, 1 - v );\r\n\t\r\n\t\t\t\tverticesRow.push( index );\r\n\t\r\n\t\t\t\tindex ++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvertices.push( verticesRow );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar indices = [];\r\n\t\r\n\t\tfor ( var y = 0; y < heightSegments; y ++ ) {\r\n\t\r\n\t\t\tfor ( var x = 0; x < widthSegments; x ++ ) {\r\n\t\r\n\t\t\t\tvar v1 = vertices[ y ][ x + 1 ];\r\n\t\t\t\tvar v2 = vertices[ y ][ x ];\r\n\t\t\t\tvar v3 = vertices[ y + 1 ][ x ];\r\n\t\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\r\n\t\r\n\t\t\t\tif ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );\r\n\t\t\t\tif ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.setIndex( new ( positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute )( indices, 1 ) );\r\n\t\tthis.addAttribute( 'position', positions );\r\n\t\tthis.addAttribute( 'normal', normals );\r\n\t\tthis.addAttribute( 'uv', uvs );\r\n\t\r\n\t\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TextGeometry.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / http://www.lab4games.net/zz85/blog\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t * Text = 3D Text\r\n\t *\r\n\t * parameters = {\r\n\t *  font: <THREE.Font>, // font\r\n\t *\r\n\t *  size: <float>, // size of the text\r\n\t *  height: <float>, // thickness to extrude text\r\n\t *  curveSegments: <int>, // number of points on the curves\r\n\t *\r\n\t *  bevelEnabled: <bool>, // turn on bevel\r\n\t *  bevelThickness: <float>, // how deep into text bevel goes\r\n\t *  bevelSize: <float> // how far from text outline is bevel\r\n\t * }\r\n\t */\r\n\t\r\n\tTHREE.TextGeometry = function ( text, parameters ) {\r\n\t\r\n\t\tparameters = parameters || {};\r\n\t\r\n\t\tvar font = parameters.font;\r\n\t\r\n\t\tif ( font instanceof THREE.Font === false ) {\r\n\t\r\n\t\t\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\r\n\t\t\treturn new THREE.Geometry();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );\r\n\t\r\n\t\t// translate parameters to ExtrudeGeometry API\r\n\t\r\n\t\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\r\n\t\r\n\t\t// defaults\r\n\t\r\n\t\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\r\n\t\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\r\n\t\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\r\n\t\r\n\t\tTHREE.ExtrudeGeometry.call( this, shapes, parameters );\r\n\t\r\n\t\tthis.type = 'TextGeometry';\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );\r\n\tTHREE.TextGeometry.prototype.constructor = THREE.TextGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TorusBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author Mugen87 / https://github.com/Mugen87\r\n\t */\r\n\t\r\n\tTHREE.TorusBufferGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'TorusBufferGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\ttube: tube,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\ttubularSegments: tubularSegments,\r\n\t\t\tarc: arc\r\n\t\t};\r\n\t\r\n\t\tradius = radius || 100;\r\n\t\ttube = tube || 40;\r\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\r\n\t\ttubularSegments = Math.floor( tubularSegments ) || 6;\r\n\t\tarc = arc || Math.PI * 2;\r\n\t\r\n\t\t// used to calculate buffer length\r\n\t\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\r\n\t\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\r\n\t\r\n\t\t// buffers\r\n\t\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\r\n\t\tvar vertices = new Float32Array( vertexCount * 3 );\r\n\t\tvar normals = new Float32Array( vertexCount * 3 );\r\n\t\tvar uvs = new Float32Array( vertexCount * 2 );\r\n\t\r\n\t\t// offset variables\r\n\t\tvar vertexBufferOffset = 0;\r\n\t\tvar uvBufferOffset = 0;\r\n\t\tvar indexBufferOffset = 0;\r\n\t\r\n\t\t// helper variables\r\n\t\tvar center = new THREE.Vector3();\r\n\t\tvar vertex = new THREE.Vector3();\r\n\t\tvar normal = new THREE.Vector3();\r\n\t\r\n\t\tvar j, i;\r\n\t\r\n\t\t// generate vertices, normals and uvs\r\n\t\r\n\t\tfor ( j = 0; j <= radialSegments; j ++ ) {\r\n\t\r\n\t\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\r\n\t\r\n\t\t\t\tvar u = i / tubularSegments * arc;\r\n\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\r\n\t\r\n\t\t\t\t// vertex\r\n\t\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\r\n\t\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\r\n\t\t\t\tvertex.z = tube * Math.sin( v );\r\n\t\r\n\t\t\t\tvertices[ vertexBufferOffset ] = vertex.x;\r\n\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vertex.y;\r\n\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vertex.z;\r\n\t\r\n\t\t\t\t// this vector is used to calculate the normal\r\n\t\t\t\tcenter.x = radius * Math.cos( u );\r\n\t\t\t\tcenter.y = radius * Math.sin( u );\r\n\t\r\n\t\t\t\t// normal\r\n\t\t\t\tnormal.subVectors( vertex, center ).normalize();\r\n\t\r\n\t\t\t\tnormals[ vertexBufferOffset ] = normal.x;\r\n\t\t\t\tnormals[ vertexBufferOffset + 1 ] = normal.y;\r\n\t\t\t\tnormals[ vertexBufferOffset + 2 ] = normal.z;\r\n\t\r\n\t\t\t\t// uv\r\n\t\t\t\tuvs[ uvBufferOffset ] = i / tubularSegments;\r\n\t\t\t\tuvs[ uvBufferOffset + 1 ] = j / radialSegments;\r\n\t\r\n\t\t\t\t// update offsets\r\n\t\t\t\tvertexBufferOffset += 3;\r\n\t\t\t\tuvBufferOffset += 2;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// generate indices\r\n\t\r\n\t\tfor ( j = 1; j <= radialSegments; j ++ ) {\r\n\t\r\n\t\t\tfor ( i = 1; i <= tubularSegments; i ++ ) {\r\n\t\r\n\t\t\t\t// indices\r\n\t\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\r\n\t\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\r\n\t\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\r\n\t\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\r\n\t\r\n\t\t\t\t// face one\r\n\t\t\t\tindices[ indexBufferOffset ] = a;\r\n\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\r\n\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\r\n\t\r\n\t\t\t\t// face two\r\n\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\r\n\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\r\n\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\r\n\t\r\n\t\t\t\t// update offset\r\n\t\t\t\tindexBufferOffset += 6;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// build geometry\r\n\t\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TorusBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.TorusBufferGeometry.prototype.constructor = THREE.TorusBufferGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TorusGeometry.js\r\n\t\r\n\t/**\r\n\t * @author oosmoxiecode\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\r\n\t */\r\n\t\r\n\tTHREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'TorusGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\ttube: tube,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\ttubularSegments: tubularSegments,\r\n\t\t\tarc: arc\r\n\t\t};\r\n\t\r\n\t\tthis.fromBufferGeometry( new THREE.TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TorusKnotBufferGeometry.js\r\n\t\r\n\t/**\r\n\t * @author Mugen87 / https://github.com/Mugen87\r\n\t *\r\n\t * see: http://www.blackpawn.com/texts/pqtorus/\r\n\t */\r\n\tTHREE.TorusKnotBufferGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tthis.type = 'TorusKnotBufferGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\ttube: tube,\r\n\t\t\ttubularSegments: tubularSegments,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\tp: p,\r\n\t\t\tq: q\r\n\t\t};\r\n\t\r\n\t\tradius = radius || 100;\r\n\t\ttube = tube || 40;\r\n\t\ttubularSegments = Math.floor( tubularSegments ) || 64;\r\n\t\tradialSegments = Math.floor( radialSegments ) || 8;\r\n\t\tp = p || 2;\r\n\t\tq = q || 3;\r\n\t\r\n\t\t// used to calculate buffer length\r\n\t\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\r\n\t\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\r\n\t\r\n\t\t// buffers\r\n\t\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\r\n\t\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\t\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\t\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\t\r\n\t\t// helper variables\r\n\t\tvar i, j, index = 0, indexOffset = 0;\r\n\t\r\n\t\tvar vertex = new THREE.Vector3();\r\n\t\tvar normal = new THREE.Vector3();\r\n\t\tvar uv = new THREE.Vector2();\r\n\t\r\n\t\tvar P1 = new THREE.Vector3();\r\n\t\tvar P2 = new THREE.Vector3();\r\n\t\r\n\t\tvar B = new THREE.Vector3();\r\n\t\tvar T = new THREE.Vector3();\r\n\t\tvar N = new THREE.Vector3();\r\n\t\r\n\t\t// generate vertices, normals and uvs\r\n\t\r\n\t\tfor ( i = 0; i <= tubularSegments; ++ i ) {\r\n\t\r\n\t\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\r\n\t\r\n\t\t\tvar u = i / tubularSegments * p * Math.PI * 2;\r\n\t\r\n\t\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\r\n\t\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\r\n\t\r\n\t\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\r\n\t\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\r\n\t\r\n\t\t\t// calculate orthonormal basis\r\n\t\r\n\t\t\tT.subVectors( P2, P1 );\r\n\t\t\tN.addVectors( P2, P1 );\r\n\t\t\tB.crossVectors( T, N );\r\n\t\t\tN.crossVectors( B, T );\r\n\t\r\n\t\t\t// normalize B, N. T can be ignored, we don't use it\r\n\t\r\n\t\t\tB.normalize();\r\n\t\t\tN.normalize();\r\n\t\r\n\t\t\tfor ( j = 0; j <= radialSegments; ++ j ) {\r\n\t\r\n\t\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\r\n\t\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\r\n\t\r\n\t\t\t\tvar v = j / radialSegments * Math.PI * 2;\r\n\t\t\t\tvar cx = - tube * Math.cos( v );\r\n\t\t\t\tvar cy = tube * Math.sin( v );\r\n\t\r\n\t\t\t\t// now calculate the final vertex position.\r\n\t\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\r\n\t\r\n\t\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\r\n\t\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\r\n\t\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\r\n\t\r\n\t\t\t\t// vertex\r\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\r\n\t\r\n\t\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\r\n\t\t\t\tnormal.subVectors( vertex, P1 ).normalize();\r\n\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\r\n\t\r\n\t\t\t\t// uv\r\n\t\t\t\tuv.x = i / tubularSegments;\r\n\t\t\t\tuv.y = j / radialSegments;\r\n\t\t\t\tuvs.setXY( index, uv.x, uv.y );\r\n\t\r\n\t\t\t\t// increase index\r\n\t\t\t\tindex ++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// generate indices\r\n\t\r\n\t\tfor ( j = 1; j <= tubularSegments; j ++ ) {\r\n\t\r\n\t\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\r\n\t\r\n\t\t\t\t// indices\r\n\t\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\r\n\t\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\r\n\t\t\t\tvar c = ( radialSegments + 1 ) * j + i;\r\n\t\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\r\n\t\r\n\t\t\t\t// face one\r\n\t\t\t\tindices.setX( indexOffset, a ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\r\n\t\r\n\t\t\t\t// face two\r\n\t\t\t\tindices.setX( indexOffset, b ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset++;\r\n\t\t\t\tindices.setX( indexOffset, d ); indexOffset++;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// build geometry\r\n\t\r\n\t\tthis.setIndex( indices );\r\n\t\tthis.addAttribute( 'position', vertices );\r\n\t\tthis.addAttribute( 'normal', normals );\r\n\t\tthis.addAttribute( 'uv', uvs );\r\n\t\r\n\t\t// this function calculates the current position on the torus curve\r\n\t\r\n\t\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\r\n\t\r\n\t\t\tvar cu = Math.cos( u );\r\n\t\t\tvar su = Math.sin( u );\r\n\t\t\tvar quOverP = q / p * u;\r\n\t\t\tvar cs = Math.cos( quOverP );\r\n\t\r\n\t\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\r\n\t\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\r\n\t\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TorusKnotBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.TorusKnotBufferGeometry.prototype.constructor = THREE.TorusKnotBufferGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TorusKnotGeometry.js\r\n\t\r\n\t/**\r\n\t * @author oosmoxiecode\r\n\t */\r\n\t\r\n\tTHREE.TorusKnotGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'TorusKnotGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\ttube: tube,\r\n\t\t\ttubularSegments: tubularSegments,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\tp: p,\r\n\t\t\tq: q\r\n\t\t};\r\n\t\r\n\t\tif( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\r\n\t\r\n\t\tthis.fromBufferGeometry( new THREE.TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\r\n\t\tthis.mergeVertices();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TubeGeometry.js\r\n\t\r\n\t/**\r\n\t * @author WestLangley / https://github.com/WestLangley\r\n\t * @author zz85 / https://github.com/zz85\r\n\t * @author miningold / https://github.com/miningold\r\n\t * @author jonobr1 / https://github.com/jonobr1\r\n\t *\r\n\t * Modified from the TorusKnotGeometry by @oosmoxiecode\r\n\t *\r\n\t * Creates a tube which extrudes along a 3d spline\r\n\t *\r\n\t * Uses parallel transport frames as described in\r\n\t * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\r\n\t */\r\n\t\r\n\tTHREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'TubeGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tpath: path,\r\n\t\t\tsegments: segments,\r\n\t\t\tradius: radius,\r\n\t\t\tradialSegments: radialSegments,\r\n\t\t\tclosed: closed,\r\n\t\t\ttaper: taper\r\n\t\t};\r\n\t\r\n\t\tsegments = segments || 64;\r\n\t\tradius = radius || 1;\r\n\t\tradialSegments = radialSegments || 8;\r\n\t\tclosed = closed || false;\r\n\t\ttaper = taper || THREE.TubeGeometry.NoTaper;\r\n\t\r\n\t\tvar grid = [];\r\n\t\r\n\t\tvar scope = this,\r\n\t\r\n\t\t\ttangent,\r\n\t\t\tnormal,\r\n\t\t\tbinormal,\r\n\t\r\n\t\t\tnumpoints = segments + 1,\r\n\t\r\n\t\t\tu, v, r,\r\n\t\r\n\t\t\tcx, cy,\r\n\t\t\tpos, pos2 = new THREE.Vector3(),\r\n\t\t\ti, j,\r\n\t\t\tip, jp,\r\n\t\t\ta, b, c, d,\r\n\t\t\tuva, uvb, uvc, uvd;\r\n\t\r\n\t\tvar frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),\r\n\t\t\ttangents = frames.tangents,\r\n\t\t\tnormals = frames.normals,\r\n\t\t\tbinormals = frames.binormals;\r\n\t\r\n\t\t// proxy internals\r\n\t\tthis.tangents = tangents;\r\n\t\tthis.normals = normals;\r\n\t\tthis.binormals = binormals;\r\n\t\r\n\t\tfunction vert( x, y, z ) {\r\n\t\r\n\t\t\treturn scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// construct the grid\r\n\t\r\n\t\tfor ( i = 0; i < numpoints; i ++ ) {\r\n\t\r\n\t\t\tgrid[ i ] = [];\r\n\t\r\n\t\t\tu = i / ( numpoints - 1 );\r\n\t\r\n\t\t\tpos = path.getPointAt( u );\r\n\t\r\n\t\t\ttangent = tangents[ i ];\r\n\t\t\tnormal = normals[ i ];\r\n\t\t\tbinormal = binormals[ i ];\r\n\t\r\n\t\t\tr = radius * taper( u );\r\n\t\r\n\t\t\tfor ( j = 0; j < radialSegments; j ++ ) {\r\n\t\r\n\t\t\t\tv = j / radialSegments * 2 * Math.PI;\r\n\t\r\n\t\t\t\tcx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\r\n\t\t\t\tcy = r * Math.sin( v );\r\n\t\r\n\t\t\t\tpos2.copy( pos );\r\n\t\t\t\tpos2.x += cx * normal.x + cy * binormal.x;\r\n\t\t\t\tpos2.y += cx * normal.y + cy * binormal.y;\r\n\t\t\t\tpos2.z += cx * normal.z + cy * binormal.z;\r\n\t\r\n\t\t\t\tgrid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// construct the mesh\r\n\t\r\n\t\tfor ( i = 0; i < segments; i ++ ) {\r\n\t\r\n\t\t\tfor ( j = 0; j < radialSegments; j ++ ) {\r\n\t\r\n\t\t\t\tip = ( closed ) ? ( i + 1 ) % segments : i + 1;\r\n\t\t\t\tjp = ( j + 1 ) % radialSegments;\r\n\t\r\n\t\t\t\ta = grid[ i ][ j ];\t\t// *** NOT NECESSARILY PLANAR ! ***\r\n\t\t\t\tb = grid[ ip ][ j ];\r\n\t\t\t\tc = grid[ ip ][ jp ];\r\n\t\t\t\td = grid[ i ][ jp ];\r\n\t\r\n\t\t\t\tuva = new THREE.Vector2( i / segments, j / radialSegments );\r\n\t\t\t\tuvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );\r\n\t\t\t\tuvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );\r\n\t\t\t\tuvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );\r\n\t\r\n\t\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\t\r\n\t\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\r\n\t\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\tthis.computeVertexNormals();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;\r\n\t\r\n\tTHREE.TubeGeometry.NoTaper = function ( u ) {\r\n\t\r\n\t\treturn 1;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TubeGeometry.SinusoidalTaper = function ( u ) {\r\n\t\r\n\t\treturn Math.sin( Math.PI * u );\r\n\t\r\n\t};\r\n\t\r\n\t// For computing of Frenet frames, exposing the tangents, normals and binormals the spline\r\n\tTHREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {\r\n\t\r\n\t\tvar\tnormal = new THREE.Vector3(),\r\n\t\r\n\t\t\ttangents = [],\r\n\t\t\tnormals = [],\r\n\t\t\tbinormals = [],\r\n\t\r\n\t\t\tvec = new THREE.Vector3(),\r\n\t\t\tmat = new THREE.Matrix4(),\r\n\t\r\n\t\t\tnumpoints = segments + 1,\r\n\t\t\ttheta,\r\n\t\t\tsmallest,\r\n\t\r\n\t\t\ttx, ty, tz,\r\n\t\t\ti, u;\r\n\t\r\n\t\r\n\t\t// expose internals\r\n\t\tthis.tangents = tangents;\r\n\t\tthis.normals = normals;\r\n\t\tthis.binormals = binormals;\r\n\t\r\n\t\t// compute the tangent vectors for each segment on the path\r\n\t\r\n\t\tfor ( i = 0; i < numpoints; i ++ ) {\r\n\t\r\n\t\t\tu = i / ( numpoints - 1 );\r\n\t\r\n\t\t\ttangents[ i ] = path.getTangentAt( u );\r\n\t\t\ttangents[ i ].normalize();\r\n\t\r\n\t\t}\r\n\t\r\n\t\tinitialNormal3();\r\n\t\r\n\t\t/*\r\n\t\tfunction initialNormal1(lastBinormal) {\r\n\t\t\t// fixed start binormal. Has dangers of 0 vectors\r\n\t\t\tnormals[ 0 ] = new THREE.Vector3();\r\n\t\t\tbinormals[ 0 ] = new THREE.Vector3();\r\n\t\t\tif (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );\r\n\t\t\tnormals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();\r\n\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n\t\t}\r\n\t\r\n\t\tfunction initialNormal2() {\r\n\t\r\n\t\t\t// This uses the Frenet-Serret formula for deriving binormal\r\n\t\t\tvar t2 = path.getTangentAt( epsilon );\r\n\t\r\n\t\t\tnormals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();\r\n\t\t\tbinormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\t\r\n\t\t\tnormals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent\r\n\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n\t\r\n\t\t}\r\n\t\t*/\r\n\t\r\n\t\tfunction initialNormal3() {\r\n\t\r\n\t\t\t// select an initial normal vector perpendicular to the first tangent vector,\r\n\t\t\t// and in the direction of the smallest tangent xyz component\r\n\t\r\n\t\t\tnormals[ 0 ] = new THREE.Vector3();\r\n\t\t\tbinormals[ 0 ] = new THREE.Vector3();\r\n\t\t\tsmallest = Number.MAX_VALUE;\r\n\t\t\ttx = Math.abs( tangents[ 0 ].x );\r\n\t\t\tty = Math.abs( tangents[ 0 ].y );\r\n\t\t\ttz = Math.abs( tangents[ 0 ].z );\r\n\t\r\n\t\t\tif ( tx <= smallest ) {\r\n\t\r\n\t\t\t\tsmallest = tx;\r\n\t\t\t\tnormal.set( 1, 0, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( ty <= smallest ) {\r\n\t\r\n\t\t\t\tsmallest = ty;\r\n\t\t\t\tnormal.set( 0, 1, 0 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( tz <= smallest ) {\r\n\t\r\n\t\t\t\tnormal.set( 0, 0, 1 );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\r\n\t\r\n\t\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\r\n\t\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// compute the slowly-varying normal and binormal vectors for each segment on the path\r\n\t\r\n\t\tfor ( i = 1; i < numpoints; i ++ ) {\r\n\t\r\n\t\t\tnormals[ i ] = normals[ i - 1 ].clone();\r\n\t\r\n\t\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\r\n\t\r\n\t\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\r\n\t\r\n\t\t\tif ( vec.length() > Number.EPSILON ) {\r\n\t\r\n\t\t\t\tvec.normalize();\r\n\t\r\n\t\t\t\ttheta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\r\n\t\r\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\r\n\t\r\n\t\tif ( closed ) {\r\n\t\r\n\t\t\ttheta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );\r\n\t\t\ttheta /= ( numpoints - 1 );\r\n\t\r\n\t\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {\r\n\t\r\n\t\t\t\ttheta = - theta;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tfor ( i = 1; i < numpoints; i ++ ) {\r\n\t\r\n\t\t\t\t// twist a little...\r\n\t\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\r\n\t\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/geometries/PolyhedronGeometry.js\r\n\t\r\n\t/**\r\n\t * @author clockworkgeek / https://github.com/clockworkgeek\r\n\t * @author timothypratley / https://github.com/timothypratley\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t*/\r\n\t\r\n\tTHREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'PolyhedronGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tvertices: vertices,\r\n\t\t\tindices: indices,\r\n\t\t\tradius: radius,\r\n\t\t\tdetail: detail\r\n\t\t};\r\n\t\r\n\t\tradius = radius || 1;\r\n\t\tdetail = detail || 0;\r\n\t\r\n\t\tvar that = this;\r\n\t\r\n\t\tfor ( var i = 0, l = vertices.length; i < l; i += 3 ) {\r\n\t\r\n\t\t\tprepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar p = this.vertices;\r\n\t\r\n\t\tvar faces = [];\r\n\t\r\n\t\tfor ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {\r\n\t\r\n\t\t\tvar v1 = p[ indices[ i ] ];\r\n\t\t\tvar v2 = p[ indices[ i + 1 ] ];\r\n\t\t\tvar v3 = p[ indices[ i + 2 ] ];\r\n\t\r\n\t\t\tfaces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, j );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar centroid = new THREE.Vector3();\r\n\t\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tsubdivide( faces[ i ], detail );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Handle case when face straddles the seam\r\n\t\r\n\t\tfor ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {\r\n\t\r\n\t\t\tvar uvs = this.faceVertexUvs[ 0 ][ i ];\r\n\t\r\n\t\t\tvar x0 = uvs[ 0 ].x;\r\n\t\t\tvar x1 = uvs[ 1 ].x;\r\n\t\t\tvar x2 = uvs[ 2 ].x;\r\n\t\r\n\t\t\tvar max = Math.max( x0, x1, x2 );\r\n\t\t\tvar min = Math.min( x0, x1, x2 );\r\n\t\r\n\t\t\tif ( max > 0.9 && min < 0.1 ) {\r\n\t\r\n\t\t\t\t// 0.9 is somewhat arbitrary\r\n\t\r\n\t\t\t\tif ( x0 < 0.2 ) uvs[ 0 ].x += 1;\r\n\t\t\t\tif ( x1 < 0.2 ) uvs[ 1 ].x += 1;\r\n\t\t\t\tif ( x2 < 0.2 ) uvs[ 2 ].x += 1;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Apply radius\r\n\t\r\n\t\tfor ( var i = 0, l = this.vertices.length; i < l; i ++ ) {\r\n\t\r\n\t\t\tthis.vertices[ i ].multiplyScalar( radius );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Merge vertices\r\n\t\r\n\t\tthis.mergeVertices();\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\r\n\t\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\t\r\n\t\r\n\t\t// Project vector onto sphere's surface\r\n\t\r\n\t\tfunction prepare( vector ) {\r\n\t\r\n\t\t\tvar vertex = vector.normalize().clone();\r\n\t\t\tvertex.index = that.vertices.push( vertex ) - 1;\r\n\t\r\n\t\t\t// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\r\n\t\r\n\t\t\tvar u = azimuth( vector ) / 2 / Math.PI + 0.5;\r\n\t\t\tvar v = inclination( vector ) / Math.PI + 0.5;\r\n\t\t\tvertex.uv = new THREE.Vector2( u, 1 - v );\r\n\t\r\n\t\t\treturn vertex;\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Approximate a curved face with recursively sub-divided triangles.\r\n\t\r\n\t\tfunction make( v1, v2, v3, materialIndex ) {\r\n\t\r\n\t\t\tvar face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, materialIndex );\r\n\t\t\tthat.faces.push( face );\r\n\t\r\n\t\t\tcentroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );\r\n\t\r\n\t\t\tvar azi = azimuth( centroid );\r\n\t\r\n\t\t\tthat.faceVertexUvs[ 0 ].push( [\r\n\t\t\t\tcorrectUV( v1.uv, v1, azi ),\r\n\t\t\t\tcorrectUV( v2.uv, v2, azi ),\r\n\t\t\t\tcorrectUV( v3.uv, v3, azi )\r\n\t\t\t] );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Analytically subdivide a face to the required detail level.\r\n\t\r\n\t\tfunction subdivide( face, detail ) {\r\n\t\r\n\t\t\tvar cols = Math.pow( 2, detail );\r\n\t\t\tvar a = prepare( that.vertices[ face.a ] );\r\n\t\t\tvar b = prepare( that.vertices[ face.b ] );\r\n\t\t\tvar c = prepare( that.vertices[ face.c ] );\r\n\t\t\tvar v = [];\r\n\t\r\n\t\t\tvar materialIndex = face.materialIndex;\r\n\t\r\n\t\t\t// Construct all of the vertices for this subdivision.\r\n\t\r\n\t\t\tfor ( var i = 0 ; i <= cols; i ++ ) {\r\n\t\r\n\t\t\t\tv[ i ] = [];\r\n\t\r\n\t\t\t\tvar aj = prepare( a.clone().lerp( c, i / cols ) );\r\n\t\t\t\tvar bj = prepare( b.clone().lerp( c, i / cols ) );\r\n\t\t\t\tvar rows = cols - i;\r\n\t\r\n\t\t\t\tfor ( var j = 0; j <= rows; j ++ ) {\r\n\t\r\n\t\t\t\t\tif ( j === 0 && i === cols ) {\r\n\t\r\n\t\t\t\t\t\tv[ i ][ j ] = aj;\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tv[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\t// Construct all of the faces.\r\n\t\r\n\t\t\tfor ( var i = 0; i < cols ; i ++ ) {\r\n\t\r\n\t\t\t\tfor ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar k = Math.floor( j / 2 );\r\n\t\r\n\t\t\t\t\tif ( j % 2 === 0 ) {\r\n\t\r\n\t\t\t\t\t\tmake(\r\n\t\t\t\t\t\t\tv[ i ][ k + 1 ],\r\n\t\t\t\t\t\t\tv[ i + 1 ][ k ],\r\n\t\t\t\t\t\t\tv[ i ][ k ],\r\n\t\t\t\t\t\t\tmaterialIndex\r\n\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t} else {\r\n\t\r\n\t\t\t\t\t\tmake(\r\n\t\t\t\t\t\t\tv[ i ][ k + 1 ],\r\n\t\t\t\t\t\t\tv[ i + 1 ][ k + 1 ],\r\n\t\t\t\t\t\t\tv[ i + 1 ][ k ],\r\n\t\t\t\t\t\t\tmaterialIndex\r\n\t\t\t\t\t\t);\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Angle around the Y axis, counter-clockwise when looking from above.\r\n\t\r\n\t\tfunction azimuth( vector ) {\r\n\t\r\n\t\t\treturn Math.atan2( vector.z, - vector.x );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Angle above the XZ plane.\r\n\t\r\n\t\tfunction inclination( vector ) {\r\n\t\r\n\t\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t\t// Texture fixing helper. Spheres have some odd behaviours.\r\n\t\r\n\t\tfunction correctUV( uv, vector, azimuth ) {\r\n\t\r\n\t\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );\r\n\t\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );\r\n\t\t\treturn uv.clone();\r\n\t\r\n\t\t}\r\n\t\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;\r\n\t\r\n\t// File:src/extras/geometries/DodecahedronGeometry.js\r\n\t\r\n\t/**\r\n\t * @author Abe Pazos / https://hamoid.com\r\n\t */\r\n\t\r\n\tTHREE.DodecahedronGeometry = function ( radius, detail ) {\r\n\t\r\n\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n\t\tvar r = 1 / t;\r\n\t\r\n\t\tvar vertices = [\r\n\t\r\n\t\t\t// (±1, ±1, ±1)\r\n\t\t\t- 1, - 1, - 1,    - 1, - 1,  1,\r\n\t\t\t- 1,  1, - 1,    - 1,  1,  1,\r\n\t\t\t 1, - 1, - 1,     1, - 1,  1,\r\n\t\t\t 1,  1, - 1,     1,  1,  1,\r\n\t\r\n\t\t\t// (0, ±1/φ, ±φ)\r\n\t\t\t 0, - r, - t,     0, - r,  t,\r\n\t\t\t 0,  r, - t,     0,  r,  t,\r\n\t\r\n\t\t\t// (±1/φ, ±φ, 0)\r\n\t\t\t- r, - t,  0,    - r,  t,  0,\r\n\t\t\t r, - t,  0,     r,  t,  0,\r\n\t\r\n\t\t\t// (±φ, 0, ±1/φ)\r\n\t\t\t- t,  0, - r,     t,  0, - r,\r\n\t\t\t- t,  0,  r,     t,  0,  r\r\n\t\t];\r\n\t\r\n\t\tvar indices = [\r\n\t\t\t 3, 11,  7,      3,  7, 15,      3, 15, 13,\r\n\t\t\t 7, 19, 17,      7, 17,  6,      7,  6, 15,\r\n\t\t\t17,  4,  8,     17,  8, 10,     17, 10,  6,\r\n\t\t\t 8,  0, 16,      8, 16,  2,      8,  2, 10,\r\n\t\t\t 0, 12,  1,      0,  1, 18,      0, 18, 16,\r\n\t\t\t 6, 10,  2,      6,  2, 13,      6, 13, 15,\r\n\t\t\t 2, 16, 18,      2, 18,  3,      2,  3, 13,\r\n\t\t\t18,  1,  9,     18,  9, 11,     18, 11,  3,\r\n\t\t\t 4, 14, 12,      4, 12,  0,      4,  0,  8,\r\n\t\t\t11,  9,  5,     11,  5, 19,     11, 19,  7,\r\n\t\t\t19,  5, 14,     19, 14,  4,     19,  4, 17,\r\n\t\t\t 1, 12, 14,      1, 14,  5,      1,  5,  9\r\n\t\t];\r\n\t\r\n\t\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\t\r\n\t\tthis.type = 'DodecahedronGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tdetail: detail\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\n\tTHREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;\r\n\t\r\n\t// File:src/extras/geometries/IcosahedronGeometry.js\r\n\t\r\n\t/**\r\n\t * @author timothypratley / https://github.com/timothypratley\r\n\t */\r\n\t\r\n\tTHREE.IcosahedronGeometry = function ( radius, detail ) {\r\n\t\r\n\t\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n\t\r\n\t\tvar vertices = [\r\n\t\t\t- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,\r\n\t\t\t 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,\r\n\t\t\t t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1\r\n\t\t];\r\n\t\r\n\t\tvar indices = [\r\n\t\t\t 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,\r\n\t\t\t 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,\r\n\t\t\t 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,\r\n\t\t\t 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1\r\n\t\t];\r\n\t\r\n\t\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\t\r\n\t\tthis.type = 'IcosahedronGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tdetail: detail\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\n\tTHREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;\r\n\t\r\n\t// File:src/extras/geometries/OctahedronGeometry.js\r\n\t\r\n\t/**\r\n\t * @author timothypratley / https://github.com/timothypratley\r\n\t */\r\n\t\r\n\tTHREE.OctahedronGeometry = function ( radius, detail ) {\r\n\t\r\n\t\tvar vertices = [\r\n\t\t\t1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1\r\n\t\t];\r\n\t\r\n\t\tvar indices = [\r\n\t\t\t0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2\r\n\t\t];\r\n\t\r\n\t\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\t\r\n\t\tthis.type = 'OctahedronGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tdetail: detail\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\n\tTHREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;\r\n\t\r\n\t// File:src/extras/geometries/TetrahedronGeometry.js\r\n\t\r\n\t/**\r\n\t * @author timothypratley / https://github.com/timothypratley\r\n\t */\r\n\t\r\n\tTHREE.TetrahedronGeometry = function ( radius, detail ) {\r\n\t\r\n\t\tvar vertices = [\r\n\t\t\t 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1\r\n\t\t];\r\n\t\r\n\t\tvar indices = [\r\n\t\t\t 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1\r\n\t\t];\r\n\t\r\n\t\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\t\r\n\t\tthis.type = 'TetrahedronGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tradius: radius,\r\n\t\t\tdetail: detail\r\n\t\t};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\n\tTHREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;\r\n\t\r\n\t// File:src/extras/geometries/ParametricGeometry.js\r\n\t\r\n\t/**\r\n\t * @author zz85 / https://github.com/zz85\r\n\t * Parametric Surfaces Geometry\r\n\t * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\r\n\t *\r\n\t * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );\r\n\t *\r\n\t */\r\n\t\r\n\tTHREE.ParametricGeometry = function ( func, slices, stacks ) {\r\n\t\r\n\t\tTHREE.Geometry.call( this );\r\n\t\r\n\t\tthis.type = 'ParametricGeometry';\r\n\t\r\n\t\tthis.parameters = {\r\n\t\t\tfunc: func,\r\n\t\t\tslices: slices,\r\n\t\t\tstacks: stacks\r\n\t\t};\r\n\t\r\n\t\tvar verts = this.vertices;\r\n\t\tvar faces = this.faces;\r\n\t\tvar uvs = this.faceVertexUvs[ 0 ];\r\n\t\r\n\t\tvar i, j, p;\r\n\t\tvar u, v;\r\n\t\r\n\t\tvar sliceCount = slices + 1;\r\n\t\r\n\t\tfor ( i = 0; i <= stacks; i ++ ) {\r\n\t\r\n\t\t\tv = i / stacks;\r\n\t\r\n\t\t\tfor ( j = 0; j <= slices; j ++ ) {\r\n\t\r\n\t\t\t\tu = j / slices;\r\n\t\r\n\t\t\t\tp = func( u, v );\r\n\t\t\t\tverts.push( p );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar a, b, c, d;\r\n\t\tvar uva, uvb, uvc, uvd;\r\n\t\r\n\t\tfor ( i = 0; i < stacks; i ++ ) {\r\n\t\r\n\t\t\tfor ( j = 0; j < slices; j ++ ) {\r\n\t\r\n\t\t\t\ta = i * sliceCount + j;\r\n\t\t\t\tb = i * sliceCount + j + 1;\r\n\t\t\t\tc = ( i + 1 ) * sliceCount + j + 1;\r\n\t\t\t\td = ( i + 1 ) * sliceCount + j;\r\n\t\r\n\t\t\t\tuva = new THREE.Vector2( j / slices, i / stacks );\r\n\t\t\t\tuvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );\r\n\t\t\t\tuvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );\r\n\t\t\t\tuvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );\r\n\t\r\n\t\t\t\tfaces.push( new THREE.Face3( a, b, d ) );\r\n\t\t\t\tuvs.push( [ uva, uvb, uvd ] );\r\n\t\r\n\t\t\t\tfaces.push( new THREE.Face3( b, c, d ) );\r\n\t\t\t\tuvs.push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\t// console.log(this);\r\n\t\r\n\t\t// magic bullet\r\n\t\t// var diff = this.mergeVertices();\r\n\t\t// console.log('removed ', diff, ' vertices by merging');\r\n\t\r\n\t\tthis.computeFaceNormals();\r\n\t\tthis.computeVertexNormals();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\n\tTHREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;\r\n\t\r\n\t// File:src/extras/geometries/WireframeGeometry.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.WireframeGeometry = function ( geometry ) {\r\n\t\r\n\t\tTHREE.BufferGeometry.call( this );\r\n\t\r\n\t\tvar edge = [ 0, 0 ], hash = {};\r\n\t\r\n\t\tfunction sortFunction( a, b ) {\r\n\t\r\n\t\t\treturn a - b;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar keys = [ 'a', 'b', 'c' ];\r\n\t\r\n\t\tif ( geometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\tvar vertices = geometry.vertices;\r\n\t\t\tvar faces = geometry.faces;\r\n\t\t\tvar numEdges = 0;\r\n\t\r\n\t\t\t// allocate maximal size\r\n\t\t\tvar edges = new Uint32Array( 6 * faces.length );\r\n\t\r\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\t\r\n\t\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\r\n\t\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\r\n\t\t\t\t\tedge.sort( sortFunction );\r\n\t\r\n\t\t\t\t\tvar key = edge.toString();\r\n\t\r\n\t\t\t\t\tif ( hash[ key ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\r\n\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\r\n\t\t\t\t\t\thash[ key ] = true;\r\n\t\t\t\t\t\tnumEdges ++;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\t\r\n\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\r\n\t\r\n\t\t\t\t\tvar vertex = vertices[ edges [ 2 * i + j ] ];\r\n\t\r\n\t\t\t\t\tvar index = 6 * i + 3 * j;\r\n\t\t\t\t\tcoords[ index + 0 ] = vertex.x;\r\n\t\t\t\t\tcoords[ index + 1 ] = vertex.y;\r\n\t\t\t\t\tcoords[ index + 2 ] = vertex.z;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\t\r\n\t\t} else if ( geometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\tif ( geometry.index !== null ) {\r\n\t\r\n\t\t\t\t// Indexed BufferGeometry\r\n\t\r\n\t\t\t\tvar indices = geometry.index.array;\r\n\t\t\t\tvar vertices = geometry.attributes.position;\r\n\t\t\t\tvar groups = geometry.groups;\r\n\t\t\t\tvar numEdges = 0;\r\n\t\r\n\t\t\t\tif ( groups.length === 0 ) {\r\n\t\r\n\t\t\t\t\tgeometry.addGroup( 0, indices.length );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\t// allocate maximal size\r\n\t\t\t\tvar edges = new Uint32Array( 2 * indices.length );\r\n\t\r\n\t\t\t\tfor ( var o = 0, ol = groups.length; o < ol; ++ o ) {\r\n\t\r\n\t\t\t\t\tvar group = groups[ o ];\r\n\t\r\n\t\t\t\t\tvar start = group.start;\r\n\t\t\t\t\tvar count = group.count;\r\n\t\r\n\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\t\r\n\t\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\t\r\n\t\t\t\t\t\t\tedge[ 0 ] = indices[ i + j ];\r\n\t\t\t\t\t\t\tedge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];\r\n\t\t\t\t\t\t\tedge.sort( sortFunction );\r\n\t\r\n\t\t\t\t\t\t\tvar key = edge.toString();\r\n\t\r\n\t\t\t\t\t\t\tif ( hash[ key ] === undefined ) {\r\n\t\r\n\t\t\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\r\n\t\t\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\r\n\t\t\t\t\t\t\t\thash[ key ] = true;\r\n\t\t\t\t\t\t\t\tnumEdges ++;\r\n\t\r\n\t\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar index = 6 * i + 3 * j;\r\n\t\t\t\t\t\tvar index2 = edges[ 2 * i + j ];\r\n\t\r\n\t\t\t\t\t\tcoords[ index + 0 ] = vertices.getX( index2 );\r\n\t\t\t\t\t\tcoords[ index + 1 ] = vertices.getY( index2 );\r\n\t\t\t\t\t\tcoords[ index + 2 ] = vertices.getZ( index2 );\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\t// non-indexed BufferGeometry\r\n\t\r\n\t\t\t\tvar vertices = geometry.attributes.position.array;\r\n\t\t\t\tvar numEdges = vertices.length / 3;\r\n\t\t\t\tvar numTris = numEdges / 3;\r\n\t\r\n\t\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = numTris; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar index = 18 * i + 6 * j;\r\n\t\r\n\t\t\t\t\t\tvar index1 = 9 * i + 3 * j;\r\n\t\t\t\t\t\tcoords[ index + 0 ] = vertices[ index1 ];\r\n\t\t\t\t\t\tcoords[ index + 1 ] = vertices[ index1 + 1 ];\r\n\t\t\t\t\t\tcoords[ index + 2 ] = vertices[ index1 + 2 ];\r\n\t\r\n\t\t\t\t\t\tvar index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\r\n\t\t\t\t\t\tcoords[ index + 3 ] = vertices[ index2 ];\r\n\t\t\t\t\t\tcoords[ index + 4 ] = vertices[ index2 + 1 ];\r\n\t\t\t\t\t\tcoords[ index + 5 ] = vertices[ index2 + 2 ];\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\n\tTHREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;\r\n\t\r\n\t// File:src/extras/helpers/AxisHelper.js\r\n\t\r\n\t/**\r\n\t * @author sroucheray / http://sroucheray.org/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.AxisHelper = function ( size ) {\r\n\t\r\n\t\tsize = size || 1;\r\n\t\r\n\t\tvar vertices = new Float32Array( [\r\n\t\t\t0, 0, 0,  size, 0, 0,\r\n\t\t\t0, 0, 0,  0, size, 0,\r\n\t\t\t0, 0, 0,  0, 0, size\r\n\t\t] );\r\n\t\r\n\t\tvar colors = new Float32Array( [\r\n\t\t\t1, 0, 0,  1, 0.6, 0,\r\n\t\t\t0, 1, 0,  0.6, 1, 0,\r\n\t\t\t0, 0, 1,  0, 0.6, 1\r\n\t\t] );\r\n\t\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\t\tgeometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\r\n\t\r\n\t\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\r\n\t\r\n\t\tTHREE.LineSegments.call( this, geometry, material );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\n\tTHREE.AxisHelper.prototype.constructor = THREE.AxisHelper;\r\n\t\r\n\t// File:src/extras/helpers/ArrowHelper.js\r\n\t\r\n\t/**\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t * @author zz85 / http://github.com/zz85\r\n\t * @author bhouston / http://clara.io\r\n\t *\r\n\t * Creates an arrow for visualizing directions\r\n\t *\r\n\t * Parameters:\r\n\t *  dir - Vector3\r\n\t *  origin - Vector3\r\n\t *  length - Number\r\n\t *  color - color in hex value\r\n\t *  headLength - Number\r\n\t *  headWidth - Number\r\n\t */\r\n\t\r\n\tTHREE.ArrowHelper = ( function () {\r\n\t\r\n\t\tvar lineGeometry = new THREE.BufferGeometry();\r\n\t\tlineGeometry.addAttribute( 'position', new THREE.Float32Attribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\r\n\t\r\n\t\tvar coneGeometry = new THREE.CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );\r\n\t\tconeGeometry.translate( 0, - 0.5, 0 );\r\n\t\r\n\t\treturn function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\r\n\t\r\n\t\t\t// dir is assumed to be normalized\r\n\t\r\n\t\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\t\tif ( color === undefined ) color = 0xffff00;\r\n\t\t\tif ( length === undefined ) length = 1;\r\n\t\t\tif ( headLength === undefined ) headLength = 0.2 * length;\r\n\t\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\r\n\t\r\n\t\t\tthis.position.copy( origin );\r\n\t\r\n\t\t\tthis.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );\r\n\t\t\tthis.line.matrixAutoUpdate = false;\r\n\t\t\tthis.add( this.line );\r\n\t\r\n\t\t\tthis.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );\r\n\t\t\tthis.cone.matrixAutoUpdate = false;\r\n\t\t\tthis.add( this.cone );\r\n\t\r\n\t\t\tthis.setDirection( dir );\r\n\t\t\tthis.setLength( length, headLength, headWidth );\r\n\t\r\n\t\t};\r\n\t\r\n\t}() );\r\n\t\r\n\tTHREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;\r\n\t\r\n\tTHREE.ArrowHelper.prototype.setDirection = ( function () {\r\n\t\r\n\t\tvar axis = new THREE.Vector3();\r\n\t\tvar radians;\r\n\t\r\n\t\treturn function setDirection( dir ) {\r\n\t\r\n\t\t\t// dir is assumed to be normalized\r\n\t\r\n\t\t\tif ( dir.y > 0.99999 ) {\r\n\t\r\n\t\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\r\n\t\r\n\t\t\t} else if ( dir.y < - 0.99999 ) {\r\n\t\r\n\t\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\r\n\t\r\n\t\t\t\tradians = Math.acos( dir.y );\r\n\t\r\n\t\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t};\r\n\t\r\n\t}() );\r\n\t\r\n\tTHREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\r\n\t\r\n\t\tif ( headLength === undefined ) headLength = 0.2 * length;\r\n\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\r\n\t\r\n\t\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\r\n\t\tthis.line.updateMatrix();\r\n\t\r\n\t\tthis.cone.scale.set( headWidth, headLength, headWidth );\r\n\t\tthis.cone.position.y = length;\r\n\t\tthis.cone.updateMatrix();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ArrowHelper.prototype.setColor = function ( color ) {\r\n\t\r\n\t\tthis.line.material.color.copy( color );\r\n\t\tthis.cone.material.color.copy( color );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/helpers/BoxHelper.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.BoxHelper = function ( object ) {\r\n\t\r\n\t\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\r\n\t\tvar positions = new Float32Array( 8 * 3 );\r\n\t\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\tgeometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n\t\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\r\n\t\r\n\t\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ) );\r\n\t\r\n\t\tif ( object !== undefined ) {\r\n\t\r\n\t\t\tthis.update( object );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\n\tTHREE.BoxHelper.prototype.constructor = THREE.BoxHelper;\r\n\t\r\n\tTHREE.BoxHelper.prototype.update = ( function () {\r\n\t\r\n\t\tvar box = new THREE.Box3();\r\n\t\r\n\t\treturn function ( object ) {\r\n\t\r\n\t\t\tif ( object instanceof THREE.Box3 ) {\r\n\t\r\n\t\t\t\tbox.copy( object );\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tbox.setFromObject( object );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tif ( box.isEmpty() ) return;\r\n\t\r\n\t\t\tvar min = box.min;\r\n\t\t\tvar max = box.max;\r\n\t\r\n\t\t\t/*\r\n\t\t\t  5____4\r\n\t\t\t1/___0/|\r\n\t\t\t| 6__|_7\r\n\t\t\t2/___3/\r\n\t\r\n\t\t\t0: max.x, max.y, max.z\r\n\t\t\t1: min.x, max.y, max.z\r\n\t\t\t2: min.x, min.y, max.z\r\n\t\t\t3: max.x, min.y, max.z\r\n\t\t\t4: max.x, max.y, min.z\r\n\t\t\t5: min.x, max.y, min.z\r\n\t\t\t6: min.x, min.y, min.z\r\n\t\t\t7: max.x, min.y, min.z\r\n\t\t\t*/\r\n\t\r\n\t\t\tvar position = this.geometry.attributes.position;\r\n\t\t\tvar array = position.array;\r\n\t\r\n\t\t\tarray[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;\r\n\t\t\tarray[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;\r\n\t\t\tarray[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;\r\n\t\t\tarray[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\r\n\t\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\r\n\t\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\r\n\t\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\r\n\t\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\r\n\t\r\n\t\t\tposition.needsUpdate = true;\r\n\t\r\n\t\t\tthis.geometry.computeBoundingSphere();\r\n\t\r\n\t\t};\r\n\t\r\n\t} )();\r\n\t\r\n\t// File:src/extras/helpers/BoundingBoxHelper.js\r\n\t\r\n\t/**\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\t// a helper to show the world-axis-aligned bounding box for an object\r\n\t\r\n\tTHREE.BoundingBoxHelper = function ( object, hex ) {\r\n\t\r\n\t\tvar color = ( hex !== undefined ) ? hex : 0x888888;\r\n\t\r\n\t\tthis.object = object;\r\n\t\r\n\t\tthis.box = new THREE.Box3();\r\n\t\r\n\t\tTHREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );\r\n\tTHREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;\r\n\t\r\n\tTHREE.BoundingBoxHelper.prototype.update = function () {\r\n\t\r\n\t\tthis.box.setFromObject( this.object );\r\n\t\r\n\t\tthis.box.size( this.scale );\r\n\t\r\n\t\tthis.box.center( this.position );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/helpers/CameraHelper.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t *\r\n\t *\t- shows frustum, line of sight and up of the camera\r\n\t *\t- suitable for fast updates\r\n\t * \t- based on frustum visualization in lightgl.js shadowmap example\r\n\t *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\r\n\t */\r\n\t\r\n\tTHREE.CameraHelper = function ( camera ) {\r\n\t\r\n\t\tvar geometry = new THREE.Geometry();\r\n\t\tvar material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );\r\n\t\r\n\t\tvar pointMap = {};\r\n\t\r\n\t\t// colors\r\n\t\r\n\t\tvar hexFrustum = 0xffaa00;\r\n\t\tvar hexCone = 0xff0000;\r\n\t\tvar hexUp = 0x00aaff;\r\n\t\tvar hexTarget = 0xffffff;\r\n\t\tvar hexCross = 0x333333;\r\n\t\r\n\t\t// near\r\n\t\r\n\t\taddLine( \"n1\", \"n2\", hexFrustum );\r\n\t\taddLine( \"n2\", \"n4\", hexFrustum );\r\n\t\taddLine( \"n4\", \"n3\", hexFrustum );\r\n\t\taddLine( \"n3\", \"n1\", hexFrustum );\r\n\t\r\n\t\t// far\r\n\t\r\n\t\taddLine( \"f1\", \"f2\", hexFrustum );\r\n\t\taddLine( \"f2\", \"f4\", hexFrustum );\r\n\t\taddLine( \"f4\", \"f3\", hexFrustum );\r\n\t\taddLine( \"f3\", \"f1\", hexFrustum );\r\n\t\r\n\t\t// sides\r\n\t\r\n\t\taddLine( \"n1\", \"f1\", hexFrustum );\r\n\t\taddLine( \"n2\", \"f2\", hexFrustum );\r\n\t\taddLine( \"n3\", \"f3\", hexFrustum );\r\n\t\taddLine( \"n4\", \"f4\", hexFrustum );\r\n\t\r\n\t\t// cone\r\n\t\r\n\t\taddLine( \"p\", \"n1\", hexCone );\r\n\t\taddLine( \"p\", \"n2\", hexCone );\r\n\t\taddLine( \"p\", \"n3\", hexCone );\r\n\t\taddLine( \"p\", \"n4\", hexCone );\r\n\t\r\n\t\t// up\r\n\t\r\n\t\taddLine( \"u1\", \"u2\", hexUp );\r\n\t\taddLine( \"u2\", \"u3\", hexUp );\r\n\t\taddLine( \"u3\", \"u1\", hexUp );\r\n\t\r\n\t\t// target\r\n\t\r\n\t\taddLine( \"c\", \"t\", hexTarget );\r\n\t\taddLine( \"p\", \"c\", hexCross );\r\n\t\r\n\t\t// cross\r\n\t\r\n\t\taddLine( \"cn1\", \"cn2\", hexCross );\r\n\t\taddLine( \"cn3\", \"cn4\", hexCross );\r\n\t\r\n\t\taddLine( \"cf1\", \"cf2\", hexCross );\r\n\t\taddLine( \"cf3\", \"cf4\", hexCross );\r\n\t\r\n\t\tfunction addLine( a, b, hex ) {\r\n\t\r\n\t\t\taddPoint( a, hex );\r\n\t\t\taddPoint( b, hex );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfunction addPoint( id, hex ) {\r\n\t\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\tgeometry.colors.push( new THREE.Color( hex ) );\r\n\t\r\n\t\t\tif ( pointMap[ id ] === undefined ) {\r\n\t\r\n\t\t\t\tpointMap[ id ] = [];\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tpointMap[ id ].push( geometry.vertices.length - 1 );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tTHREE.LineSegments.call( this, geometry, material );\r\n\t\r\n\t\tthis.camera = camera;\r\n\t\tthis.camera.updateProjectionMatrix();\r\n\t\r\n\t\tthis.matrix = camera.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tthis.pointMap = pointMap;\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\n\tTHREE.CameraHelper.prototype.constructor = THREE.CameraHelper;\r\n\t\r\n\tTHREE.CameraHelper.prototype.update = function () {\r\n\t\r\n\t\tvar geometry, pointMap;\r\n\t\r\n\t\tvar vector = new THREE.Vector3();\r\n\t\tvar camera = new THREE.Camera();\r\n\t\r\n\t\tfunction setPoint( point, x, y, z ) {\r\n\t\r\n\t\t\tvector.set( x, y, z ).unproject( camera );\r\n\t\r\n\t\t\tvar points = pointMap[ point ];\r\n\t\r\n\t\t\tif ( points !== undefined ) {\r\n\t\r\n\t\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\t\r\n\t\t\t\t\tgeometry.vertices[ points[ i ] ].copy( vector );\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn function () {\r\n\t\r\n\t\t\tgeometry = this.geometry;\r\n\t\t\tpointMap = this.pointMap;\r\n\t\r\n\t\t\tvar w = 1, h = 1;\r\n\t\r\n\t\t\t// we need just camera projection matrix\r\n\t\t\t// world matrix must be identity\r\n\t\r\n\t\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\r\n\t\r\n\t\t\t// center / target\r\n\t\r\n\t\t\tsetPoint( \"c\", 0, 0, - 1 );\r\n\t\t\tsetPoint( \"t\", 0, 0,  1 );\r\n\t\r\n\t\t\t// near\r\n\t\r\n\t\t\tsetPoint( \"n1\", - w, - h, - 1 );\r\n\t\t\tsetPoint( \"n2\",   w, - h, - 1 );\r\n\t\t\tsetPoint( \"n3\", - w,   h, - 1 );\r\n\t\t\tsetPoint( \"n4\",   w,   h, - 1 );\r\n\t\r\n\t\t\t// far\r\n\t\r\n\t\t\tsetPoint( \"f1\", - w, - h, 1 );\r\n\t\t\tsetPoint( \"f2\",   w, - h, 1 );\r\n\t\t\tsetPoint( \"f3\", - w,   h, 1 );\r\n\t\t\tsetPoint( \"f4\",   w,   h, 1 );\r\n\t\r\n\t\t\t// up\r\n\t\r\n\t\t\tsetPoint( \"u1\",   w * 0.7, h * 1.1, - 1 );\r\n\t\t\tsetPoint( \"u2\", - w * 0.7, h * 1.1, - 1 );\r\n\t\t\tsetPoint( \"u3\",         0, h * 2,   - 1 );\r\n\t\r\n\t\t\t// cross\r\n\t\r\n\t\t\tsetPoint( \"cf1\", - w,   0, 1 );\r\n\t\t\tsetPoint( \"cf2\",   w,   0, 1 );\r\n\t\t\tsetPoint( \"cf3\",   0, - h, 1 );\r\n\t\t\tsetPoint( \"cf4\",   0,   h, 1 );\r\n\t\r\n\t\t\tsetPoint( \"cn1\", - w,   0, - 1 );\r\n\t\t\tsetPoint( \"cn2\",   w,   0, - 1 );\r\n\t\t\tsetPoint( \"cn3\",   0, - h, - 1 );\r\n\t\t\tsetPoint( \"cn4\",   0,   h, - 1 );\r\n\t\r\n\t\t\tgeometry.verticesNeedUpdate = true;\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\t// File:src/extras/helpers/DirectionalLightHelper.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t */\r\n\t\r\n\tTHREE.DirectionalLightHelper = function ( light, size ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.light = light;\r\n\t\tthis.light.updateMatrixWorld();\r\n\t\r\n\t\tthis.matrix = light.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tif ( size === undefined ) size = 1;\r\n\t\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( [\r\n\t\t\t- size,   size, 0,\r\n\t\t\t  size,   size, 0,\r\n\t\t\t  size, - size, 0,\r\n\t\t\t- size, - size, 0,\r\n\t\t\t- size,   size, 0\r\n\t\t], 3 ) );\r\n\t\r\n\t\tvar material = new THREE.LineBasicMaterial( { fog: false } );\r\n\t\r\n\t\tthis.add( new THREE.Line( geometry, material ) );\r\n\t\r\n\t\tgeometry = new THREE.BufferGeometry();\r\n\t\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\r\n\t\r\n\t\tthis.add( new THREE.Line( geometry, material ));\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;\r\n\t\r\n\tTHREE.DirectionalLightHelper.prototype.dispose = function () {\r\n\t\r\n\t\tvar lightPlane = this.children[ 0 ];\r\n\t\tvar targetLine = this.children[ 1 ];\r\n\t\r\n\t\tlightPlane.geometry.dispose();\r\n\t\tlightPlane.material.dispose();\r\n\t\ttargetLine.geometry.dispose();\r\n\t\ttargetLine.material.dispose();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.DirectionalLightHelper.prototype.update = function () {\r\n\t\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\t\tvar v3 = new THREE.Vector3();\r\n\t\r\n\t\treturn function () {\r\n\t\r\n\t\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\r\n\t\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\r\n\t\t\tv3.subVectors( v2, v1 );\r\n\t\r\n\t\t\tvar lightPlane = this.children[ 0 ];\r\n\t\t\tvar targetLine = this.children[ 1 ];\r\n\t\r\n\t\t\tlightPlane.lookAt( v3 );\r\n\t\t\tlightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\t\ttargetLine.lookAt( v3 );\r\n\t\t\ttargetLine.scale.z = v3.length();\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\t// File:src/extras/helpers/EdgesHelper.js\r\n\t\r\n\t/**\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t * @param object THREE.Mesh whose geometry will be used\r\n\t * @param hex line color\r\n\t * @param thresholdAngle the minimum angle (in degrees),\r\n\t * between the face normals of adjacent faces,\r\n\t * that is required to render an edge. A value of 10 means\r\n\t * an edge is only rendered if the angle is at least 10 degrees.\r\n\t */\r\n\t\r\n\tTHREE.EdgesHelper = function ( object, hex, thresholdAngle ) {\r\n\t\r\n\t\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\r\n\t\r\n\t\tTHREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );\r\n\t\r\n\t\tthis.matrix = object.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\n\tTHREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;\r\n\t\r\n\t// File:src/extras/helpers/FaceNormalsHelper.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t*/\r\n\t\r\n\tTHREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {\r\n\t\r\n\t\t// FaceNormalsHelper only supports THREE.Geometry\r\n\t\r\n\t\tthis.object = object;\r\n\t\r\n\t\tthis.size = ( size !== undefined ) ? size : 1;\r\n\t\r\n\t\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\r\n\t\r\n\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvar nNormals = 0;\r\n\t\r\n\t\tvar objGeometry = this.object.geometry;\r\n\t\r\n\t\tif ( objGeometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\tnNormals = objGeometry.faces.length;\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tconsole.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\r\n\t\r\n\t\t}\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\r\n\t\tvar positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\r\n\t\r\n\t\tgeometry.addAttribute( 'position', positions );\r\n\t\r\n\t\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\r\n\t\r\n\t\t//\r\n\t\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\n\tTHREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;\r\n\t\r\n\tTHREE.FaceNormalsHelper.prototype.update = ( function () {\r\n\t\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\t\tvar normalMatrix = new THREE.Matrix3();\r\n\t\r\n\t\treturn function update() {\r\n\t\r\n\t\t\tthis.object.updateMatrixWorld( true );\r\n\t\r\n\t\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\r\n\t\r\n\t\t\tvar matrixWorld = this.object.matrixWorld;\r\n\t\r\n\t\t\tvar position = this.geometry.attributes.position;\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tvar objGeometry = this.object.geometry;\r\n\t\r\n\t\t\tvar vertices = objGeometry.vertices;\r\n\t\r\n\t\t\tvar faces = objGeometry.faces;\r\n\t\r\n\t\t\tvar idx = 0;\r\n\t\r\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\t\tvar normal = face.normal;\r\n\t\r\n\t\t\t\tv1.copy( vertices[ face.a ] )\r\n\t\t\t\t\t.add( vertices[ face.b ] )\r\n\t\t\t\t\t.add( vertices[ face.c ] )\r\n\t\t\t\t\t.divideScalar( 3 )\r\n\t\t\t\t\t.applyMatrix4( matrixWorld );\r\n\t\r\n\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\r\n\t\r\n\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\r\n\t\r\n\t\t\t\tidx = idx + 1;\r\n\t\r\n\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\r\n\t\r\n\t\t\t\tidx = idx + 1;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tposition.needsUpdate = true;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t};\r\n\t\r\n\t}() );\r\n\t\r\n\t// File:src/extras/helpers/GridHelper.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.GridHelper = function ( size, step, color1, color2 ) {\r\n\t\r\n\t\tcolor1 = new THREE.Color( color1 !== undefined ? color1 : 0x444444 );\r\n\t\tcolor2 = new THREE.Color( color2 !== undefined ? color2 : 0x888888 );\r\n\t\r\n\t\tvar vertices = [];\r\n\t\tvar colors = [];\r\n\t\r\n\t\tfor ( var i = - size, j = 0; i <= size; i += step ) {\r\n\t\r\n\t\t\tvertices.push( - size, 0, i, size, 0, i );\r\n\t\t\tvertices.push( i, 0, - size, i, 0, size );\r\n\t\r\n\t\t\tvar color = i === 0 ? color1 : color2;\r\n\t\r\n\t\t\tcolor.toArray( colors, j ); j += 3;\r\n\t\t\tcolor.toArray( colors, j ); j += 3;\r\n\t\t\tcolor.toArray( colors, j ); j += 3;\r\n\t\t\tcolor.toArray( colors, j ); j += 3;\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( vertices, 3 ) );\r\n\t\tgeometry.addAttribute( 'color', new THREE.Float32Attribute( colors, 3 ) );\r\n\t\r\n\t\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\r\n\t\r\n\t\tTHREE.LineSegments.call( this, geometry, material );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\n\tTHREE.GridHelper.prototype.constructor = THREE.GridHelper;\r\n\t\r\n\tTHREE.GridHelper.prototype.setColors = function () {\r\n\t\r\n\t\tconsole.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/helpers/HemisphereLightHelper.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.HemisphereLightHelper = function ( light, sphereSize ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.light = light;\r\n\t\tthis.light.updateMatrixWorld();\r\n\t\r\n\t\tthis.matrix = light.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tthis.colors = [ new THREE.Color(), new THREE.Color() ];\r\n\t\r\n\t\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\r\n\t\tgeometry.rotateX( - Math.PI / 2 );\r\n\t\r\n\t\tfor ( var i = 0, il = 8; i < il; i ++ ) {\r\n\t\r\n\t\t\tgeometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\r\n\t\r\n\t\t}\r\n\t\r\n\t\tvar material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );\r\n\t\r\n\t\tthis.lightSphere = new THREE.Mesh( geometry, material );\r\n\t\tthis.add( this.lightSphere );\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;\r\n\t\r\n\tTHREE.HemisphereLightHelper.prototype.dispose = function () {\r\n\t\r\n\t\tthis.lightSphere.geometry.dispose();\r\n\t\tthis.lightSphere.material.dispose();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.HemisphereLightHelper.prototype.update = function () {\r\n\t\r\n\t\tvar vector = new THREE.Vector3();\r\n\t\r\n\t\treturn function () {\r\n\t\r\n\t\t\tthis.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\t\tthis.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\t\tthis.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\r\n\t\t\tthis.lightSphere.geometry.colorsNeedUpdate = true;\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\t// File:src/extras/helpers/PointLightHelper.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.PointLightHelper = function ( light, sphereSize ) {\r\n\t\r\n\t\tthis.light = light;\r\n\t\tthis.light.updateMatrixWorld();\r\n\t\r\n\t\tvar geometry = new THREE.SphereBufferGeometry( sphereSize, 4, 2 );\r\n\t\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\r\n\t\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\tTHREE.Mesh.call( this, geometry, material );\r\n\t\r\n\t\tthis.matrix = this.light.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\t/*\r\n\t\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\r\n\t\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\r\n\t\r\n\t\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\r\n\t\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\r\n\t\r\n\t\tvar d = light.distance;\r\n\t\r\n\t\tif ( d === 0.0 ) {\r\n\t\r\n\t\t\tthis.lightDistance.visible = false;\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tthis.lightDistance.scale.set( d, d, d );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.add( this.lightDistance );\r\n\t\t*/\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );\r\n\tTHREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;\r\n\t\r\n\tTHREE.PointLightHelper.prototype.dispose = function () {\r\n\t\r\n\t\tthis.geometry.dispose();\r\n\t\tthis.material.dispose();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.PointLightHelper.prototype.update = function () {\r\n\t\r\n\t\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\t/*\r\n\t\tvar d = this.light.distance;\r\n\t\r\n\t\tif ( d === 0.0 ) {\r\n\t\r\n\t\t\tthis.lightDistance.visible = false;\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tthis.lightDistance.visible = true;\r\n\t\t\tthis.lightDistance.scale.set( d, d, d );\r\n\t\r\n\t\t}\r\n\t\t*/\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/helpers/SkeletonHelper.js\r\n\t\r\n\t/**\r\n\t * @author Sean Griffin / http://twitter.com/sgrif\r\n\t * @author Michael Guerrero / http://realitymeltdown.com\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author ikerr / http://verold.com\r\n\t */\r\n\t\r\n\tTHREE.SkeletonHelper = function ( object ) {\r\n\t\r\n\t\tthis.bones = this.getBoneList( object );\r\n\t\r\n\t\tvar geometry = new THREE.Geometry();\r\n\t\r\n\t\tfor ( var i = 0; i < this.bones.length; i ++ ) {\r\n\t\r\n\t\t\tvar bone = this.bones[ i ];\r\n\t\r\n\t\t\tif ( bone.parent instanceof THREE.Bone ) {\r\n\t\r\n\t\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\t\tgeometry.colors.push( new THREE.Color( 0, 0, 1 ) );\r\n\t\t\t\tgeometry.colors.push( new THREE.Color( 0, 1, 0 ) );\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tgeometry.dynamic = true;\r\n\t\r\n\t\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );\r\n\t\r\n\t\tTHREE.LineSegments.call( this, geometry, material );\r\n\t\r\n\t\tthis.root = object;\r\n\t\r\n\t\tthis.matrix = object.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\t\r\n\tTHREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\n\tTHREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;\r\n\t\r\n\tTHREE.SkeletonHelper.prototype.getBoneList = function( object ) {\r\n\t\r\n\t\tvar boneList = [];\r\n\t\r\n\t\tif ( object instanceof THREE.Bone ) {\r\n\t\r\n\t\t\tboneList.push( object );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfor ( var i = 0; i < object.children.length; i ++ ) {\r\n\t\r\n\t\t\tboneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn boneList;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SkeletonHelper.prototype.update = function () {\r\n\t\r\n\t\tvar geometry = this.geometry;\r\n\t\r\n\t\tvar matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );\r\n\t\r\n\t\tvar boneMatrix = new THREE.Matrix4();\r\n\t\r\n\t\tvar j = 0;\r\n\t\r\n\t\tfor ( var i = 0; i < this.bones.length; i ++ ) {\r\n\t\r\n\t\t\tvar bone = this.bones[ i ];\r\n\t\r\n\t\t\tif ( bone.parent instanceof THREE.Bone ) {\r\n\t\r\n\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\r\n\t\t\t\tgeometry.vertices[ j ].setFromMatrixPosition( boneMatrix );\r\n\t\r\n\t\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\r\n\t\t\t\tgeometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );\r\n\t\r\n\t\t\t\tj += 2;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tgeometry.verticesNeedUpdate = true;\r\n\t\r\n\t\tgeometry.computeBoundingSphere();\r\n\t\r\n\t};\r\n\t\r\n\t// File:src/extras/helpers/SpotLightHelper.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t*/\r\n\t\r\n\tTHREE.SpotLightHelper = function ( light ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.light = light;\r\n\t\tthis.light.updateMatrixWorld();\r\n\t\r\n\t\tthis.matrix = light.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\r\n\t\tvar positions = [\r\n\t\t\t0, 0, 0,   0,   0,   1,\r\n\t\t\t0, 0, 0,   1,   0,   1,\r\n\t\t\t0, 0, 0, - 1,   0,   1,\r\n\t\t\t0, 0, 0,   0,   1,   1,\r\n\t\t\t0, 0, 0,   0, - 1,   1\r\n\t\t];\r\n\t\r\n\t\tfor ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\r\n\t\r\n\t\t\tvar p1 = ( i / l ) * Math.PI * 2;\r\n\t\t\tvar p2 = ( j / l ) * Math.PI * 2;\r\n\t\r\n\t\t\tpositions.push(\r\n\t\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\r\n\t\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\r\n\t\t\t);\r\n\t\r\n\t\t}\r\n\t\r\n\t\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( positions, 3 ) );\r\n\t\r\n\t\tvar material = new THREE.LineBasicMaterial( { fog: false } );\r\n\t\r\n\t\tthis.cone = new THREE.LineSegments( geometry, material );\r\n\t\tthis.add( this.cone );\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;\r\n\t\r\n\tTHREE.SpotLightHelper.prototype.dispose = function () {\r\n\t\r\n\t\tthis.cone.geometry.dispose();\r\n\t\tthis.cone.material.dispose();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.SpotLightHelper.prototype.update = function () {\r\n\t\r\n\t\tvar vector = new THREE.Vector3();\r\n\t\tvar vector2 = new THREE.Vector3();\r\n\t\r\n\t\treturn function () {\r\n\t\r\n\t\t\tvar coneLength = this.light.distance ? this.light.distance : 1000;\r\n\t\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\r\n\t\r\n\t\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\r\n\t\r\n\t\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\r\n\t\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\r\n\t\r\n\t\t\tthis.cone.lookAt( vector2.sub( vector ) );\r\n\t\r\n\t\t\tthis.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\r\n\t\t};\r\n\t\r\n\t}();\r\n\t\r\n\t// File:src/extras/helpers/VertexNormalsHelper.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t * @author WestLangley / http://github.com/WestLangley\r\n\t*/\r\n\t\r\n\tTHREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {\r\n\t\r\n\t\tthis.object = object;\r\n\t\r\n\t\tthis.size = ( size !== undefined ) ? size : 1;\r\n\t\r\n\t\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\r\n\t\r\n\t\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvar nNormals = 0;\r\n\t\r\n\t\tvar objGeometry = this.object.geometry;\r\n\t\r\n\t\tif ( objGeometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\tnNormals = objGeometry.faces.length * 3;\r\n\t\r\n\t\t} else if ( objGeometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\tnNormals = objGeometry.attributes.normal.count;\r\n\t\r\n\t\t}\r\n\t\r\n\t\t//\r\n\t\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\t\r\n\t\tvar positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\r\n\t\r\n\t\tgeometry.addAttribute( 'position', positions );\r\n\t\r\n\t\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\r\n\t\r\n\t\t//\r\n\t\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t\tthis.update();\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\n\tTHREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;\r\n\t\r\n\tTHREE.VertexNormalsHelper.prototype.update = ( function () {\r\n\t\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\t\tvar normalMatrix = new THREE.Matrix3();\r\n\t\r\n\t\treturn function update() {\r\n\t\r\n\t\t\tvar keys = [ 'a', 'b', 'c' ];\r\n\t\r\n\t\t\tthis.object.updateMatrixWorld( true );\r\n\t\r\n\t\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\r\n\t\r\n\t\t\tvar matrixWorld = this.object.matrixWorld;\r\n\t\r\n\t\t\tvar position = this.geometry.attributes.position;\r\n\t\r\n\t\t\t//\r\n\t\r\n\t\t\tvar objGeometry = this.object.geometry;\r\n\t\r\n\t\t\tif ( objGeometry instanceof THREE.Geometry ) {\r\n\t\r\n\t\t\t\tvar vertices = objGeometry.vertices;\r\n\t\r\n\t\t\t\tvar faces = objGeometry.faces;\r\n\t\r\n\t\t\t\tvar idx = 0;\r\n\t\r\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\t\r\n\t\t\t\t\tvar face = faces[ i ];\r\n\t\r\n\t\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\t\tvar vertex = vertices[ face[ keys[ j ] ] ];\r\n\t\r\n\t\t\t\t\t\tvar normal = face.vertexNormals[ j ];\r\n\t\r\n\t\t\t\t\t\tv1.copy( vertex ).applyMatrix4( matrixWorld );\r\n\t\r\n\t\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\r\n\t\r\n\t\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\r\n\t\r\n\t\t\t\t\t\tidx = idx + 1;\r\n\t\r\n\t\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\r\n\t\r\n\t\t\t\t\t\tidx = idx + 1;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else if ( objGeometry instanceof THREE.BufferGeometry ) {\r\n\t\r\n\t\t\t\tvar objPos = objGeometry.attributes.position;\r\n\t\r\n\t\t\t\tvar objNorm = objGeometry.attributes.normal;\r\n\t\r\n\t\t\t\tvar idx = 0;\r\n\t\r\n\t\t\t\t// for simplicity, ignore index and drawcalls, and render every normal\r\n\t\r\n\t\t\t\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\r\n\t\r\n\t\t\t\t\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\r\n\t\r\n\t\t\t\t\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\r\n\t\r\n\t\t\t\t\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\r\n\t\r\n\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\r\n\t\r\n\t\t\t\t\tidx = idx + 1;\r\n\t\r\n\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\r\n\t\r\n\t\t\t\t\tidx = idx + 1;\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tposition.needsUpdate = true;\r\n\t\r\n\t\t\treturn this;\r\n\t\r\n\t\t};\r\n\t\r\n\t}() );\r\n\t\r\n\t// File:src/extras/helpers/WireframeHelper.js\r\n\t\r\n\t/**\r\n\t * @author mrdoob / http://mrdoob.com/\r\n\t */\r\n\t\r\n\tTHREE.WireframeHelper = function ( object, hex ) {\r\n\t\r\n\t\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\r\n\t\r\n\t\tTHREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );\r\n\t\r\n\t\tthis.matrix = object.matrixWorld;\r\n\t\tthis.matrixAutoUpdate = false;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\n\tTHREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;\r\n\t\r\n\t// File:src/extras/objects/ImmediateRenderObject.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.ImmediateRenderObject = function ( material ) {\r\n\t\r\n\t\tTHREE.Object3D.call( this );\r\n\t\r\n\t\tthis.material = material;\r\n\t\tthis.render = function ( renderCallback ) {};\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );\r\n\tTHREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;\r\n\t\r\n\t// File:src/extras/objects/MorphBlendMesh.js\r\n\t\r\n\t/**\r\n\t * @author alteredq / http://alteredqualia.com/\r\n\t */\r\n\t\r\n\tTHREE.MorphBlendMesh = function( geometry, material ) {\r\n\t\r\n\t\tTHREE.Mesh.call( this, geometry, material );\r\n\t\r\n\t\tthis.animationsMap = {};\r\n\t\tthis.animationsList = [];\r\n\t\r\n\t\t// prepare default animation\r\n\t\t// (all frames played together in 1 second)\r\n\t\r\n\t\tvar numFrames = this.geometry.morphTargets.length;\r\n\t\r\n\t\tvar name = \"__default\";\r\n\t\r\n\t\tvar startFrame = 0;\r\n\t\tvar endFrame = numFrames - 1;\r\n\t\r\n\t\tvar fps = numFrames / 1;\r\n\t\r\n\t\tthis.createAnimation( name, startFrame, endFrame, fps );\r\n\t\tthis.setAnimationWeight( name, 1 );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );\r\n\tTHREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\r\n\t\r\n\t\tvar animation = {\r\n\t\r\n\t\t\tstart: start,\r\n\t\t\tend: end,\r\n\t\r\n\t\t\tlength: end - start + 1,\r\n\t\r\n\t\t\tfps: fps,\r\n\t\t\tduration: ( end - start ) / fps,\r\n\t\r\n\t\t\tlastFrame: 0,\r\n\t\t\tcurrentFrame: 0,\r\n\t\r\n\t\t\tactive: false,\r\n\t\r\n\t\t\ttime: 0,\r\n\t\t\tdirection: 1,\r\n\t\t\tweight: 1,\r\n\t\r\n\t\t\tdirectionBackwards: false,\r\n\t\t\tmirroredLoop: false\r\n\t\r\n\t\t};\r\n\t\r\n\t\tthis.animationsMap[ name ] = animation;\r\n\t\tthis.animationsList.push( animation );\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\r\n\t\r\n\t\tvar pattern = /([a-z]+)_?(\\d+)/i;\r\n\t\r\n\t\tvar firstAnimation, frameRanges = {};\r\n\t\r\n\t\tvar geometry = this.geometry;\r\n\t\r\n\t\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\t\r\n\t\t\tvar morph = geometry.morphTargets[ i ];\r\n\t\t\tvar chunks = morph.name.match( pattern );\r\n\t\r\n\t\t\tif ( chunks && chunks.length > 1 ) {\r\n\t\r\n\t\t\t\tvar name = chunks[ 1 ];\r\n\t\r\n\t\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\r\n\t\r\n\t\t\t\tvar range = frameRanges[ name ];\r\n\t\r\n\t\t\t\tif ( i < range.start ) range.start = i;\r\n\t\t\t\tif ( i > range.end ) range.end = i;\r\n\t\r\n\t\t\t\tif ( ! firstAnimation ) firstAnimation = name;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t\tfor ( var name in frameRanges ) {\r\n\t\r\n\t\t\tvar range = frameRanges[ name ];\r\n\t\t\tthis.createAnimation( name, range.start, range.end, fps );\r\n\t\r\n\t\t}\r\n\t\r\n\t\tthis.firstAnimation = firstAnimation;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.direction = 1;\r\n\t\t\tanimation.directionBackwards = false;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.direction = - 1;\r\n\t\t\tanimation.directionBackwards = true;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.fps = fps;\r\n\t\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.duration = duration;\r\n\t\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.weight = weight;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.time = time;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {\r\n\t\r\n\t\tvar time = 0;\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\ttime = animation.time;\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn time;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\r\n\t\r\n\t\tvar duration = - 1;\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tduration = animation.duration;\r\n\t\r\n\t\t}\r\n\t\r\n\t\treturn duration;\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.time = 0;\r\n\t\t\tanimation.active = true;\r\n\t\r\n\t\t} else {\r\n\t\r\n\t\t\tconsole.warn( \"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {\r\n\t\r\n\t\tvar animation = this.animationsMap[ name ];\r\n\t\r\n\t\tif ( animation ) {\r\n\t\r\n\t\t\tanimation.active = false;\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\tTHREE.MorphBlendMesh.prototype.update = function ( delta ) {\r\n\t\r\n\t\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\r\n\t\r\n\t\t\tvar animation = this.animationsList[ i ];\r\n\t\r\n\t\t\tif ( ! animation.active ) continue;\r\n\t\r\n\t\t\tvar frameTime = animation.duration / animation.length;\r\n\t\r\n\t\t\tanimation.time += animation.direction * delta;\r\n\t\r\n\t\t\tif ( animation.mirroredLoop ) {\r\n\t\r\n\t\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\r\n\t\r\n\t\t\t\t\tanimation.direction *= - 1;\r\n\t\r\n\t\t\t\t\tif ( animation.time > animation.duration ) {\r\n\t\r\n\t\t\t\t\t\tanimation.time = animation.duration;\r\n\t\t\t\t\t\tanimation.directionBackwards = true;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\tif ( animation.time < 0 ) {\r\n\t\r\n\t\t\t\t\t\tanimation.time = 0;\r\n\t\t\t\t\t\tanimation.directionBackwards = false;\r\n\t\r\n\t\t\t\t\t}\r\n\t\r\n\t\t\t\t}\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tanimation.time = animation.time % animation.duration;\r\n\t\r\n\t\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\r\n\t\t\tvar weight = animation.weight;\r\n\t\r\n\t\t\tif ( keyframe !== animation.currentFrame ) {\r\n\t\r\n\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\r\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\r\n\t\r\n\t\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\r\n\t\r\n\t\t\t\tanimation.lastFrame = animation.currentFrame;\r\n\t\t\t\tanimation.currentFrame = keyframe;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t\tvar mix = ( animation.time % frameTime ) / frameTime;\r\n\t\r\n\t\t\tif ( animation.directionBackwards ) mix = 1 - mix;\r\n\t\r\n\t\t\tif ( animation.currentFrame !== animation.lastFrame ) {\r\n\t\r\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\r\n\t\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\r\n\t\r\n\t\t\t} else {\r\n\t\r\n\t\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = weight;\r\n\t\r\n\t\t\t}\r\n\t\r\n\t\t}\r\n\t\r\n\t};\r\n\t\r\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** bundle.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap e62b9b5a1e2a90d7a848\n **/","import THREE from 'three';\nvar TURN_SPEED = Math.PI / 8;\nvar scene, camera, renderer, spaceTexture;\nvar geometry, redMaterial, spaceMaterial, mesh, light, ambient, sphere, background;\nvar relativeX, relativeY;\nvar timestamp = new Date();\nvar loader = new THREE.JSONLoader();\n\ninit();\nanimate();\n\nfunction init() {\n\trelativeX = 0;\n\trelativeY = 0;\n\tscene = new THREE.Scene();\n\n\tcamera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 0.01, 10000 );\n\tspaceTexture = THREE.ImageUtils.loadTexture('../textures/dark-space-texture.png');\n\tredMaterial = new THREE.MeshLambertMaterial( { color: 0x3f3f3f } );\n\tredMaterial.side = THREE.DoubleSide;\n\tredMaterial.transparent = true;\n\n\tspaceMaterial = new THREE.MeshBasicMaterial();\n\tspaceMaterial.map = spaceTexture;\n\tspaceMaterial.side = THREE.DoubleSide;\n\n\tloader.load('../models/cockpit.js', function (geometry, mat) {\n\t\tgeometry.scale.x = 15;\n\t\tgeometry.scale.y = 15;\n\t\tgeometry.scale.z = 15;\n\t\tgeometry.rotateY(Math.PI / 2)\n\t\tmesh = new THREE.Mesh( geometry, redMaterial);\n\t\tscene.add(mesh);\n\t});\n\n\tsphere = new THREE.SphereGeometry(2000, 100, 100);\n\tbackground = new THREE.Mesh(sphere, spaceMaterial);\n\tscene.add(background);\n\n\tambient = new THREE.AmbientLight(0x404040);\n\tscene.add(ambient);\n\n\tlight = new THREE.SpotLight(0xffffff);\n\tlight.position.set(-20, 5, 5);\n\tscene.add(light);\n\n\trenderer = new THREE.WebGLRenderer();\n\trenderer.setSize( window.innerWidth, window.innerHeight );\n\n\tdocument.body.appendChild( renderer.domElement );\n\n\tdocument.body.addEventListener('mousemove', function (e) {\n\t\tvar x, y, screenWidth, screenHeight, offsetX, offsetY;\n\t\tx = e.clientX;\n\t\ty = e.clientY;\n\t\tscreenWidth = window.innerWidth;\n\t\tscreenHeight = window.innerHeight;\n\t\toffsetX = x - screenWidth / 2;\n\t\toffsetY = y - screenHeight / 2;\n\t\trelativeX = offsetX / (screenWidth / 2);\n\t\trelativeY = offsetY / (screenHeight / 2);\n\t});\n\n\n}\n\nfunction animate() {\n\tvar now = new Date();\n\tvar d = now - timestamp;\n\ttimestamp = now;\n\trequestAnimationFrame( animate );\n\tcamera.rotation.x -= (relativeY * TURN_SPEED * d / 1000);\n\tcamera.rotation.y -= (relativeX * TURN_SPEED * d / 1000);\n\tif (mesh) mesh.rotation.x = camera.rotation.x;\n\tif (mesh) mesh.rotation.y = camera.rotation.y;\n\trenderer.render( scene, camera );\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./scripts/index.js\n **/","// File:src/Three.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nvar THREE = { REVISION: '77' };\r\n\r\n//\r\n\r\nif ( typeof define === 'function' && define.amd ) {\r\n\r\n\tdefine( 'three', THREE );\r\n\r\n} else if ( 'undefined' !== typeof exports && 'undefined' !== typeof module ) {\r\n\r\n\tmodule.exports = THREE;\r\n\r\n}\r\n\r\n// Polyfills\r\n\r\nif ( Number.EPSILON === undefined ) {\r\n\r\n\tNumber.EPSILON = Math.pow( 2, - 52 );\r\n\r\n}\r\n\r\n//\r\n\r\nif ( Math.sign === undefined ) {\r\n\r\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign\r\n\r\n\tMath.sign = function ( x ) {\r\n\r\n\t\treturn ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;\r\n\r\n\t};\r\n\r\n}\r\n\r\nif ( Function.prototype.name === undefined ) {\r\n\r\n\t// Missing in IE9-11.\r\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name\r\n\r\n\tObject.defineProperty( Function.prototype, 'name', {\r\n\r\n\t\tget: function () {\r\n\r\n\t\t\treturn this.toString().match( /^\\s*function\\s*(\\S*)\\s*\\(/ )[ 1 ];\r\n\r\n\t\t}\r\n\r\n\t} );\r\n\r\n}\r\n\r\nif ( Object.assign === undefined ) {\r\n\r\n\t// Missing in IE.\r\n\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign\r\n\r\n\t( function () {\r\n\r\n\t\tObject.assign = function ( target ) {\r\n\r\n\t\t\t'use strict';\r\n\r\n\t\t\tif ( target === undefined || target === null ) {\r\n\r\n\t\t\t\tthrow new TypeError( 'Cannot convert undefined or null to object' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar output = Object( target );\r\n\r\n\t\t\tfor ( var index = 1; index < arguments.length; index ++ ) {\r\n\r\n\t\t\t\tvar source = arguments[ index ];\r\n\r\n\t\t\t\tif ( source !== undefined && source !== null ) {\r\n\r\n\t\t\t\t\tfor ( var nextKey in source ) {\r\n\r\n\t\t\t\t\t\tif ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {\r\n\r\n\t\t\t\t\t\t\toutput[ nextKey ] = source[ nextKey ];\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn output;\r\n\r\n\t\t};\r\n\r\n\t} )();\r\n\r\n}\r\n\r\n//\r\n\r\nObject.assign( THREE, {\r\n\r\n\t// https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.button\r\n\r\n\tMOUSE: { LEFT: 0, MIDDLE: 1, RIGHT: 2 },\r\n\r\n\t// GL STATE CONSTANTS\r\n\r\n\tCullFaceNone: 0,\r\n\tCullFaceBack: 1,\r\n\tCullFaceFront: 2,\r\n\tCullFaceFrontBack: 3,\r\n\r\n\tFrontFaceDirectionCW: 0,\r\n\tFrontFaceDirectionCCW: 1,\r\n\r\n\t// SHADOWING TYPES\r\n\r\n\tBasicShadowMap: 0,\r\n\tPCFShadowMap: 1,\r\n\tPCFSoftShadowMap: 2,\r\n\r\n\t// MATERIAL CONSTANTS\r\n\r\n\t// side\r\n\r\n\tFrontSide: 0,\r\n\tBackSide: 1,\r\n\tDoubleSide: 2,\r\n\r\n\t// shading\r\n\r\n\tFlatShading: 1,\r\n\tSmoothShading: 2,\r\n\r\n\t// colors\r\n\r\n\tNoColors: 0,\r\n\tFaceColors: 1,\r\n\tVertexColors: 2,\r\n\r\n\t// blending modes\r\n\r\n\tNoBlending: 0,\r\n\tNormalBlending: 1,\r\n\tAdditiveBlending: 2,\r\n\tSubtractiveBlending: 3,\r\n\tMultiplyBlending: 4,\r\n\tCustomBlending: 5,\r\n\r\n\t// custom blending equations\r\n\t// (numbers start from 100 not to clash with other\r\n\t// mappings to OpenGL constants defined in Texture.js)\r\n\r\n\tAddEquation: 100,\r\n\tSubtractEquation: 101,\r\n\tReverseSubtractEquation: 102,\r\n\tMinEquation: 103,\r\n\tMaxEquation: 104,\r\n\r\n\t// custom blending destination factors\r\n\r\n\tZeroFactor: 200,\r\n\tOneFactor: 201,\r\n\tSrcColorFactor: 202,\r\n\tOneMinusSrcColorFactor: 203,\r\n\tSrcAlphaFactor: 204,\r\n\tOneMinusSrcAlphaFactor: 205,\r\n\tDstAlphaFactor: 206,\r\n\tOneMinusDstAlphaFactor: 207,\r\n\r\n\t// custom blending source factors\r\n\r\n\t//ZeroFactor: 200,\r\n\t//OneFactor: 201,\r\n\t//SrcAlphaFactor: 204,\r\n\t//OneMinusSrcAlphaFactor: 205,\r\n\t//DstAlphaFactor: 206,\r\n\t//OneMinusDstAlphaFactor: 207,\r\n\tDstColorFactor: 208,\r\n\tOneMinusDstColorFactor: 209,\r\n\tSrcAlphaSaturateFactor: 210,\r\n\r\n\t// depth modes\r\n\r\n\tNeverDepth: 0,\r\n\tAlwaysDepth: 1,\r\n\tLessDepth: 2,\r\n\tLessEqualDepth: 3,\r\n\tEqualDepth: 4,\r\n\tGreaterEqualDepth: 5,\r\n\tGreaterDepth: 6,\r\n\tNotEqualDepth: 7,\r\n\r\n\r\n\t// TEXTURE CONSTANTS\r\n\r\n\tMultiplyOperation: 0,\r\n\tMixOperation: 1,\r\n\tAddOperation: 2,\r\n\r\n\t// Tone Mapping modes\r\n\r\n\tNoToneMapping: 0, // do not do any tone mapping, not even exposure (required for special purpose passes.)\r\n\tLinearToneMapping: 1, // only apply exposure.\r\n\tReinhardToneMapping: 2,\r\n\tUncharted2ToneMapping: 3, // John Hable\r\n\tCineonToneMapping: 4, // optimized filmic operator by Jim Hejl and Richard Burgess-Dawson\r\n\r\n\t// Mapping modes\r\n\r\n\tUVMapping: 300,\r\n\r\n\tCubeReflectionMapping: 301,\r\n\tCubeRefractionMapping: 302,\r\n\r\n\tEquirectangularReflectionMapping: 303,\r\n\tEquirectangularRefractionMapping: 304,\r\n\r\n\tSphericalReflectionMapping: 305,\r\n\tCubeUVReflectionMapping: 306,\r\n\tCubeUVRefractionMapping: 307,\r\n\r\n\t// Wrapping modes\r\n\r\n\tRepeatWrapping: 1000,\r\n\tClampToEdgeWrapping: 1001,\r\n\tMirroredRepeatWrapping: 1002,\r\n\r\n\t// Filters\r\n\r\n\tNearestFilter: 1003,\r\n\tNearestMipMapNearestFilter: 1004,\r\n\tNearestMipMapLinearFilter: 1005,\r\n\tLinearFilter: 1006,\r\n\tLinearMipMapNearestFilter: 1007,\r\n\tLinearMipMapLinearFilter: 1008,\r\n\r\n\t// Data types\r\n\r\n\tUnsignedByteType: 1009,\r\n\tByteType: 1010,\r\n\tShortType: 1011,\r\n\tUnsignedShortType: 1012,\r\n\tIntType: 1013,\r\n\tUnsignedIntType: 1014,\r\n\tFloatType: 1015,\r\n\tHalfFloatType: 1025,\r\n\r\n\t// Pixel types\r\n\r\n\t//UnsignedByteType: 1009,\r\n\tUnsignedShort4444Type: 1016,\r\n\tUnsignedShort5551Type: 1017,\r\n\tUnsignedShort565Type: 1018,\r\n\r\n\t// Pixel formats\r\n\r\n\tAlphaFormat: 1019,\r\n\tRGBFormat: 1020,\r\n\tRGBAFormat: 1021,\r\n\tLuminanceFormat: 1022,\r\n\tLuminanceAlphaFormat: 1023,\r\n\t// THREE.RGBEFormat handled as THREE.RGBAFormat in shaders\r\n\tRGBEFormat: THREE.RGBAFormat, //1024;\r\n\tDepthFormat: 1026,\r\n\r\n\t// DDS / ST3C Compressed texture formats\r\n\r\n\tRGB_S3TC_DXT1_Format: 2001,\r\n\tRGBA_S3TC_DXT1_Format: 2002,\r\n\tRGBA_S3TC_DXT3_Format: 2003,\r\n\tRGBA_S3TC_DXT5_Format: 2004,\r\n\r\n\t// PVRTC compressed texture formats\r\n\r\n\tRGB_PVRTC_4BPPV1_Format: 2100,\r\n\tRGB_PVRTC_2BPPV1_Format: 2101,\r\n\tRGBA_PVRTC_4BPPV1_Format: 2102,\r\n\tRGBA_PVRTC_2BPPV1_Format: 2103,\r\n\r\n\t// ETC compressed texture formats\r\n\r\n\tRGB_ETC1_Format: 2151,\r\n\r\n\t// Loop styles for AnimationAction\r\n\r\n\tLoopOnce: 2200,\r\n\tLoopRepeat: 2201,\r\n\tLoopPingPong: 2202,\r\n\r\n\t// Interpolation\r\n\r\n\tInterpolateDiscrete: 2300,\r\n\tInterpolateLinear: 2301,\r\n\tInterpolateSmooth: 2302,\r\n\r\n\t// Interpolant ending modes\r\n\r\n\tZeroCurvatureEnding: 2400,\r\n\tZeroSlopeEnding: 2401,\r\n\tWrapAroundEnding: 2402,\r\n\r\n\t// Triangle Draw modes\r\n\r\n\tTrianglesDrawMode: 0,\r\n\tTriangleStripDrawMode: 1,\r\n\tTriangleFanDrawMode: 2,\r\n\r\n\t// Texture Encodings\r\n\r\n\tLinearEncoding: 3000, // No encoding at all.\r\n\tsRGBEncoding: 3001,\r\n\tGammaEncoding: 3007, // uses GAMMA_FACTOR, for backwards compatibility with WebGLRenderer.gammaInput/gammaOutput\r\n\r\n\t// The following Texture Encodings are for RGB-only (no alpha) HDR light emission sources.\r\n\t// These encodings should not specified as output encodings except in rare situations.\r\n\tRGBEEncoding: 3002, // AKA Radiance.\r\n\tLogLuvEncoding: 3003,\r\n\tRGBM7Encoding: 3004,\r\n\tRGBM16Encoding: 3005,\r\n\tRGBDEncoding: 3006, // MaxRange is 256.\r\n\r\n\t// Depth packing strategies\r\n\r\n\tBasicDepthPacking: 3200, // for writing to float textures for high precision or for visualizing results in RGB buffers\r\n\tRGBADepthPacking: 3201 // for packing into RGBA buffers.\r\n\r\n} );\r\n\r\n// File:src/math/Color.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Color = function ( r, g, b ) {\r\n\r\n\tif ( g === undefined && b === undefined ) {\r\n\r\n\t\t// r is THREE.Color, hex or string\r\n\t\treturn this.set( r );\r\n\r\n\t}\r\n\r\n\treturn this.setRGB( r, g, b );\r\n\r\n};\r\n\r\nTHREE.Color.prototype = {\r\n\r\n\tconstructor: THREE.Color,\r\n\r\n\tr: 1, g: 1, b: 1,\r\n\r\n\tset: function ( value ) {\r\n\r\n\t\tif ( value instanceof THREE.Color ) {\r\n\r\n\t\t\tthis.copy( value );\r\n\r\n\t\t} else if ( typeof value === 'number' ) {\r\n\r\n\t\t\tthis.setHex( value );\r\n\r\n\t\t} else if ( typeof value === 'string' ) {\r\n\r\n\t\t\tthis.setStyle( value );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetScalar: function ( scalar ) {\r\n\r\n\t\tthis.r = scalar;\r\n\t\tthis.g = scalar;\r\n\t\tthis.b = scalar;\r\n\r\n\t},\r\n\r\n\tsetHex: function ( hex ) {\r\n\r\n\t\thex = Math.floor( hex );\r\n\r\n\t\tthis.r = ( hex >> 16 & 255 ) / 255;\r\n\t\tthis.g = ( hex >> 8 & 255 ) / 255;\r\n\t\tthis.b = ( hex & 255 ) / 255;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetRGB: function ( r, g, b ) {\r\n\r\n\t\tthis.r = r;\r\n\t\tthis.g = g;\r\n\t\tthis.b = b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetHSL: function () {\r\n\r\n\t\tfunction hue2rgb( p, q, t ) {\r\n\r\n\t\t\tif ( t < 0 ) t += 1;\r\n\t\t\tif ( t > 1 ) t -= 1;\r\n\t\t\tif ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;\r\n\t\t\tif ( t < 1 / 2 ) return q;\r\n\t\t\tif ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );\r\n\t\t\treturn p;\r\n\r\n\t\t}\r\n\r\n\t\treturn function ( h, s, l ) {\r\n\r\n\t\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\t\t\th = THREE.Math.euclideanModulo( h, 1 );\r\n\t\t\ts = THREE.Math.clamp( s, 0, 1 );\r\n\t\t\tl = THREE.Math.clamp( l, 0, 1 );\r\n\r\n\t\t\tif ( s === 0 ) {\r\n\r\n\t\t\t\tthis.r = this.g = this.b = l;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );\r\n\t\t\t\tvar q = ( 2 * l ) - p;\r\n\r\n\t\t\t\tthis.r = hue2rgb( q, p, h + 1 / 3 );\r\n\t\t\t\tthis.g = hue2rgb( q, p, h );\r\n\t\t\t\tthis.b = hue2rgb( q, p, h - 1 / 3 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetStyle: function ( style ) {\r\n\r\n\t\tfunction handleAlpha( string ) {\r\n\r\n\t\t\tif ( string === undefined ) return;\r\n\r\n\t\t\tif ( parseFloat( string ) < 1 ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\tvar m;\r\n\r\n\t\tif ( m = /^((?:rgb|hsl)a?)\\(\\s*([^\\)]*)\\)/.exec( style ) ) {\r\n\r\n\t\t\t// rgb / hsl\r\n\r\n\t\t\tvar color;\r\n\t\t\tvar name = m[ 1 ];\r\n\t\t\tvar components = m[ 2 ];\r\n\r\n\t\t\tswitch ( name ) {\r\n\r\n\t\t\t\tcase 'rgb':\r\n\t\t\t\tcase 'rgba':\r\n\r\n\t\t\t\t\tif ( color = /^(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\r\n\r\n\t\t\t\t\t\t// rgb(255,0,0) rgba(255,0,0,0.5)\r\n\t\t\t\t\t\tthis.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;\r\n\t\t\t\t\t\tthis.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;\r\n\t\t\t\t\t\tthis.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;\r\n\r\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\r\n\r\n\t\t\t\t\t\treturn this;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( color = /^(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\r\n\r\n\t\t\t\t\t\t// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)\r\n\t\t\t\t\t\tthis.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;\r\n\t\t\t\t\t\tthis.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;\r\n\t\t\t\t\t\tthis.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;\r\n\r\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\r\n\r\n\t\t\t\t\t\treturn this;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'hsl':\r\n\t\t\t\tcase 'hsla':\r\n\r\n\t\t\t\t\tif ( color = /^([0-9]*\\.?[0-9]+)\\s*,\\s*(\\d+)\\%\\s*,\\s*(\\d+)\\%\\s*(,\\s*([0-9]*\\.?[0-9]+)\\s*)?$/.exec( components ) ) {\r\n\r\n\t\t\t\t\t\t// hsl(120,50%,50%) hsla(120,50%,50%,0.5)\r\n\t\t\t\t\t\tvar h = parseFloat( color[ 1 ] ) / 360;\r\n\t\t\t\t\t\tvar s = parseInt( color[ 2 ], 10 ) / 100;\r\n\t\t\t\t\t\tvar l = parseInt( color[ 3 ], 10 ) / 100;\r\n\r\n\t\t\t\t\t\thandleAlpha( color[ 5 ] );\r\n\r\n\t\t\t\t\t\treturn this.setHSL( h, s, l );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( m = /^\\#([A-Fa-f0-9]+)$/.exec( style ) ) {\r\n\r\n\t\t\t// hex color\r\n\r\n\t\t\tvar hex = m[ 1 ];\r\n\t\t\tvar size = hex.length;\r\n\r\n\t\t\tif ( size === 3 ) {\r\n\r\n\t\t\t\t// #ff0\r\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;\r\n\t\t\t\tthis.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;\r\n\t\t\t\tthis.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;\r\n\r\n\t\t\t\treturn this;\r\n\r\n\t\t\t} else if ( size === 6 ) {\r\n\r\n\t\t\t\t// #ff0000\r\n\t\t\t\tthis.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;\r\n\t\t\t\tthis.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;\r\n\t\t\t\tthis.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;\r\n\r\n\t\t\t\treturn this;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( style && style.length > 0 ) {\r\n\r\n\t\t\t// color keywords\r\n\t\t\tvar hex = THREE.ColorKeywords[ style ];\r\n\r\n\t\t\tif ( hex !== undefined ) {\r\n\r\n\t\t\t\t// red\r\n\t\t\t\tthis.setHex( hex );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// unknown color\r\n\t\t\t\tconsole.warn( 'THREE.Color: Unknown color ' + style );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.r, this.g, this.b );\r\n\r\n\t},\r\n\r\n\tcopy: function ( color ) {\r\n\r\n\t\tthis.r = color.r;\r\n\t\tthis.g = color.g;\r\n\t\tthis.b = color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyGammaToLinear: function ( color, gammaFactor ) {\r\n\r\n\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\r\n\r\n\t\tthis.r = Math.pow( color.r, gammaFactor );\r\n\t\tthis.g = Math.pow( color.g, gammaFactor );\r\n\t\tthis.b = Math.pow( color.b, gammaFactor );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyLinearToGamma: function ( color, gammaFactor ) {\r\n\r\n\t\tif ( gammaFactor === undefined ) gammaFactor = 2.0;\r\n\r\n\t\tvar safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;\r\n\r\n\t\tthis.r = Math.pow( color.r, safeInverse );\r\n\t\tthis.g = Math.pow( color.g, safeInverse );\r\n\t\tthis.b = Math.pow( color.b, safeInverse );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconvertGammaToLinear: function () {\r\n\r\n\t\tvar r = this.r, g = this.g, b = this.b;\r\n\r\n\t\tthis.r = r * r;\r\n\t\tthis.g = g * g;\r\n\t\tthis.b = b * b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconvertLinearToGamma: function () {\r\n\r\n\t\tthis.r = Math.sqrt( this.r );\r\n\t\tthis.g = Math.sqrt( this.g );\r\n\t\tthis.b = Math.sqrt( this.b );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetHex: function () {\r\n\r\n\t\treturn ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;\r\n\r\n\t},\r\n\r\n\tgetHexString: function () {\r\n\r\n\t\treturn ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );\r\n\r\n\t},\r\n\r\n\tgetHSL: function ( optionalTarget ) {\r\n\r\n\t\t// h,s,l ranges are in 0.0 - 1.0\r\n\r\n\t\tvar hsl = optionalTarget || { h: 0, s: 0, l: 0 };\r\n\r\n\t\tvar r = this.r, g = this.g, b = this.b;\r\n\r\n\t\tvar max = Math.max( r, g, b );\r\n\t\tvar min = Math.min( r, g, b );\r\n\r\n\t\tvar hue, saturation;\r\n\t\tvar lightness = ( min + max ) / 2.0;\r\n\r\n\t\tif ( min === max ) {\r\n\r\n\t\t\thue = 0;\r\n\t\t\tsaturation = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar delta = max - min;\r\n\r\n\t\t\tsaturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );\r\n\r\n\t\t\tswitch ( max ) {\r\n\r\n\t\t\t\tcase r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;\r\n\t\t\t\tcase g: hue = ( b - r ) / delta + 2; break;\r\n\t\t\t\tcase b: hue = ( r - g ) / delta + 4; break;\r\n\r\n\t\t\t}\r\n\r\n\t\t\thue /= 6;\r\n\r\n\t\t}\r\n\r\n\t\thsl.h = hue;\r\n\t\thsl.s = saturation;\r\n\t\thsl.l = lightness;\r\n\r\n\t\treturn hsl;\r\n\r\n\t},\r\n\r\n\tgetStyle: function () {\r\n\r\n\t\treturn 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';\r\n\r\n\t},\r\n\r\n\toffsetHSL: function ( h, s, l ) {\r\n\r\n\t\tvar hsl = this.getHSL();\r\n\r\n\t\thsl.h += h; hsl.s += s; hsl.l += l;\r\n\r\n\t\tthis.setHSL( hsl.h, hsl.s, hsl.l );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( color ) {\r\n\r\n\t\tthis.r += color.r;\r\n\t\tthis.g += color.g;\r\n\t\tthis.b += color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddColors: function ( color1, color2 ) {\r\n\r\n\t\tthis.r = color1.r + color2.r;\r\n\t\tthis.g = color1.g + color2.g;\r\n\t\tthis.b = color1.b + color2.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.r += s;\r\n\t\tthis.g += s;\r\n\t\tthis.b += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( color ) {\r\n\r\n\t\tthis.r *= color.r;\r\n\t\tthis.g *= color.g;\r\n\t\tthis.b *= color.b;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tthis.r *= s;\r\n\t\tthis.g *= s;\r\n\t\tthis.b *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerp: function ( color, alpha ) {\r\n\r\n\t\tthis.r += ( color.r - this.r ) * alpha;\r\n\t\tthis.g += ( color.g - this.g ) * alpha;\r\n\t\tthis.b += ( color.b - this.b ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( c ) {\r\n\r\n\t\treturn ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.r = array[ offset ];\r\n\t\tthis.g = array[ offset + 1 ];\r\n\t\tthis.b = array[ offset + 2 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this.r;\r\n\t\tarray[ offset + 1 ] = this.g;\r\n\t\tarray[ offset + 2 ] = this.b;\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,\r\n'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,\r\n'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,\r\n'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,\r\n'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,\r\n'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,\r\n'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,\r\n'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,\r\n'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,\r\n'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,\r\n'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,\r\n'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,\r\n'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,\r\n'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,\r\n'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,\r\n'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,\r\n'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,\r\n'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,\r\n'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,\r\n'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,\r\n'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,\r\n'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,\r\n'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,\r\n'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };\r\n\r\n// File:src/math/Quaternion.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Quaternion = function ( x, y, z, w ) {\r\n\r\n\tthis._x = x || 0;\r\n\tthis._y = y || 0;\r\n\tthis._z = z || 0;\r\n\tthis._w = ( w !== undefined ) ? w : 1;\r\n\r\n};\r\n\r\nTHREE.Quaternion.prototype = {\r\n\r\n\tconstructor: THREE.Quaternion,\r\n\r\n\tget x () {\r\n\r\n\t\treturn this._x;\r\n\r\n\t},\r\n\r\n\tset x ( value ) {\r\n\r\n\t\tthis._x = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tget y () {\r\n\r\n\t\treturn this._y;\r\n\r\n\t},\r\n\r\n\tset y ( value ) {\r\n\r\n\t\tthis._y = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tget z () {\r\n\r\n\t\treturn this._z;\r\n\r\n\t},\r\n\r\n\tset z ( value ) {\r\n\r\n\t\tthis._z = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tget w () {\r\n\r\n\t\treturn this._w;\r\n\r\n\t},\r\n\r\n\tset w ( value ) {\r\n\r\n\t\tthis._w = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tset: function ( x, y, z, w ) {\r\n\r\n\t\tthis._x = x;\r\n\t\tthis._y = y;\r\n\t\tthis._z = z;\r\n\t\tthis._w = w;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this._x, this._y, this._z, this._w );\r\n\r\n\t},\r\n\r\n\tcopy: function ( quaternion ) {\r\n\r\n\t\tthis._x = quaternion.x;\r\n\t\tthis._y = quaternion.y;\r\n\t\tthis._z = quaternion.z;\r\n\t\tthis._w = quaternion.w;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromEuler: function ( euler, update ) {\r\n\r\n\t\tif ( euler instanceof THREE.Euler === false ) {\r\n\r\n\t\t\tthrow new Error( 'THREE.Quaternion: .setFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\r\n\t\t}\r\n\r\n\t\t// http://www.mathworks.com/matlabcentral/fileexchange/\r\n\t\t// \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\r\n\t\t//\tcontent/SpinCalc.m\r\n\r\n\t\tvar c1 = Math.cos( euler._x / 2 );\r\n\t\tvar c2 = Math.cos( euler._y / 2 );\r\n\t\tvar c3 = Math.cos( euler._z / 2 );\r\n\t\tvar s1 = Math.sin( euler._x / 2 );\r\n\t\tvar s2 = Math.sin( euler._y / 2 );\r\n\t\tvar s3 = Math.sin( euler._z / 2 );\r\n\r\n\t\tvar order = euler.order;\r\n\r\n\t\tif ( order === 'XYZ' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'YXZ' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'ZXY' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'ZYX' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'YZX' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 + c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 + s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 - s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 - s1 * s2 * s3;\r\n\r\n\t\t} else if ( order === 'XZY' ) {\r\n\r\n\t\t\tthis._x = s1 * c2 * c3 - c1 * s2 * s3;\r\n\t\t\tthis._y = c1 * s2 * c3 - s1 * c2 * s3;\r\n\t\t\tthis._z = c1 * c2 * s3 + s1 * s2 * c3;\r\n\t\t\tthis._w = c1 * c2 * c3 + s1 * s2 * s3;\r\n\r\n\t\t}\r\n\r\n\t\tif ( update !== false ) this.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromAxisAngle: function ( axis, angle ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm\r\n\r\n\t\t// assumes axis is normalized\r\n\r\n\t\tvar halfAngle = angle / 2, s = Math.sin( halfAngle );\r\n\r\n\t\tthis._x = axis.x * s;\r\n\t\tthis._y = axis.y * s;\r\n\t\tthis._z = axis.z * s;\r\n\t\tthis._w = Math.cos( halfAngle );\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromRotationMatrix: function ( m ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tvar te = m.elements,\r\n\r\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],\r\n\r\n\t\t\ttrace = m11 + m22 + m33,\r\n\t\t\ts;\r\n\r\n\t\tif ( trace > 0 ) {\r\n\r\n\t\t\ts = 0.5 / Math.sqrt( trace + 1.0 );\r\n\r\n\t\t\tthis._w = 0.25 / s;\r\n\t\t\tthis._x = ( m32 - m23 ) * s;\r\n\t\t\tthis._y = ( m13 - m31 ) * s;\r\n\t\t\tthis._z = ( m21 - m12 ) * s;\r\n\r\n\t\t} else if ( m11 > m22 && m11 > m33 ) {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );\r\n\r\n\t\t\tthis._w = ( m32 - m23 ) / s;\r\n\t\t\tthis._x = 0.25 * s;\r\n\t\t\tthis._y = ( m12 + m21 ) / s;\r\n\t\t\tthis._z = ( m13 + m31 ) / s;\r\n\r\n\t\t} else if ( m22 > m33 ) {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );\r\n\r\n\t\t\tthis._w = ( m13 - m31 ) / s;\r\n\t\t\tthis._x = ( m12 + m21 ) / s;\r\n\t\t\tthis._y = 0.25 * s;\r\n\t\t\tthis._z = ( m23 + m32 ) / s;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ts = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );\r\n\r\n\t\t\tthis._w = ( m21 - m12 ) / s;\r\n\t\t\tthis._x = ( m13 + m31 ) / s;\r\n\t\t\tthis._y = ( m23 + m32 ) / s;\r\n\t\t\tthis._z = 0.25 * s;\r\n\r\n\t\t}\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromUnitVectors: function () {\r\n\r\n\t\t// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final\r\n\r\n\t\t// assumes direction vectors vFrom and vTo are normalized\r\n\r\n\t\tvar v1, r;\r\n\r\n\t\tvar EPS = 0.000001;\r\n\r\n\t\treturn function ( vFrom, vTo ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n\t\t\tr = vFrom.dot( vTo ) + 1;\r\n\r\n\t\t\tif ( r < EPS ) {\r\n\r\n\t\t\t\tr = 0;\r\n\r\n\t\t\t\tif ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {\r\n\r\n\t\t\t\t\tv1.set( - vFrom.y, vFrom.x, 0 );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tv1.set( 0, - vFrom.z, vFrom.y );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tv1.crossVectors( vFrom, vTo );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis._x = v1.x;\r\n\t\t\tthis._y = v1.y;\r\n\t\t\tthis._z = v1.z;\r\n\t\t\tthis._w = r;\r\n\r\n\t\t\treturn this.normalize();\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tinverse: function () {\r\n\r\n\t\treturn this.conjugate().normalize();\r\n\r\n\t},\r\n\r\n\tconjugate: function () {\r\n\r\n\t\tthis._x *= - 1;\r\n\t\tthis._y *= - 1;\r\n\t\tthis._z *= - 1;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\tvar l = this.length();\r\n\r\n\t\tif ( l === 0 ) {\r\n\r\n\t\t\tthis._x = 0;\r\n\t\t\tthis._y = 0;\r\n\t\t\tthis._z = 0;\r\n\t\t\tthis._w = 1;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tl = 1 / l;\r\n\r\n\t\t\tthis._x = this._x * l;\r\n\t\t\tthis._y = this._y * l;\r\n\t\t\tthis._z = this._z * l;\r\n\t\t\tthis._w = this._w * l;\r\n\r\n\t\t}\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( q, p ) {\r\n\r\n\t\tif ( p !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );\r\n\t\t\treturn this.multiplyQuaternions( q, p );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.multiplyQuaternions( this, q );\r\n\r\n\t},\r\n\r\n\tpremultiply: function ( q ) {\r\n\r\n\t\treturn this.multiplyQuaternions( q, this );\r\n\r\n\t},\r\n\r\n\tmultiplyQuaternions: function ( a, b ) {\r\n\r\n\t\t// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm\r\n\r\n\t\tvar qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\r\n\t\tvar qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\r\n\r\n\t\tthis._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\r\n\t\tthis._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\r\n\t\tthis._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\r\n\t\tthis._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tslerp: function ( qb, t ) {\r\n\r\n\t\tif ( t === 0 ) return this;\r\n\t\tif ( t === 1 ) return this.copy( qb );\r\n\r\n\t\tvar x = this._x, y = this._y, z = this._z, w = this._w;\r\n\r\n\t\t// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/\r\n\r\n\t\tvar cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;\r\n\r\n\t\tif ( cosHalfTheta < 0 ) {\r\n\r\n\t\t\tthis._w = - qb._w;\r\n\t\t\tthis._x = - qb._x;\r\n\t\t\tthis._y = - qb._y;\r\n\t\t\tthis._z = - qb._z;\r\n\r\n\t\t\tcosHalfTheta = - cosHalfTheta;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.copy( qb );\r\n\r\n\t\t}\r\n\r\n\t\tif ( cosHalfTheta >= 1.0 ) {\r\n\r\n\t\t\tthis._w = w;\r\n\t\t\tthis._x = x;\r\n\t\t\tthis._y = y;\r\n\t\t\tthis._z = z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tvar sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );\r\n\r\n\t\tif ( Math.abs( sinHalfTheta ) < 0.001 ) {\r\n\r\n\t\t\tthis._w = 0.5 * ( w + this._w );\r\n\t\t\tthis._x = 0.5 * ( x + this._x );\r\n\t\t\tthis._y = 0.5 * ( y + this._y );\r\n\t\t\tthis._z = 0.5 * ( z + this._z );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tvar halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );\r\n\t\tvar ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,\r\n\t\tratioB = Math.sin( t * halfTheta ) / sinHalfTheta;\r\n\r\n\t\tthis._w = ( w * ratioA + this._w * ratioB );\r\n\t\tthis._x = ( x * ratioA + this._x * ratioB );\r\n\t\tthis._y = ( y * ratioA + this._y * ratioB );\r\n\t\tthis._z = ( z * ratioA + this._z * ratioB );\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( quaternion ) {\r\n\r\n\t\treturn ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis._x = array[ offset ];\r\n\t\tthis._y = array[ offset + 1 ];\r\n\t\tthis._z = array[ offset + 2 ];\r\n\t\tthis._w = array[ offset + 3 ];\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this._x;\r\n\t\tarray[ offset + 1 ] = this._y;\r\n\t\tarray[ offset + 2 ] = this._z;\r\n\t\tarray[ offset + 3 ] = this._w;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tonChange: function ( callback ) {\r\n\r\n\t\tthis.onChangeCallback = callback;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tonChangeCallback: function () {}\r\n\r\n};\r\n\r\nObject.assign( THREE.Quaternion, {\r\n\r\n\tslerp: function( qa, qb, qm, t ) {\r\n\r\n\t\treturn qm.copy( qa ).slerp( qb, t );\r\n\r\n\t},\r\n\r\n\tslerpFlat: function(\r\n\t\t\tdst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {\r\n\r\n\t\t// fuzz-free, array-based Quaternion SLERP operation\r\n\r\n\t\tvar x0 = src0[ srcOffset0 + 0 ],\r\n\t\t\ty0 = src0[ srcOffset0 + 1 ],\r\n\t\t\tz0 = src0[ srcOffset0 + 2 ],\r\n\t\t\tw0 = src0[ srcOffset0 + 3 ],\r\n\r\n\t\t\tx1 = src1[ srcOffset1 + 0 ],\r\n\t\t\ty1 = src1[ srcOffset1 + 1 ],\r\n\t\t\tz1 = src1[ srcOffset1 + 2 ],\r\n\t\t\tw1 = src1[ srcOffset1 + 3 ];\r\n\r\n\t\tif ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {\r\n\r\n\t\t\tvar s = 1 - t,\r\n\r\n\t\t\t\tcos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,\r\n\r\n\t\t\t\tdir = ( cos >= 0 ? 1 : - 1 ),\r\n\t\t\t\tsqrSin = 1 - cos * cos;\r\n\r\n\t\t\t// Skip the Slerp for tiny steps to avoid numeric problems:\r\n\t\t\tif ( sqrSin > Number.EPSILON ) {\r\n\r\n\t\t\t\tvar sin = Math.sqrt( sqrSin ),\r\n\t\t\t\t\tlen = Math.atan2( sin, cos * dir );\r\n\r\n\t\t\t\ts = Math.sin( s * len ) / sin;\r\n\t\t\t\tt = Math.sin( t * len ) / sin;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar tDir = t * dir;\r\n\r\n\t\t\tx0 = x0 * s + x1 * tDir;\r\n\t\t\ty0 = y0 * s + y1 * tDir;\r\n\t\t\tz0 = z0 * s + z1 * tDir;\r\n\t\t\tw0 = w0 * s + w1 * tDir;\r\n\r\n\t\t\t// Normalize in case we just did a lerp:\r\n\t\t\tif ( s === 1 - t ) {\r\n\r\n\t\t\t\tvar f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );\r\n\r\n\t\t\t\tx0 *= f;\r\n\t\t\t\ty0 *= f;\r\n\t\t\t\tz0 *= f;\r\n\t\t\t\tw0 *= f;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tdst[ dstOffset ] = x0;\r\n\t\tdst[ dstOffset + 1 ] = y0;\r\n\t\tdst[ dstOffset + 2 ] = z0;\r\n\t\tdst[ dstOffset + 3 ] = w0;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/math/Vector2.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author egraether / http://egraether.com/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\nTHREE.Vector2 = function ( x, y ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\r\n};\r\n\r\nTHREE.Vector2.prototype = {\r\n\r\n\tconstructor: THREE.Vector2,\r\n\r\n\tget width() {\r\n\r\n\t\treturn this.x;\r\n\r\n\t},\r\n\r\n\tset width( value ) {\r\n\r\n\t\tthis.x = value;\r\n\r\n\t},\r\n\r\n\tget height() {\r\n\r\n\t\treturn this.y;\r\n\r\n\t},\r\n\r\n\tset height( value ) {\r\n\r\n\t\tthis.y = value;\r\n\r\n\t},\r\n\r\n\t//\r\n\r\n\tset: function ( x, y ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetScalar: function ( scalar ) {\r\n\r\n\t\tthis.x = scalar;\r\n\t\tthis.y = scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.x, this.y );\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScaledVector: function ( v, s ) {\r\n\r\n\t\tthis.x += v.x * s;\r\n\t\tthis.y += v.y * s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubScalar: function ( s ) {\r\n\r\n\t\tthis.x -= s;\r\n\t\tthis.y -= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( v ) {\r\n\r\n\t\tthis.x *= v.x;\r\n\t\tthis.y *= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( scalar ) {\r\n\r\n\t\tif ( isFinite( scalar ) ) {\r\n\r\n\t\t\tthis.x *= scalar;\r\n\t\t\tthis.y *= scalar;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivide: function ( v ) {\r\n\r\n\t\tthis.x /= v.x;\r\n\t\tthis.y /= v.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( scalar ) {\r\n\r\n\t\treturn this.multiplyScalar( 1 / scalar );\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tthis.x = Math.min( this.x, v.x );\r\n\t\tthis.y = Math.min( this.y, v.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tthis.x = Math.max( this.x, v.x );\r\n\t\tthis.y = Math.max( this.y, v.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclampScalar: function () {\r\n\r\n\t\tvar min, max;\r\n\r\n\t\treturn function clampScalar( minVal, maxVal ) {\r\n\r\n\t\t\tif ( min === undefined ) {\r\n\r\n\t\t\t\tmin = new THREE.Vector2();\r\n\t\t\t\tmax = new THREE.Vector2();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmin.set( minVal, minVal );\r\n\t\t\tmax.set( maxVal, maxVal );\r\n\r\n\t\t\treturn this.clamp( min, max );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclampLength: function ( min, max ) {\r\n\r\n\t\tvar length = this.length();\r\n\r\n\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\r\n\r\n\t},\r\n\r\n\tfloor: function () {\r\n\r\n\t\tthis.x = Math.floor( this.x );\r\n\t\tthis.y = Math.floor( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tceil: function () {\r\n\r\n\t\tthis.x = Math.ceil( this.x );\r\n\t\tthis.y = Math.ceil( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tround: function () {\r\n\r\n\t\tthis.x = Math.round( this.x );\r\n\t\tthis.y = Math.round( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\troundToZero: function () {\r\n\r\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.x = - this.x;\r\n\t\tthis.y = - this.y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y );\r\n\r\n\t},\r\n\r\n\tlengthManhattan: function() {\r\n\r\n\t\treturn Math.abs( this.x ) + Math.abs( this.y );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() );\r\n\r\n\t},\r\n\r\n\tangle: function () {\r\n\r\n\t\t// computes the angle in radians with respect to the positive x-axis\r\n\r\n\t\tvar angle = Math.atan2( this.y, this.x );\r\n\r\n\t\tif ( angle < 0 ) angle += 2 * Math.PI;\r\n\r\n\t\treturn angle;\r\n\r\n\t},\r\n\r\n\tdistanceTo: function ( v ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n\t},\r\n\r\n\tdistanceToSquared: function ( v ) {\r\n\r\n\t\tvar dx = this.x - v.x, dy = this.y - v.y;\r\n\t\treturn dx * dx + dy * dy;\r\n\r\n\t},\r\n\r\n\tsetLength: function ( length ) {\r\n\r\n\t\treturn this.multiplyScalar( length / this.length() );\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerpVectors: function ( v1, v2, alpha ) {\r\n\r\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.x = array[ offset ];\r\n\t\tthis.y = array[ offset + 1 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this.x;\r\n\t\tarray[ offset + 1 ] = this.y;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tfromAttribute: function ( attribute, index, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tindex = index * attribute.itemSize + offset;\r\n\r\n\t\tthis.x = attribute.array[ index ];\r\n\t\tthis.y = attribute.array[ index + 1 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trotateAround: function ( center, angle ) {\r\n\r\n\t\tvar c = Math.cos( angle ), s = Math.sin( angle );\r\n\r\n\t\tvar x = this.x - center.x;\r\n\t\tvar y = this.y - center.y;\r\n\r\n\t\tthis.x = x * c - y * s + center.x;\r\n\t\tthis.y = x * s + y * c + center.y;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Vector3.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author *kile / http://kile.stravaganza.org/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author egraether / http://egraether.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Vector3 = function ( x, y, z ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\tthis.z = z || 0;\r\n\r\n};\r\n\r\nTHREE.Vector3.prototype = {\r\n\r\n\tconstructor: THREE.Vector3,\r\n\r\n\tset: function ( x, y, z ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetScalar: function ( scalar ) {\r\n\r\n\t\tthis.x = scalar;\r\n\t\tthis.y = scalar;\r\n\t\tthis.z = scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetZ: function ( z ) {\r\n\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tcase 2: this.z = value; break;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tcase 2: return this.z;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.x, this.y, this.z );\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\t\tthis.z = v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\t\tthis.z += v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\t\tthis.z += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\t\tthis.z = a.z + b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScaledVector: function ( v, s ) {\r\n\r\n\t\tthis.x += v.x * s;\r\n\t\tthis.y += v.y * s;\r\n\t\tthis.z += v.z * s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\t\tthis.z -= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubScalar: function ( s ) {\r\n\r\n\t\tthis.x -= s;\r\n\t\tthis.y -= s;\r\n\t\tthis.z -= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\t\tthis.z = a.z - b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiply: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );\r\n\t\t\treturn this.multiplyVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x *= v.x;\r\n\t\tthis.y *= v.y;\r\n\t\tthis.z *= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( scalar ) {\r\n\r\n\t\tif ( isFinite( scalar ) ) {\r\n\r\n\t\t\tthis.x *= scalar;\r\n\t\t\tthis.y *= scalar;\r\n\t\t\tthis.z *= scalar;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.z = 0;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x * b.x;\r\n\t\tthis.y = a.y * b.y;\r\n\t\tthis.z = a.z * b.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyEuler: function () {\r\n\r\n\t\tvar quaternion;\r\n\r\n\t\treturn function applyEuler( euler ) {\r\n\r\n\t\t\tif ( euler instanceof THREE.Euler === false ) {\r\n\r\n\t\t\t\tconsole.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\r\n\r\n\t\t\treturn this.applyQuaternion( quaternion.setFromEuler( euler ) );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyAxisAngle: function () {\r\n\r\n\t\tvar quaternion;\r\n\r\n\t\treturn function applyAxisAngle( axis, angle ) {\r\n\r\n\t\t\tif ( quaternion === undefined ) quaternion = new THREE.Quaternion();\r\n\r\n\t\t\treturn this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyMatrix3: function ( m ) {\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;\r\n\t\tthis.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;\r\n\t\tthis.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( m ) {\r\n\r\n\t\t// input: THREE.Matrix4 affine matrix\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];\r\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];\r\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyProjection: function ( m ) {\r\n\r\n\t\t// input: THREE.Matrix4 projection matrix\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\tvar e = m.elements;\r\n\t\tvar d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide\r\n\r\n\t\tthis.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;\r\n\t\tthis.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;\r\n\t\tthis.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyQuaternion: function ( q ) {\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\tvar qx = q.x, qy = q.y, qz = q.z, qw = q.w;\r\n\r\n\t\t// calculate quat * vector\r\n\r\n\t\tvar ix =  qw * x + qy * z - qz * y;\r\n\t\tvar iy =  qw * y + qz * x - qx * z;\r\n\t\tvar iz =  qw * z + qx * y - qy * x;\r\n\t\tvar iw = - qx * x - qy * y - qz * z;\r\n\r\n\t\t// calculate result * inverse quat\r\n\r\n\t\tthis.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;\r\n\t\tthis.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;\r\n\t\tthis.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tproject: function () {\r\n\r\n\t\tvar matrix;\r\n\r\n\t\treturn function project( camera ) {\r\n\r\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\r\n\t\t\tmatrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );\r\n\t\t\treturn this.applyProjection( matrix );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tunproject: function () {\r\n\r\n\t\tvar matrix;\r\n\r\n\t\treturn function unproject( camera ) {\r\n\r\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\r\n\t\t\tmatrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );\r\n\t\t\treturn this.applyProjection( matrix );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttransformDirection: function ( m ) {\r\n\r\n\t\t// input: THREE.Matrix4 affine matrix\r\n\t\t// vector interpreted as a direction\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;\r\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;\r\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;\r\n\r\n\t\treturn this.normalize();\r\n\r\n\t},\r\n\r\n\tdivide: function ( v ) {\r\n\r\n\t\tthis.x /= v.x;\r\n\t\tthis.y /= v.y;\r\n\t\tthis.z /= v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( scalar ) {\r\n\r\n\t\treturn this.multiplyScalar( 1 / scalar );\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tthis.x = Math.min( this.x, v.x );\r\n\t\tthis.y = Math.min( this.y, v.y );\r\n\t\tthis.z = Math.min( this.z, v.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tthis.x = Math.max( this.x, v.x );\r\n\t\tthis.y = Math.max( this.y, v.y );\r\n\t\tthis.z = Math.max( this.z, v.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclampScalar: function () {\r\n\r\n\t\tvar min, max;\r\n\r\n\t\treturn function clampScalar( minVal, maxVal ) {\r\n\r\n\t\t\tif ( min === undefined ) {\r\n\r\n\t\t\t\tmin = new THREE.Vector3();\r\n\t\t\t\tmax = new THREE.Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmin.set( minVal, minVal, minVal );\r\n\t\t\tmax.set( maxVal, maxVal, maxVal );\r\n\r\n\t\t\treturn this.clamp( min, max );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclampLength: function ( min, max ) {\r\n\r\n\t\tvar length = this.length();\r\n\r\n\t\treturn this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );\r\n\r\n\t},\r\n\r\n\tfloor: function () {\r\n\r\n\t\tthis.x = Math.floor( this.x );\r\n\t\tthis.y = Math.floor( this.y );\r\n\t\tthis.z = Math.floor( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tceil: function () {\r\n\r\n\t\tthis.x = Math.ceil( this.x );\r\n\t\tthis.y = Math.ceil( this.y );\r\n\t\tthis.z = Math.ceil( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tround: function () {\r\n\r\n\t\tthis.x = Math.round( this.x );\r\n\t\tthis.y = Math.round( this.y );\r\n\t\tthis.z = Math.round( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\troundToZero: function () {\r\n\r\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.x = - this.x;\r\n\t\tthis.y = - this.y;\r\n\t\tthis.z = - this.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );\r\n\r\n\t},\r\n\r\n\tlengthManhattan: function () {\r\n\r\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() );\r\n\r\n\t},\r\n\r\n\tsetLength: function ( length ) {\r\n\r\n\t\treturn this.multiplyScalar( length / this.length() );\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerpVectors: function ( v1, v2, alpha ) {\r\n\r\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n\t},\r\n\r\n\tcross: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );\r\n\t\t\treturn this.crossVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z;\r\n\r\n\t\tthis.x = y * v.z - z * v.y;\r\n\t\tthis.y = z * v.x - x * v.z;\r\n\t\tthis.z = x * v.y - y * v.x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcrossVectors: function ( a, b ) {\r\n\r\n\t\tvar ax = a.x, ay = a.y, az = a.z;\r\n\t\tvar bx = b.x, by = b.y, bz = b.z;\r\n\r\n\t\tthis.x = ay * bz - az * by;\r\n\t\tthis.y = az * bx - ax * bz;\r\n\t\tthis.z = ax * by - ay * bx;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tprojectOnVector: function () {\r\n\r\n\t\tvar v1, dot;\r\n\r\n\t\treturn function projectOnVector( vector ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n\t\t\tv1.copy( vector ).normalize();\r\n\r\n\t\t\tdot = this.dot( v1 );\r\n\r\n\t\t\treturn this.copy( v1 ).multiplyScalar( dot );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tprojectOnPlane: function () {\r\n\r\n\t\tvar v1;\r\n\r\n\t\treturn function projectOnPlane( planeNormal ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n\t\t\tv1.copy( this ).projectOnVector( planeNormal );\r\n\r\n\t\t\treturn this.sub( v1 );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\treflect: function () {\r\n\r\n\t\t// reflect incident vector off plane orthogonal to normal\r\n\t\t// normal is assumed to have unit length\r\n\r\n\t\tvar v1;\r\n\r\n\t\treturn function reflect( normal ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n\t\t\treturn this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tangleTo: function ( v ) {\r\n\r\n\t\tvar theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );\r\n\r\n\t\t// clamp, to handle numerical problems\r\n\r\n\t\treturn Math.acos( THREE.Math.clamp( theta, - 1, 1 ) );\r\n\r\n\t},\r\n\r\n\tdistanceTo: function ( v ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceToSquared( v ) );\r\n\r\n\t},\r\n\r\n\tdistanceToSquared: function ( v ) {\r\n\r\n\t\tvar dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\r\n\r\n\t\treturn dx * dx + dy * dy + dz * dz;\r\n\r\n\t},\r\n\r\n\tsetFromSpherical: function( s ) {\r\n\r\n\t\tvar sinPhiRadius = Math.sin( s.phi ) * s.radius;\r\n\r\n\t\tthis.x = sinPhiRadius * Math.sin( s.theta );\r\n\t\tthis.y = Math.cos( s.phi ) * s.radius;\r\n\t\tthis.z = sinPhiRadius * Math.cos( s.theta );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrixPosition: function ( m ) {\r\n\r\n\t\treturn this.setFromMatrixColumn( m, 3 );\r\n\r\n\t},\r\n\r\n\tsetFromMatrixScale: function ( m ) {\r\n\r\n\t\tvar sx = this.setFromMatrixColumn( m, 0 ).length();\r\n\t\tvar sy = this.setFromMatrixColumn( m, 1 ).length();\r\n\t\tvar sz = this.setFromMatrixColumn( m, 2 ).length();\r\n\r\n\t\tthis.x = sx;\r\n\t\tthis.y = sy;\r\n\t\tthis.z = sz;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrixColumn: function ( m, index ) {\r\n\r\n\t\tif ( typeof m === 'number' ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );\r\n\t\t\tvar temp = m\r\n\t\t\tm = index;\r\n\t\t\tindex = temp;\r\n\r\n\t\t}\r\n\r\n\t\treturn this.fromArray( m.elements, index * 4 );\r\n\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.x = array[ offset ];\r\n\t\tthis.y = array[ offset + 1 ];\r\n\t\tthis.z = array[ offset + 2 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this.x;\r\n\t\tarray[ offset + 1 ] = this.y;\r\n\t\tarray[ offset + 2 ] = this.z;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tfromAttribute: function ( attribute, index, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tindex = index * attribute.itemSize + offset;\r\n\r\n\t\tthis.x = attribute.array[ index ];\r\n\t\tthis.y = attribute.array[ index + 1 ];\r\n\t\tthis.z = attribute.array[ index + 2 ];\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Vector4.js\r\n\r\n/**\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author egraether / http://egraether.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Vector4 = function ( x, y, z, w ) {\r\n\r\n\tthis.x = x || 0;\r\n\tthis.y = y || 0;\r\n\tthis.z = z || 0;\r\n\tthis.w = ( w !== undefined ) ? w : 1;\r\n\r\n};\r\n\r\nTHREE.Vector4.prototype = {\r\n\r\n\tconstructor: THREE.Vector4,\r\n\r\n\tset: function ( x, y, z, w ) {\r\n\r\n\t\tthis.x = x;\r\n\t\tthis.y = y;\r\n\t\tthis.z = z;\r\n\t\tthis.w = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetScalar: function ( scalar ) {\r\n\r\n\t\tthis.x = scalar;\r\n\t\tthis.y = scalar;\r\n\t\tthis.z = scalar;\r\n\t\tthis.w = scalar;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetX: function ( x ) {\r\n\r\n\t\tthis.x = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( y ) {\r\n\r\n\t\tthis.y = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetZ: function ( z ) {\r\n\r\n\t\tthis.z = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetW: function ( w ) {\r\n\r\n\t\tthis.w = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponent: function ( index, value ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: this.x = value; break;\r\n\t\t\tcase 1: this.y = value; break;\r\n\t\t\tcase 2: this.z = value; break;\r\n\t\t\tcase 3: this.w = value; break;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetComponent: function ( index ) {\r\n\r\n\t\tswitch ( index ) {\r\n\r\n\t\t\tcase 0: return this.x;\r\n\t\t\tcase 1: return this.y;\r\n\t\t\tcase 2: return this.z;\r\n\t\t\tcase 3: return this.w;\r\n\t\t\tdefault: throw new Error( 'index is out of range: ' + index );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.x, this.y, this.z, this.w );\r\n\r\n\t},\r\n\r\n\tcopy: function ( v ) {\r\n\r\n\t\tthis.x = v.x;\r\n\t\tthis.y = v.y;\r\n\t\tthis.z = v.z;\r\n\t\tthis.w = ( v.w !== undefined ) ? v.w : 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );\r\n\t\t\treturn this.addVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x += v.x;\r\n\t\tthis.y += v.y;\r\n\t\tthis.z += v.z;\r\n\t\tthis.w += v.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScalar: function ( s ) {\r\n\r\n\t\tthis.x += s;\r\n\t\tthis.y += s;\r\n\t\tthis.z += s;\r\n\t\tthis.w += s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x + b.x;\r\n\t\tthis.y = a.y + b.y;\r\n\t\tthis.z = a.z + b.z;\r\n\t\tthis.w = a.w + b.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddScaledVector: function ( v, s ) {\r\n\r\n\t\tthis.x += v.x * s;\r\n\t\tthis.y += v.y * s;\r\n\t\tthis.z += v.z * s;\r\n\t\tthis.w += v.w * s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsub: function ( v, w ) {\r\n\r\n\t\tif ( w !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );\r\n\t\t\treturn this.subVectors( v, w );\r\n\r\n\t\t}\r\n\r\n\t\tthis.x -= v.x;\r\n\t\tthis.y -= v.y;\r\n\t\tthis.z -= v.z;\r\n\t\tthis.w -= v.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubScalar: function ( s ) {\r\n\r\n\t\tthis.x -= s;\r\n\t\tthis.y -= s;\r\n\t\tthis.z -= s;\r\n\t\tthis.w -= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsubVectors: function ( a, b ) {\r\n\r\n\t\tthis.x = a.x - b.x;\r\n\t\tthis.y = a.y - b.y;\r\n\t\tthis.z = a.z - b.z;\r\n\t\tthis.w = a.w - b.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( scalar ) {\r\n\r\n\t\tif ( isFinite( scalar ) ) {\r\n\r\n\t\t\tthis.x *= scalar;\r\n\t\t\tthis.y *= scalar;\r\n\t\t\tthis.z *= scalar;\r\n\t\t\tthis.w *= scalar;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.x = 0;\r\n\t\t\tthis.y = 0;\r\n\t\t\tthis.z = 0;\r\n\t\t\tthis.w = 0;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( m ) {\r\n\r\n\t\tvar x = this.x, y = this.y, z = this.z, w = this.w;\r\n\t\tvar e = m.elements;\r\n\r\n\t\tthis.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;\r\n\t\tthis.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;\r\n\t\tthis.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;\r\n\t\tthis.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdivideScalar: function ( scalar ) {\r\n\r\n\t\treturn this.multiplyScalar( 1 / scalar );\r\n\r\n\t},\r\n\r\n\tsetAxisAngleFromQuaternion: function ( q ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\r\n\r\n\t\t// q is assumed to be normalized\r\n\r\n\t\tthis.w = 2 * Math.acos( q.w );\r\n\r\n\t\tvar s = Math.sqrt( 1 - q.w * q.w );\r\n\r\n\t\tif ( s < 0.0001 ) {\r\n\r\n\t\t\t this.x = 1;\r\n\t\t\t this.y = 0;\r\n\t\t\t this.z = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t this.x = q.x / s;\r\n\t\t\t this.y = q.y / s;\r\n\t\t\t this.z = q.z / s;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetAxisAngleFromRotationMatrix: function ( m ) {\r\n\r\n\t\t// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tvar angle, x, y, z,\t\t// variables for result\r\n\t\t\tepsilon = 0.01,\t\t// margin to allow for rounding errors\r\n\t\t\tepsilon2 = 0.1,\t\t// margin to distinguish between 0 and 180 degrees\r\n\r\n\t\t\tte = m.elements,\r\n\r\n\t\t\tm11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],\r\n\t\t\tm21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],\r\n\t\t\tm31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\r\n\t\tif ( ( Math.abs( m12 - m21 ) < epsilon ) &&\r\n\t\t     ( Math.abs( m13 - m31 ) < epsilon ) &&\r\n\t\t     ( Math.abs( m23 - m32 ) < epsilon ) ) {\r\n\r\n\t\t\t// singularity found\r\n\t\t\t// first check for identity matrix which must have +1 for all terms\r\n\t\t\t// in leading diagonal and zero in other terms\r\n\r\n\t\t\tif ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&\r\n\t\t\t     ( Math.abs( m13 + m31 ) < epsilon2 ) &&\r\n\t\t\t     ( Math.abs( m23 + m32 ) < epsilon2 ) &&\r\n\t\t\t     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {\r\n\r\n\t\t\t\t// this singularity is identity matrix so angle = 0\r\n\r\n\t\t\t\tthis.set( 1, 0, 0, 0 );\r\n\r\n\t\t\t\treturn this; // zero angle, arbitrary axis\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// otherwise this singularity is angle = 180\r\n\r\n\t\t\tangle = Math.PI;\r\n\r\n\t\t\tvar xx = ( m11 + 1 ) / 2;\r\n\t\t\tvar yy = ( m22 + 1 ) / 2;\r\n\t\t\tvar zz = ( m33 + 1 ) / 2;\r\n\t\t\tvar xy = ( m12 + m21 ) / 4;\r\n\t\t\tvar xz = ( m13 + m31 ) / 4;\r\n\t\t\tvar yz = ( m23 + m32 ) / 4;\r\n\r\n\t\t\tif ( ( xx > yy ) && ( xx > zz ) ) {\r\n\r\n\t\t\t\t// m11 is the largest diagonal term\r\n\r\n\t\t\t\tif ( xx < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0;\r\n\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\tz = 0.707106781;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tx = Math.sqrt( xx );\r\n\t\t\t\t\ty = xy / x;\r\n\t\t\t\t\tz = xz / x;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( yy > zz ) {\r\n\r\n\t\t\t\t// m22 is the largest diagonal term\r\n\r\n\t\t\t\tif ( yy < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\ty = 0;\r\n\t\t\t\t\tz = 0.707106781;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ty = Math.sqrt( yy );\r\n\t\t\t\t\tx = xy / y;\r\n\t\t\t\t\tz = yz / y;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// m33 is the largest diagonal term so base result on this\r\n\r\n\t\t\t\tif ( zz < epsilon ) {\r\n\r\n\t\t\t\t\tx = 0.707106781;\r\n\t\t\t\t\ty = 0.707106781;\r\n\t\t\t\t\tz = 0;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tz = Math.sqrt( zz );\r\n\t\t\t\t\tx = xz / z;\r\n\t\t\t\t\ty = yz / z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.set( x, y, z, angle );\r\n\r\n\t\t\treturn this; // return 180 deg rotation\r\n\r\n\t\t}\r\n\r\n\t\t// as we have reached here there are no singularities so we can handle normally\r\n\r\n\t\tvar s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +\r\n\t\t                   ( m13 - m31 ) * ( m13 - m31 ) +\r\n\t\t                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize\r\n\r\n\t\tif ( Math.abs( s ) < 0.001 ) s = 1;\r\n\r\n\t\t// prevent divide by zero, should not happen if matrix is orthogonal and should be\r\n\t\t// caught by singularity test above, but I've left it in just in case\r\n\r\n\t\tthis.x = ( m32 - m23 ) / s;\r\n\t\tthis.y = ( m13 - m31 ) / s;\r\n\t\tthis.z = ( m21 - m12 ) / s;\r\n\t\tthis.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmin: function ( v ) {\r\n\r\n\t\tthis.x = Math.min( this.x, v.x );\r\n\t\tthis.y = Math.min( this.y, v.y );\r\n\t\tthis.z = Math.min( this.z, v.z );\r\n\t\tthis.w = Math.min( this.w, v.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmax: function ( v ) {\r\n\r\n\t\tthis.x = Math.max( this.x, v.x );\r\n\t\tthis.y = Math.max( this.y, v.y );\r\n\t\tthis.z = Math.max( this.z, v.z );\r\n\t\tthis.w = Math.max( this.w, v.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclamp: function ( min, max ) {\r\n\r\n\t\t// This function assumes min < max, if this assumption isn't true it will not operate correctly\r\n\r\n\t\tthis.x = Math.max( min.x, Math.min( max.x, this.x ) );\r\n\t\tthis.y = Math.max( min.y, Math.min( max.y, this.y ) );\r\n\t\tthis.z = Math.max( min.z, Math.min( max.z, this.z ) );\r\n\t\tthis.w = Math.max( min.w, Math.min( max.w, this.w ) );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclampScalar: function () {\r\n\r\n\t\tvar min, max;\r\n\r\n\t\treturn function clampScalar( minVal, maxVal ) {\r\n\r\n\t\t\tif ( min === undefined ) {\r\n\r\n\t\t\t\tmin = new THREE.Vector4();\r\n\t\t\t\tmax = new THREE.Vector4();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmin.set( minVal, minVal, minVal, minVal );\r\n\t\t\tmax.set( maxVal, maxVal, maxVal, maxVal );\r\n\r\n\t\t\treturn this.clamp( min, max );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tfloor: function () {\r\n\r\n\t\tthis.x = Math.floor( this.x );\r\n\t\tthis.y = Math.floor( this.y );\r\n\t\tthis.z = Math.floor( this.z );\r\n\t\tthis.w = Math.floor( this.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tceil: function () {\r\n\r\n\t\tthis.x = Math.ceil( this.x );\r\n\t\tthis.y = Math.ceil( this.y );\r\n\t\tthis.z = Math.ceil( this.z );\r\n\t\tthis.w = Math.ceil( this.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tround: function () {\r\n\r\n\t\tthis.x = Math.round( this.x );\r\n\t\tthis.y = Math.round( this.y );\r\n\t\tthis.z = Math.round( this.z );\r\n\t\tthis.w = Math.round( this.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\troundToZero: function () {\r\n\r\n\t\tthis.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );\r\n\t\tthis.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );\r\n\t\tthis.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );\r\n\t\tthis.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.x = - this.x;\r\n\t\tthis.y = - this.y;\r\n\t\tthis.z = - this.z;\r\n\t\tthis.w = - this.w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdot: function ( v ) {\r\n\r\n\t\treturn this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n\r\n\t},\r\n\r\n\tlengthSq: function () {\r\n\r\n\t\treturn this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\r\n\r\n\t},\r\n\r\n\tlength: function () {\r\n\r\n\t\treturn Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );\r\n\r\n\t},\r\n\r\n\tlengthManhattan: function () {\r\n\r\n\t\treturn Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\treturn this.divideScalar( this.length() );\r\n\r\n\t},\r\n\r\n\tsetLength: function ( length ) {\r\n\r\n\t\treturn this.multiplyScalar( length / this.length() );\r\n\r\n\t},\r\n\r\n\tlerp: function ( v, alpha ) {\r\n\r\n\t\tthis.x += ( v.x - this.x ) * alpha;\r\n\t\tthis.y += ( v.y - this.y ) * alpha;\r\n\t\tthis.z += ( v.z - this.z ) * alpha;\r\n\t\tthis.w += ( v.w - this.w ) * alpha;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlerpVectors: function ( v1, v2, alpha ) {\r\n\r\n\t\treturn this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );\r\n\r\n\t},\r\n\r\n\tequals: function ( v ) {\r\n\r\n\t\treturn ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.x = array[ offset ];\r\n\t\tthis.y = array[ offset + 1 ];\r\n\t\tthis.z = array[ offset + 2 ];\r\n\t\tthis.w = array[ offset + 3 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this.x;\r\n\t\tarray[ offset + 1 ] = this.y;\r\n\t\tarray[ offset + 2 ] = this.z;\r\n\t\tarray[ offset + 3 ] = this.w;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tfromAttribute: function ( attribute, index, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tindex = index * attribute.itemSize + offset;\r\n\r\n\t\tthis.x = attribute.array[ index ];\r\n\t\tthis.y = attribute.array[ index + 1 ];\r\n\t\tthis.z = attribute.array[ index + 2 ];\r\n\t\tthis.w = attribute.array[ index + 3 ];\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Euler.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Euler = function ( x, y, z, order ) {\r\n\r\n\tthis._x = x || 0;\r\n\tthis._y = y || 0;\r\n\tthis._z = z || 0;\r\n\tthis._order = order || THREE.Euler.DefaultOrder;\r\n\r\n};\r\n\r\nTHREE.Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];\r\n\r\nTHREE.Euler.DefaultOrder = 'XYZ';\r\n\r\nTHREE.Euler.prototype = {\r\n\r\n\tconstructor: THREE.Euler,\r\n\r\n\tget x () {\r\n\r\n\t\treturn this._x;\r\n\r\n\t},\r\n\r\n\tset x ( value ) {\r\n\r\n\t\tthis._x = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tget y () {\r\n\r\n\t\treturn this._y;\r\n\r\n\t},\r\n\r\n\tset y ( value ) {\r\n\r\n\t\tthis._y = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tget z () {\r\n\r\n\t\treturn this._z;\r\n\r\n\t},\r\n\r\n\tset z ( value ) {\r\n\r\n\t\tthis._z = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tget order () {\r\n\r\n\t\treturn this._order;\r\n\r\n\t},\r\n\r\n\tset order ( value ) {\r\n\r\n\t\tthis._order = value;\r\n\t\tthis.onChangeCallback();\r\n\r\n\t},\r\n\r\n\tset: function ( x, y, z, order ) {\r\n\r\n\t\tthis._x = x;\r\n\t\tthis._y = y;\r\n\t\tthis._z = z;\r\n\t\tthis._order = order || this._order;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this._x, this._y, this._z, this._order );\r\n\r\n\t},\r\n\r\n\tcopy: function ( euler ) {\r\n\r\n\t\tthis._x = euler._x;\r\n\t\tthis._y = euler._y;\r\n\t\tthis._z = euler._z;\r\n\t\tthis._order = euler._order;\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromRotationMatrix: function ( m, order, update ) {\r\n\r\n\t\tvar clamp = THREE.Math.clamp;\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tvar te = m.elements;\r\n\t\tvar m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];\r\n\t\tvar m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];\r\n\t\tvar m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];\r\n\r\n\t\torder = order || this._order;\r\n\r\n\t\tif ( order === 'XYZ' ) {\r\n\r\n\t\t\tthis._y = Math.asin( clamp( m13, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m13 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\r\n\t\t\t\tthis._z = Math.atan2( - m12, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\r\n\t\t\t\tthis._z = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'YXZ' ) {\r\n\r\n\t\t\tthis._x = Math.asin( - clamp( m23, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m23 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\r\n\t\t\t\tthis._z = Math.atan2( m21, m22 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\r\n\t\t\t\tthis._z = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'ZXY' ) {\r\n\r\n\t\t\tthis._x = Math.asin( clamp( m32, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m32 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._y = Math.atan2( - m31, m33 );\r\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._y = 0;\r\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'ZYX' ) {\r\n\r\n\t\t\tthis._y = Math.asin( - clamp( m31, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m31 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( m32, m33 );\r\n\t\t\t\tthis._z = Math.atan2( m21, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = 0;\r\n\t\t\t\tthis._z = Math.atan2( - m12, m22 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'YZX' ) {\r\n\r\n\t\t\tthis._z = Math.asin( clamp( m21, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m21 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( - m23, m22 );\r\n\t\t\t\tthis._y = Math.atan2( - m31, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = 0;\r\n\t\t\t\tthis._y = Math.atan2( m13, m33 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( order === 'XZY' ) {\r\n\r\n\t\t\tthis._z = Math.asin( - clamp( m12, - 1, 1 ) );\r\n\r\n\t\t\tif ( Math.abs( m12 ) < 0.99999 ) {\r\n\r\n\t\t\t\tthis._x = Math.atan2( m32, m22 );\r\n\t\t\t\tthis._y = Math.atan2( m13, m11 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis._x = Math.atan2( - m23, m33 );\r\n\t\t\t\tthis._y = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );\r\n\r\n\t\t}\r\n\r\n\t\tthis._order = order;\r\n\r\n\t\tif ( update !== false ) this.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromQuaternion: function () {\r\n\r\n\t\tvar matrix;\r\n\r\n\t\treturn function ( q, order, update ) {\r\n\r\n\t\t\tif ( matrix === undefined ) matrix = new THREE.Matrix4();\r\n\r\n\t\t\tmatrix.makeRotationFromQuaternion( q );\r\n\r\n\t\t\treturn this.setFromRotationMatrix( matrix, order, update );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetFromVector3: function ( v, order ) {\r\n\r\n\t\treturn this.set( v.x, v.y, v.z, order || this._order );\r\n\r\n\t},\r\n\r\n\treorder: function () {\r\n\r\n\t\t// WARNING: this discards revolution information -bhouston\r\n\r\n\t\tvar q = new THREE.Quaternion();\r\n\r\n\t\treturn function ( newOrder ) {\r\n\r\n\t\t\tq.setFromEuler( this );\r\n\t\t\t\r\n\t\t\treturn this.setFromQuaternion( q, newOrder );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tequals: function ( euler ) {\r\n\r\n\t\treturn ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array ) {\r\n\r\n\t\tthis._x = array[ 0 ];\r\n\t\tthis._y = array[ 1 ];\r\n\t\tthis._z = array[ 2 ];\r\n\t\tif ( array[ 3 ] !== undefined ) this._order = array[ 3 ];\r\n\r\n\t\tthis.onChangeCallback();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tarray[ offset ] = this._x;\r\n\t\tarray[ offset + 1 ] = this._y;\r\n\t\tarray[ offset + 2 ] = this._z;\r\n\t\tarray[ offset + 3 ] = this._order;\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\ttoVector3: function ( optionalResult ) {\r\n\r\n\t\tif ( optionalResult ) {\r\n\r\n\t\t\treturn optionalResult.set( this._x, this._y, this._z );\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn new THREE.Vector3( this._x, this._y, this._z );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tonChange: function ( callback ) {\r\n\r\n\t\tthis.onChangeCallback = callback;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tonChangeCallback: function () {}\r\n\r\n};\r\n\r\n// File:src/math/Line3.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Line3 = function ( start, end ) {\r\n\r\n\tthis.start = ( start !== undefined ) ? start : new THREE.Vector3();\r\n\tthis.end = ( end !== undefined ) ? end : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Line3.prototype = {\r\n\r\n\tconstructor: THREE.Line3,\r\n\r\n\tset: function ( start, end ) {\r\n\r\n\t\tthis.start.copy( start );\r\n\t\tthis.end.copy( end );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( line ) {\r\n\r\n\t\tthis.start.copy( line.start );\r\n\t\tthis.end.copy( line.end );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcenter: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );\r\n\r\n\t},\r\n\r\n\tdelta: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.subVectors( this.end, this.start );\r\n\r\n\t},\r\n\r\n\tdistanceSq: function () {\r\n\r\n\t\treturn this.start.distanceToSquared( this.end );\r\n\r\n\t},\r\n\r\n\tdistance: function () {\r\n\r\n\t\treturn this.start.distanceTo( this.end );\r\n\r\n\t},\r\n\r\n\tat: function ( t, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\r\n\r\n\t},\r\n\r\n\tclosestPointToPointParameter: function () {\r\n\r\n\t\tvar startP = new THREE.Vector3();\r\n\t\tvar startEnd = new THREE.Vector3();\r\n\r\n\t\treturn function ( point, clampToLine ) {\r\n\r\n\t\t\tstartP.subVectors( point, this.start );\r\n\t\t\tstartEnd.subVectors( this.end, this.start );\r\n\r\n\t\t\tvar startEnd2 = startEnd.dot( startEnd );\r\n\t\t\tvar startEnd_startP = startEnd.dot( startP );\r\n\r\n\t\t\tvar t = startEnd_startP / startEnd2;\r\n\r\n\t\t\tif ( clampToLine ) {\r\n\r\n\t\t\t\tt = THREE.Math.clamp( t, 0, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn t;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclosestPointToPoint: function ( point, clampToLine, optionalTarget ) {\r\n\r\n\t\tvar t = this.closestPointToPointParameter( point, clampToLine );\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\treturn this.delta( result ).multiplyScalar( t ).add( this.start );\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( matrix ) {\r\n\r\n\t\tthis.start.applyMatrix4( matrix );\r\n\t\tthis.end.applyMatrix4( matrix );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( line ) {\r\n\r\n\t\treturn line.start.equals( this.start ) && line.end.equals( this.end );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Box2.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Box2 = function ( min, max ) {\r\n\r\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector2( + Infinity, + Infinity );\r\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector2( - Infinity, - Infinity );\r\n\r\n};\r\n\r\nTHREE.Box2.prototype = {\r\n\r\n\tconstructor: THREE.Box2,\r\n\r\n\tset: function ( min, max ) {\r\n\r\n\t\tthis.min.copy( min );\r\n\t\tthis.max.copy( max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function ( points ) {\r\n\r\n\t\tthis.makeEmpty();\r\n\r\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.expandByPoint( points[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCenterAndSize: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector2();\r\n\r\n\t\treturn function ( center, size ) {\r\n\r\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\t\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\t\tthis.max.copy( center ).add( halfSize );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( box ) {\r\n\r\n\t\tthis.min.copy( box.min );\r\n\t\tthis.max.copy( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeEmpty: function () {\r\n\r\n\t\tthis.min.x = this.min.y = + Infinity;\r\n\t\tthis.max.x = this.max.y = - Infinity;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tisEmpty: function () {\r\n\r\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\r\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );\r\n\r\n\t},\r\n\r\n\tcenter: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\r\n\t},\r\n\r\n\tsize: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\treturn result.subVectors( this.max, this.min );\r\n\r\n\t},\r\n\r\n\texpandByPoint: function ( point ) {\r\n\r\n\t\tthis.min.min( point );\r\n\t\tthis.max.max( point );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByVector: function ( vector ) {\r\n\r\n\t\tthis.min.sub( vector );\r\n\t\tthis.max.add( vector );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByScalar: function ( scalar ) {\r\n\r\n\t\tthis.min.addScalar( - scalar );\r\n\t\tthis.max.addScalar( scalar );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\r\n\t\t     point.y < this.min.y || point.y > this.max.y ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tcontainsBox: function ( box ) {\r\n\r\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n\t\t     ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tgetParameter: function ( point, optionalTarget ) {\r\n\r\n\t\t// This can potentially have a divide by zero if the box\r\n\t\t// has a size dimension of 0.\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\r\n\t\treturn result.set(\r\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y )\r\n\t\t);\r\n\r\n\t},\r\n\r\n\tintersectsBox: function ( box ) {\r\n\r\n\t\t// using 6 splitting planes to rule out intersections.\r\n\r\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t     box.max.y < this.min.y || box.min.y > this.max.y ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tclampPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector2();\r\n\t\treturn result.copy( point ).clamp( this.min, this.max );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector2();\r\n\r\n\t\treturn function ( point ) {\r\n\r\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n\t\t\treturn clampedPoint.sub( point ).length();\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersect: function ( box ) {\r\n\r\n\t\tthis.min.max( box.min );\r\n\t\tthis.max.min( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tunion: function ( box ) {\r\n\r\n\t\tthis.min.min( box.min );\r\n\t\tthis.max.max( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.min.add( offset );\r\n\t\tthis.max.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( box ) {\r\n\r\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Box3.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Box3 = function ( min, max ) {\r\n\r\n\tthis.min = ( min !== undefined ) ? min : new THREE.Vector3( + Infinity, + Infinity, + Infinity );\r\n\tthis.max = ( max !== undefined ) ? max : new THREE.Vector3( - Infinity, - Infinity, - Infinity );\r\n\r\n};\r\n\r\nTHREE.Box3.prototype = {\r\n\r\n\tconstructor: THREE.Box3,\r\n\r\n\tset: function ( min, max ) {\r\n\r\n\t\tthis.min.copy( min );\r\n\t\tthis.max.copy( max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromArray: function ( array ) {\r\n\r\n\t\tvar minX = + Infinity;\r\n\t\tvar minY = + Infinity;\r\n\t\tvar minZ = + Infinity;\r\n\r\n\t\tvar maxX = - Infinity;\r\n\t\tvar maxY = - Infinity;\r\n\t\tvar maxZ = - Infinity;\r\n\r\n\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\r\n\r\n\t\t\tvar x = array[ i ];\r\n\t\t\tvar y = array[ i + 1 ];\r\n\t\t\tvar z = array[ i + 2 ];\r\n\r\n\t\t\tif ( x < minX ) minX = x;\r\n\t\t\tif ( y < minY ) minY = y;\r\n\t\t\tif ( z < minZ ) minZ = z;\r\n\r\n\t\t\tif ( x > maxX ) maxX = x;\r\n\t\t\tif ( y > maxY ) maxY = y;\r\n\t\t\tif ( z > maxZ ) maxZ = z;\r\n\r\n\t\t}\r\n\r\n\t\tthis.min.set( minX, minY, minZ );\r\n\t\tthis.max.set( maxX, maxY, maxZ );\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function ( points ) {\r\n\r\n\t\tthis.makeEmpty();\r\n\r\n\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.expandByPoint( points[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCenterAndSize: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( center, size ) {\r\n\r\n\t\t\tvar halfSize = v1.copy( size ).multiplyScalar( 0.5 );\r\n\r\n\t\t\tthis.min.copy( center ).sub( halfSize );\r\n\t\t\tthis.max.copy( center ).add( halfSize );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetFromObject: function () {\r\n\r\n\t\t// Computes the world-axis-aligned bounding box of an object (including its children),\r\n\t\t// accounting for both the object's, and children's, world transforms\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( object ) {\r\n\r\n\t\t\tvar scope = this;\r\n\r\n\t\t\tobject.updateMatrixWorld( true );\r\n\r\n\t\t\tthis.makeEmpty();\r\n\r\n\t\t\tobject.traverse( function ( node ) {\r\n\r\n\t\t\t\tvar geometry = node.geometry;\r\n\r\n\t\t\t\tif ( geometry !== undefined ) {\r\n\r\n\t\t\t\t\tif ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\t\t\t\tvar vertices = geometry.vertices;\r\n\r\n\t\t\t\t\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tv1.copy( vertices[ i ] );\r\n\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\r\n\r\n\t\t\t\t\t\t\tscope.expandByPoint( v1 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else if ( geometry instanceof THREE.BufferGeometry && geometry.attributes[ 'position' ] !== undefined ) {\r\n\r\n\t\t\t\t\t\tvar positions = geometry.attributes[ 'position' ].array;\r\n\r\n\t\t\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\t\t\tv1.fromArray( positions, i );\r\n\t\t\t\t\t\t\tv1.applyMatrix4( node.matrixWorld );\r\n\r\n\t\t\t\t\t\t\tscope.expandByPoint( v1 );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( box ) {\r\n\r\n\t\tthis.min.copy( box.min );\r\n\t\tthis.max.copy( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeEmpty: function () {\r\n\r\n\t\tthis.min.x = this.min.y = this.min.z = + Infinity;\r\n\t\tthis.max.x = this.max.y = this.max.z = - Infinity;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tisEmpty: function () {\r\n\r\n\t\t// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes\r\n\r\n\t\treturn ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );\r\n\r\n\t},\r\n\r\n\tcenter: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );\r\n\r\n\t},\r\n\r\n\tsize: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.subVectors( this.max, this.min );\r\n\r\n\t},\r\n\r\n\texpandByPoint: function ( point ) {\r\n\r\n\t\tthis.min.min( point );\r\n\t\tthis.max.max( point );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByVector: function ( vector ) {\r\n\r\n\t\tthis.min.sub( vector );\r\n\t\tthis.max.add( vector );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\texpandByScalar: function ( scalar ) {\r\n\r\n\t\tthis.min.addScalar( - scalar );\r\n\t\tthis.max.addScalar( scalar );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\tif ( point.x < this.min.x || point.x > this.max.x ||\r\n\t\t\t\t point.y < this.min.y || point.y > this.max.y ||\r\n\t\t\t\t point.z < this.min.z || point.z > this.max.z ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tcontainsBox: function ( box ) {\r\n\r\n\t\tif ( ( this.min.x <= box.min.x ) && ( box.max.x <= this.max.x ) &&\r\n\t\t\t ( this.min.y <= box.min.y ) && ( box.max.y <= this.max.y ) &&\r\n\t\t\t ( this.min.z <= box.min.z ) && ( box.max.z <= this.max.z ) ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tgetParameter: function ( point, optionalTarget ) {\r\n\r\n\t\t// This can potentially have a divide by zero if the box\r\n\t\t// has a size dimension of 0.\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\treturn result.set(\r\n\t\t\t( point.x - this.min.x ) / ( this.max.x - this.min.x ),\r\n\t\t\t( point.y - this.min.y ) / ( this.max.y - this.min.y ),\r\n\t\t\t( point.z - this.min.z ) / ( this.max.z - this.min.z )\r\n\t\t);\r\n\r\n\t},\r\n\r\n\tintersectsBox: function ( box ) {\r\n\r\n\t\t// using 6 splitting planes to rule out intersections.\r\n\r\n\t\tif ( box.max.x < this.min.x || box.min.x > this.max.x ||\r\n\t\t\t\t box.max.y < this.min.y || box.min.y > this.max.y ||\r\n\t\t\t\t box.max.z < this.min.z || box.min.z > this.max.z ) {\r\n\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tintersectsSphere: ( function () {\r\n\r\n\t\tvar closestPoint;\r\n\r\n\t\treturn function intersectsSphere( sphere ) {\r\n\r\n\t\t\tif ( closestPoint === undefined ) closestPoint = new THREE.Vector3();\r\n\r\n\t\t\t// Find the point on the AABB closest to the sphere center.\r\n\t\t\tthis.clampPoint( sphere.center, closestPoint );\r\n\r\n\t\t\t// If that point is inside the sphere, the AABB and sphere intersect.\r\n\t\t\treturn closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n\tintersectsPlane: function ( plane ) {\r\n\r\n\t\t// We compute the minimum and maximum dot product values. If those values\r\n\t\t// are on the same side (back or front) of the plane, then there is no intersection.\r\n\r\n\t\tvar min, max;\r\n\r\n\t\tif ( plane.normal.x > 0 ) {\r\n\r\n\t\t\tmin = plane.normal.x * this.min.x;\r\n\t\t\tmax = plane.normal.x * this.max.x;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmin = plane.normal.x * this.max.x;\r\n\t\t\tmax = plane.normal.x * this.min.x;\r\n\r\n\t\t}\r\n\r\n\t\tif ( plane.normal.y > 0 ) {\r\n\r\n\t\t\tmin += plane.normal.y * this.min.y;\r\n\t\t\tmax += plane.normal.y * this.max.y;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmin += plane.normal.y * this.max.y;\r\n\t\t\tmax += plane.normal.y * this.min.y;\r\n\r\n\t\t}\r\n\r\n\t\tif ( plane.normal.z > 0 ) {\r\n\r\n\t\t\tmin += plane.normal.z * this.min.z;\r\n\t\t\tmax += plane.normal.z * this.max.z;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tmin += plane.normal.z * this.max.z;\r\n\t\t\tmax += plane.normal.z * this.min.z;\r\n\r\n\t\t}\r\n\r\n\t\treturn ( min <= plane.constant && max >= plane.constant );\r\n\r\n\t},\r\n\r\n\tclampPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.copy( point ).clamp( this.min, this.max );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( point ) {\r\n\r\n\t\t\tvar clampedPoint = v1.copy( point ).clamp( this.min, this.max );\r\n\t\t\treturn clampedPoint.sub( point ).length();\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetBoundingSphere: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Sphere();\r\n\r\n\t\t\tresult.center = this.center();\r\n\t\t\tresult.radius = this.size( v1 ).length() * 0.5;\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersect: function ( box ) {\r\n\r\n\t\tthis.min.max( box.min );\r\n\t\tthis.max.min( box.max );\r\n\r\n\t\t// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.\r\n\t\tif( this.isEmpty() ) this.makeEmpty();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tunion: function ( box ) {\r\n\r\n\t\tthis.min.min( box.min );\r\n\t\tthis.max.max( box.max );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function () {\r\n\r\n\t\tvar points = [\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3(),\r\n\t\t\tnew THREE.Vector3()\r\n\t\t];\r\n\r\n\t\treturn function ( matrix ) {\r\n\r\n\t\t\t// transform of empty box is an empty box.\r\n\t\t\tif( this.isEmpty() ) return this;\r\n\r\n\t\t\t// NOTE: I am using a binary pattern to specify all 2^3 combinations below\r\n\t\t\tpoints[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000\r\n\t\t\tpoints[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001\r\n\t\t\tpoints[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010\r\n\t\t\tpoints[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011\r\n\t\t\tpoints[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100\r\n\t\t\tpoints[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101\r\n\t\t\tpoints[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110\r\n\t\t\tpoints[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );\t// 111\r\n\r\n\t\t\tthis.setFromPoints( points );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.min.add( offset );\r\n\t\tthis.max.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( box ) {\r\n\r\n\t\treturn box.min.equals( this.min ) && box.max.equals( this.max );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Matrix3.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author bhouston / http://clara.io\r\n * @author tschw\r\n */\r\n\r\nTHREE.Matrix3 = function () {\r\n\r\n\tthis.elements = new Float32Array( [\r\n\r\n\t\t1, 0, 0,\r\n\t\t0, 1, 0,\r\n\t\t0, 0, 1\r\n\r\n\t] );\r\n\r\n\tif ( arguments.length > 0 ) {\r\n\r\n\t\tconsole.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Matrix3.prototype = {\r\n\r\n\tconstructor: THREE.Matrix3,\r\n\r\n\tset: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;\r\n\t\tte[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;\r\n\t\tte[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tidentity: function () {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0,\r\n\t\t\t0, 1, 0,\r\n\t\t\t0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().fromArray( this.elements );\r\n\r\n\t},\r\n\r\n\tcopy: function ( m ) {\r\n\r\n\t\tvar me = m.elements;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tme[ 0 ], me[ 3 ], me[ 6 ],\r\n\t\t\tme[ 1 ], me[ 4 ], me[ 7 ],\r\n\t\t\tme[ 2 ], me[ 5 ], me[ 8 ]\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrix4: function( m ) {\r\n\r\n\t\tvar me = m.elements;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tme[ 0 ], me[ 4 ], me[  8 ],\r\n\t\t\tme[ 1 ], me[ 5 ], me[  9 ],\r\n\t\t\tme[ 2 ], me[ 6 ], me[ 10 ]\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyToVector3Array: function () {\r\n\r\n\t\tvar v1;\r\n\r\n\t\treturn function ( array, offset, length ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\tif ( length === undefined ) length = array.length;\r\n\r\n\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\r\n\r\n\t\t\t\tv1.fromArray( array, j );\r\n\t\t\t\tv1.applyMatrix3( this );\r\n\t\t\t\tv1.toArray( array, j );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyToBuffer: function () {\r\n\r\n\t\tvar v1;\r\n\r\n\t\treturn function applyToBuffer( buffer, offset, length ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\r\n\r\n\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\r\n\r\n\t\t\t\tv1.x = buffer.getX( j );\r\n\t\t\t\tv1.y = buffer.getY( j );\r\n\t\t\t\tv1.z = buffer.getZ( j );\r\n\r\n\t\t\t\tv1.applyMatrix3( this );\r\n\r\n\t\t\t\tbuffer.setXYZ( v1.x, v1.y, v1.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn buffer;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;\r\n\t\tte[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;\r\n\t\tte[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdeterminant: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],\r\n\t\t\td = te[ 3 ], e = te[ 4 ], f = te[ 5 ],\r\n\t\t\tg = te[ 6 ], h = te[ 7 ], i = te[ 8 ];\r\n\r\n\t\treturn a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;\r\n\r\n\t},\r\n\r\n\tgetInverse: function ( matrix, throwOnDegenerate ) {\r\n\r\n\t\tif ( matrix instanceof THREE.Matrix4 ) {\r\n\r\n\t\t\tconsole.error( \"THREE.Matrix3.getInverse no longer takes a Matrix4 argument.\" );\r\n\r\n\t\t}\r\n\r\n\t\tvar me = matrix.elements,\r\n\t\t\tte = this.elements,\r\n\r\n\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],\r\n\t\t\tn12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],\r\n\t\t\tn13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],\r\n\r\n\t\t\tt11 = n33 * n22 - n32 * n23,\r\n\t\t\tt12 = n32 * n13 - n33 * n12,\r\n\t\t\tt13 = n23 * n12 - n22 * n13,\r\n\r\n\t\t\tdet = n11 * t11 + n21 * t12 + n31 * t13;\r\n\r\n\t\tif ( det === 0 ) {\r\n\r\n\t\t\tvar msg = \"THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0\";\r\n\r\n\t\t\tif ( throwOnDegenerate || false ) {\r\n\r\n\t\t\t\tthrow new Error( msg );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( msg );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.identity();\r\n\t\t}\r\n\t\t\r\n\t\tvar detInv = 1 / det;\r\n\r\n\t\tte[ 0 ] = t11 * detInv;\r\n\t\tte[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;\r\n\t\tte[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;\r\n\r\n\t\tte[ 3 ] = t12 * detInv;\r\n\t\tte[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;\r\n\t\tte[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;\r\n\r\n\t\tte[ 6 ] = t13 * detInv;\r\n\t\tte[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;\r\n\t\tte[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranspose: function () {\r\n\r\n\t\tvar tmp, m = this.elements;\r\n\r\n\t\ttmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;\r\n\t\ttmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;\r\n\t\ttmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tflattenToArrayOffset: function ( array, offset ) {\r\n\r\n\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\r\n\t\t\t\t\"- just use .toArray instead.\" );\r\n\r\n\t\treturn this.toArray( array, offset );\r\n\r\n\t},\r\n\r\n\tgetNormalMatrix: function ( matrix4 ) {\r\n\r\n\t\treturn this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();\r\n\r\n\t},\r\n\r\n\ttransposeIntoArray: function ( r ) {\r\n\r\n\t\tvar m = this.elements;\r\n\r\n\t\tr[ 0 ] = m[ 0 ];\r\n\t\tr[ 1 ] = m[ 3 ];\r\n\t\tr[ 2 ] = m[ 6 ];\r\n\t\tr[ 3 ] = m[ 1 ];\r\n\t\tr[ 4 ] = m[ 4 ];\r\n\t\tr[ 5 ] = m[ 7 ];\r\n\t\tr[ 6 ] = m[ 2 ];\r\n\t\tr[ 7 ] = m[ 5 ];\r\n\t\tr[ 8 ] = m[ 8 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array ) {\r\n\r\n\t\tthis.elements.set( array );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tarray[ offset ] = te[ 0 ];\r\n\t\tarray[ offset + 1 ] = te[ 1 ];\r\n\t\tarray[ offset + 2 ] = te[ 2 ];\r\n\r\n\t\tarray[ offset + 3 ] = te[ 3 ];\r\n\t\tarray[ offset + 4 ] = te[ 4 ];\r\n\t\tarray[ offset + 5 ] = te[ 5 ];\r\n\r\n\t\tarray[ offset + 6 ] = te[ 6 ];\r\n\t\tarray[ offset + 7 ] = te[ 7 ];\r\n\t\tarray[ offset + 8 ]  = te[ 8 ];\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Matrix4.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author philogb / http://blog.thejit.org/\r\n * @author jordi_ros / http://plattsoft.com\r\n * @author D1plo1d / http://github.com/D1plo1d\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author timknip / http://www.floorplanner.com/\r\n * @author bhouston / http://clara.io\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.Matrix4 = function () {\r\n\r\n\tthis.elements = new Float32Array( [\r\n\r\n\t\t1, 0, 0, 0,\r\n\t\t0, 1, 0, 0,\r\n\t\t0, 0, 1, 0,\r\n\t\t0, 0, 0, 1\r\n\r\n\t] );\r\n\r\n\tif ( arguments.length > 0 ) {\r\n\r\n\t\tconsole.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Matrix4.prototype = {\r\n\r\n\tconstructor: THREE.Matrix4,\r\n\r\n\tset: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;\r\n\t\tte[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;\r\n\t\tte[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;\r\n\t\tte[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tidentity: function () {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0, 0,\r\n\t\t\t0, 1, 0, 0,\r\n\t\t\t0, 0, 1, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Matrix4().fromArray( this.elements );\r\n\r\n\t},\r\n\r\n\tcopy: function ( m ) {\r\n\r\n\t\tthis.elements.set( m.elements );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyPosition: function ( m ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar me = m.elements;\r\n\r\n\t\tte[ 12 ] = me[ 12 ];\r\n\t\tte[ 13 ] = me[ 13 ];\r\n\t\tte[ 14 ] = me[ 14 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\textractBasis: function ( xAxis, yAxis, zAxis ) {\r\n\r\n\t\txAxis.setFromMatrixColumn( this, 0 );\r\n\t\tyAxis.setFromMatrixColumn( this, 1 );\r\n\t\tzAxis.setFromMatrixColumn( this, 2 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeBasis: function ( xAxis, yAxis, zAxis ) {\r\n\r\n\t\tthis.set(\r\n\t\t\txAxis.x, yAxis.x, zAxis.x, 0,\r\n\t\t\txAxis.y, yAxis.y, zAxis.y, 0,\r\n\t\t\txAxis.z, yAxis.z, zAxis.z, 0,\r\n\t\t\t0,       0,       0,       1\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\textractRotation: function () {\r\n\r\n\t\tvar v1;\r\n\r\n\t\treturn function ( m ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\r\n\t\t\tvar te = this.elements;\r\n\t\t\tvar me = m.elements;\r\n\r\n\t\t\tvar scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();\r\n\t\t\tvar scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();\r\n\t\t\tvar scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();\r\n\r\n\t\t\tte[ 0 ] = me[ 0 ] * scaleX;\r\n\t\t\tte[ 1 ] = me[ 1 ] * scaleX;\r\n\t\t\tte[ 2 ] = me[ 2 ] * scaleX;\r\n\r\n\t\t\tte[ 4 ] = me[ 4 ] * scaleY;\r\n\t\t\tte[ 5 ] = me[ 5 ] * scaleY;\r\n\t\t\tte[ 6 ] = me[ 6 ] * scaleY;\r\n\r\n\t\t\tte[ 8 ] = me[ 8 ] * scaleZ;\r\n\t\t\tte[ 9 ] = me[ 9 ] * scaleZ;\r\n\t\t\tte[ 10 ] = me[ 10 ] * scaleZ;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmakeRotationFromEuler: function ( euler ) {\r\n\r\n\t\tif ( euler instanceof THREE.Euler === false ) {\r\n\r\n\t\t\tconsole.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );\r\n\r\n\t\t}\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar x = euler.x, y = euler.y, z = euler.z;\r\n\t\tvar a = Math.cos( x ), b = Math.sin( x );\r\n\t\tvar c = Math.cos( y ), d = Math.sin( y );\r\n\t\tvar e = Math.cos( z ), f = Math.sin( z );\r\n\r\n\t\tif ( euler.order === 'XYZ' ) {\r\n\r\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = - c * f;\r\n\t\t\tte[ 8 ] = d;\r\n\r\n\t\t\tte[ 1 ] = af + be * d;\r\n\t\t\tte[ 5 ] = ae - bf * d;\r\n\t\t\tte[ 9 ] = - b * c;\r\n\r\n\t\t\tte[ 2 ] = bf - ae * d;\r\n\t\t\tte[ 6 ] = be + af * d;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'YXZ' ) {\r\n\r\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n\t\t\tte[ 0 ] = ce + df * b;\r\n\t\t\tte[ 4 ] = de * b - cf;\r\n\t\t\tte[ 8 ] = a * d;\r\n\r\n\t\t\tte[ 1 ] = a * f;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = - b;\r\n\r\n\t\t\tte[ 2 ] = cf * b - de;\r\n\t\t\tte[ 6 ] = df + ce * b;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'ZXY' ) {\r\n\r\n\t\t\tvar ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n\r\n\t\t\tte[ 0 ] = ce - df * b;\r\n\t\t\tte[ 4 ] = - a * f;\r\n\t\t\tte[ 8 ] = de + cf * b;\r\n\r\n\t\t\tte[ 1 ] = cf + de * b;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = df - ce * b;\r\n\r\n\t\t\tte[ 2 ] = - a * d;\r\n\t\t\tte[ 6 ] = b;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'ZYX' ) {\r\n\r\n\t\t\tvar ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = be * d - af;\r\n\t\t\tte[ 8 ] = ae * d + bf;\r\n\r\n\t\t\tte[ 1 ] = c * f;\r\n\t\t\tte[ 5 ] = bf * d + ae;\r\n\t\t\tte[ 9 ] = af * d - be;\r\n\r\n\t\t\tte[ 2 ] = - d;\r\n\t\t\tte[ 6 ] = b * c;\r\n\t\t\tte[ 10 ] = a * c;\r\n\r\n\t\t} else if ( euler.order === 'YZX' ) {\r\n\r\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = bd - ac * f;\r\n\t\t\tte[ 8 ] = bc * f + ad;\r\n\r\n\t\t\tte[ 1 ] = f;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = - b * e;\r\n\r\n\t\t\tte[ 2 ] = - d * e;\r\n\t\t\tte[ 6 ] = ad * f + bc;\r\n\t\t\tte[ 10 ] = ac - bd * f;\r\n\r\n\t\t} else if ( euler.order === 'XZY' ) {\r\n\r\n\t\t\tvar ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n\r\n\t\t\tte[ 0 ] = c * e;\r\n\t\t\tte[ 4 ] = - f;\r\n\t\t\tte[ 8 ] = d * e;\r\n\r\n\t\t\tte[ 1 ] = ac * f + bd;\r\n\t\t\tte[ 5 ] = a * e;\r\n\t\t\tte[ 9 ] = ad * f - bc;\r\n\r\n\t\t\tte[ 2 ] = bc * f - ad;\r\n\t\t\tte[ 6 ] = b * e;\r\n\t\t\tte[ 10 ] = bd * f + ac;\r\n\r\n\t\t}\r\n\r\n\t\t// last column\r\n\t\tte[ 3 ] = 0;\r\n\t\tte[ 7 ] = 0;\r\n\t\tte[ 11 ] = 0;\r\n\r\n\t\t// bottom row\r\n\t\tte[ 12 ] = 0;\r\n\t\tte[ 13 ] = 0;\r\n\t\tte[ 14 ] = 0;\r\n\t\tte[ 15 ] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationFromQuaternion: function ( q ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar x = q.x, y = q.y, z = q.z, w = q.w;\r\n\t\tvar x2 = x + x, y2 = y + y, z2 = z + z;\r\n\t\tvar xx = x * x2, xy = x * y2, xz = x * z2;\r\n\t\tvar yy = y * y2, yz = y * z2, zz = z * z2;\r\n\t\tvar wx = w * x2, wy = w * y2, wz = w * z2;\r\n\r\n\t\tte[ 0 ] = 1 - ( yy + zz );\r\n\t\tte[ 4 ] = xy - wz;\r\n\t\tte[ 8 ] = xz + wy;\r\n\r\n\t\tte[ 1 ] = xy + wz;\r\n\t\tte[ 5 ] = 1 - ( xx + zz );\r\n\t\tte[ 9 ] = yz - wx;\r\n\r\n\t\tte[ 2 ] = xz - wy;\r\n\t\tte[ 6 ] = yz + wx;\r\n\t\tte[ 10 ] = 1 - ( xx + yy );\r\n\r\n\t\t// last column\r\n\t\tte[ 3 ] = 0;\r\n\t\tte[ 7 ] = 0;\r\n\t\tte[ 11 ] = 0;\r\n\r\n\t\t// bottom row\r\n\t\tte[ 12 ] = 0;\r\n\t\tte[ 13 ] = 0;\r\n\t\tte[ 14 ] = 0;\r\n\t\tte[ 15 ] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tlookAt: function () {\r\n\r\n\t\tvar x, y, z;\r\n\r\n\t\treturn function ( eye, target, up ) {\r\n\r\n\t\t\tif ( x === undefined ) {\r\n\r\n\t\t\t\tx = new THREE.Vector3();\r\n\t\t\t\ty = new THREE.Vector3();\r\n\t\t\t\tz = new THREE.Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tz.subVectors( eye, target ).normalize();\r\n\r\n\t\t\tif ( z.lengthSq() === 0 ) {\r\n\r\n\t\t\t\tz.z = 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tx.crossVectors( up, z ).normalize();\r\n\r\n\t\t\tif ( x.lengthSq() === 0 ) {\r\n\r\n\t\t\t\tz.z += 0.0001;\r\n\t\t\t\tx.crossVectors( up, z ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t\ty.crossVectors( z, x );\r\n\r\n\r\n\t\t\tte[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;\r\n\t\t\tte[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;\r\n\t\t\tte[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmultiply: function ( m, n ) {\r\n\r\n\t\tif ( n !== undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );\r\n\t\t\treturn this.multiplyMatrices( m, n );\r\n\r\n\t\t}\r\n\r\n\t\treturn this.multiplyMatrices( this, m );\r\n\r\n\t},\r\n\r\n\tpremultiply: function ( m ) {\r\n\r\n\t\treturn this.multiplyMatrices( m, this );\r\n\r\n\t},\r\n\r\n\tmultiplyMatrices: function ( a, b ) {\r\n\r\n\t\tvar ae = a.elements;\r\n\t\tvar be = b.elements;\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];\r\n\t\tvar a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];\r\n\t\tvar a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];\r\n\t\tvar a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];\r\n\r\n\t\tvar b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];\r\n\t\tvar b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];\r\n\t\tvar b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];\r\n\t\tvar b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];\r\n\r\n\t\tte[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\r\n\t\tte[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\r\n\t\tte[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\r\n\t\tte[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\r\n\r\n\t\tte[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\r\n\t\tte[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\r\n\t\tte[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\r\n\t\tte[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\r\n\r\n\t\tte[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\r\n\t\tte[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\r\n\t\tte[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\r\n\t\tte[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\r\n\r\n\t\tte[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\r\n\t\tte[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\r\n\t\tte[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\r\n\t\tte[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyToArray: function ( a, b, r ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tthis.multiplyMatrices( a, b );\r\n\r\n\t\tr[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];\r\n\t\tr[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];\r\n\t\tr[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];\r\n\t\tr[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmultiplyScalar: function ( s ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;\r\n\t\tte[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;\r\n\t\tte[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;\r\n\t\tte[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tapplyToVector3Array: function () {\r\n\r\n\t\tvar v1;\r\n\r\n\t\treturn function ( array, offset, length ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\tif ( length === undefined ) length = array.length;\r\n\r\n\t\t\tfor ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {\r\n\r\n\t\t\t\tv1.fromArray( array, j );\r\n\t\t\t\tv1.applyMatrix4( this );\r\n\t\t\t\tv1.toArray( array, j );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn array;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyToBuffer: function () {\r\n\r\n\t\tvar v1;\r\n\r\n\t\treturn function applyToBuffer( buffer, offset, length ) {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\t\tif ( offset === undefined ) offset = 0;\r\n\t\t\tif ( length === undefined ) length = buffer.length / buffer.itemSize;\r\n\r\n\t\t\tfor ( var i = 0, j = offset; i < length; i ++, j ++ ) {\r\n\r\n\t\t\t\tv1.x = buffer.getX( j );\r\n\t\t\t\tv1.y = buffer.getY( j );\r\n\t\t\t\tv1.z = buffer.getZ( j );\r\n\r\n\t\t\t\tv1.applyMatrix4( this );\r\n\r\n\t\t\t\tbuffer.setXYZ( v1.x, v1.y, v1.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn buffer;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tdeterminant: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];\r\n\t\tvar n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];\r\n\t\tvar n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];\r\n\t\tvar n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];\r\n\r\n\t\t//TODO: make this more efficient\r\n\t\t//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )\r\n\r\n\t\treturn (\r\n\t\t\tn41 * (\r\n\t\t\t\t+ n14 * n23 * n32\r\n\t\t\t\t - n13 * n24 * n32\r\n\t\t\t\t - n14 * n22 * n33\r\n\t\t\t\t + n12 * n24 * n33\r\n\t\t\t\t + n13 * n22 * n34\r\n\t\t\t\t - n12 * n23 * n34\r\n\t\t\t) +\r\n\t\t\tn42 * (\r\n\t\t\t\t+ n11 * n23 * n34\r\n\t\t\t\t - n11 * n24 * n33\r\n\t\t\t\t + n14 * n21 * n33\r\n\t\t\t\t - n13 * n21 * n34\r\n\t\t\t\t + n13 * n24 * n31\r\n\t\t\t\t - n14 * n23 * n31\r\n\t\t\t) +\r\n\t\t\tn43 * (\r\n\t\t\t\t+ n11 * n24 * n32\r\n\t\t\t\t - n11 * n22 * n34\r\n\t\t\t\t - n14 * n21 * n32\r\n\t\t\t\t + n12 * n21 * n34\r\n\t\t\t\t + n14 * n22 * n31\r\n\t\t\t\t - n12 * n24 * n31\r\n\t\t\t) +\r\n\t\t\tn44 * (\r\n\t\t\t\t- n13 * n22 * n31\r\n\t\t\t\t - n11 * n23 * n32\r\n\t\t\t\t + n11 * n22 * n33\r\n\t\t\t\t + n13 * n21 * n32\r\n\t\t\t\t - n12 * n21 * n33\r\n\t\t\t\t + n12 * n23 * n31\r\n\t\t\t)\r\n\r\n\t\t);\r\n\r\n\t},\r\n\r\n\ttranspose: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar tmp;\r\n\r\n\t\ttmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;\r\n\t\ttmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;\r\n\t\ttmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;\r\n\r\n\t\ttmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;\r\n\t\ttmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;\r\n\t\ttmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tflattenToArrayOffset: function ( array, offset ) {\r\n\r\n\t\tconsole.warn( \"THREE.Matrix3: .flattenToArrayOffset is deprecated \" +\r\n\t\t\t\t\"- just use .toArray instead.\" );\r\n\r\n\t\treturn this.toArray( array, offset );\r\n\r\n\t},\r\n\r\n\tgetPosition: function () {\r\n\r\n\t\tvar v1;\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tif ( v1 === undefined ) v1 = new THREE.Vector3();\r\n\t\t\tconsole.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );\r\n\r\n\t\t\treturn v1.setFromMatrixColumn( this, 3 );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tsetPosition: function ( v ) {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tte[ 12 ] = v.x;\r\n\t\tte[ 13 ] = v.y;\r\n\t\tte[ 14 ] = v.z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetInverse: function ( m, throwOnDegenerate ) {\r\n\r\n\t\t// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm\r\n\t\tvar te = this.elements,\r\n\t\t\tme = m.elements,\r\n\r\n\t\t\tn11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],\r\n\t\t\tn12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],\r\n\t\t\tn13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],\r\n\t\t\tn14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],\r\n\r\n\t\t\tt11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,\r\n\t\t\tt12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,\r\n\t\t\tt13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,\r\n\t\t\tt14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\r\n\r\n\t\tvar det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\r\n\r\n\t\tif ( det === 0 ) {\r\n\r\n\t\t\tvar msg = \"THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0\";\r\n\r\n\t\t\tif ( throwOnDegenerate || false ) {\r\n\r\n\t\t\t\tthrow new Error( msg );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.warn( msg );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this.identity();\r\n\r\n\t\t}\r\n\t\t\r\n\t\tvar detInv = 1 / det;\r\n\r\n\t\tte[ 0 ] = t11 * detInv;\r\n\t\tte[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;\r\n\t\tte[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;\r\n\t\tte[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;\r\n\r\n\t\tte[ 4 ] = t12 * detInv;\r\n\t\tte[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;\r\n\t\tte[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;\r\n\t\tte[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;\r\n\r\n\t\tte[ 8 ] = t13 * detInv;\r\n\t\tte[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;\r\n\t\tte[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;\r\n\t\tte[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;\r\n\r\n\t\tte[ 12 ] = t14 * detInv;\r\n\t\tte[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;\r\n\t\tte[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;\r\n\t\tte[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tscale: function ( v ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar x = v.x, y = v.y, z = v.z;\r\n\r\n\t\tte[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;\r\n\t\tte[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;\r\n\t\tte[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;\r\n\t\tte[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetMaxScaleOnAxis: function () {\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tvar scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];\r\n\t\tvar scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];\r\n\t\tvar scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];\r\n\r\n\t\treturn Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );\r\n\r\n\t},\r\n\r\n\tmakeTranslation: function ( x, y, z ) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0, 0, x,\r\n\t\t\t0, 1, 0, y,\r\n\t\t\t0, 0, 1, z,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationX: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t1, 0,  0, 0,\r\n\t\t\t0, c, - s, 0,\r\n\t\t\t0, s,  c, 0,\r\n\t\t\t0, 0,  0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationY: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\t c, 0, s, 0,\r\n\t\t\t 0, 1, 0, 0,\r\n\t\t\t- s, 0, c, 0,\r\n\t\t\t 0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationZ: function ( theta ) {\r\n\r\n\t\tvar c = Math.cos( theta ), s = Math.sin( theta );\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tc, - s, 0, 0,\r\n\t\t\ts,  c, 0, 0,\r\n\t\t\t0,  0, 1, 0,\r\n\t\t\t0,  0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakeRotationAxis: function ( axis, angle ) {\r\n\r\n\t\t// Based on http://www.gamedev.net/reference/articles/article1199.asp\r\n\r\n\t\tvar c = Math.cos( angle );\r\n\t\tvar s = Math.sin( angle );\r\n\t\tvar t = 1 - c;\r\n\t\tvar x = axis.x, y = axis.y, z = axis.z;\r\n\t\tvar tx = t * x, ty = t * y;\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\ttx * x + c, tx * y - s * z, tx * z + s * y, 0,\r\n\t\t\ttx * y + s * z, ty * y + c, ty * z - s * x, 0,\r\n\t\t\ttx * z - s * y, ty * z + s * x, t * z * z + c, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\t return this;\r\n\r\n\t},\r\n\r\n\tmakeScale: function ( x, y, z ) {\r\n\r\n\t\tthis.set(\r\n\r\n\t\t\tx, 0, 0, 0,\r\n\t\t\t0, y, 0, 0,\r\n\t\t\t0, 0, z, 0,\r\n\t\t\t0, 0, 0, 1\r\n\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcompose: function ( position, quaternion, scale ) {\r\n\r\n\t\tthis.makeRotationFromQuaternion( quaternion );\r\n\t\tthis.scale( scale );\r\n\t\tthis.setPosition( position );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdecompose: function () {\r\n\r\n\t\tvar vector, matrix;\r\n\r\n\t\treturn function ( position, quaternion, scale ) {\r\n\r\n\t\t\tif ( vector === undefined ) {\r\n\r\n\t\t\t\tvector = new THREE.Vector3();\r\n\t\t\t\tmatrix = new THREE.Matrix4();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar te = this.elements;\r\n\r\n\t\t\tvar sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();\r\n\t\t\tvar sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();\r\n\t\t\tvar sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();\r\n\r\n\t\t\t// if determine is negative, we need to invert one scale\r\n\t\t\tvar det = this.determinant();\r\n\t\t\tif ( det < 0 ) {\r\n\r\n\t\t\t\tsx = - sx;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tposition.x = te[ 12 ];\r\n\t\t\tposition.y = te[ 13 ];\r\n\t\t\tposition.z = te[ 14 ];\r\n\r\n\t\t\t// scale the rotation part\r\n\r\n\t\t\tmatrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()\r\n\r\n\t\t\tvar invSX = 1 / sx;\r\n\t\t\tvar invSY = 1 / sy;\r\n\t\t\tvar invSZ = 1 / sz;\r\n\r\n\t\t\tmatrix.elements[ 0 ] *= invSX;\r\n\t\t\tmatrix.elements[ 1 ] *= invSX;\r\n\t\t\tmatrix.elements[ 2 ] *= invSX;\r\n\r\n\t\t\tmatrix.elements[ 4 ] *= invSY;\r\n\t\t\tmatrix.elements[ 5 ] *= invSY;\r\n\t\t\tmatrix.elements[ 6 ] *= invSY;\r\n\r\n\t\t\tmatrix.elements[ 8 ] *= invSZ;\r\n\t\t\tmatrix.elements[ 9 ] *= invSZ;\r\n\t\t\tmatrix.elements[ 10 ] *= invSZ;\r\n\r\n\t\t\tquaternion.setFromRotationMatrix( matrix );\r\n\r\n\t\t\tscale.x = sx;\r\n\t\t\tscale.y = sy;\r\n\t\t\tscale.z = sz;\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmakeFrustum: function ( left, right, bottom, top, near, far ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar x = 2 * near / ( right - left );\r\n\t\tvar y = 2 * near / ( top - bottom );\r\n\r\n\t\tvar a = ( right + left ) / ( right - left );\r\n\t\tvar b = ( top + bottom ) / ( top - bottom );\r\n\t\tvar c = - ( far + near ) / ( far - near );\r\n\t\tvar d = - 2 * far * near / ( far - near );\r\n\r\n\t\tte[ 0 ] = x;\tte[ 4 ] = 0;\tte[ 8 ] = a;\tte[ 12 ] = 0;\r\n\t\tte[ 1 ] = 0;\tte[ 5 ] = y;\tte[ 9 ] = b;\tte[ 13 ] = 0;\r\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = c;\tte[ 14 ] = d;\r\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = - 1;\tte[ 15 ] = 0;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tmakePerspective: function ( fov, aspect, near, far ) {\r\n\r\n\t\tvar ymax = near * Math.tan( THREE.Math.DEG2RAD * fov * 0.5 );\r\n\t\tvar ymin = - ymax;\r\n\t\tvar xmin = ymin * aspect;\r\n\t\tvar xmax = ymax * aspect;\r\n\r\n\t\treturn this.makeFrustum( xmin, xmax, ymin, ymax, near, far );\r\n\r\n\t},\r\n\r\n\tmakeOrthographic: function ( left, right, top, bottom, near, far ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar w = 1.0 / ( right - left );\r\n\t\tvar h = 1.0 / ( top - bottom );\r\n\t\tvar p = 1.0 / ( far - near );\r\n\r\n\t\tvar x = ( right + left ) * w;\r\n\t\tvar y = ( top + bottom ) * h;\r\n\t\tvar z = ( far + near ) * p;\r\n\r\n\t\tte[ 0 ] = 2 * w;\tte[ 4 ] = 0;\tte[ 8 ] = 0;\tte[ 12 ] = - x;\r\n\t\tte[ 1 ] = 0;\tte[ 5 ] = 2 * h;\tte[ 9 ] = 0;\tte[ 13 ] = - y;\r\n\t\tte[ 2 ] = 0;\tte[ 6 ] = 0;\tte[ 10 ] = - 2 * p;\tte[ 14 ] = - z;\r\n\t\tte[ 3 ] = 0;\tte[ 7 ] = 0;\tte[ 11 ] = 0;\tte[ 15 ] = 1;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( matrix ) {\r\n\r\n\t\tvar te = this.elements;\r\n\t\tvar me = matrix.elements;\r\n\r\n\t\tfor ( var i = 0; i < 16; i ++ ) {\r\n\r\n\t\t\tif ( te[ i ] !== me[ i ] ) return false;\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tfromArray: function ( array ) {\r\n\r\n\t\tthis.elements.set( array );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoArray: function ( array, offset ) {\r\n\r\n\t\tif ( array === undefined ) array = [];\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tvar te = this.elements;\r\n\r\n\t\tarray[ offset ] = te[ 0 ];\r\n\t\tarray[ offset + 1 ] = te[ 1 ];\r\n\t\tarray[ offset + 2 ] = te[ 2 ];\r\n\t\tarray[ offset + 3 ] = te[ 3 ];\r\n\r\n\t\tarray[ offset + 4 ] = te[ 4 ];\r\n\t\tarray[ offset + 5 ] = te[ 5 ];\r\n\t\tarray[ offset + 6 ] = te[ 6 ];\r\n\t\tarray[ offset + 7 ] = te[ 7 ];\r\n\r\n\t\tarray[ offset + 8 ]  = te[ 8 ];\r\n\t\tarray[ offset + 9 ]  = te[ 9 ];\r\n\t\tarray[ offset + 10 ] = te[ 10 ];\r\n\t\tarray[ offset + 11 ] = te[ 11 ];\r\n\r\n\t\tarray[ offset + 12 ] = te[ 12 ];\r\n\t\tarray[ offset + 13 ] = te[ 13 ];\r\n\t\tarray[ offset + 14 ] = te[ 14 ];\r\n\t\tarray[ offset + 15 ] = te[ 15 ];\r\n\r\n\t\treturn array;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Ray.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Ray = function ( origin, direction ) {\r\n\r\n\tthis.origin = ( origin !== undefined ) ? origin : new THREE.Vector3();\r\n\tthis.direction = ( direction !== undefined ) ? direction : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Ray.prototype = {\r\n\r\n\tconstructor: THREE.Ray,\r\n\r\n\tset: function ( origin, direction ) {\r\n\r\n\t\tthis.origin.copy( origin );\r\n\t\tthis.direction.copy( direction );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( ray ) {\r\n\r\n\t\tthis.origin.copy( ray.origin );\r\n\t\tthis.direction.copy( ray.direction );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tat: function ( t, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\treturn result.copy( this.direction ).multiplyScalar( t ).add( this.origin );\r\n\r\n\t},\r\n\r\n\tlookAt: function ( v ) {\r\n\r\n\t\tthis.direction.copy( v ).sub( this.origin ).normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trecast: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( t ) {\r\n\r\n\t\t\tthis.origin.copy( this.at( t, v1 ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclosestPointToPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\tresult.subVectors( point, this.origin );\r\n\t\tvar directionDistance = result.dot( this.direction );\r\n\r\n\t\tif ( directionDistance < 0 ) {\r\n\r\n\t\t\treturn result.copy( this.origin );\r\n\r\n\t\t}\r\n\r\n\t\treturn result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function ( point ) {\r\n\r\n\t\treturn Math.sqrt( this.distanceSqToPoint( point ) );\r\n\r\n\t},\r\n\r\n\tdistanceSqToPoint: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( point ) {\r\n\r\n\t\t\tvar directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );\r\n\r\n\t\t\t// point behind the ray\r\n\r\n\t\t\tif ( directionDistance < 0 ) {\r\n\r\n\t\t\t\treturn this.origin.distanceToSquared( point );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tv1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );\r\n\r\n\t\t\treturn v1.distanceToSquared( point );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tdistanceSqToSegment: function () {\r\n\r\n\t\tvar segCenter = new THREE.Vector3();\r\n\t\tvar segDir = new THREE.Vector3();\r\n\t\tvar diff = new THREE.Vector3();\r\n\r\n\t\treturn function ( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {\r\n\r\n\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h\r\n\t\t\t// It returns the min distance between the ray and the segment\r\n\t\t\t// defined by v0 and v1\r\n\t\t\t// It can also set two optional targets :\r\n\t\t\t// - The closest point on the ray\r\n\t\t\t// - The closest point on the segment\r\n\r\n\t\t\tsegCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );\r\n\t\t\tsegDir.copy( v1 ).sub( v0 ).normalize();\r\n\t\t\tdiff.copy( this.origin ).sub( segCenter );\r\n\r\n\t\t\tvar segExtent = v0.distanceTo( v1 ) * 0.5;\r\n\t\t\tvar a01 = - this.direction.dot( segDir );\r\n\t\t\tvar b0 = diff.dot( this.direction );\r\n\t\t\tvar b1 = - diff.dot( segDir );\r\n\t\t\tvar c = diff.lengthSq();\r\n\t\t\tvar det = Math.abs( 1 - a01 * a01 );\r\n\t\t\tvar s0, s1, sqrDist, extDet;\r\n\r\n\t\t\tif ( det > 0 ) {\r\n\r\n\t\t\t\t// The ray and segment are not parallel.\r\n\r\n\t\t\t\ts0 = a01 * b1 - b0;\r\n\t\t\t\ts1 = a01 * b0 - b1;\r\n\t\t\t\textDet = segExtent * det;\r\n\r\n\t\t\t\tif ( s0 >= 0 ) {\r\n\r\n\t\t\t\t\tif ( s1 >= - extDet ) {\r\n\r\n\t\t\t\t\t\tif ( s1 <= extDet ) {\r\n\r\n\t\t\t\t\t\t\t// region 0\r\n\t\t\t\t\t\t\t// Minimum at interior points of ray and segment.\r\n\r\n\t\t\t\t\t\t\tvar invDet = 1 / det;\r\n\t\t\t\t\t\t\ts0 *= invDet;\r\n\t\t\t\t\t\t\ts1 *= invDet;\r\n\t\t\t\t\t\t\tsqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t// region 1\r\n\r\n\t\t\t\t\t\t\ts1 = segExtent;\r\n\t\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// region 5\r\n\r\n\t\t\t\t\t\ts1 = - segExtent;\r\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( s1 <= - extDet ) {\r\n\r\n\t\t\t\t\t\t// region 4\r\n\r\n\t\t\t\t\t\ts0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );\r\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t} else if ( s1 <= extDet ) {\r\n\r\n\t\t\t\t\t\t// region 3\r\n\r\n\t\t\t\t\t\ts0 = 0;\r\n\t\t\t\t\t\ts1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\tsqrDist = s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// region 2\r\n\r\n\t\t\t\t\t\ts0 = Math.max( 0, - ( a01 * segExtent + b0 ) );\r\n\t\t\t\t\t\ts1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );\r\n\t\t\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// Ray and segment are parallel.\r\n\r\n\t\t\t\ts1 = ( a01 > 0 ) ? - segExtent : segExtent;\r\n\t\t\t\ts0 = Math.max( 0, - ( a01 * s1 + b0 ) );\r\n\t\t\t\tsqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( optionalPointOnRay ) {\r\n\r\n\t\t\t\toptionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( optionalPointOnSegment ) {\r\n\r\n\t\t\t\toptionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn sqrDist;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersectSphere: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( sphere, optionalTarget ) {\r\n\r\n\t\t\tv1.subVectors( sphere.center, this.origin );\r\n\t\t\tvar tca = v1.dot( this.direction );\r\n\t\t\tvar d2 = v1.dot( v1 ) - tca * tca;\r\n\t\t\tvar radius2 = sphere.radius * sphere.radius;\r\n\r\n\t\t\tif ( d2 > radius2 ) return null;\r\n\r\n\t\t\tvar thc = Math.sqrt( radius2 - d2 );\r\n\r\n\t\t\t// t0 = first intersect point - entrance on front of sphere\r\n\t\t\tvar t0 = tca - thc;\r\n\r\n\t\t\t// t1 = second intersect point - exit point on back of sphere\r\n\t\t\tvar t1 = tca + thc;\r\n\r\n\t\t\t// test to see if both t0 and t1 are behind the ray - if so, return null\r\n\t\t\tif ( t0 < 0 && t1 < 0 ) return null;\r\n\r\n\t\t\t// test to see if t0 is behind the ray:\r\n\t\t\t// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,\r\n\t\t\t// in order to always return an intersect point that is in front of the ray.\r\n\t\t\tif ( t0 < 0 ) return this.at( t1, optionalTarget );\r\n\r\n\t\t\t// else t0 is in front of the ray, so return the first collision point scaled by t0\r\n\t\t\treturn this.at( t0, optionalTarget );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\treturn this.distanceToPoint( sphere.center ) <= sphere.radius;\r\n\r\n\t},\r\n\r\n\tdistanceToPlane: function ( plane ) {\r\n\r\n\t\tvar denominator = plane.normal.dot( this.direction );\r\n\r\n\t\tif ( denominator === 0 ) {\r\n\r\n\t\t\t// line is coplanar, return origin\r\n\t\t\tif ( plane.distanceToPoint( this.origin ) === 0 ) {\r\n\r\n\t\t\t\treturn 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Null is preferable to undefined since undefined means.... it is undefined\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tvar t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;\r\n\r\n\t\t// Return if the ray never intersects the plane\r\n\r\n\t\treturn t >= 0 ? t :  null;\r\n\r\n\t},\r\n\r\n\tintersectPlane: function ( plane, optionalTarget ) {\r\n\r\n\t\tvar t = this.distanceToPlane( plane );\r\n\r\n\t\tif ( t === null ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\treturn this.at( t, optionalTarget );\r\n\r\n\t},\r\n\r\n\r\n\r\n\tintersectsPlane: function ( plane ) {\r\n\r\n\t\t// check if the ray lies on the plane first\r\n\r\n\t\tvar distToPoint = plane.distanceToPoint( this.origin );\r\n\r\n\t\tif ( distToPoint === 0 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\tvar denominator = plane.normal.dot( this.direction );\r\n\r\n\t\tif ( denominator * distToPoint < 0 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\t// ray origin is behind the plane (and is pointing behind it)\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tintersectBox: function ( box, optionalTarget ) {\r\n\r\n\t\tvar tmin, tmax, tymin, tymax, tzmin, tzmax;\r\n\r\n\t\tvar invdirx = 1 / this.direction.x,\r\n\t\t\tinvdiry = 1 / this.direction.y,\r\n\t\t\tinvdirz = 1 / this.direction.z;\r\n\r\n\t\tvar origin = this.origin;\r\n\r\n\t\tif ( invdirx >= 0 ) {\r\n\r\n\t\t\ttmin = ( box.min.x - origin.x ) * invdirx;\r\n\t\t\ttmax = ( box.max.x - origin.x ) * invdirx;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttmin = ( box.max.x - origin.x ) * invdirx;\r\n\t\t\ttmax = ( box.min.x - origin.x ) * invdirx;\r\n\r\n\t\t}\r\n\r\n\t\tif ( invdiry >= 0 ) {\r\n\r\n\t\t\ttymin = ( box.min.y - origin.y ) * invdiry;\r\n\t\t\ttymax = ( box.max.y - origin.y ) * invdiry;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttymin = ( box.max.y - origin.y ) * invdiry;\r\n\t\t\ttymax = ( box.min.y - origin.y ) * invdiry;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;\r\n\r\n\t\t// These lines also handle the case where tmin or tmax is NaN\r\n\t\t// (result of 0 * Infinity). x !== x returns true if x is NaN\r\n\r\n\t\tif ( tymin > tmin || tmin !== tmin ) tmin = tymin;\r\n\r\n\t\tif ( tymax < tmax || tmax !== tmax ) tmax = tymax;\r\n\r\n\t\tif ( invdirz >= 0 ) {\r\n\r\n\t\t\ttzmin = ( box.min.z - origin.z ) * invdirz;\r\n\t\t\ttzmax = ( box.max.z - origin.z ) * invdirz;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttzmin = ( box.max.z - origin.z ) * invdirz;\r\n\t\t\ttzmax = ( box.min.z - origin.z ) * invdirz;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;\r\n\r\n\t\tif ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;\r\n\r\n\t\tif ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;\r\n\r\n\t\t//return point closest to the ray (positive side)\r\n\r\n\t\tif ( tmax < 0 ) return null;\r\n\r\n\t\treturn this.at( tmin >= 0 ? tmin : tmax, optionalTarget );\r\n\r\n\t},\r\n\r\n\tintersectsBox: ( function () {\r\n\r\n\t\tvar v = new THREE.Vector3();\r\n\r\n\t\treturn function ( box ) {\r\n\r\n\t\t\treturn this.intersectBox( box, v ) !== null;\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n\tintersectTriangle: function () {\r\n\r\n\t\t// Compute the offset origin, edges, and normal.\r\n\t\tvar diff = new THREE.Vector3();\r\n\t\tvar edge1 = new THREE.Vector3();\r\n\t\tvar edge2 = new THREE.Vector3();\r\n\t\tvar normal = new THREE.Vector3();\r\n\r\n\t\treturn function ( a, b, c, backfaceCulling, optionalTarget ) {\r\n\r\n\t\t\t// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\r\n\r\n\t\t\tedge1.subVectors( b, a );\r\n\t\t\tedge2.subVectors( c, a );\r\n\t\t\tnormal.crossVectors( edge1, edge2 );\r\n\r\n\t\t\t// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,\r\n\t\t\t// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by\r\n\t\t\t//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))\r\n\t\t\t//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))\r\n\t\t\t//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)\r\n\t\t\tvar DdN = this.direction.dot( normal );\r\n\t\t\tvar sign;\r\n\r\n\t\t\tif ( DdN > 0 ) {\r\n\r\n\t\t\t\tif ( backfaceCulling ) return null;\r\n\t\t\t\tsign = 1;\r\n\r\n\t\t\t} else if ( DdN < 0 ) {\r\n\r\n\t\t\t\tsign = - 1;\r\n\t\t\t\tDdN = - DdN;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdiff.subVectors( this.origin, a );\r\n\t\t\tvar DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );\r\n\r\n\t\t\t// b1 < 0, no intersection\r\n\t\t\tif ( DdQxE2 < 0 ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );\r\n\r\n\t\t\t// b2 < 0, no intersection\r\n\t\t\tif ( DdE1xQ < 0 ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// b1+b2 > 1, no intersection\r\n\t\t\tif ( DdQxE2 + DdE1xQ > DdN ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Line intersects triangle, check if ray does.\r\n\t\t\tvar QdN = - sign * diff.dot( normal );\r\n\r\n\t\t\t// t < 0, no intersection\r\n\t\t\tif ( QdN < 0 ) {\r\n\r\n\t\t\t\treturn null;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Ray intersects triangle.\r\n\t\t\treturn this.at( QdN / DdN, optionalTarget );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tapplyMatrix4: function ( matrix4 ) {\r\n\r\n\t\tthis.direction.add( this.origin ).applyMatrix4( matrix4 );\r\n\t\tthis.origin.applyMatrix4( matrix4 );\r\n\t\tthis.direction.sub( this.origin );\r\n\t\tthis.direction.normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( ray ) {\r\n\r\n\t\treturn ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Sphere.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Sphere = function ( center, radius ) {\r\n\r\n\tthis.center = ( center !== undefined ) ? center : new THREE.Vector3();\r\n\tthis.radius = ( radius !== undefined ) ? radius : 0;\r\n\r\n};\r\n\r\nTHREE.Sphere.prototype = {\r\n\r\n\tconstructor: THREE.Sphere,\r\n\r\n\tset: function ( center, radius ) {\r\n\r\n\t\tthis.center.copy( center );\r\n\t\tthis.radius = radius;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPoints: function () {\r\n\r\n\t\tvar box = new THREE.Box3();\r\n\r\n\t\treturn function ( points, optionalCenter ) {\r\n\r\n\t\t\tvar center = this.center;\r\n\r\n\t\t\tif ( optionalCenter !== undefined ) {\r\n\r\n\t\t\t\tcenter.copy( optionalCenter );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbox.setFromPoints( points ).center( center );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar maxRadiusSq = 0;\r\n\r\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.radius = Math.sqrt( maxRadiusSq );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( sphere ) {\r\n\r\n\t\tthis.center.copy( sphere.center );\r\n\t\tthis.radius = sphere.radius;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tempty: function () {\r\n\r\n\t\treturn ( this.radius <= 0 );\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\treturn ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function ( point ) {\r\n\r\n\t\treturn ( point.distanceTo( this.center ) - this.radius );\r\n\r\n\t},\r\n\r\n\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\tvar radiusSum = this.radius + sphere.radius;\r\n\r\n\t\treturn sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );\r\n\r\n\t},\r\n\r\n\tintersectsBox: function ( box ) {\r\n\r\n\t\treturn box.intersectsSphere( this );\r\n\r\n\t},\r\n\r\n\tintersectsPlane: function ( plane ) {\r\n\r\n\t\t// We use the following equation to compute the signed distance from\r\n\t\t// the center of the sphere to the plane.\r\n\t\t//\r\n\t\t// distance = q * n - d\r\n\t\t//\r\n\t\t// If this distance is greater than the radius of the sphere,\r\n\t\t// then there is no intersection.\r\n\r\n\t\treturn Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;\r\n\r\n\t},\r\n\r\n\tclampPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar deltaLengthSq = this.center.distanceToSquared( point );\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\tresult.copy( point );\r\n\r\n\t\tif ( deltaLengthSq > ( this.radius * this.radius ) ) {\r\n\r\n\t\t\tresult.sub( this.center ).normalize();\r\n\t\t\tresult.multiplyScalar( this.radius ).add( this.center );\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\tgetBoundingBox: function ( optionalTarget ) {\r\n\r\n\t\tvar box = optionalTarget || new THREE.Box3();\r\n\r\n\t\tbox.set( this.center, this.center );\r\n\t\tbox.expandByScalar( this.radius );\r\n\r\n\t\treturn box;\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function ( matrix ) {\r\n\r\n\t\tthis.center.applyMatrix4( matrix );\r\n\t\tthis.radius = this.radius * matrix.getMaxScaleOnAxis();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.center.add( offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( sphere ) {\r\n\r\n\t\treturn sphere.center.equals( this.center ) && ( sphere.radius === this.radius );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Frustum.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Frustum = function ( p0, p1, p2, p3, p4, p5 ) {\r\n\r\n\tthis.planes = [\r\n\r\n\t\t( p0 !== undefined ) ? p0 : new THREE.Plane(),\r\n\t\t( p1 !== undefined ) ? p1 : new THREE.Plane(),\r\n\t\t( p2 !== undefined ) ? p2 : new THREE.Plane(),\r\n\t\t( p3 !== undefined ) ? p3 : new THREE.Plane(),\r\n\t\t( p4 !== undefined ) ? p4 : new THREE.Plane(),\r\n\t\t( p5 !== undefined ) ? p5 : new THREE.Plane()\r\n\r\n\t];\r\n\r\n};\r\n\r\nTHREE.Frustum.prototype = {\r\n\r\n\tconstructor: THREE.Frustum,\r\n\r\n\tset: function ( p0, p1, p2, p3, p4, p5 ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\r\n\t\tplanes[ 0 ].copy( p0 );\r\n\t\tplanes[ 1 ].copy( p1 );\r\n\t\tplanes[ 2 ].copy( p2 );\r\n\t\tplanes[ 3 ].copy( p3 );\r\n\t\tplanes[ 4 ].copy( p4 );\r\n\t\tplanes[ 5 ].copy( p5 );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( frustum ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\r\n\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tplanes[ i ].copy( frustum.planes[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromMatrix: function ( m ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\t\tvar me = m.elements;\r\n\t\tvar me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];\r\n\t\tvar me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];\r\n\t\tvar me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];\r\n\t\tvar me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];\r\n\r\n\t\tplanes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();\r\n\t\tplanes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();\r\n\t\tplanes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();\r\n\t\tplanes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();\r\n\t\tplanes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();\r\n\t\tplanes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tintersectsObject: function () {\r\n\r\n\t\tvar sphere = new THREE.Sphere();\r\n\r\n\t\treturn function ( object ) {\r\n\r\n\t\t\tvar geometry = object.geometry;\r\n\r\n\t\t\tif ( geometry.boundingSphere === null )\r\n\t\t\t\tgeometry.computeBoundingSphere();\r\n\r\n\t\t\tsphere.copy( geometry.boundingSphere )\r\n\t\t\t\t.applyMatrix4( object.matrixWorld );\r\n\r\n\t\t\treturn this.intersectsSphere( sphere );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersectsSprite: function () {\r\n\r\n\t\tvar sphere = new THREE.Sphere();\r\n\r\n\t\treturn function ( sprite ) {\r\n\r\n\t\t\tsphere.center.set( 0, 0, 0 );\r\n\t\t\tsphere.radius = 0.7071067811865476;\r\n\t\t\tsphere.applyMatrix4( sprite.matrixWorld );\r\n\r\n\t\t\treturn this.intersectsSphere( sphere );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\t\tvar center = sphere.center;\r\n\t\tvar negRadius = - sphere.radius;\r\n\r\n\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tvar distance = planes[ i ].distanceToPoint( center );\r\n\r\n\t\t\tif ( distance < negRadius ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t},\r\n\r\n\tintersectsBox: function () {\r\n\r\n\t\tvar p1 = new THREE.Vector3(),\r\n\t\t\tp2 = new THREE.Vector3();\r\n\r\n\t\treturn function ( box ) {\r\n\r\n\t\t\tvar planes = this.planes;\r\n\r\n\t\t\tfor ( var i = 0; i < 6 ; i ++ ) {\r\n\r\n\t\t\t\tvar plane = planes[ i ];\r\n\r\n\t\t\t\tp1.x = plane.normal.x > 0 ? box.min.x : box.max.x;\r\n\t\t\t\tp2.x = plane.normal.x > 0 ? box.max.x : box.min.x;\r\n\t\t\t\tp1.y = plane.normal.y > 0 ? box.min.y : box.max.y;\r\n\t\t\t\tp2.y = plane.normal.y > 0 ? box.max.y : box.min.y;\r\n\t\t\t\tp1.z = plane.normal.z > 0 ? box.min.z : box.max.z;\r\n\t\t\t\tp2.z = plane.normal.z > 0 ? box.max.z : box.min.z;\r\n\r\n\t\t\t\tvar d1 = plane.distanceToPoint( p1 );\r\n\t\t\t\tvar d2 = plane.distanceToPoint( p2 );\r\n\r\n\t\t\t\t// if both outside plane, no intersection\r\n\r\n\t\t\t\tif ( d1 < 0 && d2 < 0 ) {\r\n\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\tvar planes = this.planes;\r\n\r\n\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\tif ( planes[ i ].distanceToPoint( point ) < 0 ) {\r\n\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Plane.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Plane = function ( normal, constant ) {\r\n\r\n\tthis.normal = ( normal !== undefined ) ? normal : new THREE.Vector3( 1, 0, 0 );\r\n\tthis.constant = ( constant !== undefined ) ? constant : 0;\r\n\r\n};\r\n\r\nTHREE.Plane.prototype = {\r\n\r\n\tconstructor: THREE.Plane,\r\n\r\n\tset: function ( normal, constant ) {\r\n\r\n\t\tthis.normal.copy( normal );\r\n\t\tthis.constant = constant;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetComponents: function ( x, y, z, w ) {\r\n\r\n\t\tthis.normal.set( x, y, z );\r\n\t\tthis.constant = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromNormalAndCoplanarPoint: function ( normal, point ) {\r\n\r\n\t\tthis.normal.copy( normal );\r\n\t\tthis.constant = - point.dot( this.normal );\t// must be this.normal, not normal, as this.normal is normalized\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromCoplanarPoints: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\r\n\t\treturn function ( a, b, c ) {\r\n\r\n\t\t\tvar normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();\r\n\r\n\t\t\t// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?\r\n\r\n\t\t\tthis.setFromNormalAndCoplanarPoint( normal, a );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( plane ) {\r\n\r\n\t\tthis.normal.copy( plane.normal );\r\n\t\tthis.constant = plane.constant;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\t// Note: will lead to a divide by zero if the plane is invalid.\r\n\r\n\t\tvar inverseNormalLength = 1.0 / this.normal.length();\r\n\t\tthis.normal.multiplyScalar( inverseNormalLength );\r\n\t\tthis.constant *= inverseNormalLength;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnegate: function () {\r\n\r\n\t\tthis.constant *= - 1;\r\n\t\tthis.normal.negate();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdistanceToPoint: function ( point ) {\r\n\r\n\t\treturn this.normal.dot( point ) + this.constant;\r\n\r\n\t},\r\n\r\n\tdistanceToSphere: function ( sphere ) {\r\n\r\n\t\treturn this.distanceToPoint( sphere.center ) - sphere.radius;\r\n\r\n\t},\r\n\r\n\tprojectPoint: function ( point, optionalTarget ) {\r\n\r\n\t\treturn this.orthoPoint( point, optionalTarget ).sub( point ).negate();\r\n\r\n\t},\r\n\r\n\torthoPoint: function ( point, optionalTarget ) {\r\n\r\n\t\tvar perpendicularMagnitude = this.distanceToPoint( point );\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );\r\n\r\n\t},\r\n\r\n\tintersectLine: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( line, optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\t\tvar direction = line.delta( v1 );\r\n\r\n\t\t\tvar denominator = this.normal.dot( direction );\r\n\r\n\t\t\tif ( denominator === 0 ) {\r\n\r\n\t\t\t\t// line is coplanar, return origin\r\n\t\t\t\tif ( this.distanceToPoint( line.start ) === 0 ) {\r\n\r\n\t\t\t\t\treturn result.copy( line.start );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Unsure if this is the correct method to handle this case.\r\n\t\t\t\treturn undefined;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;\r\n\r\n\t\t\tif ( t < 0 || t > 1 ) {\r\n\r\n\t\t\t\treturn undefined;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result.copy( direction ).multiplyScalar( t ).add( line.start );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tintersectsLine: function ( line ) {\r\n\r\n\t\t// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.\r\n\r\n\t\tvar startSign = this.distanceToPoint( line.start );\r\n\t\tvar endSign = this.distanceToPoint( line.end );\r\n\r\n\t\treturn ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );\r\n\r\n\t},\r\n\r\n\tintersectsBox: function ( box ) {\r\n\r\n\t\treturn box.intersectsPlane( this );\r\n\r\n\t},\r\n\r\n\tintersectsSphere: function ( sphere ) {\r\n\r\n\t\treturn sphere.intersectsPlane( this );\r\n\r\n\t},\r\n\r\n\tcoplanarPoint: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.copy( this.normal ).multiplyScalar( - this.constant );\r\n\r\n\t},\r\n\r\n\tapplyMatrix4: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar m1 = new THREE.Matrix3();\r\n\r\n\t\treturn function ( matrix, optionalNormalMatrix ) {\r\n\r\n\t\t\tvar referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );\r\n\r\n\t\t\t// transform normal based on theory here:\r\n\t\t\t// http://www.songho.ca/opengl/gl_normaltransform.html\r\n\t\t\tvar normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );\r\n\t\t\tvar normal = this.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t// recalculate constant (like in setFromNormalAndCoplanarPoint)\r\n\t\t\tthis.constant = - referencePoint.dot( normal );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function ( offset ) {\r\n\r\n\t\tthis.constant = this.constant - offset.dot( this.normal );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tequals: function ( plane ) {\r\n\r\n\t\treturn plane.normal.equals( this.normal ) && ( plane.constant === this.constant );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Spherical.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system\r\n *\r\n * The poles (phi) are at the positive and negative y axis.\r\n * The equator starts at positive z.\r\n */\r\n\r\nTHREE.Spherical = function ( radius, phi, theta ) {\r\n\r\n\tthis.radius = ( radius !== undefined ) ? radius : 1.0;\r\n\tthis.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole\r\n\tthis.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nTHREE.Spherical.prototype = {\r\n\r\n\tconstructor: THREE.Spherical,\r\n\r\n\tset: function ( radius, phi, theta ) {\r\n\r\n\t\tthis.radius = radius;\r\n\t\tthis.phi = phi;\r\n\t\tthis.theta = theta;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( other ) {\r\n\r\n\t\tthis.radius.copy( other.radius );\r\n\t\tthis.phi.copy( other.phi );\r\n\t\tthis.theta.copy( other.theta );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// restrict phi to be betwee EPS and PI-EPS\r\n\tmakeSafe: function() {\r\n\r\n\t\tvar EPS = 0.000001;\r\n\t\tthis.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromVector3: function( vec3 ) {\r\n\r\n\t\tthis.radius = vec3.length();\r\n\r\n\t\tif ( this.radius === 0 ) {\r\n\r\n\t\t\tthis.theta = 0;\r\n\t\t\tthis.phi = 0;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis\r\n\t\t\tthis.phi = Math.acos( THREE.Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n};\r\n\r\n// File:src/math/Math.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Math = {\r\n\r\n\tDEG2RAD: Math.PI / 180,\r\n\tRAD2DEG: 180 / Math.PI,\r\n\r\n\tgenerateUUID: function () {\r\n\r\n\t\t// http://www.broofa.com/Tools/Math.uuid.htm\r\n\r\n\t\tvar chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );\r\n\t\tvar uuid = new Array( 36 );\r\n\t\tvar rnd = 0, r;\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tfor ( var i = 0; i < 36; i ++ ) {\r\n\r\n\t\t\t\tif ( i === 8 || i === 13 || i === 18 || i === 23 ) {\r\n\r\n\t\t\t\t\tuuid[ i ] = '-';\r\n\r\n\t\t\t\t} else if ( i === 14 ) {\r\n\r\n\t\t\t\t\tuuid[ i ] = '4';\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;\r\n\t\t\t\t\tr = rnd & 0xf;\r\n\t\t\t\t\trnd = rnd >> 4;\r\n\t\t\t\t\tuuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn uuid.join( '' );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tclamp: function ( value, min, max ) {\r\n\r\n\t\treturn Math.max( min, Math.min( max, value ) );\r\n\r\n\t},\r\n\r\n\t// compute euclidian modulo of m % n\r\n\t// https://en.wikipedia.org/wiki/Modulo_operation\r\n\r\n\teuclideanModulo: function ( n, m ) {\r\n\r\n\t\treturn ( ( n % m ) + m ) % m;\r\n\r\n\t},\r\n\r\n\t// Linear mapping from range <a1, a2> to range <b1, b2>\r\n\r\n\tmapLinear: function ( x, a1, a2, b1, b2 ) {\r\n\r\n\t\treturn b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );\r\n\r\n\t},\r\n\r\n\t// http://en.wikipedia.org/wiki/Smoothstep\r\n\r\n\tsmoothstep: function ( x, min, max ) {\r\n\r\n\t\tif ( x <= min ) return 0;\r\n\t\tif ( x >= max ) return 1;\r\n\r\n\t\tx = ( x - min ) / ( max - min );\r\n\r\n\t\treturn x * x * ( 3 - 2 * x );\r\n\r\n\t},\r\n\r\n\tsmootherstep: function ( x, min, max ) {\r\n\r\n\t\tif ( x <= min ) return 0;\r\n\t\tif ( x >= max ) return 1;\r\n\r\n\t\tx = ( x - min ) / ( max - min );\r\n\r\n\t\treturn x * x * x * ( x * ( x * 6 - 15 ) + 10 );\r\n\r\n\t},\r\n\r\n\trandom16: function () {\r\n\r\n\t\tconsole.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );\r\n\t\treturn Math.random();\r\n\r\n\t},\r\n\r\n\t// Random integer from <low, high> interval\r\n\r\n\trandInt: function ( low, high ) {\r\n\r\n\t\treturn low + Math.floor( Math.random() * ( high - low + 1 ) );\r\n\r\n\t},\r\n\r\n\t// Random float from <low, high> interval\r\n\r\n\trandFloat: function ( low, high ) {\r\n\r\n\t\treturn low + Math.random() * ( high - low );\r\n\r\n\t},\r\n\r\n\t// Random float from <-range/2, range/2> interval\r\n\r\n\trandFloatSpread: function ( range ) {\r\n\r\n\t\treturn range * ( 0.5 - Math.random() );\r\n\r\n\t},\r\n\r\n\tdegToRad: function ( degrees ) {\r\n\r\n\t\treturn degrees * THREE.Math.DEG2RAD;\r\n\r\n\t},\r\n\r\n\tradToDeg: function ( radians ) {\r\n\r\n\t\treturn radians * THREE.Math.RAD2DEG;\r\n\r\n\t},\r\n\r\n\tisPowerOfTwo: function ( value ) {\r\n\r\n\t\treturn ( value & ( value - 1 ) ) === 0 && value !== 0;\r\n\r\n\t},\r\n\r\n\tnearestPowerOfTwo: function ( value ) {\r\n\r\n\t\treturn Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );\r\n\r\n\t},\r\n\r\n\tnextPowerOfTwo: function ( value ) {\r\n\r\n\t\tvalue --;\r\n\t\tvalue |= value >> 1;\r\n\t\tvalue |= value >> 2;\r\n\t\tvalue |= value >> 4;\r\n\t\tvalue |= value >> 8;\r\n\t\tvalue |= value >> 16;\r\n\t\tvalue ++;\r\n\r\n\t\treturn value;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Spline.js\r\n\r\n/**\r\n * Spline from Tween.js, slightly optimized (and trashed)\r\n * http://sole.github.com/tween.js/examples/05_spline.html\r\n *\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Spline = function ( points ) {\r\n\r\n\tthis.points = points;\r\n\r\n\tvar c = [], v3 = { x: 0, y: 0, z: 0 },\r\n\tpoint, intPoint, weight, w2, w3,\r\n\tpa, pb, pc, pd;\r\n\r\n\tthis.initFromArray = function ( a ) {\r\n\r\n\t\tthis.points = [];\r\n\r\n\t\tfor ( var i = 0; i < a.length; i ++ ) {\r\n\r\n\t\t\tthis.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.getPoint = function ( k ) {\r\n\r\n\t\tpoint = ( this.points.length - 1 ) * k;\r\n\t\tintPoint = Math.floor( point );\r\n\t\tweight = point - intPoint;\r\n\r\n\t\tc[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;\r\n\t\tc[ 1 ] = intPoint;\r\n\t\tc[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;\r\n\t\tc[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;\r\n\r\n\t\tpa = this.points[ c[ 0 ] ];\r\n\t\tpb = this.points[ c[ 1 ] ];\r\n\t\tpc = this.points[ c[ 2 ] ];\r\n\t\tpd = this.points[ c[ 3 ] ];\r\n\r\n\t\tw2 = weight * weight;\r\n\t\tw3 = weight * w2;\r\n\r\n\t\tv3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );\r\n\t\tv3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );\r\n\t\tv3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );\r\n\r\n\t\treturn v3;\r\n\r\n\t};\r\n\r\n\tthis.getControlPointsArray = function () {\r\n\r\n\t\tvar i, p, l = this.points.length,\r\n\t\t\tcoords = [];\r\n\r\n\t\tfor ( i = 0; i < l; i ++ ) {\r\n\r\n\t\t\tp = this.points[ i ];\r\n\t\t\tcoords[ i ] = [ p.x, p.y, p.z ];\r\n\r\n\t\t}\r\n\r\n\t\treturn coords;\r\n\r\n\t};\r\n\r\n\t// approximate length by summing linear segments\r\n\r\n\tthis.getLength = function ( nSubDivisions ) {\r\n\r\n\t\tvar i, index, nSamples, position,\r\n\t\t\tpoint = 0, intPoint = 0, oldIntPoint = 0,\r\n\t\t\toldPosition = new THREE.Vector3(),\r\n\t\t\ttmpVec = new THREE.Vector3(),\r\n\t\t\tchunkLengths = [],\r\n\t\t\ttotalLength = 0;\r\n\r\n\t\t// first point has 0 length\r\n\r\n\t\tchunkLengths[ 0 ] = 0;\r\n\r\n\t\tif ( ! nSubDivisions ) nSubDivisions = 100;\r\n\r\n\t\tnSamples = this.points.length * nSubDivisions;\r\n\r\n\t\toldPosition.copy( this.points[ 0 ] );\r\n\r\n\t\tfor ( i = 1; i < nSamples; i ++ ) {\r\n\r\n\t\t\tindex = i / nSamples;\r\n\r\n\t\t\tposition = this.getPoint( index );\r\n\t\t\ttmpVec.copy( position );\r\n\r\n\t\t\ttotalLength += tmpVec.distanceTo( oldPosition );\r\n\r\n\t\t\toldPosition.copy( position );\r\n\r\n\t\t\tpoint = ( this.points.length - 1 ) * index;\r\n\t\t\tintPoint = Math.floor( point );\r\n\r\n\t\t\tif ( intPoint !== oldIntPoint ) {\r\n\r\n\t\t\t\tchunkLengths[ intPoint ] = totalLength;\r\n\t\t\t\toldIntPoint = intPoint;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// last point ends with total length\r\n\r\n\t\tchunkLengths[ chunkLengths.length ] = totalLength;\r\n\r\n\t\treturn { chunks: chunkLengths, total: totalLength };\r\n\r\n\t};\r\n\r\n\tthis.reparametrizeByArcLength = function ( samplingCoef ) {\r\n\r\n\t\tvar i, j,\r\n\t\t\tindex, indexCurrent, indexNext,\r\n\t\t\trealDistance,\r\n\t\t\tsampling, position,\r\n\t\t\tnewpoints = [],\r\n\t\t\ttmpVec = new THREE.Vector3(),\r\n\t\t\tsl = this.getLength();\r\n\r\n\t\tnewpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );\r\n\r\n\t\tfor ( i = 1; i < this.points.length; i ++ ) {\r\n\r\n\t\t\t//tmpVec.copy( this.points[ i - 1 ] );\r\n\t\t\t//linearDistance = tmpVec.distanceTo( this.points[ i ] );\r\n\r\n\t\t\trealDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];\r\n\r\n\t\t\tsampling = Math.ceil( samplingCoef * realDistance / sl.total );\r\n\r\n\t\t\tindexCurrent = ( i - 1 ) / ( this.points.length - 1 );\r\n\t\t\tindexNext = i / ( this.points.length - 1 );\r\n\r\n\t\t\tfor ( j = 1; j < sampling - 1; j ++ ) {\r\n\r\n\t\t\t\tindex = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );\r\n\r\n\t\t\t\tposition = this.getPoint( index );\r\n\t\t\t\tnewpoints.push( tmpVec.copy( position ).clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnewpoints.push( tmpVec.copy( this.points[ i ] ).clone() );\r\n\r\n\t\t}\r\n\r\n\t\tthis.points = newpoints;\r\n\r\n\t};\r\n\r\n\t// Catmull-Rom\r\n\r\n\tfunction interpolate( p0, p1, p2, p3, t, t2, t3 ) {\r\n\r\n\t\tvar v0 = ( p2 - p0 ) * 0.5,\r\n\t\t\tv1 = ( p3 - p1 ) * 0.5;\r\n\r\n\t\treturn ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Triangle.js\r\n\r\n/**\r\n * @author bhouston / http://clara.io\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Triangle = function ( a, b, c ) {\r\n\r\n\tthis.a = ( a !== undefined ) ? a : new THREE.Vector3();\r\n\tthis.b = ( b !== undefined ) ? b : new THREE.Vector3();\r\n\tthis.c = ( c !== undefined ) ? c : new THREE.Vector3();\r\n\r\n};\r\n\r\nTHREE.Triangle.normal = function () {\r\n\r\n\tvar v0 = new THREE.Vector3();\r\n\r\n\treturn function ( a, b, c, optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\tresult.subVectors( c, b );\r\n\t\tv0.subVectors( a, b );\r\n\t\tresult.cross( v0 );\r\n\r\n\t\tvar resultLengthSq = result.lengthSq();\r\n\t\tif ( resultLengthSq > 0 ) {\r\n\r\n\t\t\treturn result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn result.set( 0, 0, 0 );\r\n\r\n\t};\r\n\r\n}();\r\n\r\n// static/instance method to calculate barycentric coordinates\r\n// based on: http://www.blackpawn.com/texts/pointinpoly/default.html\r\nTHREE.Triangle.barycoordFromPoint = function () {\r\n\r\n\tvar v0 = new THREE.Vector3();\r\n\tvar v1 = new THREE.Vector3();\r\n\tvar v2 = new THREE.Vector3();\r\n\r\n\treturn function ( point, a, b, c, optionalTarget ) {\r\n\r\n\t\tv0.subVectors( c, a );\r\n\t\tv1.subVectors( b, a );\r\n\t\tv2.subVectors( point, a );\r\n\r\n\t\tvar dot00 = v0.dot( v0 );\r\n\t\tvar dot01 = v0.dot( v1 );\r\n\t\tvar dot02 = v0.dot( v2 );\r\n\t\tvar dot11 = v1.dot( v1 );\r\n\t\tvar dot12 = v1.dot( v2 );\r\n\r\n\t\tvar denom = ( dot00 * dot11 - dot01 * dot01 );\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\t// collinear or singular triangle\r\n\t\tif ( denom === 0 ) {\r\n\r\n\t\t\t// arbitrary location outside of triangle?\r\n\t\t\t// not sure if this is the best idea, maybe should be returning undefined\r\n\t\t\treturn result.set( - 2, - 1, - 1 );\r\n\r\n\t\t}\r\n\r\n\t\tvar invDenom = 1 / denom;\r\n\t\tvar u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;\r\n\t\tvar v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;\r\n\r\n\t\t// barycentric coordinates must always sum to 1\r\n\t\treturn result.set( 1 - u - v, v, u );\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.Triangle.containsPoint = function () {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\r\n\treturn function ( point, a, b, c ) {\r\n\r\n\t\tvar result = THREE.Triangle.barycoordFromPoint( point, a, b, c, v1 );\r\n\r\n\t\treturn ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.Triangle.prototype = {\r\n\r\n\tconstructor: THREE.Triangle,\r\n\r\n\tset: function ( a, b, c ) {\r\n\r\n\t\tthis.a.copy( a );\r\n\t\tthis.b.copy( b );\r\n\t\tthis.c.copy( c );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetFromPointsAndIndices: function ( points, i0, i1, i2 ) {\r\n\r\n\t\tthis.a.copy( points[ i0 ] );\r\n\t\tthis.b.copy( points[ i1 ] );\r\n\t\tthis.c.copy( points[ i2 ] );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( triangle ) {\r\n\r\n\t\tthis.a.copy( triangle.a );\r\n\t\tthis.b.copy( triangle.b );\r\n\t\tthis.c.copy( triangle.c );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tarea: function () {\r\n\r\n\t\tvar v0 = new THREE.Vector3();\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tv0.subVectors( this.c, this.b );\r\n\t\t\tv1.subVectors( this.a, this.b );\r\n\r\n\t\t\treturn v0.cross( v1 ).length() * 0.5;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tmidpoint: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\treturn result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );\r\n\r\n\t},\r\n\r\n\tnormal: function ( optionalTarget ) {\r\n\r\n\t\treturn THREE.Triangle.normal( this.a, this.b, this.c, optionalTarget );\r\n\r\n\t},\r\n\r\n\tplane: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Plane();\r\n\r\n\t\treturn result.setFromCoplanarPoints( this.a, this.b, this.c );\r\n\r\n\t},\r\n\r\n\tbarycoordFromPoint: function ( point, optionalTarget ) {\r\n\r\n\t\treturn THREE.Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );\r\n\r\n\t},\r\n\r\n\tcontainsPoint: function ( point ) {\r\n\r\n\t\treturn THREE.Triangle.containsPoint( point, this.a, this.b, this.c );\r\n\r\n\t},\r\n\r\n\tclosestPointToPoint: function () {\r\n\r\n\t\tvar plane, edgeList, projectedPoint, closestPoint;\r\n\r\n\t\treturn function closestPointToPoint( point, optionalTarget ) {\r\n\r\n\t\t\tif ( plane === undefined ) {\r\n\r\n\t\t\t\tplane = new THREE.Plane();\r\n\t\t\t\tedgeList = [ new THREE.Line3(), new THREE.Line3(), new THREE.Line3() ];\r\n\t\t\t\tprojectedPoint = new THREE.Vector3();\r\n\t\t\t\tclosestPoint = new THREE.Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\t\t\tvar minDistance = Infinity;\r\n\r\n\t\t\t// project the point onto the plane of the triangle\r\n\r\n\t\t\tplane.setFromCoplanarPoints( this.a, this.b, this.c );\r\n\t\t\tplane.projectPoint( point, projectedPoint );\r\n\r\n\t\t\t// check if the projection lies within the triangle\r\n\r\n\t\t\tif( this.containsPoint( projectedPoint ) === true ) {\r\n\r\n\t\t\t\t// if so, this is the closest point\r\n\r\n\t\t\t\tresult.copy( projectedPoint );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices\r\n\r\n\t\t\t\tedgeList[ 0 ].set( this.a, this.b );\r\n\t\t\t\tedgeList[ 1 ].set( this.b, this.c );\r\n\t\t\t\tedgeList[ 2 ].set( this.c, this.a );\r\n\r\n\t\t\t\tfor( var i = 0; i < edgeList.length; i ++ ) {\r\n\r\n\t\t\t\t\tedgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );\r\n\r\n\t\t\t\t\tvar distance = projectedPoint.distanceToSquared( closestPoint );\r\n\r\n\t\t\t\t\tif( distance < minDistance ) {\r\n\r\n\t\t\t\t\t\tminDistance = distance;\r\n\r\n\t\t\t\t\t\tresult.copy( closestPoint );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tequals: function ( triangle ) {\r\n\r\n\t\treturn triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/math/Interpolant.js\r\n\r\n/**\r\n * Abstract base class of interpolants over parametric samples.\r\n *\r\n * The parameter domain is one dimensional, typically the time or a path\r\n * along a curve defined by the data.\r\n *\r\n * The sample values can have any dimensionality and derived classes may\r\n * apply special interpretations to the data.\r\n *\r\n * This class provides the interval seek in a Template Method, deferring\r\n * the actual interpolation to derived classes.\r\n *\r\n * Time complexity is O(1) for linear access crossing at most two points\r\n * and O(log N) for random access, where N is the number of positions.\r\n *\r\n * References:\r\n *\r\n * \t\thttp://www.oodesign.com/template-method-pattern.html\r\n *\r\n * @author tschw\r\n */\r\n\r\nTHREE.Interpolant = function(\r\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n\tthis.parameterPositions = parameterPositions;\r\n\tthis._cachedIndex = 0;\r\n\r\n\tthis.resultBuffer = resultBuffer !== undefined ?\r\n\t\t\tresultBuffer : new sampleValues.constructor( sampleSize );\r\n\tthis.sampleValues = sampleValues;\r\n\tthis.valueSize = sampleSize;\r\n\r\n};\r\n\r\nTHREE.Interpolant.prototype = {\r\n\r\n\tconstructor: THREE.Interpolant,\r\n\r\n\tevaluate: function( t ) {\r\n\r\n\t\tvar pp = this.parameterPositions,\r\n\t\t\ti1 = this._cachedIndex,\r\n\r\n\t\t\tt1 = pp[   i1   ],\r\n\t\t\tt0 = pp[ i1 - 1 ];\r\n\r\n\t\tvalidate_interval: {\r\n\r\n\t\t\tseek: {\r\n\r\n\t\t\t\tvar right;\r\n\r\n\t\t\t\tlinear_scan: {\r\n//- See http://jsperf.com/comparison-to-undefined/3\r\n//- slower code:\r\n//-\r\n//- \t\t\t\tif ( t >= t1 || t1 === undefined ) {\r\n\t\t\t\t\tforward_scan: if ( ! ( t < t1 ) ) {\r\n\r\n\t\t\t\t\t\tfor ( var giveUpAt = i1 + 2; ;) {\r\n\r\n\t\t\t\t\t\t\tif ( t1 === undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( t < t0 ) break forward_scan;\r\n\r\n\t\t\t\t\t\t\t\t// after end\r\n\r\n\t\t\t\t\t\t\t\ti1 = pp.length;\r\n\t\t\t\t\t\t\t\tthis._cachedIndex = i1;\r\n\t\t\t\t\t\t\t\treturn this.afterEnd_( i1 - 1, t, t0 );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\r\n\r\n\t\t\t\t\t\t\tt0 = t1;\r\n\t\t\t\t\t\t\tt1 = pp[ ++ i1 ];\r\n\r\n\t\t\t\t\t\t\tif ( t < t1 ) {\r\n\r\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\r\n\t\t\t\t\t\t\t\tbreak seek;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// prepare binary search on the right side of the index\r\n\t\t\t\t\t\tright = pp.length;\r\n\t\t\t\t\t\tbreak linear_scan;\r\n\r\n\t\t\t\t\t}\r\n\r\n//- slower code:\r\n//-\t\t\t\t\tif ( t < t0 || t0 === undefined ) {\r\n\t\t\t\t\tif ( ! ( t >= t0 ) ) {\r\n\r\n\t\t\t\t\t\t// looping?\r\n\r\n\t\t\t\t\t\tvar t1global = pp[ 1 ];\r\n\r\n\t\t\t\t\t\tif ( t < t1global ) {\r\n\r\n\t\t\t\t\t\t\ti1 = 2; // + 1, using the scan for the details\r\n\t\t\t\t\t\t\tt0 = t1global;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// linear reverse scan\r\n\r\n\t\t\t\t\t\tfor ( var giveUpAt = i1 - 2; ;) {\r\n\r\n\t\t\t\t\t\t\tif ( t0 === undefined ) {\r\n\r\n\t\t\t\t\t\t\t\t// before start\r\n\r\n\t\t\t\t\t\t\t\tthis._cachedIndex = 0;\r\n\t\t\t\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif ( i1 === giveUpAt ) break; // this loop\r\n\r\n\t\t\t\t\t\t\tt1 = t0;\r\n\t\t\t\t\t\t\tt0 = pp[ -- i1 - 1 ];\r\n\r\n\t\t\t\t\t\t\tif ( t >= t0 ) {\r\n\r\n\t\t\t\t\t\t\t\t// we have arrived at the sought interval\r\n\t\t\t\t\t\t\t\tbreak seek;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t// prepare binary search on the left side of the index\r\n\t\t\t\t\t\tright = i1;\r\n\t\t\t\t\t\ti1 = 0;\r\n\t\t\t\t\t\tbreak linear_scan;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// the interval is valid\r\n\r\n\t\t\t\t\tbreak validate_interval;\r\n\r\n\t\t\t\t} // linear scan\r\n\r\n\t\t\t\t// binary search\r\n\r\n\t\t\t\twhile ( i1 < right ) {\r\n\r\n\t\t\t\t\tvar mid = ( i1 + right ) >>> 1;\r\n\r\n\t\t\t\t\tif ( t < pp[ mid ] ) {\r\n\r\n\t\t\t\t\t\tright = mid;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\ti1 = mid + 1;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tt1 = pp[   i1   ];\r\n\t\t\t\tt0 = pp[ i1 - 1 ];\r\n\r\n\t\t\t\t// check boundary cases, again\r\n\r\n\t\t\t\tif ( t0 === undefined ) {\r\n\r\n\t\t\t\t\tthis._cachedIndex = 0;\r\n\t\t\t\t\treturn this.beforeStart_( 0, t, t1 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( t1 === undefined ) {\r\n\r\n\t\t\t\t\ti1 = pp.length;\r\n\t\t\t\t\tthis._cachedIndex = i1;\r\n\t\t\t\t\treturn this.afterEnd_( i1 - 1, t0, t );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} // seek\r\n\r\n\t\t\tthis._cachedIndex = i1;\r\n\r\n\t\t\tthis.intervalChanged_( i1, t0, t1 );\r\n\r\n\t\t} // validate_interval\r\n\r\n\t\treturn this.interpolate_( i1, t0, t, t1 );\r\n\r\n\t},\r\n\r\n\tsettings: null, // optional, subclass-specific settings structure\r\n\t// Note: The indirection allows central control of many interpolants.\r\n\r\n\t// --- Protected interface\r\n\r\n\tDefaultSettings_: {},\r\n\r\n\tgetSettings_: function() {\r\n\r\n\t\treturn this.settings || this.DefaultSettings_;\r\n\r\n\t},\r\n\r\n\tcopySampleValue_: function( index ) {\r\n\r\n\t\t// copies a sample value to the result buffer\r\n\r\n\t\tvar result = this.resultBuffer,\r\n\t\t\tvalues = this.sampleValues,\r\n\t\t\tstride = this.valueSize,\r\n\t\t\toffset = index * stride;\r\n\r\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\r\n\t\t\tresult[ i ] = values[ offset + i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\t// Template methods for derived classes:\r\n\r\n\tinterpolate_: function( i1, t0, t, t1 ) {\r\n\r\n\t\tthrow new Error( \"call to abstract method\" );\r\n\t\t// implementations shall return this.resultBuffer\r\n\r\n\t},\r\n\r\n\tintervalChanged_: function( i1, t0, t1 ) {\r\n\r\n\t\t// empty\r\n\r\n\t}\r\n\r\n};\r\n\r\nObject.assign( THREE.Interpolant.prototype, {\r\n\r\n\tbeforeStart_: //( 0, t, t0 ), returns this.resultBuffer\r\n\t\tTHREE.Interpolant.prototype.copySampleValue_,\r\n\r\n\tafterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer\r\n\t\tTHREE.Interpolant.prototype.copySampleValue_\r\n\r\n} );\r\n\r\n// File:src/math/interpolants/CubicInterpolant.js\r\n\r\n/**\r\n * Fast and simple cubic spline interpolant.\r\n *\r\n * It was derived from a Hermitian construction setting the first derivative\r\n * at each sample position to the linear slope between neighboring positions\r\n * over their parameter interval.\r\n *\r\n * @author tschw\r\n */\r\n\r\nTHREE.CubicInterpolant = function(\r\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n\tTHREE.Interpolant.call(\r\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\r\n\tthis._weightPrev = -0;\r\n\tthis._offsetPrev = -0;\r\n\tthis._weightNext = -0;\r\n\tthis._offsetNext = -0;\r\n\r\n};\r\n\r\nTHREE.CubicInterpolant.prototype =\r\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\r\n\r\n\tconstructor: THREE.CubicInterpolant,\r\n\r\n\tDefaultSettings_: {\r\n\r\n\t\tendingStart: \tTHREE.ZeroCurvatureEnding,\r\n\t\tendingEnd:\t\tTHREE.ZeroCurvatureEnding\r\n\r\n\t},\r\n\r\n\tintervalChanged_: function( i1, t0, t1 ) {\r\n\r\n\t\tvar pp = this.parameterPositions,\r\n\t\t\tiPrev = i1 - 2,\r\n\t\t\tiNext = i1 + 1,\r\n\r\n\t\t\ttPrev = pp[ iPrev ],\r\n\t\t\ttNext = pp[ iNext ];\r\n\r\n\t\tif ( tPrev === undefined ) {\r\n\r\n\t\t\tswitch ( this.getSettings_().endingStart ) {\r\n\r\n\t\t\t\tcase THREE.ZeroSlopeEnding:\r\n\r\n\t\t\t\t\t// f'(t0) = 0\r\n\t\t\t\t\tiPrev = i1;\r\n\t\t\t\t\ttPrev = 2 * t0 - t1;\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.WrapAroundEnding:\r\n\r\n\t\t\t\t\t// use the other end of the curve\r\n\t\t\t\t\tiPrev = pp.length - 2;\r\n\t\t\t\t\ttPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault: // ZeroCurvatureEnding\r\n\r\n\t\t\t\t\t// f''(t0) = 0 a.k.a. Natural Spline\r\n\t\t\t\t\tiPrev = i1;\r\n\t\t\t\t\ttPrev = t1;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( tNext === undefined ) {\r\n\r\n\t\t\tswitch ( this.getSettings_().endingEnd ) {\r\n\r\n\t\t\t\tcase THREE.ZeroSlopeEnding:\r\n\r\n\t\t\t\t\t// f'(tN) = 0\r\n\t\t\t\t\tiNext = i1;\r\n\t\t\t\t\ttNext = 2 * t1 - t0;\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.WrapAroundEnding:\r\n\r\n\t\t\t\t\t// use the other end of the curve\r\n\t\t\t\t\tiNext = 1;\r\n\t\t\t\t\ttNext = t1 + pp[ 1 ] - pp[ 0 ];\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault: // ZeroCurvatureEnding\r\n\r\n\t\t\t\t\t// f''(tN) = 0, a.k.a. Natural Spline\r\n\t\t\t\t\tiNext = i1 - 1;\r\n\t\t\t\t\ttNext = t0;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar halfDt = ( t1 - t0 ) * 0.5,\r\n\t\t\tstride = this.valueSize;\r\n\r\n\t\tthis._weightPrev = halfDt / ( t0 - tPrev );\r\n\t\tthis._weightNext = halfDt / ( tNext - t1 );\r\n\t\tthis._offsetPrev = iPrev * stride;\r\n\t\tthis._offsetNext = iNext * stride;\r\n\r\n\t},\r\n\r\n\tinterpolate_: function( i1, t0, t, t1 ) {\r\n\r\n\t\tvar result = this.resultBuffer,\r\n\t\t\tvalues = this.sampleValues,\r\n\t\t\tstride = this.valueSize,\r\n\r\n\t\t\to1 = i1 * stride,\t\to0 = o1 - stride,\r\n\t\t\toP = this._offsetPrev, \toN = this._offsetNext,\r\n\t\t\twP = this._weightPrev,\twN = this._weightNext,\r\n\r\n\t\t\tp = ( t - t0 ) / ( t1 - t0 ),\r\n\t\t\tpp = p * p,\r\n\t\t\tppp = pp * p;\r\n\r\n\t\t// evaluate polynomials\r\n\r\n\t\tvar sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;\r\n\t\tvar s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;\r\n\t\tvar s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;\r\n\t\tvar sN =       wN   * ppp   -           wN      * pp;\r\n\r\n\t\t// combine data linearly\r\n\r\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\r\n\t\t\tresult[ i ] =\r\n\t\t\t\t\tsP * values[ oP + i ] +\r\n\t\t\t\t\ts0 * values[ o0 + i ] +\r\n\t\t\t\t\ts1 * values[ o1 + i ] +\r\n\t\t\t\t\tsN * values[ oN + i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/math/interpolants/DiscreteInterpolant.js\r\n\r\n/**\r\n *\r\n * Interpolant that evaluates to the sample value at the position preceeding\r\n * the parameter.\r\n *\r\n * @author tschw\r\n */\r\n\r\nTHREE.DiscreteInterpolant = function(\r\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n\tTHREE.Interpolant.call(\r\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\r\n};\r\n\r\nTHREE.DiscreteInterpolant.prototype =\r\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\r\n\r\n\tconstructor: THREE.DiscreteInterpolant,\r\n\r\n\tinterpolate_: function( i1, t0, t, t1 ) {\r\n\r\n\t\treturn this.copySampleValue_( i1 - 1 );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/math/interpolants/LinearInterpolant.js\r\n\r\n/**\r\n * @author tschw\r\n */\r\n\r\nTHREE.LinearInterpolant = function(\r\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n\tTHREE.Interpolant.call(\r\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\r\n};\r\n\r\nTHREE.LinearInterpolant.prototype =\r\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\r\n\r\n\tconstructor: THREE.LinearInterpolant,\r\n\r\n\tinterpolate_: function( i1, t0, t, t1 ) {\r\n\r\n\t\tvar result = this.resultBuffer,\r\n\t\t\tvalues = this.sampleValues,\r\n\t\t\tstride = this.valueSize,\r\n\r\n\t\t\toffset1 = i1 * stride,\r\n\t\t\toffset0 = offset1 - stride,\r\n\r\n\t\t\tweight1 = ( t - t0 ) / ( t1 - t0 ),\r\n\t\t\tweight0 = 1 - weight1;\r\n\r\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\r\n\t\t\tresult[ i ] =\r\n\t\t\t\t\tvalues[ offset0 + i ] * weight0 +\r\n\t\t\t\t\tvalues[ offset1 + i ] * weight1;\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/math/interpolants/QuaternionLinearInterpolant.js\r\n\r\n/**\r\n * Spherical linear unit quaternion interpolant.\r\n *\r\n * @author tschw\r\n */\r\n\r\nTHREE.QuaternionLinearInterpolant = function(\r\n\t\tparameterPositions, sampleValues, sampleSize, resultBuffer ) {\r\n\r\n\tTHREE.Interpolant.call(\r\n\t\t\tthis, parameterPositions, sampleValues, sampleSize, resultBuffer );\r\n\r\n};\r\n\r\nTHREE.QuaternionLinearInterpolant.prototype =\r\n\t\tObject.assign( Object.create( THREE.Interpolant.prototype ), {\r\n\r\n\tconstructor: THREE.QuaternionLinearInterpolant,\r\n\r\n\tinterpolate_: function( i1, t0, t, t1 ) {\r\n\r\n\t\tvar result = this.resultBuffer,\r\n\t\t\tvalues = this.sampleValues,\r\n\t\t\tstride = this.valueSize,\r\n\r\n\t\t\toffset = i1 * stride,\r\n\r\n\t\t\talpha = ( t - t0 ) / ( t1 - t0 );\r\n\r\n\t\tfor ( var end = offset + stride; offset !== end; offset += 4 ) {\r\n\r\n\t\t\tTHREE.Quaternion.slerpFlat( result, 0,\r\n\t\t\t\t\tvalues, offset - stride, values, offset, alpha );\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/core/Clock.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Clock = function ( autoStart ) {\r\n\r\n\tthis.autoStart = ( autoStart !== undefined ) ? autoStart : true;\r\n\r\n\tthis.startTime = 0;\r\n\tthis.oldTime = 0;\r\n\tthis.elapsedTime = 0;\r\n\r\n\tthis.running = false;\r\n\r\n};\r\n\r\nTHREE.Clock.prototype = {\r\n\r\n\tconstructor: THREE.Clock,\r\n\r\n\tstart: function () {\r\n\r\n\t\tthis.startTime = ( performance || Date ).now();\r\n\r\n\t\tthis.oldTime = this.startTime;\r\n\t\tthis.running = true;\r\n\r\n\t},\r\n\r\n\tstop: function () {\r\n\r\n\t\tthis.getElapsedTime();\r\n\t\tthis.running = false;\r\n\r\n\t},\r\n\r\n\tgetElapsedTime: function () {\r\n\r\n\t\tthis.getDelta();\r\n\t\treturn this.elapsedTime;\r\n\r\n\t},\r\n\r\n\tgetDelta: function () {\r\n\r\n\t\tvar diff = 0;\r\n\r\n\t\tif ( this.autoStart && ! this.running ) {\r\n\r\n\t\t\tthis.start();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.running ) {\r\n\r\n\t\t\tvar newTime = ( performance || Date ).now();\r\n\r\n\t\t\tdiff = ( newTime - this.oldTime ) / 1000;\r\n\t\t\tthis.oldTime = newTime;\r\n\r\n\t\t\tthis.elapsedTime += diff;\r\n\r\n\t\t}\r\n\r\n\t\treturn diff;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/core/EventDispatcher.js\r\n\r\n/**\r\n * https://github.com/mrdoob/eventdispatcher.js/\r\n */\r\n\r\nTHREE.EventDispatcher = function () {};\r\n\r\nObject.assign( THREE.EventDispatcher.prototype, {\r\n\r\n\taddEventListener: function ( type, listener ) {\r\n\r\n\t\tif ( this._listeners === undefined ) this._listeners = {};\r\n\r\n\t\tvar listeners = this._listeners;\r\n\r\n\t\tif ( listeners[ type ] === undefined ) {\r\n\r\n\t\t\tlisteners[ type ] = [];\r\n\r\n\t\t}\r\n\r\n\t\tif ( listeners[ type ].indexOf( listener ) === - 1 ) {\r\n\r\n\t\t\tlisteners[ type ].push( listener );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\thasEventListener: function ( type, listener ) {\r\n\r\n\t\tif ( this._listeners === undefined ) return false;\r\n\r\n\t\tvar listeners = this._listeners;\r\n\r\n\t\tif ( listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1 ) {\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\tremoveEventListener: function ( type, listener ) {\r\n\r\n\t\tif ( this._listeners === undefined ) return;\r\n\r\n\t\tvar listeners = this._listeners;\r\n\t\tvar listenerArray = listeners[ type ];\r\n\r\n\t\tif ( listenerArray !== undefined ) {\r\n\r\n\t\t\tvar index = listenerArray.indexOf( listener );\r\n\r\n\t\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\t\tlistenerArray.splice( index, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tdispatchEvent: function ( event ) {\r\n\r\n\t\tif ( this._listeners === undefined ) return;\r\n\r\n\t\tvar listeners = this._listeners;\r\n\t\tvar listenerArray = listeners[ event.type ];\r\n\r\n\t\tif ( listenerArray !== undefined ) {\r\n\r\n\t\t\tevent.target = this;\r\n\r\n\t\t\tvar array = [], i = 0;\r\n\t\t\tvar length = listenerArray.length;\r\n\r\n\t\t\tfor ( i = 0; i < length; i ++ ) {\r\n\r\n\t\t\t\tarray[ i ] = listenerArray[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( i = 0; i < length; i ++ ) {\r\n\r\n\t\t\t\tarray[ i ].call( this, event );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/core/Layers.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Layers = function () {\r\n\r\n\tthis.mask = 1;\r\n\r\n};\r\n\r\nTHREE.Layers.prototype = {\r\n\r\n\tconstructor: THREE.Layers,\r\n\r\n\tset: function ( channel ) {\r\n\r\n\t\tthis.mask = 1 << channel;\r\n\r\n\t},\r\n\r\n\tenable: function ( channel ) {\r\n\r\n\t\tthis.mask |= 1 << channel;\r\n\r\n\t},\r\n\r\n\ttoggle: function ( channel ) {\r\n\r\n\t\tthis.mask ^= 1 << channel;\r\n\r\n\t},\r\n\r\n\tdisable: function ( channel ) {\r\n\r\n\t\tthis.mask &= ~ ( 1 << channel );\r\n\r\n\t},\r\n\r\n\ttest: function ( layers ) {\r\n\r\n\t\treturn ( this.mask & layers.mask ) !== 0;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/core/Raycaster.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author bhouston / http://clara.io/\r\n * @author stephomi / http://stephaneginier.com/\r\n */\r\n\r\n( function ( THREE ) {\r\n\r\n\tTHREE.Raycaster = function ( origin, direction, near, far ) {\r\n\r\n\t\tthis.ray = new THREE.Ray( origin, direction );\r\n\t\t// direction is assumed to be normalized (for accurate distance calculations)\r\n\r\n\t\tthis.near = near || 0;\r\n\t\tthis.far = far || Infinity;\r\n\r\n\t\tthis.params = {\r\n\t\t\tMesh: {},\r\n\t\t\tLine: {},\r\n\t\t\tLOD: {},\r\n\t\t\tPoints: { threshold: 1 },\r\n\t\t\tSprite: {}\r\n\t\t};\r\n\r\n\t\tObject.defineProperties( this.params, {\r\n\t\t\tPointCloud: {\r\n\t\t\t\tget: function () {\r\n\t\t\t\t\tconsole.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );\r\n\t\t\t\t\treturn this.Points;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t} );\r\n\r\n\t};\r\n\r\n\tfunction ascSort( a, b ) {\r\n\r\n\t\treturn a.distance - b.distance;\r\n\r\n\t}\r\n\r\n\tfunction intersectObject( object, raycaster, intersects, recursive ) {\r\n\r\n\t\tif ( object.visible === false ) return;\r\n\r\n\t\tobject.raycast( raycaster, intersects );\r\n\r\n\t\tif ( recursive === true ) {\r\n\r\n\t\t\tvar children = object.children;\r\n\r\n\t\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tintersectObject( children[ i ], raycaster, intersects, true );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tTHREE.Raycaster.prototype = {\r\n\r\n\t\tconstructor: THREE.Raycaster,\r\n\r\n\t\tlinePrecision: 1,\r\n\r\n\t\tset: function ( origin, direction ) {\r\n\r\n\t\t\t// direction is assumed to be normalized (for accurate distance calculations)\r\n\r\n\t\t\tthis.ray.set( origin, direction );\r\n\r\n\t\t},\r\n\r\n\t\tsetFromCamera: function ( coords, camera ) {\r\n\r\n\t\t\tif ( camera instanceof THREE.PerspectiveCamera ) {\r\n\r\n\t\t\t\tthis.ray.origin.setFromMatrixPosition( camera.matrixWorld );\r\n\t\t\t\tthis.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();\r\n\r\n\t\t\t} else if ( camera instanceof THREE.OrthographicCamera ) {\r\n\r\n\t\t\t\tthis.ray.origin.set( coords.x, coords.y, - 1 ).unproject( camera );\r\n\t\t\t\tthis.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tconsole.error( 'THREE.Raycaster: Unsupported camera type.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tintersectObject: function ( object, recursive ) {\r\n\r\n\t\t\tvar intersects = [];\r\n\r\n\t\t\tintersectObject( object, this, intersects, recursive );\r\n\r\n\t\t\tintersects.sort( ascSort );\r\n\r\n\t\t\treturn intersects;\r\n\r\n\t\t},\r\n\r\n\t\tintersectObjects: function ( objects, recursive ) {\r\n\r\n\t\t\tvar intersects = [];\r\n\r\n\t\t\tif ( Array.isArray( objects ) === false ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );\r\n\t\t\t\treturn intersects;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0, l = objects.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tintersectObject( objects[ i ], this, intersects, recursive );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tintersects.sort( ascSort );\r\n\r\n\t\t\treturn intersects;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}( THREE ) );\r\n\r\n// File:src/core/Object3D.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author elephantatwork / www.elephantatwork.ch\r\n */\r\n\r\nTHREE.Object3D = function () {\r\n\r\n\tObject.defineProperty( this, 'id', { value: THREE.Object3DIdCount ++ } );\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'Object3D';\r\n\r\n\tthis.parent = null;\r\n\tthis.children = [];\r\n\r\n\tthis.up = THREE.Object3D.DefaultUp.clone();\r\n\r\n\tvar position = new THREE.Vector3();\r\n\tvar rotation = new THREE.Euler();\r\n\tvar quaternion = new THREE.Quaternion();\r\n\tvar scale = new THREE.Vector3( 1, 1, 1 );\r\n\r\n\tfunction onRotationChange() {\r\n\r\n\t\tquaternion.setFromEuler( rotation, false );\r\n\r\n\t}\r\n\r\n\tfunction onQuaternionChange() {\r\n\r\n\t\trotation.setFromQuaternion( quaternion, undefined, false );\r\n\r\n\t}\r\n\r\n\trotation.onChange( onRotationChange );\r\n\tquaternion.onChange( onQuaternionChange );\r\n\r\n\tObject.defineProperties( this, {\r\n\t\tposition: {\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: position\r\n\t\t},\r\n\t\trotation: {\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: rotation\r\n\t\t},\r\n\t\tquaternion: {\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: quaternion\r\n\t\t},\r\n\t\tscale: {\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: scale\r\n\t\t},\r\n\t\tmodelViewMatrix: {\r\n\t\t\tvalue: new THREE.Matrix4()\r\n\t\t},\r\n\t\tnormalMatrix: {\r\n\t\t\tvalue: new THREE.Matrix3()\r\n\t\t}\r\n\t} );\r\n\r\n\tthis.matrix = new THREE.Matrix4();\r\n\tthis.matrixWorld = new THREE.Matrix4();\r\n\r\n\tthis.matrixAutoUpdate = THREE.Object3D.DefaultMatrixAutoUpdate;\r\n\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\tthis.layers = new THREE.Layers();\r\n\tthis.visible = true;\r\n\r\n\tthis.castShadow = false;\r\n\tthis.receiveShadow = false;\r\n\r\n\tthis.frustumCulled = true;\r\n\tthis.renderOrder = 0;\r\n\r\n\tthis.userData = {};\r\n\r\n};\r\n\r\nTHREE.Object3D.DefaultUp = new THREE.Vector3( 0, 1, 0 );\r\nTHREE.Object3D.DefaultMatrixAutoUpdate = true;\r\n\r\nObject.assign( THREE.Object3D.prototype, THREE.EventDispatcher.prototype, {\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tthis.matrix.multiplyMatrices( matrix, this.matrix );\r\n\r\n\t\tthis.matrix.decompose( this.position, this.quaternion, this.scale );\r\n\r\n\t},\r\n\r\n\tsetRotationFromAxisAngle: function ( axis, angle ) {\r\n\r\n\t\t// assumes axis is normalized\r\n\r\n\t\tthis.quaternion.setFromAxisAngle( axis, angle );\r\n\r\n\t},\r\n\r\n\tsetRotationFromEuler: function ( euler ) {\r\n\r\n\t\tthis.quaternion.setFromEuler( euler, true );\r\n\r\n\t},\r\n\r\n\tsetRotationFromMatrix: function ( m ) {\r\n\r\n\t\t// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\r\n\r\n\t\tthis.quaternion.setFromRotationMatrix( m );\r\n\r\n\t},\r\n\r\n\tsetRotationFromQuaternion: function ( q ) {\r\n\r\n\t\t// assumes q is normalized\r\n\r\n\t\tthis.quaternion.copy( q );\r\n\r\n\t},\r\n\r\n\trotateOnAxis: function () {\r\n\r\n\t\t// rotate object on axis in object space\r\n\t\t// axis is assumed to be normalized\r\n\r\n\t\tvar q1 = new THREE.Quaternion();\r\n\r\n\t\treturn function ( axis, angle ) {\r\n\r\n\t\t\tq1.setFromAxisAngle( axis, angle );\r\n\r\n\t\t\tthis.quaternion.multiply( q1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateX: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\r\n\r\n\t\treturn function ( angle ) {\r\n\r\n\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateY: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\r\n\r\n\t\treturn function ( angle ) {\r\n\r\n\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateZ: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\r\n\r\n\t\treturn function ( angle ) {\r\n\r\n\t\t\treturn this.rotateOnAxis( v1, angle );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateOnAxis: function () {\r\n\r\n\t\t// translate object by distance along axis in object space\r\n\t\t// axis is assumed to be normalized\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\r\n\t\treturn function ( axis, distance ) {\r\n\r\n\t\t\tv1.copy( axis ).applyQuaternion( this.quaternion );\r\n\r\n\t\t\tthis.position.add( v1.multiplyScalar( distance ) );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateX: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 1, 0, 0 );\r\n\r\n\t\treturn function ( distance ) {\r\n\r\n\t\t\treturn this.translateOnAxis( v1, distance );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateY: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 0, 1, 0 );\r\n\r\n\t\treturn function ( distance ) {\r\n\r\n\t\t\treturn this.translateOnAxis( v1, distance );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslateZ: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3( 0, 0, 1 );\r\n\r\n\t\treturn function ( distance ) {\r\n\r\n\t\t\treturn this.translateOnAxis( v1, distance );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlocalToWorld: function ( vector ) {\r\n\r\n\t\treturn vector.applyMatrix4( this.matrixWorld );\r\n\r\n\t},\r\n\r\n\tworldToLocal: function () {\r\n\r\n\t\tvar m1 = new THREE.Matrix4();\r\n\r\n\t\treturn function ( vector ) {\r\n\r\n\t\t\treturn vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlookAt: function () {\r\n\r\n\t\t// This routine does not support objects with rotated and/or translated parent(s)\r\n\r\n\t\tvar m1 = new THREE.Matrix4();\r\n\r\n\t\treturn function ( vector ) {\r\n\r\n\t\t\tm1.lookAt( vector, this.position, this.up );\r\n\r\n\t\t\tthis.quaternion.setFromRotationMatrix( m1 );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tadd: function ( object ) {\r\n\r\n\t\tif ( arguments.length > 1 ) {\r\n\r\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\r\n\r\n\t\t\t\tthis.add( arguments[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tif ( object === this ) {\r\n\r\n\t\t\tconsole.error( \"THREE.Object3D.add: object can't be added as a child of itself.\", object );\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tif ( object instanceof THREE.Object3D ) {\r\n\r\n\t\t\tif ( object.parent !== null ) {\r\n\r\n\t\t\t\tobject.parent.remove( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.parent = this;\r\n\t\t\tobject.dispatchEvent( { type: 'added' } );\r\n\r\n\t\t\tthis.children.push( object );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.error( \"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tremove: function ( object ) {\r\n\r\n\t\tif ( arguments.length > 1 ) {\r\n\r\n\t\t\tfor ( var i = 0; i < arguments.length; i ++ ) {\r\n\r\n\t\t\t\tthis.remove( arguments[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar index = this.children.indexOf( object );\r\n\r\n\t\tif ( index !== - 1 ) {\r\n\r\n\t\t\tobject.parent = null;\r\n\r\n\t\t\tobject.dispatchEvent( { type: 'removed' } );\r\n\r\n\t\t\tthis.children.splice( index, 1 );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetObjectById: function ( id ) {\r\n\r\n\t\treturn this.getObjectByProperty( 'id', id );\r\n\r\n\t},\r\n\r\n\tgetObjectByName: function ( name ) {\r\n\r\n\t\treturn this.getObjectByProperty( 'name', name );\r\n\r\n\t},\r\n\r\n\tgetObjectByProperty: function ( name, value ) {\r\n\r\n\t\tif ( this[ name ] === value ) return this;\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar child = this.children[ i ];\r\n\t\t\tvar object = child.getObjectByProperty( name, value );\r\n\r\n\t\t\tif ( object !== undefined ) {\r\n\r\n\t\t\t\treturn object;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn undefined;\r\n\r\n\t},\r\n\r\n\tgetWorldPosition: function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\treturn result.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t},\r\n\r\n\tgetWorldQuaternion: function () {\r\n\r\n\t\tvar position = new THREE.Vector3();\r\n\t\tvar scale = new THREE.Vector3();\r\n\r\n\t\treturn function ( optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Quaternion();\r\n\r\n\t\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\t\tthis.matrixWorld.decompose( position, result, scale );\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetWorldRotation: function () {\r\n\r\n\t\tvar quaternion = new THREE.Quaternion();\r\n\r\n\t\treturn function ( optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Euler();\r\n\r\n\t\t\tthis.getWorldQuaternion( quaternion );\r\n\r\n\t\t\treturn result.setFromQuaternion( quaternion, this.rotation.order, false );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetWorldScale: function () {\r\n\r\n\t\tvar position = new THREE.Vector3();\r\n\t\tvar quaternion = new THREE.Quaternion();\r\n\r\n\t\treturn function ( optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\t\tthis.matrixWorld.decompose( position, quaternion, result );\r\n\r\n\t\t\treturn result;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tgetWorldDirection: function () {\r\n\r\n\t\tvar quaternion = new THREE.Quaternion();\r\n\r\n\t\treturn function ( optionalTarget ) {\r\n\r\n\t\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\t\tthis.getWorldQuaternion( quaternion );\r\n\r\n\t\t\treturn result.set( 0, 0, 1 ).applyQuaternion( quaternion );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\traycast: function () {},\r\n\r\n\ttraverse: function ( callback ) {\r\n\r\n\t\tcallback( this );\r\n\r\n\t\tvar children = this.children;\r\n\r\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tchildren[ i ].traverse( callback );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttraverseVisible: function ( callback ) {\r\n\r\n\t\tif ( this.visible === false ) return;\r\n\r\n\t\tcallback( this );\r\n\r\n\t\tvar children = this.children;\r\n\r\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tchildren[ i ].traverseVisible( callback );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttraverseAncestors: function ( callback ) {\r\n\r\n\t\tvar parent = this.parent;\r\n\r\n\t\tif ( parent !== null ) {\r\n\r\n\t\t\tcallback( parent );\r\n\r\n\t\t\tparent.traverseAncestors( callback );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tupdateMatrix: function () {\r\n\r\n\t\tthis.matrix.compose( this.position, this.quaternion, this.scale );\r\n\r\n\t\tthis.matrixWorldNeedsUpdate = true;\r\n\r\n\t},\r\n\r\n\tupdateMatrixWorld: function ( force ) {\r\n\r\n\t\tif ( this.matrixAutoUpdate === true ) this.updateMatrix();\r\n\r\n\t\tif ( this.matrixWorldNeedsUpdate === true || force === true ) {\r\n\r\n\t\t\tif ( this.parent === null ) {\r\n\r\n\t\t\t\tthis.matrixWorld.copy( this.matrix );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.matrixWorldNeedsUpdate = false;\r\n\r\n\t\t\tforce = true;\r\n\r\n\t\t}\r\n\r\n\t\t// update children\r\n\r\n\t\tfor ( var i = 0, l = this.children.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis.children[ i ].updateMatrixWorld( force );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttoJSON: function ( meta ) {\r\n\r\n\t\t// meta is '' when called from JSON.stringify\r\n\t\tvar isRootObject = ( meta === undefined || meta === '' );\r\n\r\n\t\tvar output = {};\r\n\r\n\t\t// meta is a hash used to collect geometries, materials.\r\n\t\t// not providing it implies that this is the root object\r\n\t\t// being serialized.\r\n\t\tif ( isRootObject ) {\r\n\r\n\t\t\t// initialize meta obj\r\n\t\t\tmeta = {\r\n\t\t\t\tgeometries: {},\r\n\t\t\t\tmaterials: {},\r\n\t\t\t\ttextures: {},\r\n\t\t\t\timages: {}\r\n\t\t\t};\r\n\r\n\t\t\toutput.metadata = {\r\n\t\t\t\tversion: 4.4,\r\n\t\t\t\ttype: 'Object',\r\n\t\t\t\tgenerator: 'Object3D.toJSON'\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\t// standard Object3D serialization\r\n\r\n\t\tvar object = {};\r\n\r\n\t\tobject.uuid = this.uuid;\r\n\t\tobject.type = this.type;\r\n\r\n\t\tif ( this.name !== '' ) object.name = this.name;\r\n\t\tif ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;\r\n\t\tif ( this.castShadow === true ) object.castShadow = true;\r\n\t\tif ( this.receiveShadow === true ) object.receiveShadow = true;\r\n\t\tif ( this.visible === false ) object.visible = false;\r\n\r\n\t\tobject.matrix = this.matrix.toArray();\r\n\r\n\t\t//\r\n\r\n\t\tif ( this.geometry !== undefined ) {\r\n\r\n\t\t\tif ( meta.geometries[ this.geometry.uuid ] === undefined ) {\r\n\r\n\t\t\t\tmeta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.geometry = this.geometry.uuid;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.material !== undefined ) {\r\n\r\n\t\t\tif ( meta.materials[ this.material.uuid ] === undefined ) {\r\n\r\n\t\t\t\tmeta.materials[ this.material.uuid ] = this.material.toJSON( meta );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.material = this.material.uuid;\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( this.children.length > 0 ) {\r\n\r\n\t\t\tobject.children = [];\r\n\r\n\t\t\tfor ( var i = 0; i < this.children.length; i ++ ) {\r\n\r\n\t\t\t\tobject.children.push( this.children[ i ].toJSON( meta ).object );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( isRootObject ) {\r\n\r\n\t\t\tvar geometries = extractFromCache( meta.geometries );\r\n\t\t\tvar materials = extractFromCache( meta.materials );\r\n\t\t\tvar textures = extractFromCache( meta.textures );\r\n\t\t\tvar images = extractFromCache( meta.images );\r\n\r\n\t\t\tif ( geometries.length > 0 ) output.geometries = geometries;\r\n\t\t\tif ( materials.length > 0 ) output.materials = materials;\r\n\t\t\tif ( textures.length > 0 ) output.textures = textures;\r\n\t\t\tif ( images.length > 0 ) output.images = images;\r\n\r\n\t\t}\r\n\r\n\t\toutput.object = object;\r\n\r\n\t\treturn output;\r\n\r\n\t\t// extract data from the cache hash\r\n\t\t// remove metadata on each item\r\n\t\t// and return as array\r\n\t\tfunction extractFromCache ( cache ) {\r\n\r\n\t\t\tvar values = [];\r\n\t\t\tfor ( var key in cache ) {\r\n\r\n\t\t\t\tvar data = cache[ key ];\r\n\t\t\t\tdelete data.metadata;\r\n\t\t\t\tvalues.push( data );\r\n\r\n\t\t\t}\r\n\t\t\treturn values;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function ( recursive ) {\r\n\r\n\t\treturn new this.constructor().copy( this, recursive );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source, recursive ) {\r\n\r\n\t\tif ( recursive === undefined ) recursive = true;\r\n\r\n\t\tthis.name = source.name;\r\n\r\n\t\tthis.up.copy( source.up );\r\n\r\n\t\tthis.position.copy( source.position );\r\n\t\tthis.quaternion.copy( source.quaternion );\r\n\t\tthis.scale.copy( source.scale );\r\n\r\n\t\tthis.matrix.copy( source.matrix );\r\n\t\tthis.matrixWorld.copy( source.matrixWorld );\r\n\r\n\t\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\r\n\t\tthis.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\r\n\r\n\t\tthis.visible = source.visible;\r\n\r\n\t\tthis.castShadow = source.castShadow;\r\n\t\tthis.receiveShadow = source.receiveShadow;\r\n\r\n\t\tthis.frustumCulled = source.frustumCulled;\r\n\t\tthis.renderOrder = source.renderOrder;\r\n\r\n\t\tthis.userData = JSON.parse( JSON.stringify( source.userData ) );\r\n\r\n\t\tif ( recursive === true ) {\r\n\r\n\t\t\tfor ( var i = 0; i < source.children.length; i ++ ) {\r\n\r\n\t\t\t\tvar child = source.children[ i ];\r\n\t\t\t\tthis.add( child.clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\r\n\r\nTHREE.Object3DIdCount = 0;\r\n\r\n// File:src/core/Face3.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Face3 = function ( a, b, c, normal, color, materialIndex ) {\r\n\r\n\tthis.a = a;\r\n\tthis.b = b;\r\n\tthis.c = c;\r\n\r\n\tthis.normal = normal instanceof THREE.Vector3 ? normal : new THREE.Vector3();\r\n\tthis.vertexNormals = Array.isArray( normal ) ? normal : [];\r\n\r\n\tthis.color = color instanceof THREE.Color ? color : new THREE.Color();\r\n\tthis.vertexColors = Array.isArray( color ) ? color : [];\r\n\r\n\tthis.materialIndex = materialIndex !== undefined ? materialIndex : 0;\r\n\r\n};\r\n\r\nTHREE.Face3.prototype = {\r\n\r\n\tconstructor: THREE.Face3,\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.a = source.a;\r\n\t\tthis.b = source.b;\r\n\t\tthis.c = source.c;\r\n\r\n\t\tthis.normal.copy( source.normal );\r\n\t\tthis.color.copy( source.color );\r\n\r\n\t\tthis.materialIndex = source.materialIndex;\r\n\r\n\t\tfor ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.vertexNormals[ i ] = source.vertexNormals[ i ].clone();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.vertexColors[ i ] = source.vertexColors[ i ].clone();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/core/BufferAttribute.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BufferAttribute = function ( array, itemSize, normalized ) {\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.array = array;\r\n\tthis.itemSize = itemSize;\r\n\r\n\tthis.dynamic = false;\r\n\tthis.updateRange = { offset: 0, count: - 1 };\r\n\r\n\tthis.version = 0;\r\n\tthis.normalized = normalized === true;\r\n\r\n};\r\n\r\nTHREE.BufferAttribute.prototype = {\r\n\r\n\tconstructor: THREE.BufferAttribute,\r\n\r\n\tget count() {\r\n\r\n\t\treturn this.array.length / this.itemSize;\r\n\r\n\t},\r\n\r\n\tset needsUpdate( value ) {\r\n\r\n\t\tif ( value === true ) this.version ++;\r\n\r\n\t},\r\n\r\n\tsetDynamic: function ( value ) {\r\n\r\n\t\tthis.dynamic = value;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.array = new source.array.constructor( source.array );\r\n\t\tthis.itemSize = source.itemSize;\r\n\r\n\t\tthis.dynamic = source.dynamic;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyAt: function ( index1, attribute, index2 ) {\r\n\r\n\t\tindex1 *= this.itemSize;\r\n\t\tindex2 *= attribute.itemSize;\r\n\r\n\t\tfor ( var i = 0, l = this.itemSize; i < l; i ++ ) {\r\n\r\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyArray: function ( array ) {\r\n\r\n\t\tthis.array.set( array );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyColorsArray: function ( colors ) {\r\n\r\n\t\tvar array = this.array, offset = 0;\r\n\r\n\t\tfor ( var i = 0, l = colors.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar color = colors[ i ];\r\n\r\n\t\t\tif ( color === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );\r\n\t\t\t\tcolor = new THREE.Color();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tarray[ offset ++ ] = color.r;\r\n\t\t\tarray[ offset ++ ] = color.g;\r\n\t\t\tarray[ offset ++ ] = color.b;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyIndicesArray: function ( indices ) {\r\n\r\n\t\tvar array = this.array, offset = 0;\r\n\r\n\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar index = indices[ i ];\r\n\r\n\t\t\tarray[ offset ++ ] = index.a;\r\n\t\t\tarray[ offset ++ ] = index.b;\r\n\t\t\tarray[ offset ++ ] = index.c;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyVector2sArray: function ( vectors ) {\r\n\r\n\t\tvar array = this.array, offset = 0;\r\n\r\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar vector = vectors[ i ];\r\n\r\n\t\t\tif ( vector === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );\r\n\t\t\t\tvector = new THREE.Vector2();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tarray[ offset ++ ] = vector.x;\r\n\t\t\tarray[ offset ++ ] = vector.y;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyVector3sArray: function ( vectors ) {\r\n\r\n\t\tvar array = this.array, offset = 0;\r\n\r\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar vector = vectors[ i ];\r\n\r\n\t\t\tif ( vector === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );\r\n\t\t\t\tvector = new THREE.Vector3();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tarray[ offset ++ ] = vector.x;\r\n\t\t\tarray[ offset ++ ] = vector.y;\r\n\t\t\tarray[ offset ++ ] = vector.z;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyVector4sArray: function ( vectors ) {\r\n\r\n\t\tvar array = this.array, offset = 0;\r\n\r\n\t\tfor ( var i = 0, l = vectors.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar vector = vectors[ i ];\r\n\r\n\t\t\tif ( vector === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );\r\n\t\t\t\tvector = new THREE.Vector4();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tarray[ offset ++ ] = vector.x;\r\n\t\t\tarray[ offset ++ ] = vector.y;\r\n\t\t\tarray[ offset ++ ] = vector.z;\r\n\t\t\tarray[ offset ++ ] = vector.w;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tset: function ( value, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.array.set( value, offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetX: function ( index ) {\r\n\r\n\t\treturn this.array[ index * this.itemSize ];\r\n\r\n\t},\r\n\r\n\tsetX: function ( index, x ) {\r\n\r\n\t\tthis.array[ index * this.itemSize ] = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetY: function ( index ) {\r\n\r\n\t\treturn this.array[ index * this.itemSize + 1 ];\r\n\r\n\t},\r\n\r\n\tsetY: function ( index, y ) {\r\n\r\n\t\tthis.array[ index * this.itemSize + 1 ] = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetZ: function ( index ) {\r\n\r\n\t\treturn this.array[ index * this.itemSize + 2 ];\r\n\r\n\t},\r\n\r\n\tsetZ: function ( index, z ) {\r\n\r\n\t\tthis.array[ index * this.itemSize + 2 ] = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetW: function ( index ) {\r\n\r\n\t\treturn this.array[ index * this.itemSize + 3 ];\r\n\r\n\t},\r\n\r\n\tsetW: function ( index, w ) {\r\n\r\n\t\tthis.array[ index * this.itemSize + 3 ] = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXY: function ( index, x, y ) {\r\n\r\n\t\tindex *= this.itemSize;\r\n\r\n\t\tthis.array[ index + 0 ] = x;\r\n\t\tthis.array[ index + 1 ] = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXYZ: function ( index, x, y, z ) {\r\n\r\n\t\tindex *= this.itemSize;\r\n\r\n\t\tthis.array[ index + 0 ] = x;\r\n\t\tthis.array[ index + 1 ] = y;\r\n\t\tthis.array[ index + 2 ] = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXYZW: function ( index, x, y, z, w ) {\r\n\r\n\t\tindex *= this.itemSize;\r\n\r\n\t\tthis.array[ index + 0 ] = x;\r\n\t\tthis.array[ index + 1 ] = y;\r\n\t\tthis.array[ index + 2 ] = z;\r\n\t\tthis.array[ index + 3 ] = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n//\r\n\r\nTHREE.Int8Attribute = function ( array, itemSize ) {\r\n\r\n\treturn new THREE.BufferAttribute( new Int8Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint8Attribute = function ( array, itemSize ) {\r\n\r\n\treturn new THREE.BufferAttribute( new Uint8Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint8ClampedAttribute = function ( array, itemSize ) {\r\n\r\n\treturn new THREE.BufferAttribute( new Uint8ClampedArray( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Int16Attribute = function ( array, itemSize ) {\r\n\r\n\treturn new THREE.BufferAttribute( new Int16Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint16Attribute = function ( array, itemSize ) {\r\n\r\n\treturn new THREE.BufferAttribute( new Uint16Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Int32Attribute = function ( array, itemSize ) {\r\n\r\n\treturn new THREE.BufferAttribute( new Int32Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Uint32Attribute = function ( array, itemSize ) {\r\n\r\n\treturn new THREE.BufferAttribute( new Uint32Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Float32Attribute = function ( array, itemSize ) {\r\n\r\n\treturn new THREE.BufferAttribute( new Float32Array( array ), itemSize );\r\n\r\n};\r\n\r\nTHREE.Float64Attribute = function ( array, itemSize ) {\r\n\r\n\treturn new THREE.BufferAttribute( new Float64Array( array ), itemSize );\r\n\r\n};\r\n\r\n\r\n// Deprecated\r\n\r\nTHREE.DynamicBufferAttribute = function ( array, itemSize ) {\r\n\r\n\tconsole.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );\r\n\treturn new THREE.BufferAttribute( array, itemSize ).setDynamic( true );\r\n\r\n};\r\n\r\n// File:src/core/InstancedBufferAttribute.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\n\r\nTHREE.InstancedBufferAttribute = function ( array, itemSize, meshPerAttribute ) {\r\n\r\n\tTHREE.BufferAttribute.call( this, array, itemSize );\r\n\r\n\tthis.meshPerAttribute = meshPerAttribute || 1;\r\n\r\n};\r\n\r\nTHREE.InstancedBufferAttribute.prototype = Object.create( THREE.BufferAttribute.prototype );\r\nTHREE.InstancedBufferAttribute.prototype.constructor = THREE.InstancedBufferAttribute;\r\n\r\nTHREE.InstancedBufferAttribute.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.BufferAttribute.prototype.copy.call( this, source );\r\n\r\n\tthis.meshPerAttribute = source.meshPerAttribute;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/core/InterleavedBuffer.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\n\r\nTHREE.InterleavedBuffer = function ( array, stride ) {\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.array = array;\r\n\tthis.stride = stride;\r\n\r\n\tthis.dynamic = false;\r\n\tthis.updateRange = { offset: 0, count: - 1 };\r\n\r\n\tthis.version = 0;\r\n\r\n};\r\n\r\nTHREE.InterleavedBuffer.prototype = {\r\n\r\n\tconstructor: THREE.InterleavedBuffer,\r\n\r\n\tget length () {\r\n\r\n\t\treturn this.array.length;\r\n\r\n\t},\r\n\r\n\tget count () {\r\n\r\n\t\treturn this.array.length / this.stride;\r\n\r\n\t},\r\n\r\n\tset needsUpdate( value ) {\r\n\r\n\t\tif ( value === true ) this.version ++;\r\n\r\n\t},\r\n\r\n\tsetDynamic: function ( value ) {\r\n\r\n\t\tthis.dynamic = value;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.array = new source.array.constructor( source.array );\r\n\t\tthis.stride = source.stride;\r\n\t\tthis.dynamic = source.dynamic;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcopyAt: function ( index1, attribute, index2 ) {\r\n\r\n\t\tindex1 *= this.stride;\r\n\t\tindex2 *= attribute.stride;\r\n\r\n\t\tfor ( var i = 0, l = this.stride; i < l; i ++ ) {\r\n\r\n\t\t\tthis.array[ index1 + i ] = attribute.array[ index2 + i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tset: function ( value, offset ) {\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tthis.array.set( value, offset );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/core/InstancedInterleavedBuffer.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\n\r\nTHREE.InstancedInterleavedBuffer = function ( array, stride, meshPerAttribute ) {\r\n\r\n\tTHREE.InterleavedBuffer.call( this, array, stride );\r\n\r\n\tthis.meshPerAttribute = meshPerAttribute || 1;\r\n\r\n};\r\n\r\nTHREE.InstancedInterleavedBuffer.prototype = Object.create( THREE.InterleavedBuffer.prototype );\r\nTHREE.InstancedInterleavedBuffer.prototype.constructor = THREE.InstancedInterleavedBuffer;\r\n\r\nTHREE.InstancedInterleavedBuffer.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.InterleavedBuffer.prototype.copy.call( this, source );\r\n\r\n\tthis.meshPerAttribute = source.meshPerAttribute;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/core/InterleavedBufferAttribute.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\n\r\nTHREE.InterleavedBufferAttribute = function ( interleavedBuffer, itemSize, offset ) {\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.data = interleavedBuffer;\r\n\tthis.itemSize = itemSize;\r\n\tthis.offset = offset;\r\n\r\n};\r\n\r\n\r\nTHREE.InterleavedBufferAttribute.prototype = {\r\n\r\n\tconstructor: THREE.InterleavedBufferAttribute,\r\n\r\n\tget length() {\r\n\r\n\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\r\n\t\treturn this.array.length;\r\n\r\n\t},\r\n\r\n\tget count() {\r\n\r\n\t\treturn this.data.count;\r\n\r\n\t},\r\n\r\n\tsetX: function ( index, x ) {\r\n\r\n\t\tthis.data.array[ index * this.data.stride + this.offset ] = x;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetY: function ( index, y ) {\r\n\r\n\t\tthis.data.array[ index * this.data.stride + this.offset + 1 ] = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetZ: function ( index, z ) {\r\n\r\n\t\tthis.data.array[ index * this.data.stride + this.offset + 2 ] = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetW: function ( index, w ) {\r\n\r\n\t\tthis.data.array[ index * this.data.stride + this.offset + 3 ] = w;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetX: function ( index ) {\r\n\r\n\t\treturn this.data.array[ index * this.data.stride + this.offset ];\r\n\r\n\t},\r\n\r\n\tgetY: function ( index ) {\r\n\r\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 1 ];\r\n\r\n\t},\r\n\r\n\tgetZ: function ( index ) {\r\n\r\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 2 ];\r\n\r\n\t},\r\n\r\n\tgetW: function ( index ) {\r\n\r\n\t\treturn this.data.array[ index * this.data.stride + this.offset + 3 ];\r\n\r\n\t},\r\n\r\n\tsetXY: function ( index, x, y ) {\r\n\r\n\t\tindex = index * this.data.stride + this.offset;\r\n\r\n\t\tthis.data.array[ index + 0 ] = x;\r\n\t\tthis.data.array[ index + 1 ] = y;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXYZ: function ( index, x, y, z ) {\r\n\r\n\t\tindex = index * this.data.stride + this.offset;\r\n\r\n\t\tthis.data.array[ index + 0 ] = x;\r\n\t\tthis.data.array[ index + 1 ] = y;\r\n\t\tthis.data.array[ index + 2 ] = z;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetXYZW: function ( index, x, y, z, w ) {\r\n\r\n\t\tindex = index * this.data.stride + this.offset;\r\n\r\n\t\tthis.data.array[ index + 0 ] = x;\r\n\t\tthis.data.array[ index + 1 ] = y;\r\n\t\tthis.data.array[ index + 2 ] = z;\r\n\t\tthis.data.array[ index + 3 ] = w;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/core/Geometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author kile / http://kile.stravaganza.org/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\nTHREE.Geometry = function () {\r\n\r\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'Geometry';\r\n\r\n\tthis.vertices = [];\r\n\tthis.colors = [];\r\n\tthis.faces = [];\r\n\tthis.faceVertexUvs = [ [] ];\r\n\r\n\tthis.morphTargets = [];\r\n\tthis.morphNormals = [];\r\n\r\n\tthis.skinWeights = [];\r\n\tthis.skinIndices = [];\r\n\r\n\tthis.lineDistances = [];\r\n\r\n\tthis.boundingBox = null;\r\n\tthis.boundingSphere = null;\r\n\r\n\t// update flags\r\n\r\n\tthis.verticesNeedUpdate = false;\r\n\tthis.elementsNeedUpdate = false;\r\n\tthis.uvsNeedUpdate = false;\r\n\tthis.normalsNeedUpdate = false;\r\n\tthis.colorsNeedUpdate = false;\r\n\tthis.lineDistancesNeedUpdate = false;\r\n\tthis.groupsNeedUpdate = false;\r\n\r\n};\r\n\r\nObject.assign( THREE.Geometry.prototype, THREE.EventDispatcher.prototype, {\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\r\n\t\tfor ( var i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar vertex = this.vertices[ i ];\r\n\t\t\tvertex.applyMatrix4( matrix );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar face = this.faces[ i ];\r\n\t\t\tface.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tface.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingBox !== null ) {\r\n\r\n\t\t\tthis.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.computeBoundingSphere();\r\n\r\n\t\t}\r\n\r\n\t\tthis.verticesNeedUpdate = true;\r\n\t\tthis.normalsNeedUpdate = true;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trotateX: function () {\r\n\r\n\t\t// rotate geometry around world x-axis\r\n\r\n\t\tvar m1;\r\n\r\n\t\treturn function rotateX( angle ) {\r\n\r\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n\t\t\tm1.makeRotationX( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateY: function () {\r\n\r\n\t\t// rotate geometry around world y-axis\r\n\r\n\t\tvar m1;\r\n\r\n\t\treturn function rotateY( angle ) {\r\n\r\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n\t\t\tm1.makeRotationY( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateZ: function () {\r\n\r\n\t\t// rotate geometry around world z-axis\r\n\r\n\t\tvar m1;\r\n\r\n\t\treturn function rotateZ( angle ) {\r\n\r\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n\t\t\tm1.makeRotationZ( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function () {\r\n\r\n\t\t// translate geometry\r\n\r\n\t\tvar m1;\r\n\r\n\t\treturn function translate( x, y, z ) {\r\n\r\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n\t\t\tm1.makeTranslation( x, y, z );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tscale: function () {\r\n\r\n\t\t// scale geometry\r\n\r\n\t\tvar m1;\r\n\r\n\t\treturn function scale( x, y, z ) {\r\n\r\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n\t\t\tm1.makeScale( x, y, z );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlookAt: function () {\r\n\r\n\t\tvar obj;\r\n\r\n\t\treturn function lookAt( vector ) {\r\n\r\n\t\t\tif ( obj === undefined ) obj = new THREE.Object3D();\r\n\r\n\t\t\tobj.lookAt( vector );\r\n\r\n\t\t\tobj.updateMatrix();\r\n\r\n\t\t\tthis.applyMatrix( obj.matrix );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tfromBufferGeometry: function ( geometry ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar indices = geometry.index !== null ? geometry.index.array : undefined;\r\n\t\tvar attributes = geometry.attributes;\r\n\r\n\t\tvar positions = attributes.position.array;\r\n\t\tvar normals = attributes.normal !== undefined ? attributes.normal.array : undefined;\r\n\t\tvar colors = attributes.color !== undefined ? attributes.color.array : undefined;\r\n\t\tvar uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;\r\n\t\tvar uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;\r\n\r\n\t\tif ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];\r\n\r\n\t\tvar tempNormals = [];\r\n\t\tvar tempUVs = [];\r\n\t\tvar tempUVs2 = [];\r\n\r\n\t\tfor ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {\r\n\r\n\t\t\tscope.vertices.push( new THREE.Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );\r\n\r\n\t\t\tif ( normals !== undefined ) {\r\n\r\n\t\t\t\ttempNormals.push( new THREE.Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( colors !== undefined ) {\r\n\r\n\t\t\t\tscope.colors.push( new THREE.Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( uvs !== undefined ) {\r\n\r\n\t\t\t\ttempUVs.push( new THREE.Vector2( uvs[ j ], uvs[ j + 1 ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( uvs2 !== undefined ) {\r\n\r\n\t\t\t\ttempUVs2.push( new THREE.Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction addFace( a, b, c, materialIndex ) {\r\n\r\n\t\t\tvar vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];\r\n\t\t\tvar vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];\r\n\r\n\t\t\tvar face = new THREE.Face3( a, b, c, vertexNormals, vertexColors, materialIndex );\r\n\r\n\t\t\tscope.faces.push( face );\r\n\r\n\t\t\tif ( uvs !== undefined ) {\r\n\r\n\t\t\t\tscope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( uvs2 !== undefined ) {\r\n\r\n\t\t\t\tscope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( indices !== undefined ) {\r\n\r\n\t\t\tvar groups = geometry.groups;\r\n\r\n\t\t\tif ( groups.length > 0 ) {\r\n\r\n\t\t\t\tfor ( var i = 0; i < groups.length; i ++ ) {\r\n\r\n\t\t\t\t\tvar group = groups[ i ];\r\n\r\n\t\t\t\t\tvar start = group.start;\r\n\t\t\t\t\tvar count = group.count;\r\n\r\n\t\t\t\t\tfor ( var j = start, jl = start + count; j < jl; j += 3 ) {\r\n\r\n\t\t\t\t\t\taddFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( var i = 0; i < indices.length; i += 3 ) {\r\n\r\n\t\t\t\t\taddFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( var i = 0; i < positions.length / 3; i += 3 ) {\r\n\r\n\t\t\t\taddFace( i, i + 1, i + 2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.computeFaceNormals();\r\n\r\n\t\tif ( geometry.boundingBox !== null ) {\r\n\r\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcenter: function () {\r\n\r\n\t\tthis.computeBoundingBox();\r\n\r\n\t\tvar offset = this.boundingBox.center().negate();\r\n\r\n\t\tthis.translate( offset.x, offset.y, offset.z );\r\n\r\n\t\treturn offset;\r\n\r\n\t},\r\n\r\n\tnormalize: function () {\r\n\r\n\t\tthis.computeBoundingSphere();\r\n\r\n\t\tvar center = this.boundingSphere.center;\r\n\t\tvar radius = this.boundingSphere.radius;\r\n\r\n\t\tvar s = radius === 0 ? 1 : 1.0 / radius;\r\n\r\n\t\tvar matrix = new THREE.Matrix4();\r\n\t\tmatrix.set(\r\n\t\t\ts, 0, 0, - s * center.x,\r\n\t\t\t0, s, 0, - s * center.y,\r\n\t\t\t0, 0, s, - s * center.z,\r\n\t\t\t0, 0, 0, 1\r\n\t\t);\r\n\r\n\t\tthis.applyMatrix( matrix );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcomputeFaceNormals: function () {\r\n\r\n\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\r\n\r\n\t\tfor ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tvar face = this.faces[ f ];\r\n\r\n\t\t\tvar vA = this.vertices[ face.a ];\r\n\t\t\tvar vB = this.vertices[ face.b ];\r\n\t\t\tvar vC = this.vertices[ face.c ];\r\n\r\n\t\t\tcb.subVectors( vC, vB );\r\n\t\t\tab.subVectors( vA, vB );\r\n\t\t\tcb.cross( ab );\r\n\r\n\t\t\tcb.normalize();\r\n\r\n\t\t\tface.normal.copy( cb );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeVertexNormals: function ( areaWeighted ) {\r\n\r\n\t\tif ( areaWeighted === undefined ) areaWeighted = true;\r\n\r\n\t\tvar v, vl, f, fl, face, vertices;\r\n\r\n\t\tvertices = new Array( this.vertices.length );\r\n\r\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\tvertices[ v ] = new THREE.Vector3();\r\n\r\n\t\t}\r\n\r\n\t\tif ( areaWeighted ) {\r\n\r\n\t\t\t// vertex normals weighted by triangle areas\r\n\t\t\t// http://www.iquilezles.org/www/articles/normals/normals.htm\r\n\r\n\t\t\tvar vA, vB, vC;\r\n\t\t\tvar cb = new THREE.Vector3(), ab = new THREE.Vector3();\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tvA = this.vertices[ face.a ];\r\n\t\t\t\tvB = this.vertices[ face.b ];\r\n\t\t\t\tvC = this.vertices[ face.c ];\r\n\r\n\t\t\t\tcb.subVectors( vC, vB );\r\n\t\t\t\tab.subVectors( vA, vB );\r\n\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\tvertices[ face.a ].add( cb );\r\n\t\t\t\tvertices[ face.b ].add( cb );\r\n\t\t\t\tvertices[ face.c ].add( cb );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tvertices[ face.a ].add( face.normal );\r\n\t\t\t\tvertices[ face.b ].add( face.normal );\r\n\t\t\t\tvertices[ face.c ].add( face.normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {\r\n\r\n\t\t\tvertices[ v ].normalize();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tvar vertexNormals = face.vertexNormals;\r\n\r\n\t\t\tif ( vertexNormals.length === 3 ) {\r\n\r\n\t\t\t\tvertexNormals[ 0 ].copy( vertices[ face.a ] );\r\n\t\t\t\tvertexNormals[ 1 ].copy( vertices[ face.b ] );\r\n\t\t\t\tvertexNormals[ 2 ].copy( vertices[ face.c ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvertexNormals[ 0 ] = vertices[ face.a ].clone();\r\n\t\t\t\tvertexNormals[ 1 ] = vertices[ face.b ].clone();\r\n\t\t\t\tvertexNormals[ 2 ] = vertices[ face.c ].clone();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.faces.length > 0 ) {\r\n\r\n\t\t\tthis.normalsNeedUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeMorphNormals: function () {\r\n\r\n\t\tvar i, il, f, fl, face;\r\n\r\n\t\t// save original normals\r\n\t\t// - create temp variables on first access\r\n\t\t//   otherwise just copy (for faster repeated calls)\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tif ( ! face.__originalFaceNormal ) {\r\n\r\n\t\t\t\tface.__originalFaceNormal = face.normal.clone();\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tface.__originalFaceNormal.copy( face.normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];\r\n\r\n\t\t\tfor ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tif ( ! face.__originalVertexNormals[ i ] ) {\r\n\r\n\t\t\t\t\tface.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tface.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// use temp geometry to compute face and vertex normals for each morph\r\n\r\n\t\tvar tmpGeo = new THREE.Geometry();\r\n\t\ttmpGeo.faces = this.faces;\r\n\r\n\t\tfor ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\t\t// create on first access\r\n\r\n\t\t\tif ( ! this.morphNormals[ i ] ) {\r\n\r\n\t\t\t\tthis.morphNormals[ i ] = {};\r\n\t\t\t\tthis.morphNormals[ i ].faceNormals = [];\r\n\t\t\t\tthis.morphNormals[ i ].vertexNormals = [];\r\n\r\n\t\t\t\tvar dstNormalsFace = this.morphNormals[ i ].faceNormals;\r\n\t\t\t\tvar dstNormalsVertex = this.morphNormals[ i ].vertexNormals;\r\n\r\n\t\t\t\tvar faceNormal, vertexNormals;\r\n\r\n\t\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\tfaceNormal = new THREE.Vector3();\r\n\t\t\t\t\tvertexNormals = { a: new THREE.Vector3(), b: new THREE.Vector3(), c: new THREE.Vector3() };\r\n\r\n\t\t\t\t\tdstNormalsFace.push( faceNormal );\r\n\t\t\t\t\tdstNormalsVertex.push( vertexNormals );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar morphNormals = this.morphNormals[ i ];\r\n\r\n\t\t\t// set vertices to morph target\r\n\r\n\t\t\ttmpGeo.vertices = this.morphTargets[ i ].vertices;\r\n\r\n\t\t\t// compute morph normals\r\n\r\n\t\t\ttmpGeo.computeFaceNormals();\r\n\t\t\ttmpGeo.computeVertexNormals();\r\n\r\n\t\t\t// store morph normals\r\n\r\n\t\t\tvar faceNormal, vertexNormals;\r\n\r\n\t\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\t\tfaceNormal = morphNormals.faceNormals[ f ];\r\n\t\t\t\tvertexNormals = morphNormals.vertexNormals[ f ];\r\n\r\n\t\t\t\tfaceNormal.copy( face.normal );\r\n\r\n\t\t\t\tvertexNormals.a.copy( face.vertexNormals[ 0 ] );\r\n\t\t\t\tvertexNormals.b.copy( face.vertexNormals[ 1 ] );\r\n\t\t\t\tvertexNormals.c.copy( face.vertexNormals[ 2 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// restore original normals\r\n\r\n\t\tfor ( f = 0, fl = this.faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\tface = this.faces[ f ];\r\n\r\n\t\t\tface.normal = face.__originalFaceNormal;\r\n\t\t\tface.vertexNormals = face.__originalVertexNormals;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeTangents: function () {\r\n\r\n\t\tconsole.warn( 'THREE.Geometry: .computeTangents() has been removed.' );\r\n\r\n\t},\r\n\r\n\tcomputeLineDistances: function () {\r\n\r\n\t\tvar d = 0;\r\n\t\tvar vertices = this.vertices;\r\n\r\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tif ( i > 0 ) {\r\n\r\n\t\t\t\td += vertices[ i ].distanceTo( vertices[ i - 1 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.lineDistances[ i ] = d;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeBoundingBox: function () {\r\n\r\n\t\tif ( this.boundingBox === null ) {\r\n\r\n\t\t\tthis.boundingBox = new THREE.Box3();\r\n\r\n\t\t}\r\n\r\n\t\tthis.boundingBox.setFromPoints( this.vertices );\r\n\r\n\t},\r\n\r\n\tcomputeBoundingSphere: function () {\r\n\r\n\t\tif ( this.boundingSphere === null ) {\r\n\r\n\t\t\tthis.boundingSphere = new THREE.Sphere();\r\n\r\n\t\t}\r\n\r\n\t\tthis.boundingSphere.setFromPoints( this.vertices );\r\n\r\n\t},\r\n\r\n\tmerge: function ( geometry, matrix, materialIndexOffset ) {\r\n\r\n\t\tif ( geometry instanceof THREE.Geometry === false ) {\r\n\r\n\t\t\tconsole.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar normalMatrix,\r\n\t\tvertexOffset = this.vertices.length,\r\n\t\tvertices1 = this.vertices,\r\n\t\tvertices2 = geometry.vertices,\r\n\t\tfaces1 = this.faces,\r\n\t\tfaces2 = geometry.faces,\r\n\t\tuvs1 = this.faceVertexUvs[ 0 ],\r\n\t\tuvs2 = geometry.faceVertexUvs[ 0 ];\r\n\r\n\t\tif ( materialIndexOffset === undefined ) materialIndexOffset = 0;\r\n\r\n\t\tif ( matrix !== undefined ) {\r\n\r\n\t\t\tnormalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\r\n\t\t}\r\n\r\n\t\t// vertices\r\n\r\n\t\tfor ( var i = 0, il = vertices2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar vertex = vertices2[ i ];\r\n\r\n\t\t\tvar vertexCopy = vertex.clone();\r\n\r\n\t\t\tif ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );\r\n\r\n\t\t\tvertices1.push( vertexCopy );\r\n\r\n\t\t}\r\n\r\n\t\t// faces\r\n\r\n\t\tfor ( i = 0, il = faces2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar face = faces2[ i ], faceCopy, normal, color,\r\n\t\t\tfaceVertexNormals = face.vertexNormals,\r\n\t\t\tfaceVertexColors = face.vertexColors;\r\n\r\n\t\t\tfaceCopy = new THREE.Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );\r\n\t\t\tfaceCopy.normal.copy( face.normal );\r\n\r\n\t\t\tif ( normalMatrix !== undefined ) {\r\n\r\n\t\t\t\tfaceCopy.normal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tnormal = faceVertexNormals[ j ].clone();\r\n\r\n\t\t\t\tif ( normalMatrix !== undefined ) {\r\n\r\n\t\t\t\t\tnormal.applyMatrix3( normalMatrix ).normalize();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfaceCopy.vertexNormals.push( normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfaceCopy.color.copy( face.color );\r\n\r\n\t\t\tfor ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tcolor = faceVertexColors[ j ];\r\n\t\t\t\tfaceCopy.vertexColors.push( color.clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfaceCopy.materialIndex = face.materialIndex + materialIndexOffset;\r\n\r\n\t\t\tfaces1.push( faceCopy );\r\n\r\n\t\t}\r\n\r\n\t\t// uvs\r\n\r\n\t\tfor ( i = 0, il = uvs2.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar uv = uvs2[ i ], uvCopy = [];\r\n\r\n\t\t\tif ( uv === undefined ) {\r\n\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 0, jl = uv.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tuvCopy.push( uv[ j ].clone() );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuvs1.push( uvCopy );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tmergeMesh: function ( mesh ) {\r\n\r\n\t\tif ( mesh instanceof THREE.Mesh === false ) {\r\n\r\n\t\t\tconsole.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tmesh.matrixAutoUpdate && mesh.updateMatrix();\r\n\r\n\t\tthis.merge( mesh.geometry, mesh.matrix );\r\n\r\n\t},\r\n\r\n\t/*\r\n\t * Checks for duplicate vertices with hashmap.\r\n\t * Duplicated vertices are removed\r\n\t * and faces' vertices are updated.\r\n\t */\r\n\r\n\tmergeVertices: function () {\r\n\r\n\t\tvar verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\r\n\t\tvar unique = [], changes = [];\r\n\r\n\t\tvar v, key;\r\n\t\tvar precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\r\n\t\tvar precision = Math.pow( 10, precisionPoints );\r\n\t\tvar i, il, face;\r\n\t\tvar indices, j, jl;\r\n\r\n\t\tfor ( i = 0, il = this.vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tv = this.vertices[ i ];\r\n\t\t\tkey = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );\r\n\r\n\t\t\tif ( verticesMap[ key ] === undefined ) {\r\n\r\n\t\t\t\tverticesMap[ key ] = i;\r\n\t\t\t\tunique.push( this.vertices[ i ] );\r\n\t\t\t\tchanges[ i ] = unique.length - 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);\r\n\t\t\t\tchanges[ i ] = changes[ verticesMap[ key ] ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// if faces are completely degenerate after merging vertices, we\r\n\t\t// have to remove them from the geometry.\r\n\t\tvar faceIndicesToRemove = [];\r\n\r\n\t\tfor ( i = 0, il = this.faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tface = this.faces[ i ];\r\n\r\n\t\t\tface.a = changes[ face.a ];\r\n\t\t\tface.b = changes[ face.b ];\r\n\t\t\tface.c = changes[ face.c ];\r\n\r\n\t\t\tindices = [ face.a, face.b, face.c ];\r\n\r\n\t\t\tvar dupIndex = - 1;\r\n\r\n\t\t\t// if any duplicate vertices are found in a Face3\r\n\t\t\t// we have to remove the face as nothing can be saved\r\n\t\t\tfor ( var n = 0; n < 3; n ++ ) {\r\n\r\n\t\t\t\tif ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {\r\n\r\n\t\t\t\t\tdupIndex = n;\r\n\t\t\t\t\tfaceIndicesToRemove.push( i );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {\r\n\r\n\t\t\tvar idx = faceIndicesToRemove[ i ];\r\n\r\n\t\t\tthis.faces.splice( idx, 1 );\r\n\r\n\t\t\tfor ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tthis.faceVertexUvs[ j ].splice( idx, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Use unique set of vertices\r\n\r\n\t\tvar diff = this.vertices.length - unique.length;\r\n\t\tthis.vertices = unique;\r\n\t\treturn diff;\r\n\r\n\t},\r\n\r\n\tsortFacesByMaterialIndex: function () {\r\n\r\n\t\tvar faces = this.faces;\r\n\t\tvar length = faces.length;\r\n\r\n\t\t// tag faces\r\n\r\n\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\r\n\t\t\tfaces[ i ]._id = i;\r\n\r\n\t\t}\r\n\r\n\t\t// sort faces\r\n\r\n\t\tfunction materialIndexSort( a, b ) {\r\n\r\n\t\t\treturn a.materialIndex - b.materialIndex;\r\n\r\n\t\t}\r\n\r\n\t\tfaces.sort( materialIndexSort );\r\n\r\n\t\t// sort uvs\r\n\r\n\t\tvar uvs1 = this.faceVertexUvs[ 0 ];\r\n\t\tvar uvs2 = this.faceVertexUvs[ 1 ];\r\n\r\n\t\tvar newUvs1, newUvs2;\r\n\r\n\t\tif ( uvs1 && uvs1.length === length ) newUvs1 = [];\r\n\t\tif ( uvs2 && uvs2.length === length ) newUvs2 = [];\r\n\r\n\t\tfor ( var i = 0; i < length; i ++ ) {\r\n\r\n\t\t\tvar id = faces[ i ]._id;\r\n\r\n\t\t\tif ( newUvs1 ) newUvs1.push( uvs1[ id ] );\r\n\t\t\tif ( newUvs2 ) newUvs2.push( uvs2[ id ] );\r\n\r\n\t\t}\r\n\r\n\t\tif ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;\r\n\t\tif ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar data = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.4,\r\n\t\t\t\ttype: 'Geometry',\r\n\t\t\t\tgenerator: 'Geometry.toJSON'\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// standard Geometry serialization\r\n\r\n\t\tdata.uuid = this.uuid;\r\n\t\tdata.type = this.type;\r\n\t\tif ( this.name !== '' ) data.name = this.name;\r\n\r\n\t\tif ( this.parameters !== undefined ) {\r\n\r\n\t\t\tvar parameters = this.parameters;\r\n\r\n\t\t\tfor ( var key in parameters ) {\r\n\r\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tvar vertices = [];\r\n\r\n\t\tfor ( var i = 0; i < this.vertices.length; i ++ ) {\r\n\r\n\t\t\tvar vertex = this.vertices[ i ];\r\n\t\t\tvertices.push( vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t}\r\n\r\n\t\tvar faces = [];\r\n\t\tvar normals = [];\r\n\t\tvar normalsHash = {};\r\n\t\tvar colors = [];\r\n\t\tvar colorsHash = {};\r\n\t\tvar uvs = [];\r\n\t\tvar uvsHash = {};\r\n\r\n\t\tfor ( var i = 0; i < this.faces.length; i ++ ) {\r\n\r\n\t\t\tvar face = this.faces[ i ];\r\n\r\n\t\t\tvar hasMaterial = true;\r\n\t\t\tvar hasFaceUv = false; // deprecated\r\n\t\t\tvar hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;\r\n\t\t\tvar hasFaceNormal = face.normal.length() > 0;\r\n\t\t\tvar hasFaceVertexNormal = face.vertexNormals.length > 0;\r\n\t\t\tvar hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;\r\n\t\t\tvar hasFaceVertexColor = face.vertexColors.length > 0;\r\n\r\n\t\t\tvar faceType = 0;\r\n\r\n\t\t\tfaceType = setBit( faceType, 0, 0 ); // isQuad\r\n\t\t\tfaceType = setBit( faceType, 1, hasMaterial );\r\n\t\t\tfaceType = setBit( faceType, 2, hasFaceUv );\r\n\t\t\tfaceType = setBit( faceType, 3, hasFaceVertexUv );\r\n\t\t\tfaceType = setBit( faceType, 4, hasFaceNormal );\r\n\t\t\tfaceType = setBit( faceType, 5, hasFaceVertexNormal );\r\n\t\t\tfaceType = setBit( faceType, 6, hasFaceColor );\r\n\t\t\tfaceType = setBit( faceType, 7, hasFaceVertexColor );\r\n\r\n\t\t\tfaces.push( faceType );\r\n\t\t\tfaces.push( face.a, face.b, face.c );\r\n\t\t\tfaces.push( face.materialIndex );\r\n\r\n\t\t\tif ( hasFaceVertexUv ) {\r\n\r\n\t\t\t\tvar faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];\r\n\r\n\t\t\t\tfaces.push(\r\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 0 ] ),\r\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 1 ] ),\r\n\t\t\t\t\tgetUvIndex( faceVertexUvs[ 2 ] )\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceNormal ) {\r\n\r\n\t\t\t\tfaces.push( getNormalIndex( face.normal ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexNormal ) {\r\n\r\n\t\t\t\tvar vertexNormals = face.vertexNormals;\r\n\r\n\t\t\t\tfaces.push(\r\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 0 ] ),\r\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 1 ] ),\r\n\t\t\t\t\tgetNormalIndex( vertexNormals[ 2 ] )\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceColor ) {\r\n\r\n\t\t\t\tfaces.push( getColorIndex( face.color ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexColor ) {\r\n\r\n\t\t\t\tvar vertexColors = face.vertexColors;\r\n\r\n\t\t\t\tfaces.push(\r\n\t\t\t\t\tgetColorIndex( vertexColors[ 0 ] ),\r\n\t\t\t\t\tgetColorIndex( vertexColors[ 1 ] ),\r\n\t\t\t\t\tgetColorIndex( vertexColors[ 2 ] )\r\n\t\t\t\t);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction setBit( value, position, enabled ) {\r\n\r\n\t\t\treturn enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );\r\n\r\n\t\t}\r\n\r\n\t\tfunction getNormalIndex( normal ) {\r\n\r\n\t\t\tvar hash = normal.x.toString() + normal.y.toString() + normal.z.toString();\r\n\r\n\t\t\tif ( normalsHash[ hash ] !== undefined ) {\r\n\r\n\t\t\t\treturn normalsHash[ hash ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tnormalsHash[ hash ] = normals.length / 3;\r\n\t\t\tnormals.push( normal.x, normal.y, normal.z );\r\n\r\n\t\t\treturn normalsHash[ hash ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction getColorIndex( color ) {\r\n\r\n\t\t\tvar hash = color.r.toString() + color.g.toString() + color.b.toString();\r\n\r\n\t\t\tif ( colorsHash[ hash ] !== undefined ) {\r\n\r\n\t\t\t\treturn colorsHash[ hash ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcolorsHash[ hash ] = colors.length;\r\n\t\t\tcolors.push( color.getHex() );\r\n\r\n\t\t\treturn colorsHash[ hash ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction getUvIndex( uv ) {\r\n\r\n\t\t\tvar hash = uv.x.toString() + uv.y.toString();\r\n\r\n\t\t\tif ( uvsHash[ hash ] !== undefined ) {\r\n\r\n\t\t\t\treturn uvsHash[ hash ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuvsHash[ hash ] = uvs.length / 2;\r\n\t\t\tuvs.push( uv.x, uv.y );\r\n\r\n\t\t\treturn uvsHash[ hash ];\r\n\r\n\t\t}\r\n\r\n\t\tdata.data = {};\r\n\r\n\t\tdata.data.vertices = vertices;\r\n\t\tdata.data.normals = normals;\r\n\t\tif ( colors.length > 0 ) data.data.colors = colors;\r\n\t\tif ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility\r\n\t\tdata.data.faces = faces;\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\t/*\r\n\t\t// Handle primitives\r\n\r\n\t\tvar parameters = this.parameters;\r\n\r\n\t\tif ( parameters !== undefined ) {\r\n\r\n\t\t\tvar values = [];\r\n\r\n\t\t\tfor ( var key in parameters ) {\r\n\r\n\t\t\t\tvalues.push( parameters[ key ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar geometry = Object.create( this.constructor.prototype );\r\n\t\t\tthis.constructor.apply( geometry, values );\r\n\t\t\treturn geometry;\r\n\r\n\t\t}\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\t\t*/\r\n\r\n\t\treturn new THREE.Geometry().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.vertices = [];\r\n\t\tthis.faces = [];\r\n\t\tthis.faceVertexUvs = [ [] ];\r\n\r\n\t\tvar vertices = source.vertices;\r\n\r\n\t\tfor ( var i = 0, il = vertices.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.vertices.push( vertices[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\tvar faces = source.faces;\r\n\r\n\t\tfor ( var i = 0, il = faces.length; i < il; i ++ ) {\r\n\r\n\t\t\tthis.faces.push( faces[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar faceVertexUvs = source.faceVertexUvs[ i ];\r\n\r\n\t\t\tif ( this.faceVertexUvs[ i ] === undefined ) {\r\n\r\n\t\t\t\tthis.faceVertexUvs[ i ] = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\tvar uvs = faceVertexUvs[ j ], uvsCopy = [];\r\n\r\n\t\t\t\tfor ( var k = 0, kl = uvs.length; k < kl; k ++ ) {\r\n\r\n\t\t\t\t\tvar uv = uvs[ k ];\r\n\r\n\t\t\t\t\tuvsCopy.push( uv.clone() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.faceVertexUvs[ i ].push( uvsCopy );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n} );\r\n\r\nTHREE.GeometryIdCount = 0;\r\n\r\n// File:src/core/DirectGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.DirectGeometry = function () {\r\n\r\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'DirectGeometry';\r\n\r\n\tthis.indices = [];\r\n\tthis.vertices = [];\r\n\tthis.normals = [];\r\n\tthis.colors = [];\r\n\tthis.uvs = [];\r\n\tthis.uvs2 = [];\r\n\r\n\tthis.groups = [];\r\n\r\n\tthis.morphTargets = {};\r\n\r\n\tthis.skinWeights = [];\r\n\tthis.skinIndices = [];\r\n\r\n\t// this.lineDistances = [];\r\n\r\n\tthis.boundingBox = null;\r\n\tthis.boundingSphere = null;\r\n\r\n\t// update flags\r\n\r\n\tthis.verticesNeedUpdate = false;\r\n\tthis.normalsNeedUpdate = false;\r\n\tthis.colorsNeedUpdate = false;\r\n\tthis.uvsNeedUpdate = false;\r\n\tthis.groupsNeedUpdate = false;\r\n\r\n};\r\n\r\nObject.assign( THREE.DirectGeometry.prototype, THREE.EventDispatcher.prototype, {\r\n\r\n\tcomputeBoundingBox: THREE.Geometry.prototype.computeBoundingBox,\r\n\tcomputeBoundingSphere: THREE.Geometry.prototype.computeBoundingSphere,\r\n\r\n\tcomputeFaceNormals: function () {\r\n\r\n\t\tconsole.warn( 'THREE.DirectGeometry: computeFaceNormals() is not a method of this type of geometry.' );\r\n\r\n\t},\r\n\r\n\tcomputeVertexNormals: function () {\r\n\r\n\t\tconsole.warn( 'THREE.DirectGeometry: computeVertexNormals() is not a method of this type of geometry.' );\r\n\r\n\t},\r\n\r\n\tcomputeGroups: function ( geometry ) {\r\n\r\n\t\tvar group;\r\n\t\tvar groups = [];\r\n\t\tvar materialIndex;\r\n\r\n\t\tvar faces = geometry.faces;\r\n\r\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\t// materials\r\n\r\n\t\t\tif ( face.materialIndex !== materialIndex ) {\r\n\r\n\t\t\t\tmaterialIndex = face.materialIndex;\r\n\r\n\t\t\t\tif ( group !== undefined ) {\r\n\r\n\t\t\t\t\tgroup.count = ( i * 3 ) - group.start;\r\n\t\t\t\t\tgroups.push( group );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgroup = {\r\n\t\t\t\t\tstart: i * 3,\r\n\t\t\t\t\tmaterialIndex: materialIndex\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( group !== undefined ) {\r\n\r\n\t\t\tgroup.count = ( i * 3 ) - group.start;\r\n\t\t\tgroups.push( group );\r\n\r\n\t\t}\r\n\r\n\t\tthis.groups = groups;\r\n\r\n\t},\r\n\r\n\tfromGeometry: function ( geometry ) {\r\n\r\n\t\tvar faces = geometry.faces;\r\n\t\tvar vertices = geometry.vertices;\r\n\t\tvar faceVertexUvs = geometry.faceVertexUvs;\r\n\r\n\t\tvar hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;\r\n\t\tvar hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;\r\n\r\n\t\t// morphs\r\n\r\n\t\tvar morphTargets = geometry.morphTargets;\r\n\t\tvar morphTargetsLength = morphTargets.length;\r\n\r\n\t\tvar morphTargetsPosition;\r\n\r\n\t\tif ( morphTargetsLength > 0 ) {\r\n\r\n\t\t\tmorphTargetsPosition = [];\r\n\r\n\t\t\tfor ( var i = 0; i < morphTargetsLength; i ++ ) {\r\n\r\n\t\t\t\tmorphTargetsPosition[ i ] = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.morphTargets.position = morphTargetsPosition;\r\n\r\n\t\t}\r\n\r\n\t\tvar morphNormals = geometry.morphNormals;\r\n\t\tvar morphNormalsLength = morphNormals.length;\r\n\r\n\t\tvar morphTargetsNormal;\r\n\r\n\t\tif ( morphNormalsLength > 0 ) {\r\n\r\n\t\t\tmorphTargetsNormal = [];\r\n\r\n\t\t\tfor ( var i = 0; i < morphNormalsLength; i ++ ) {\r\n\r\n\t\t\t\tmorphTargetsNormal[ i ] = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.morphTargets.normal = morphTargetsNormal;\r\n\r\n\t\t}\r\n\r\n\t\t// skins\r\n\r\n\t\tvar skinIndices = geometry.skinIndices;\r\n\t\tvar skinWeights = geometry.skinWeights;\r\n\r\n\t\tvar hasSkinIndices = skinIndices.length === vertices.length;\r\n\t\tvar hasSkinWeights = skinWeights.length === vertices.length;\r\n\r\n\t\t//\r\n\r\n\t\tfor ( var i = 0; i < faces.length; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\tthis.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );\r\n\r\n\t\t\tvar vertexNormals = face.vertexNormals;\r\n\r\n\t\t\tif ( vertexNormals.length === 3 ) {\r\n\r\n\t\t\t\tthis.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar normal = face.normal;\r\n\r\n\t\t\t\tthis.normals.push( normal, normal, normal );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar vertexColors = face.vertexColors;\r\n\r\n\t\t\tif ( vertexColors.length === 3 ) {\r\n\r\n\t\t\t\tthis.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar color = face.color;\r\n\r\n\t\t\t\tthis.colors.push( color, color, color );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexUv === true ) {\r\n\r\n\t\t\t\tvar vertexUvs = faceVertexUvs[ 0 ][ i ];\r\n\r\n\t\t\t\tif ( vertexUvs !== undefined ) {\r\n\r\n\t\t\t\t\tthis.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );\r\n\r\n\t\t\t\t\tthis.uvs.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasFaceVertexUv2 === true ) {\r\n\r\n\t\t\t\tvar vertexUvs = faceVertexUvs[ 1 ][ i ];\r\n\r\n\t\t\t\tif ( vertexUvs !== undefined ) {\r\n\r\n\t\t\t\t\tthis.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );\r\n\r\n\t\t\t\t\tthis.uvs2.push( new THREE.Vector2(), new THREE.Vector2(), new THREE.Vector2() );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// morphs\r\n\r\n\t\t\tfor ( var j = 0; j < morphTargetsLength; j ++ ) {\r\n\r\n\t\t\t\tvar morphTarget = morphTargets[ j ].vertices;\r\n\r\n\t\t\t\tmorphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var j = 0; j < morphNormalsLength; j ++ ) {\r\n\r\n\t\t\t\tvar morphNormal = morphNormals[ j ].vertexNormals[ i ];\r\n\r\n\t\t\t\tmorphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// skins\r\n\r\n\t\t\tif ( hasSkinIndices ) {\r\n\r\n\t\t\t\tthis.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( hasSkinWeights ) {\r\n\r\n\t\t\t\tthis.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.computeGroups( geometry );\r\n\r\n\t\tthis.verticesNeedUpdate = geometry.verticesNeedUpdate;\r\n\t\tthis.normalsNeedUpdate = geometry.normalsNeedUpdate;\r\n\t\tthis.colorsNeedUpdate = geometry.colorsNeedUpdate;\r\n\t\tthis.uvsNeedUpdate = geometry.uvsNeedUpdate;\r\n\t\tthis.groupsNeedUpdate = geometry.groupsNeedUpdate;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/core/BufferGeometry.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BufferGeometry = function () {\r\n\r\n\tObject.defineProperty( this, 'id', { value: THREE.GeometryIdCount ++ } );\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'BufferGeometry';\r\n\r\n\tthis.index = null;\r\n\tthis.attributes = {};\r\n\r\n\tthis.morphAttributes = {};\r\n\r\n\tthis.groups = [];\r\n\r\n\tthis.boundingBox = null;\r\n\tthis.boundingSphere = null;\r\n\r\n\tthis.drawRange = { start: 0, count: Infinity };\r\n\r\n};\r\n\r\nObject.assign( THREE.BufferGeometry.prototype, THREE.EventDispatcher.prototype, {\r\n\r\n\tgetIndex: function () {\r\n\r\n\t\treturn this.index;\r\n\r\n\t},\r\n\r\n\tsetIndex: function ( index ) {\r\n\r\n\t\tthis.index = index;\r\n\r\n\t},\r\n\r\n\taddAttribute: function ( name, attribute ) {\r\n\r\n\t\tif ( attribute instanceof THREE.BufferAttribute === false && attribute instanceof THREE.InterleavedBufferAttribute === false ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );\r\n\r\n\t\t\tthis.addAttribute( name, new THREE.BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( name === 'index' ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );\r\n\t\t\tthis.setIndex( attribute );\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tthis.attributes[ name ] = attribute;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetAttribute: function ( name ) {\r\n\r\n\t\treturn this.attributes[ name ];\r\n\r\n\t},\r\n\r\n\tremoveAttribute: function ( name ) {\r\n\r\n\t\tdelete this.attributes[ name ];\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddGroup: function ( start, count, materialIndex ) {\r\n\r\n\t\tthis.groups.push( {\r\n\r\n\t\t\tstart: start,\r\n\t\t\tcount: count,\r\n\t\t\tmaterialIndex: materialIndex !== undefined ? materialIndex : 0\r\n\r\n\t\t} );\r\n\r\n\t},\r\n\r\n\tclearGroups: function () {\r\n\r\n\t\tthis.groups = [];\r\n\r\n\t},\r\n\r\n\tsetDrawRange: function ( start, count ) {\r\n\r\n\t\tthis.drawRange.start = start;\r\n\t\tthis.drawRange.count = count;\r\n\r\n\t},\r\n\r\n\tapplyMatrix: function ( matrix ) {\r\n\r\n\t\tvar position = this.attributes.position;\r\n\r\n\t\tif ( position !== undefined ) {\r\n\r\n\t\t\tmatrix.applyToVector3Array( position.array );\r\n\t\t\tposition.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tvar normal = this.attributes.normal;\r\n\r\n\t\tif ( normal !== undefined ) {\r\n\r\n\t\t\tvar normalMatrix = new THREE.Matrix3().getNormalMatrix( matrix );\r\n\r\n\t\t\tnormalMatrix.applyToVector3Array( normal.array );\r\n\t\t\tnormal.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingBox !== null ) {\r\n\r\n\t\t\tthis.computeBoundingBox();\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.computeBoundingSphere();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\trotateX: function () {\r\n\r\n\t\t// rotate geometry around world x-axis\r\n\r\n\t\tvar m1;\r\n\r\n\t\treturn function rotateX( angle ) {\r\n\r\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n\t\t\tm1.makeRotationX( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateY: function () {\r\n\r\n\t\t// rotate geometry around world y-axis\r\n\r\n\t\tvar m1;\r\n\r\n\t\treturn function rotateY( angle ) {\r\n\r\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n\t\t\tm1.makeRotationY( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\trotateZ: function () {\r\n\r\n\t\t// rotate geometry around world z-axis\r\n\r\n\t\tvar m1;\r\n\r\n\t\treturn function rotateZ( angle ) {\r\n\r\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n\t\t\tm1.makeRotationZ( angle );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttranslate: function () {\r\n\r\n\t\t// translate geometry\r\n\r\n\t\tvar m1;\r\n\r\n\t\treturn function translate( x, y, z ) {\r\n\r\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n\t\t\tm1.makeTranslation( x, y, z );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tscale: function () {\r\n\r\n\t\t// scale geometry\r\n\r\n\t\tvar m1;\r\n\r\n\t\treturn function scale( x, y, z ) {\r\n\r\n\t\t\tif ( m1 === undefined ) m1 = new THREE.Matrix4();\r\n\r\n\t\t\tm1.makeScale( x, y, z );\r\n\r\n\t\t\tthis.applyMatrix( m1 );\r\n\r\n\t\t\treturn this;\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tlookAt: function () {\r\n\r\n\t\tvar obj;\r\n\r\n\t\treturn function lookAt( vector ) {\r\n\r\n\t\t\tif ( obj === undefined ) obj = new THREE.Object3D();\r\n\r\n\t\t\tobj.lookAt( vector );\r\n\r\n\t\t\tobj.updateMatrix();\r\n\r\n\t\t\tthis.applyMatrix( obj.matrix );\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcenter: function () {\r\n\r\n\t\tthis.computeBoundingBox();\r\n\r\n\t\tvar offset = this.boundingBox.center().negate();\r\n\r\n\t\tthis.translate( offset.x, offset.y, offset.z );\r\n\r\n\t\treturn offset;\r\n\r\n\t},\r\n\r\n\tsetFromObject: function ( object ) {\r\n\r\n\t\t// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );\r\n\r\n\t\tvar geometry = object.geometry;\r\n\r\n\t\tif ( object instanceof THREE.Points || object instanceof THREE.Line ) {\r\n\r\n\t\t\tvar positions = new THREE.Float32Attribute( geometry.vertices.length * 3, 3 );\r\n\t\t\tvar colors = new THREE.Float32Attribute( geometry.colors.length * 3, 3 );\r\n\r\n\t\t\tthis.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );\r\n\t\t\tthis.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );\r\n\r\n\t\t\tif ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {\r\n\r\n\t\t\t\tvar lineDistances = new THREE.Float32Attribute( geometry.lineDistances.length, 1 );\r\n\r\n\t\t\t\tthis.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( geometry.boundingSphere !== null ) {\r\n\r\n\t\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( geometry.boundingBox !== null ) {\r\n\r\n\t\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\tif ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\t\tthis.fromGeometry( geometry );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tupdateFromObject: function ( object ) {\r\n\r\n\t\tvar geometry = object.geometry;\r\n\r\n\t\tif ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\tvar direct = geometry.__directGeometry;\r\n\r\n\t\t\tif ( direct === undefined ) {\r\n\r\n\t\t\t\treturn this.fromGeometry( geometry );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdirect.verticesNeedUpdate = geometry.verticesNeedUpdate;\r\n\t\t\tdirect.normalsNeedUpdate = geometry.normalsNeedUpdate;\r\n\t\t\tdirect.colorsNeedUpdate = geometry.colorsNeedUpdate;\r\n\t\t\tdirect.uvsNeedUpdate = geometry.uvsNeedUpdate;\r\n\t\t\tdirect.groupsNeedUpdate = geometry.groupsNeedUpdate;\r\n\r\n\t\t\tgeometry.verticesNeedUpdate = false;\r\n\t\t\tgeometry.normalsNeedUpdate = false;\r\n\t\t\tgeometry.colorsNeedUpdate = false;\r\n\t\t\tgeometry.uvsNeedUpdate = false;\r\n\t\t\tgeometry.groupsNeedUpdate = false;\r\n\r\n\t\t\tgeometry = direct;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.verticesNeedUpdate === true ) {\r\n\r\n\t\t\tvar attribute = this.attributes.position;\r\n\r\n\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\tattribute.copyVector3sArray( geometry.vertices );\r\n\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.verticesNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.normalsNeedUpdate === true ) {\r\n\r\n\t\t\tvar attribute = this.attributes.normal;\r\n\r\n\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\tattribute.copyVector3sArray( geometry.normals );\r\n\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.normalsNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.colorsNeedUpdate === true ) {\r\n\r\n\t\t\tvar attribute = this.attributes.color;\r\n\r\n\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\tattribute.copyColorsArray( geometry.colors );\r\n\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.colorsNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.uvsNeedUpdate ) {\r\n\r\n\t\t\tvar attribute = this.attributes.uv;\r\n\r\n\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\tattribute.copyVector2sArray( geometry.uvs );\r\n\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.uvsNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.lineDistancesNeedUpdate ) {\r\n\r\n\t\t\tvar attribute = this.attributes.lineDistance;\r\n\r\n\t\t\tif ( attribute !== undefined ) {\r\n\r\n\t\t\t\tattribute.copyArray( geometry.lineDistances );\r\n\t\t\t\tattribute.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.lineDistancesNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.groupsNeedUpdate ) {\r\n\r\n\t\t\tgeometry.computeGroups( object.geometry );\r\n\t\t\tthis.groups = geometry.groups;\r\n\r\n\t\t\tgeometry.groupsNeedUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tfromGeometry: function ( geometry ) {\r\n\r\n\t\tgeometry.__directGeometry = new THREE.DirectGeometry().fromGeometry( geometry );\r\n\r\n\t\treturn this.fromDirectGeometry( geometry.__directGeometry );\r\n\r\n\t},\r\n\r\n\tfromDirectGeometry: function ( geometry ) {\r\n\r\n\t\tvar positions = new Float32Array( geometry.vertices.length * 3 );\r\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );\r\n\r\n\t\tif ( geometry.normals.length > 0 ) {\r\n\r\n\t\t\tvar normals = new Float32Array( geometry.normals.length * 3 );\r\n\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.colors.length > 0 ) {\r\n\r\n\t\t\tvar colors = new Float32Array( geometry.colors.length * 3 );\r\n\t\t\tthis.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.uvs.length > 0 ) {\r\n\r\n\t\t\tvar uvs = new Float32Array( geometry.uvs.length * 2 );\r\n\t\t\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.uvs2.length > 0 ) {\r\n\r\n\t\t\tvar uvs2 = new Float32Array( geometry.uvs2.length * 2 );\r\n\t\t\tthis.addAttribute( 'uv2', new THREE.BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.indices.length > 0 ) {\r\n\r\n\t\t\tvar TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;\r\n\t\t\tvar indices = new TypeArray( geometry.indices.length * 3 );\r\n\t\t\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );\r\n\r\n\t\t}\r\n\r\n\t\t// groups\r\n\r\n\t\tthis.groups = geometry.groups;\r\n\r\n\t\t// morphs\r\n\r\n\t\tfor ( var name in geometry.morphTargets ) {\r\n\r\n\t\t\tvar array = [];\r\n\t\t\tvar morphTargets = geometry.morphTargets[ name ];\r\n\r\n\t\t\tfor ( var i = 0, l = morphTargets.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar morphTarget = morphTargets[ i ];\r\n\r\n\t\t\t\tvar attribute = new THREE.Float32Attribute( morphTarget.length * 3, 3 );\r\n\r\n\t\t\t\tarray.push( attribute.copyVector3sArray( morphTarget ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.morphAttributes[ name ] = array;\r\n\r\n\t\t}\r\n\r\n\t\t// skinning\r\n\r\n\t\tif ( geometry.skinIndices.length > 0 ) {\r\n\r\n\t\t\tvar skinIndices = new THREE.Float32Attribute( geometry.skinIndices.length * 4, 4 );\r\n\t\t\tthis.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.skinWeights.length > 0 ) {\r\n\r\n\t\t\tvar skinWeights = new THREE.Float32Attribute( geometry.skinWeights.length * 4, 4 );\r\n\t\t\tthis.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( geometry.boundingSphere !== null ) {\r\n\r\n\t\t\tthis.boundingSphere = geometry.boundingSphere.clone();\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry.boundingBox !== null ) {\r\n\r\n\t\t\tthis.boundingBox = geometry.boundingBox.clone();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcomputeBoundingBox: function () {\r\n\r\n\t\tif ( this.boundingBox === null ) {\r\n\r\n\t\t\tthis.boundingBox = new THREE.Box3();\r\n\r\n\t\t}\r\n\r\n\t\tvar positions = this.attributes.position.array;\r\n\r\n\t\tif ( positions !== undefined ) {\r\n\r\n\t\t\tthis.boundingBox.setFromArray( positions );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.boundingBox.makeEmpty();\r\n\r\n\t\t}\r\n\r\n\t\tif ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {\r\n\r\n\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tcomputeBoundingSphere: function () {\r\n\r\n\t\tvar box = new THREE.Box3();\r\n\t\tvar vector = new THREE.Vector3();\r\n\r\n\t\treturn function computeBoundingSphere() {\r\n\r\n\t\t\tif ( this.boundingSphere === null ) {\r\n\r\n\t\t\t\tthis.boundingSphere = new THREE.Sphere();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar positions = this.attributes.position.array;\r\n\r\n\t\t\tif ( positions ) {\r\n\r\n\t\t\t\tvar center = this.boundingSphere.center;\r\n\r\n\t\t\t\tbox.setFromArray( positions );\r\n\t\t\t\tbox.center( center );\r\n\r\n\t\t\t\t// hoping to find a boundingSphere with a radius smaller than the\r\n\t\t\t\t// boundingSphere of the boundingBox: sqrt(3) smaller in the best case\r\n\r\n\t\t\t\tvar maxRadiusSq = 0;\r\n\r\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\tvector.fromArray( positions, i );\r\n\t\t\t\t\tmaxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.boundingSphere.radius = Math.sqrt( maxRadiusSq );\r\n\r\n\t\t\t\tif ( isNaN( this.boundingSphere.radius ) ) {\r\n\r\n\t\t\t\t\tconsole.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\tcomputeFaceNormals: function () {\r\n\r\n\t\t// backwards compatibility\r\n\r\n\t},\r\n\r\n\tcomputeVertexNormals: function () {\r\n\r\n\t\tvar index = this.index;\r\n\t\tvar attributes = this.attributes;\r\n\t\tvar groups = this.groups;\r\n\r\n\t\tif ( attributes.position ) {\r\n\r\n\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\tif ( attributes.normal === undefined ) {\r\n\r\n\t\t\t\tthis.addAttribute( 'normal', new THREE.BufferAttribute( new Float32Array( positions.length ), 3 ) );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// reset existing normals to zero\r\n\r\n\t\t\t\tvar array = attributes.normal.array;\r\n\r\n\t\t\t\tfor ( var i = 0, il = array.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tarray[ i ] = 0;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar normals = attributes.normal.array;\r\n\r\n\t\t\tvar vA, vB, vC,\r\n\r\n\t\t\tpA = new THREE.Vector3(),\r\n\t\t\tpB = new THREE.Vector3(),\r\n\t\t\tpC = new THREE.Vector3(),\r\n\r\n\t\t\tcb = new THREE.Vector3(),\r\n\t\t\tab = new THREE.Vector3();\r\n\r\n\t\t\t// indexed elements\r\n\r\n\t\t\tif ( index ) {\r\n\r\n\t\t\t\tvar indices = index.array;\r\n\r\n\t\t\t\tif ( groups.length === 0 ) {\r\n\r\n\t\t\t\t\tthis.addGroup( 0, indices.length );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var j = 0, jl = groups.length; j < jl; ++ j ) {\r\n\r\n\t\t\t\t\tvar group = groups[ j ];\r\n\r\n\t\t\t\t\tvar start = group.start;\r\n\t\t\t\t\tvar count = group.count;\r\n\r\n\t\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\t\tvA = indices[ i + 0 ] * 3;\r\n\t\t\t\t\t\tvB = indices[ i + 1 ] * 3;\r\n\t\t\t\t\t\tvC = indices[ i + 2 ] * 3;\r\n\r\n\t\t\t\t\t\tpA.fromArray( positions, vA );\r\n\t\t\t\t\t\tpB.fromArray( positions, vB );\r\n\t\t\t\t\t\tpC.fromArray( positions, vC );\r\n\r\n\t\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\t\t\tnormals[ vA ] += cb.x;\r\n\t\t\t\t\t\tnormals[ vA + 1 ] += cb.y;\r\n\t\t\t\t\t\tnormals[ vA + 2 ] += cb.z;\r\n\r\n\t\t\t\t\t\tnormals[ vB ] += cb.x;\r\n\t\t\t\t\t\tnormals[ vB + 1 ] += cb.y;\r\n\t\t\t\t\t\tnormals[ vB + 2 ] += cb.z;\r\n\r\n\t\t\t\t\t\tnormals[ vC ] += cb.x;\r\n\t\t\t\t\t\tnormals[ vC + 1 ] += cb.y;\r\n\t\t\t\t\t\tnormals[ vC + 2 ] += cb.z;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// non-indexed elements (unconnected triangle soup)\r\n\r\n\t\t\t\tfor ( var i = 0, il = positions.length; i < il; i += 9 ) {\r\n\r\n\t\t\t\t\tpA.fromArray( positions, i );\r\n\t\t\t\t\tpB.fromArray( positions, i + 3 );\r\n\t\t\t\t\tpC.fromArray( positions, i + 6 );\r\n\r\n\t\t\t\t\tcb.subVectors( pC, pB );\r\n\t\t\t\t\tab.subVectors( pA, pB );\r\n\t\t\t\t\tcb.cross( ab );\r\n\r\n\t\t\t\t\tnormals[ i ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 1 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 2 ] = cb.z;\r\n\r\n\t\t\t\t\tnormals[ i + 3 ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 4 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 5 ] = cb.z;\r\n\r\n\t\t\t\t\tnormals[ i + 6 ] = cb.x;\r\n\t\t\t\t\tnormals[ i + 7 ] = cb.y;\r\n\t\t\t\t\tnormals[ i + 8 ] = cb.z;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.normalizeNormals();\r\n\r\n\t\t\tattributes.normal.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tmerge: function ( geometry, offset ) {\r\n\r\n\t\tif ( geometry instanceof THREE.BufferGeometry === false ) {\r\n\r\n\t\t\tconsole.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( offset === undefined ) offset = 0;\r\n\r\n\t\tvar attributes = this.attributes;\r\n\r\n\t\tfor ( var key in attributes ) {\r\n\r\n\t\t\tif ( geometry.attributes[ key ] === undefined ) continue;\r\n\r\n\t\t\tvar attribute1 = attributes[ key ];\r\n\t\t\tvar attributeArray1 = attribute1.array;\r\n\r\n\t\t\tvar attribute2 = geometry.attributes[ key ];\r\n\t\t\tvar attributeArray2 = attribute2.array;\r\n\r\n\t\t\tvar attributeSize = attribute2.itemSize;\r\n\r\n\t\t\tfor ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {\r\n\r\n\t\t\t\tattributeArray1[ j ] = attributeArray2[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tnormalizeNormals: function () {\r\n\r\n\t\tvar normals = this.attributes.normal.array;\r\n\r\n\t\tvar x, y, z, n;\r\n\r\n\t\tfor ( var i = 0, il = normals.length; i < il; i += 3 ) {\r\n\r\n\t\t\tx = normals[ i ];\r\n\t\t\ty = normals[ i + 1 ];\r\n\t\t\tz = normals[ i + 2 ];\r\n\r\n\t\t\tn = 1.0 / Math.sqrt( x * x + y * y + z * z );\r\n\r\n\t\t\tnormals[ i ] *= n;\r\n\t\t\tnormals[ i + 1 ] *= n;\r\n\t\t\tnormals[ i + 2 ] *= n;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttoNonIndexed: function () {\r\n\r\n\t\tif ( this.index === null ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );\r\n\t\t\treturn this;\r\n\r\n\t\t}\r\n\r\n\t\tvar geometry2 = new THREE.BufferGeometry();\r\n\r\n\t\tvar indices = this.index.array;\r\n\t\tvar attributes = this.attributes;\r\n\r\n\t\tfor ( var name in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ name ];\r\n\r\n\t\t\tvar array = attribute.array;\r\n\t\t\tvar itemSize = attribute.itemSize;\r\n\r\n\t\t\tvar array2 = new array.constructor( indices.length * itemSize );\r\n\r\n\t\t\tvar index = 0, index2 = 0;\r\n\r\n\t\t\tfor ( var i = 0, l = indices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tindex = indices[ i ] * itemSize;\r\n\r\n\t\t\t\tfor ( var j = 0; j < itemSize; j ++ ) {\r\n\r\n\t\t\t\t\tarray2[ index2 ++ ] = array[ index ++ ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry2.addAttribute( name, new THREE.BufferAttribute( array2, itemSize ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn geometry2;\r\n\r\n\t},\r\n\r\n\ttoJSON: function () {\r\n\r\n\t\tvar data = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.4,\r\n\t\t\t\ttype: 'BufferGeometry',\r\n\t\t\t\tgenerator: 'BufferGeometry.toJSON'\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// standard BufferGeometry serialization\r\n\r\n\t\tdata.uuid = this.uuid;\r\n\t\tdata.type = this.type;\r\n\t\tif ( this.name !== '' ) data.name = this.name;\r\n\r\n\t\tif ( this.parameters !== undefined ) {\r\n\r\n\t\t\tvar parameters = this.parameters;\r\n\r\n\t\t\tfor ( var key in parameters ) {\r\n\r\n\t\t\t\tif ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn data;\r\n\r\n\t\t}\r\n\r\n\t\tdata.data = { attributes: {} };\r\n\r\n\t\tvar index = this.index;\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\tvar array = Array.prototype.slice.call( index.array );\r\n\r\n\t\t\tdata.data.index = {\r\n\t\t\t\ttype: index.array.constructor.name,\r\n\t\t\t\tarray: array\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tvar attributes = this.attributes;\r\n\r\n\t\tfor ( var key in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ key ];\r\n\r\n\t\t\tvar array = Array.prototype.slice.call( attribute.array );\r\n\r\n\t\t\tdata.data.attributes[ key ] = {\r\n\t\t\t\titemSize: attribute.itemSize,\r\n\t\t\t\ttype: attribute.array.constructor.name,\r\n\t\t\t\tarray: array,\r\n\t\t\t\tnormalized: attribute.normalized\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tvar groups = this.groups;\r\n\r\n\t\tif ( groups.length > 0 ) {\r\n\r\n\t\t\tdata.data.groups = JSON.parse( JSON.stringify( groups ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar boundingSphere = this.boundingSphere;\r\n\r\n\t\tif ( boundingSphere !== null ) {\r\n\r\n\t\t\tdata.data.boundingSphere = {\r\n\t\t\t\tcenter: boundingSphere.center.toArray(),\r\n\t\t\t\tradius: boundingSphere.radius\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\t/*\r\n\t\t// Handle primitives\r\n\r\n\t\tvar parameters = this.parameters;\r\n\r\n\t\tif ( parameters !== undefined ) {\r\n\r\n\t\t\tvar values = [];\r\n\r\n\t\t\tfor ( var key in parameters ) {\r\n\r\n\t\t\t\tvalues.push( parameters[ key ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar geometry = Object.create( this.constructor.prototype );\r\n\t\t\tthis.constructor.apply( geometry, values );\r\n\t\t\treturn geometry;\r\n\r\n\t\t}\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\t\t*/\r\n\r\n\t\treturn new THREE.BufferGeometry().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tvar index = source.index;\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\tthis.setIndex( index.clone() );\r\n\r\n\t\t}\r\n\r\n\t\tvar attributes = source.attributes;\r\n\r\n\t\tfor ( var name in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ name ];\r\n\t\t\tthis.addAttribute( name, attribute.clone() );\r\n\r\n\t\t}\r\n\r\n\t\tvar groups = source.groups;\r\n\r\n\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar group = groups[ i ];\r\n\t\t\tthis.addGroup( group.start, group.count, group.materialIndex );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n} );\r\n\r\nTHREE.BufferGeometry.MaxIndex = 65535;\r\n\r\n// File:src/core/InstancedBufferGeometry.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\n\r\nTHREE.InstancedBufferGeometry = function () {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'InstancedBufferGeometry';\r\n\tthis.maxInstancedCount = undefined;\r\n\r\n};\r\n\r\nTHREE.InstancedBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.InstancedBufferGeometry.prototype.constructor = THREE.InstancedBufferGeometry;\r\n\r\nTHREE.InstancedBufferGeometry.prototype.addGroup = function ( start, count, instances ) {\r\n\r\n\tthis.groups.push( {\r\n\r\n\t\tstart: start,\r\n\t\tcount: count,\r\n\t\tinstances: instances\r\n\r\n\t} );\r\n\r\n};\r\n\r\nTHREE.InstancedBufferGeometry.prototype.copy = function ( source ) {\r\n\r\n\tvar index = source.index;\r\n\r\n\tif ( index !== null ) {\r\n\r\n\t\tthis.setIndex( index.clone() );\r\n\r\n\t}\r\n\r\n\tvar attributes = source.attributes;\r\n\r\n\tfor ( var name in attributes ) {\r\n\r\n\t\tvar attribute = attributes[ name ];\r\n\t\tthis.addAttribute( name, attribute.clone() );\r\n\r\n\t}\r\n\r\n\tvar groups = source.groups;\r\n\r\n\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n\t\tvar group = groups[ i ];\r\n\t\tthis.addGroup( group.start, group.count, group.instances );\r\n\r\n\t}\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/core/Uniform.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Uniform = function ( value ) {\r\n\r\n\tif ( typeof value === 'string' ) {\r\n\r\n\t\tconsole.warn( 'THREE.Uniform: Type parameter is no longer needed.' );\r\n\t\tvalue = arguments[ 1 ];\r\n\r\n\t}\r\n\r\n\tthis.value = value;\r\n\r\n\tthis.dynamic = false;\r\n\r\n};\r\n\r\nTHREE.Uniform.prototype = {\r\n\r\n\tconstructor: THREE.Uniform,\r\n\r\n\tonUpdate: function ( callback ) {\r\n\r\n\t\tthis.dynamic = true;\r\n\t\tthis.onUpdateCallback = callback;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/animation/AnimationAction.js\r\n\r\n/**\r\n *\r\n * Action provided by AnimationMixer for scheduling clip playback on specific\r\n * objects.\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n *\r\n */\r\n\r\nTHREE.AnimationAction = function() {\r\n\r\n\tthrow new Error( \"THREE.AnimationAction: \" +\r\n\t\t\t\"Use mixer.clipAction for construction.\" );\r\n\r\n};\r\n\r\nTHREE.AnimationAction._new =\r\n\t\tfunction AnimationAction( mixer, clip, localRoot ) {\r\n\r\n\tthis._mixer = mixer;\r\n\tthis._clip = clip;\r\n\tthis._localRoot = localRoot || null;\r\n\r\n\tvar tracks = clip.tracks,\r\n\t\tnTracks = tracks.length,\r\n\t\tinterpolants = new Array( nTracks );\r\n\r\n\tvar interpolantSettings = {\r\n\t\t\tendingStart: \tTHREE.ZeroCurvatureEnding,\r\n\t\t\tendingEnd:\t\tTHREE.ZeroCurvatureEnding\r\n\t};\r\n\r\n\tfor ( var i = 0; i !== nTracks; ++ i ) {\r\n\r\n\t\tvar interpolant = tracks[ i ].createInterpolant( null );\r\n\t\tinterpolants[ i ] = interpolant;\r\n\t\tinterpolant.settings = interpolantSettings;\r\n\r\n\t}\r\n\r\n\tthis._interpolantSettings = interpolantSettings;\r\n\r\n\tthis._interpolants = interpolants;\t// bound by the mixer\r\n\r\n\t// inside: PropertyMixer (managed by the mixer)\r\n\tthis._propertyBindings = new Array( nTracks );\r\n\r\n\tthis._cacheIndex = null;\t\t\t// for the memory manager\r\n\tthis._byClipCacheIndex = null;\t\t// for the memory manager\r\n\r\n\tthis._timeScaleInterpolant = null;\r\n\tthis._weightInterpolant = null;\r\n\r\n\tthis.loop = THREE.LoopRepeat;\r\n\tthis._loopCount = -1;\r\n\r\n\t// global mixer time when the action is to be started\r\n\t// it's set back to 'null' upon start of the action\r\n\tthis._startTime = null;\r\n\r\n\t// scaled local time of the action\r\n\t// gets clamped or wrapped to 0..clip.duration according to loop\r\n\tthis.time = 0;\r\n\r\n\tthis.timeScale = 1;\r\n\tthis._effectiveTimeScale = 1;\r\n\r\n\tthis.weight = 1;\r\n\tthis._effectiveWeight = 1;\r\n\r\n\tthis.repetitions = Infinity; \t\t// no. of repetitions when looping\r\n\r\n\tthis.paused = false;\t\t\t\t// false -> zero effective time scale\r\n\tthis.enabled = true;\t\t\t\t// true -> zero effective weight\r\n\r\n\tthis.clampWhenFinished \t= false;\t// keep feeding the last frame?\r\n\r\n\tthis.zeroSlopeAtStart \t= true;\t\t// for smooth interpolation w/o separate\r\n\tthis.zeroSlopeAtEnd\t\t= true;\t\t// clips for start, loop and end\r\n\r\n};\r\n\r\nTHREE.AnimationAction._new.prototype = {\r\n\r\n\tconstructor: THREE.AnimationAction._new,\r\n\r\n\t// State & Scheduling\r\n\r\n\tplay: function() {\r\n\r\n\t\tthis._mixer._activateAction( this );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tstop: function() {\r\n\r\n\t\tthis._mixer._deactivateAction( this );\r\n\r\n\t\treturn this.reset();\r\n\r\n\t},\r\n\r\n\treset: function() {\r\n\r\n\t\tthis.paused = false;\r\n\t\tthis.enabled = true;\r\n\r\n\t\tthis.time = 0;\t\t\t// restart clip\r\n\t\tthis._loopCount = -1;\t// forget previous loops\r\n\t\tthis._startTime = null;\t// forget scheduling\r\n\r\n\t\treturn this.stopFading().stopWarping();\r\n\r\n\t},\r\n\r\n\tisRunning: function() {\r\n\r\n\t\tvar start = this._startTime;\r\n\r\n\t\treturn this.enabled && ! this.paused && this.timeScale !== 0 &&\r\n\t\t\t\tthis._startTime === null && this._mixer._isActiveAction( this );\r\n\r\n\t},\r\n\r\n\t// return true when play has been called\r\n\tisScheduled: function() {\r\n\r\n\t\treturn this._mixer._isActiveAction( this );\r\n\r\n\t},\r\n\r\n\tstartAt: function( time ) {\r\n\r\n\t\tthis._startTime = time;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetLoop: function( mode, repetitions ) {\r\n\r\n\t\tthis.loop = mode;\r\n\t\tthis.repetitions = repetitions;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// Weight\r\n\r\n\t// set the weight stopping any scheduled fading\r\n\t// although .enabled = false yields an effective weight of zero, this\r\n\t// method does *not* change .enabled, because it would be confusing\r\n\tsetEffectiveWeight: function( weight ) {\r\n\r\n\t\tthis.weight = weight;\r\n\r\n\t\t// note: same logic as when updated at runtime\r\n\t\tthis._effectiveWeight = this.enabled ? weight : 0;\r\n\r\n\t\treturn this.stopFading();\r\n\r\n\t},\r\n\r\n\t// return the weight considering fading and .enabled\r\n\tgetEffectiveWeight: function() {\r\n\r\n\t\treturn this._effectiveWeight;\r\n\r\n\t},\r\n\r\n\tfadeIn: function( duration ) {\r\n\r\n\t\treturn this._scheduleFading( duration, 0, 1 );\r\n\r\n\t},\r\n\r\n\tfadeOut: function( duration ) {\r\n\r\n\t\treturn this._scheduleFading( duration, 1, 0 );\r\n\r\n\t},\r\n\r\n\tcrossFadeFrom: function( fadeOutAction, duration, warp ) {\r\n\r\n\t\tvar mixer = this._mixer;\r\n\r\n\t\tfadeOutAction.fadeOut( duration );\r\n\t\tthis.fadeIn( duration );\r\n\r\n\t\tif( warp ) {\r\n\r\n\t\t\tvar fadeInDuration = this._clip.duration,\r\n\t\t\t\tfadeOutDuration = fadeOutAction._clip.duration,\r\n\r\n\t\t\t\tstartEndRatio = fadeOutDuration / fadeInDuration,\r\n\t\t\t\tendStartRatio = fadeInDuration / fadeOutDuration;\r\n\r\n\t\t\tfadeOutAction.warp( 1.0, startEndRatio, duration );\r\n\t\t\tthis.warp( endStartRatio, 1.0, duration );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tcrossFadeTo: function( fadeInAction, duration, warp ) {\r\n\r\n\t\treturn fadeInAction.crossFadeFrom( this, duration, warp );\r\n\r\n\t},\r\n\r\n\tstopFading: function() {\r\n\r\n\t\tvar weightInterpolant = this._weightInterpolant;\r\n\r\n\t\tif ( weightInterpolant !== null ) {\r\n\r\n\t\t\tthis._weightInterpolant = null;\r\n\t\t\tthis._mixer._takeBackControlInterpolant( weightInterpolant );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// Time Scale Control\r\n\r\n\t// set the weight stopping any scheduled warping\r\n\t// although .paused = true yields an effective time scale of zero, this\r\n\t// method does *not* change .paused, because it would be confusing\r\n\tsetEffectiveTimeScale: function( timeScale ) {\r\n\r\n\t\tthis.timeScale = timeScale;\r\n\t\tthis._effectiveTimeScale = this.paused ? 0 :timeScale;\r\n\r\n\t\treturn this.stopWarping();\r\n\r\n\t},\r\n\r\n\t// return the time scale considering warping and .paused\r\n\tgetEffectiveTimeScale: function() {\r\n\r\n\t\treturn this._effectiveTimeScale;\r\n\r\n\t},\r\n\r\n\tsetDuration: function( duration ) {\r\n\r\n\t\tthis.timeScale = this._clip.duration / duration;\r\n\r\n\t\treturn this.stopWarping();\r\n\r\n\t},\r\n\r\n\tsyncWith: function( action ) {\r\n\r\n\t\tthis.time = action.time;\r\n\t\tthis.timeScale = action.timeScale;\r\n\r\n\t\treturn this.stopWarping();\r\n\r\n\t},\r\n\r\n\thalt: function( duration ) {\r\n\r\n\t\treturn this.warp( this._effectiveTimeScale, 0, duration );\r\n\r\n\t},\r\n\r\n\twarp: function( startTimeScale, endTimeScale, duration ) {\r\n\r\n\t\tvar mixer = this._mixer, now = mixer.time,\r\n\t\t\tinterpolant = this._timeScaleInterpolant,\r\n\r\n\t\t\ttimeScale = this.timeScale;\r\n\r\n\t\tif ( interpolant === null ) {\r\n\r\n\t\t\tinterpolant = mixer._lendControlInterpolant(),\r\n\t\t\tthis._timeScaleInterpolant = interpolant;\r\n\r\n\t\t}\r\n\r\n\t\tvar times = interpolant.parameterPositions,\r\n\t\t\tvalues = interpolant.sampleValues;\r\n\r\n\t\ttimes[ 0 ] = now;\r\n\t\ttimes[ 1 ] = now + duration;\r\n\r\n\t\tvalues[ 0 ] = startTimeScale / timeScale;\r\n\t\tvalues[ 1 ] = endTimeScale / timeScale;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tstopWarping: function() {\r\n\r\n\t\tvar timeScaleInterpolant = this._timeScaleInterpolant;\r\n\r\n\t\tif ( timeScaleInterpolant !== null ) {\r\n\r\n\t\t\tthis._timeScaleInterpolant = null;\r\n\t\t\tthis._mixer._takeBackControlInterpolant( timeScaleInterpolant );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// Object Accessors\r\n\r\n\tgetMixer: function() {\r\n\r\n\t\treturn this._mixer;\r\n\r\n\t},\r\n\r\n\tgetClip: function() {\r\n\r\n\t\treturn this._clip;\r\n\r\n\t},\r\n\r\n\tgetRoot: function() {\r\n\r\n\t\treturn this._localRoot || this._mixer._root;\r\n\r\n\t},\r\n\r\n\t// Interna\r\n\r\n\t_update: function( time, deltaTime, timeDirection, accuIndex ) {\r\n\t\t// called by the mixer\r\n\r\n\t\tvar startTime = this._startTime;\r\n\r\n\t\tif ( startTime !== null ) {\r\n\r\n\t\t\t// check for scheduled start of action\r\n\r\n\t\t\tvar timeRunning = ( time - startTime ) * timeDirection;\r\n\t\t\tif ( timeRunning < 0 || timeDirection === 0 ) {\r\n\r\n\t\t\t\treturn; // yet to come / don't decide when delta = 0\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// start\r\n\r\n\t\t\tthis._startTime = null; // unschedule\r\n\t\t\tdeltaTime = timeDirection * timeRunning;\r\n\r\n\t\t}\r\n\r\n\t\t// apply time scale and advance time\r\n\r\n\t\tdeltaTime *= this._updateTimeScale( time );\r\n\t\tvar clipTime = this._updateTime( deltaTime );\r\n\r\n\t\t// note: _updateTime may disable the action resulting in\r\n\t\t// an effective weight of 0\r\n\r\n\t\tvar weight = this._updateWeight( time );\r\n\r\n\t\tif ( weight > 0 ) {\r\n\r\n\t\t\tvar interpolants = this._interpolants;\r\n\t\t\tvar propertyMixers = this._propertyBindings;\r\n\r\n\t\t\tfor ( var j = 0, m = interpolants.length; j !== m; ++ j ) {\r\n\r\n\t\t\t\tinterpolants[ j ].evaluate( clipTime );\r\n\t\t\t\tpropertyMixers[ j ].accumulate( accuIndex, weight );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t_updateWeight: function( time ) {\r\n\r\n\t\tvar weight = 0;\r\n\r\n\t\tif ( this.enabled ) {\r\n\r\n\t\t\tweight = this.weight;\r\n\t\t\tvar interpolant = this._weightInterpolant;\r\n\r\n\t\t\tif ( interpolant !== null ) {\r\n\r\n\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\r\n\r\n\t\t\t\tweight *= interpolantValue;\r\n\r\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\r\n\r\n\t\t\t\t\tthis.stopFading();\r\n\r\n\t\t\t\t\tif ( interpolantValue === 0 ) {\r\n\r\n\t\t\t\t\t\t// faded out, disable\r\n\t\t\t\t\t\tthis.enabled = false;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis._effectiveWeight = weight;\r\n\t\treturn weight;\r\n\r\n\t},\r\n\r\n\t_updateTimeScale: function( time ) {\r\n\r\n\t\tvar timeScale = 0;\r\n\r\n\t\tif ( ! this.paused ) {\r\n\r\n\t\t\ttimeScale = this.timeScale;\r\n\r\n\t\t\tvar interpolant = this._timeScaleInterpolant;\r\n\r\n\t\t\tif ( interpolant !== null ) {\r\n\r\n\t\t\t\tvar interpolantValue = interpolant.evaluate( time )[ 0 ];\r\n\r\n\t\t\t\ttimeScale *= interpolantValue;\r\n\r\n\t\t\t\tif ( time > interpolant.parameterPositions[ 1 ] ) {\r\n\r\n\t\t\t\t\tthis.stopWarping();\r\n\r\n\t\t\t\t\tif ( timeScale === 0 ) {\r\n\r\n\t\t\t\t\t\t// motion has halted, pause\r\n\t\t\t\t\t\tthis.paused = true;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t// warp done - apply final time scale\r\n\t\t\t\t\t\tthis.timeScale = timeScale;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis._effectiveTimeScale = timeScale;\r\n\t\treturn timeScale;\r\n\r\n\t},\r\n\r\n\t_updateTime: function( deltaTime ) {\r\n\r\n\t\tvar time = this.time + deltaTime;\r\n\r\n\t\tif ( deltaTime === 0 ) return time;\r\n\r\n\t\tvar duration = this._clip.duration,\r\n\r\n\t\t\tloop = this.loop,\r\n\t\t\tloopCount = this._loopCount;\r\n\r\n\t\tif ( loop === THREE.LoopOnce ) {\r\n\r\n\t\t\tif ( loopCount === -1 ) {\r\n\t\t\t\t// just started\r\n\r\n\t\t\t\tthis.loopCount = 0;\r\n\t\t\t\tthis._setEndings( true, true, false );\r\n\r\n\t\t\t}\r\n\r\n\t\t\thandle_stop: {\r\n\r\n\t\t\t\tif ( time >= duration ) {\r\n\r\n\t\t\t\t\ttime = duration;\r\n\r\n\t\t\t\t} else if ( time < 0 ) {\r\n\r\n\t\t\t\t\ttime = 0;\r\n\r\n\t\t\t\t} else break handle_stop;\r\n\r\n\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\r\n\t\t\t\telse this.enabled = false;\r\n\r\n\t\t\t\tthis._mixer.dispatchEvent( {\r\n\t\t\t\t\ttype: 'finished', action: this,\r\n\t\t\t\t\tdirection: deltaTime < 0 ? -1 : 1\r\n\t\t\t\t} );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else { // repetitive Repeat or PingPong\r\n\r\n\t\t\tvar pingPong = ( loop === THREE.LoopPingPong );\r\n\r\n\t\t\tif ( loopCount === -1 ) {\r\n\t\t\t\t// just started\r\n\r\n\t\t\t\tif ( deltaTime >= 0 ) {\r\n\r\n\t\t\t\t\tloopCount = 0;\r\n\r\n\t\t\t\t\tthis._setEndings(\r\n\t\t\t\t\t\t\ttrue, this.repetitions === 0, pingPong );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// when looping in reverse direction, the initial\r\n\t\t\t\t\t// transition through zero counts as a repetition,\r\n\t\t\t\t\t// so leave loopCount at -1\r\n\r\n\t\t\t\t\tthis._setEndings(\r\n\t\t\t\t\t\t\tthis.repetitions === 0, true, pingPong );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( time >= duration || time < 0 ) {\r\n\t\t\t\t// wrap around\r\n\r\n\t\t\t\tvar loopDelta = Math.floor( time / duration ); // signed\r\n\t\t\t\ttime -= duration * loopDelta;\r\n\r\n\t\t\t\tloopCount += Math.abs( loopDelta );\r\n\r\n\t\t\t\tvar pending = this.repetitions - loopCount;\r\n\r\n\t\t\t\tif ( pending < 0 ) {\r\n\t\t\t\t\t// have to stop (switch state, clamp time, fire event)\r\n\r\n\t\t\t\t\tif ( this.clampWhenFinished ) this.paused = true;\r\n\t\t\t\t\telse this.enabled = false;\r\n\r\n\t\t\t\t\ttime = deltaTime > 0 ? duration : 0;\r\n\r\n\t\t\t\t\tthis._mixer.dispatchEvent( {\r\n\t\t\t\t\t\ttype: 'finished', action: this,\r\n\t\t\t\t\t\tdirection: deltaTime > 0 ? 1 : -1\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// keep running\r\n\r\n\t\t\t\t\tif ( pending === 0 ) {\r\n\t\t\t\t\t\t// entering the last round\r\n\r\n\t\t\t\t\t\tvar atStart = deltaTime < 0;\r\n\t\t\t\t\t\tthis._setEndings( atStart, ! atStart, pingPong );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tthis._setEndings( false, false, pingPong );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tthis._loopCount = loopCount;\r\n\r\n\t\t\t\t\tthis._mixer.dispatchEvent( {\r\n\t\t\t\t\t\ttype: 'loop', action: this, loopDelta: loopDelta\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( pingPong && ( loopCount & 1 ) === 1 ) {\r\n\t\t\t\t// invert time for the \"pong round\"\r\n\r\n\t\t\t\tthis.time = time;\r\n\t\t\t\treturn duration - time;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.time = time;\r\n\t\treturn time;\r\n\r\n\t},\r\n\r\n\t_setEndings: function( atStart, atEnd, pingPong ) {\r\n\r\n\t\tvar settings = this._interpolantSettings;\r\n\r\n\t\tif ( pingPong ) {\r\n\r\n\t\t\tsettings.endingStart \t= THREE.ZeroSlopeEnding;\r\n\t\t\tsettings.endingEnd\t\t= THREE.ZeroSlopeEnding;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// assuming for LoopOnce atStart == atEnd == true\r\n\r\n\t\t\tif ( atStart ) {\r\n\r\n\t\t\t\tsettings.endingStart = this.zeroSlopeAtStart ?\r\n\t\t\t\t\t\tTHREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tsettings.endingStart = THREE.WrapAroundEnding;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( atEnd ) {\r\n\r\n\t\t\t\tsettings.endingEnd = this.zeroSlopeAtEnd ?\r\n\t\t\t\t\t\tTHREE.ZeroSlopeEnding : THREE.ZeroCurvatureEnding;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tsettings.endingEnd \t = THREE.WrapAroundEnding;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t_scheduleFading: function( duration, weightNow, weightThen ) {\r\n\r\n\t\tvar mixer = this._mixer, now = mixer.time,\r\n\t\t\tinterpolant = this._weightInterpolant;\r\n\r\n\t\tif ( interpolant === null ) {\r\n\r\n\t\t\tinterpolant = mixer._lendControlInterpolant(),\r\n\t\t\tthis._weightInterpolant = interpolant;\r\n\r\n\t\t}\r\n\r\n\t\tvar times = interpolant.parameterPositions,\r\n\t\t\tvalues = interpolant.sampleValues;\r\n\r\n\t\ttimes[ 0 ] = now; \t\t\t\tvalues[ 0 ] = weightNow;\r\n\t\ttimes[ 1 ] = now + duration;\tvalues[ 1 ] = weightThen;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\n// File:src/animation/AnimationClip.js\r\n\r\n/**\r\n *\r\n * Reusable set of Tracks that represent an animation.\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n */\r\n\r\nTHREE.AnimationClip = function ( name, duration, tracks ) {\r\n\r\n\tthis.name = name;\r\n\tthis.tracks = tracks;\r\n\tthis.duration = ( duration !== undefined ) ? duration : -1;\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\t// this means it should figure out its duration by scanning the tracks\r\n\tif ( this.duration < 0 ) {\r\n\r\n\t\tthis.resetDuration();\r\n\r\n\t}\r\n\r\n\t// maybe only do these on demand, as doing them here could potentially slow down loading\r\n\t// but leaving these here during development as this ensures a lot of testing of these functions\r\n\tthis.trim();\r\n\tthis.optimize();\r\n\r\n};\r\n\r\nTHREE.AnimationClip.prototype = {\r\n\r\n\tconstructor: THREE.AnimationClip,\r\n\r\n\tresetDuration: function() {\r\n\r\n\t\tvar tracks = this.tracks,\r\n\t\t\tduration = 0;\r\n\r\n\t\tfor ( var i = 0, n = tracks.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar track = this.tracks[ i ];\r\n\r\n\t\t\tduration = Math.max(\r\n\t\t\t\t\tduration, track.times[ track.times.length - 1 ] );\r\n\r\n\t\t}\r\n\r\n\t\tthis.duration = duration;\r\n\r\n\t},\r\n\r\n\ttrim: function() {\r\n\r\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\r\n\r\n\t\t\tthis.tracks[ i ].trim( 0, this.duration );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\toptimize: function() {\r\n\r\n\t\tfor ( var i = 0; i < this.tracks.length; i ++ ) {\r\n\r\n\t\t\tthis.tracks[ i ].optimize();\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// Static methods:\r\n\r\nObject.assign( THREE.AnimationClip, {\r\n\r\n\tparse: function( json ) {\r\n\r\n\t\tvar tracks = [],\r\n\t\t\tjsonTracks = json.tracks,\r\n\t\t\tframeTime = 1.0 / ( json.fps || 1.0 );\r\n\r\n\t\tfor ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {\r\n\r\n\t\t\ttracks.push( THREE.KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn new THREE.AnimationClip( json.name, json.duration, tracks );\r\n\r\n\t},\r\n\r\n\r\n\ttoJSON: function( clip ) {\r\n\r\n\t\tvar tracks = [],\r\n\t\t\tclipTracks = clip.tracks;\r\n\r\n\t\tvar json = {\r\n\r\n\t\t\t'name': clip.name,\r\n\t\t\t'duration': clip.duration,\r\n\t\t\t'tracks': tracks\r\n\r\n\t\t};\r\n\r\n\t\tfor ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {\r\n\r\n\t\t\ttracks.push( THREE.KeyframeTrack.toJSON( clipTracks[ i ] ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn json;\r\n\r\n\t},\r\n\r\n\r\n\tCreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {\r\n\r\n\t\tvar numMorphTargets = morphTargetSequence.length;\r\n\t\tvar tracks = [];\r\n\r\n\t\tfor ( var i = 0; i < numMorphTargets; i ++ ) {\r\n\r\n\t\t\tvar times = [];\r\n\t\t\tvar values = [];\r\n\r\n\t\t\ttimes.push(\r\n\t\t\t\t\t( i + numMorphTargets - 1 ) % numMorphTargets,\r\n\t\t\t\t\ti,\r\n\t\t\t\t\t( i + 1 ) % numMorphTargets );\r\n\r\n\t\t\tvalues.push( 0, 1, 0 );\r\n\r\n\t\t\tvar order = THREE.AnimationUtils.getKeyframeOrder( times );\r\n\t\t\ttimes = THREE.AnimationUtils.sortedArray( times, 1, order );\r\n\t\t\tvalues = THREE.AnimationUtils.sortedArray( values, 1, order );\r\n\r\n\t\t\t// if there is a key at the first frame, duplicate it as the\r\n\t\t\t// last frame as well for perfect loop.\r\n\t\t\tif ( ! noLoop && times[ 0 ] === 0 ) {\r\n\r\n\t\t\t\ttimes.push( numMorphTargets );\r\n\t\t\t\tvalues.push( values[ 0 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttracks.push(\r\n\t\t\t\t\tnew THREE.NumberKeyframeTrack(\r\n\t\t\t\t\t\t'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',\r\n\t\t\t\t\t\ttimes, values\r\n\t\t\t\t\t).scale( 1.0 / fps ) );\r\n\t\t}\r\n\r\n\t\treturn new THREE.AnimationClip( name, -1, tracks );\r\n\r\n\t},\r\n\r\n\tfindByName: function( objectOrClipArray, name ) {\r\n\r\n\t\tvar clipArray = objectOrClipArray;\r\n\r\n\t\tif ( ! Array.isArray( objectOrClipArray ) ) {\r\n\r\n\t\t\tvar o = objectOrClipArray;\r\n\t\t\tclipArray = o.geometry && o.geometry.animations || o.animations;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i < clipArray.length; i ++ ) {\r\n\r\n\t\t\tif ( clipArray[ i ].name === name ) {\r\n\r\n\t\t\t\treturn clipArray[ i ];\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t},\r\n\r\n\tCreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {\r\n\r\n\t\tvar animationToMorphTargets = {};\r\n\r\n\t\t// tested with https://regex101.com/ on trick sequences\r\n\t\t// such flamingo_flyA_003, flamingo_run1_003, crdeath0059\r\n\t\tvar pattern = /^([\\w-]*?)([\\d]+)$/;\r\n\r\n\t\t// sort morph target names into animation groups based\r\n\t\t// patterns like Walk_001, Walk_002, Run_001, Run_002\r\n\t\tfor ( var i = 0, il = morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar morphTarget = morphTargets[ i ];\r\n\t\t\tvar parts = morphTarget.name.match( pattern );\r\n\r\n\t\t\tif ( parts && parts.length > 1 ) {\r\n\r\n\t\t\t\tvar name = parts[ 1 ];\r\n\r\n\t\t\t\tvar animationMorphTargets = animationToMorphTargets[ name ];\r\n\t\t\t\tif ( ! animationMorphTargets ) {\r\n\r\n\t\t\t\t\tanimationToMorphTargets[ name ] = animationMorphTargets = [];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tanimationMorphTargets.push( morphTarget );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar clips = [];\r\n\r\n\t\tfor ( var name in animationToMorphTargets ) {\r\n\r\n\t\t\tclips.push( THREE.AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn clips;\r\n\r\n\t},\r\n\r\n\t// parse the animation.hierarchy format\r\n\tparseAnimation: function( animation, bones, nodeName ) {\r\n\r\n\t\tif ( ! animation ) {\r\n\r\n\t\t\tconsole.error( \"  no animation in JSONLoader data\" );\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tvar addNonemptyTrack = function(\r\n\t\t\t\ttrackType, trackName, animationKeys, propertyName, destTracks ) {\r\n\r\n\t\t\t// only return track if there are actually keys.\r\n\t\t\tif ( animationKeys.length !== 0 ) {\r\n\r\n\t\t\t\tvar times = [];\r\n\t\t\t\tvar values = [];\r\n\r\n\t\t\t\tTHREE.AnimationUtils.flattenJSON(\r\n\t\t\t\t\t\tanimationKeys, times, values, propertyName );\r\n\r\n\t\t\t\t// empty keys are filtered out, so check again\r\n\t\t\t\tif ( times.length !== 0 ) {\r\n\r\n\t\t\t\t\tdestTracks.push( new trackType( trackName, times, values ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t\tvar tracks = [];\r\n\r\n\t\tvar clipName = animation.name || 'default';\r\n\t\t// automatic length determination in AnimationClip.\r\n\t\tvar duration = animation.length || -1;\r\n\t\tvar fps = animation.fps || 30;\r\n\r\n\t\tvar hierarchyTracks = animation.hierarchy || [];\r\n\r\n\t\tfor ( var h = 0; h < hierarchyTracks.length; h ++ ) {\r\n\r\n\t\t\tvar animationKeys = hierarchyTracks[ h ].keys;\r\n\r\n\t\t\t// skip empty tracks\r\n\t\t\tif ( ! animationKeys || animationKeys.length === 0 ) continue;\r\n\r\n\t\t\t// process morph targets in a way exactly compatible\r\n\t\t\t// with AnimationHandler.init( animation )\r\n\t\t\tif ( animationKeys[0].morphTargets ) {\r\n\r\n\t\t\t\t// figure out all morph targets used in this track\r\n\t\t\t\tvar morphTargetNames = {};\r\n\t\t\t\tfor ( var k = 0; k < animationKeys.length; k ++ ) {\r\n\r\n\t\t\t\t\tif ( animationKeys[k].morphTargets ) {\r\n\r\n\t\t\t\t\t\tfor ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {\r\n\r\n\t\t\t\t\t\t\tmorphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// create a track for each morph target with all zero\r\n\t\t\t\t// morphTargetInfluences except for the keys in which\r\n\t\t\t\t// the morphTarget is named.\r\n\t\t\t\tfor ( var morphTargetName in morphTargetNames ) {\r\n\r\n\t\t\t\t\tvar times = [];\r\n\t\t\t\t\tvar values = [];\r\n\r\n\t\t\t\t\tfor ( var m = 0;\r\n\t\t\t\t\t\t\tm !== animationKeys[k].morphTargets.length; ++ m ) {\r\n\r\n\t\t\t\t\t\tvar animationKey = animationKeys[k];\r\n\r\n\t\t\t\t\t\ttimes.push( animationKey.time );\r\n\t\t\t\t\t\tvalues.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttracks.push( new THREE.NumberKeyframeTrack(\r\n\t\t\t\t\t\t\t'.morphTargetInfluence[' + morphTargetName + ']', times, values ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tduration = morphTargetNames.length * ( fps || 1.0 );\r\n\r\n\t\t\t} else {\r\n\t\t\t\t// ...assume skeletal animation\r\n\r\n\t\t\t\tvar boneName = '.bones[' + bones[ h ].name + ']';\r\n\r\n\t\t\t\taddNonemptyTrack(\r\n\t\t\t\t\t\tTHREE.VectorKeyframeTrack, boneName + '.position',\r\n\t\t\t\t\t\tanimationKeys, 'pos', tracks );\r\n\r\n\t\t\t\taddNonemptyTrack(\r\n\t\t\t\t\t\tTHREE.QuaternionKeyframeTrack, boneName + '.quaternion',\r\n\t\t\t\t\t\tanimationKeys, 'rot', tracks );\r\n\r\n\t\t\t\taddNonemptyTrack(\r\n\t\t\t\t\t\tTHREE.VectorKeyframeTrack, boneName + '.scale',\r\n\t\t\t\t\t\tanimationKeys, 'scl', tracks );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( tracks.length === 0 ) {\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t}\r\n\r\n\t\tvar clip = new THREE.AnimationClip( clipName, duration, tracks );\r\n\r\n\t\treturn clip;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/animation/AnimationMixer.js\r\n\r\n/**\r\n *\r\n * Player for AnimationClips.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.AnimationMixer = function( root ) {\r\n\r\n\tthis._root = root;\r\n\tthis._initMemoryManager();\r\n\tthis._accuIndex = 0;\r\n\r\n\tthis.time = 0;\r\n\r\n\tthis.timeScale = 1.0;\r\n\r\n};\r\n\r\nObject.assign( THREE.AnimationMixer.prototype, THREE.EventDispatcher.prototype, {\r\n\r\n\t// return an action for a clip optionally using a custom root target\r\n\t// object (this method allocates a lot of dynamic memory in case a\r\n\t// previously unknown clip/root combination is specified)\r\n\tclipAction: function( clip, optionalRoot ) {\r\n\r\n\t\tvar root = optionalRoot || this._root,\r\n\t\t\trootUuid = root.uuid,\r\n\r\n\t\t\tclipObject = typeof clip === 'string' ?\r\n\t\t\t\t\tTHREE.AnimationClip.findByName( root, clip ) : clip,\r\n\r\n\t\t\tclipUuid = clipObject !== null ? clipObject.uuid : clip,\r\n\r\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ],\r\n\t\t\tprototypeAction = null;\r\n\r\n\t\tif ( actionsForClip !== undefined ) {\r\n\r\n\t\t\tvar existingAction =\r\n\t\t\t\t\tactionsForClip.actionByRoot[ rootUuid ];\r\n\r\n\t\t\tif ( existingAction !== undefined ) {\r\n\r\n\t\t\t\treturn existingAction;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// we know the clip, so we don't have to parse all\r\n\t\t\t// the bindings again but can just copy\r\n\t\t\tprototypeAction = actionsForClip.knownActions[ 0 ];\r\n\r\n\t\t\t// also, take the clip from the prototype action\r\n\t\t\tif ( clipObject === null )\r\n\t\t\t\tclipObject = prototypeAction._clip;\r\n\r\n\t\t}\r\n\r\n\t\t// clip must be known when specified via string\r\n\t\tif ( clipObject === null ) return null;\r\n\r\n\t\t// allocate all resources required to run it\r\n\t\tvar newAction = new THREE.\r\n\t\t\t\tAnimationMixer._Action( this, clipObject, optionalRoot );\r\n\r\n\t\tthis._bindAction( newAction, prototypeAction );\r\n\r\n\t\t// and make the action known to the memory manager\r\n\t\tthis._addInactiveAction( newAction, clipUuid, rootUuid );\r\n\r\n\t\treturn newAction;\r\n\r\n\t},\r\n\r\n\t// get an existing action\r\n\texistingAction: function( clip, optionalRoot ) {\r\n\r\n\t\tvar root = optionalRoot || this._root,\r\n\t\t\trootUuid = root.uuid,\r\n\r\n\t\t\tclipObject = typeof clip === 'string' ?\r\n\t\t\t\t\tTHREE.AnimationClip.findByName( root, clip ) : clip,\r\n\r\n\t\t\tclipUuid = clipObject ? clipObject.uuid : clip,\r\n\r\n\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\r\n\r\n\t\tif ( actionsForClip !== undefined ) {\r\n\r\n\t\t\treturn actionsForClip.actionByRoot[ rootUuid ] || null;\r\n\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t},\r\n\r\n\t// deactivates all previously scheduled actions\r\n\tstopAllAction: function() {\r\n\r\n\t\tvar actions = this._actions,\r\n\t\t\tnActions = this._nActiveActions,\r\n\t\t\tbindings = this._bindings,\r\n\t\t\tnBindings = this._nActiveBindings;\r\n\r\n\t\tthis._nActiveActions = 0;\r\n\t\tthis._nActiveBindings = 0;\r\n\r\n\t\tfor ( var i = 0; i !== nActions; ++ i ) {\r\n\r\n\t\t\tactions[ i ].reset();\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\r\n\r\n\t\t\tbindings[ i ].useCount = 0;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// advance the time and update apply the animation\r\n\tupdate: function( deltaTime ) {\r\n\r\n\t\tdeltaTime *= this.timeScale;\r\n\r\n\t\tvar actions = this._actions,\r\n\t\t\tnActions = this._nActiveActions,\r\n\r\n\t\t\ttime = this.time += deltaTime,\r\n\t\t\ttimeDirection = Math.sign( deltaTime ),\r\n\r\n\t\t\taccuIndex = this._accuIndex ^= 1;\r\n\r\n\t\t// run active actions\r\n\r\n\t\tfor ( var i = 0; i !== nActions; ++ i ) {\r\n\r\n\t\t\tvar action = actions[ i ];\r\n\r\n\t\t\tif ( action.enabled ) {\r\n\r\n\t\t\t\taction._update( time, deltaTime, timeDirection, accuIndex );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// update scene graph\r\n\r\n\t\tvar bindings = this._bindings,\r\n\t\t\tnBindings = this._nActiveBindings;\r\n\r\n\t\tfor ( var i = 0; i !== nBindings; ++ i ) {\r\n\r\n\t\t\tbindings[ i ].apply( accuIndex );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// return this mixer's root target object\r\n\tgetRoot: function() {\r\n\r\n\t\treturn this._root;\r\n\r\n\t},\r\n\r\n\t// free all resources specific to a particular clip\r\n\tuncacheClip: function( clip ) {\r\n\r\n\t\tvar actions = this._actions,\r\n\t\t\tclipUuid = clip.uuid,\r\n\t\t\tactionsByClip = this._actionsByClip,\r\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\r\n\r\n\t\tif ( actionsForClip !== undefined ) {\r\n\r\n\t\t\t// note: just calling _removeInactiveAction would mess up the\r\n\t\t\t// iteration state and also require updating the state we can\r\n\t\t\t// just throw away\r\n\r\n\t\t\tvar actionsToRemove = actionsForClip.knownActions;\r\n\r\n\t\t\tfor ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\tvar action = actionsToRemove[ i ];\r\n\r\n\t\t\t\tthis._deactivateAction( action );\r\n\r\n\t\t\t\tvar cacheIndex = action._cacheIndex,\r\n\t\t\t\t\tlastInactiveAction = actions[ actions.length - 1 ];\r\n\r\n\t\t\t\taction._cacheIndex = null;\r\n\t\t\t\taction._byClipCacheIndex = null;\r\n\r\n\t\t\t\tlastInactiveAction._cacheIndex = cacheIndex;\r\n\t\t\t\tactions[ cacheIndex ] = lastInactiveAction;\r\n\t\t\t\tactions.pop();\r\n\r\n\t\t\t\tthis._removeInactiveBindingsForAction( action );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tdelete actionsByClip[ clipUuid ];\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// free all resources specific to a particular root target object\r\n\tuncacheRoot: function( root ) {\r\n\r\n\t\tvar rootUuid = root.uuid,\r\n\t\t\tactionsByClip = this._actionsByClip;\r\n\r\n\t\tfor ( var clipUuid in actionsByClip ) {\r\n\r\n\t\t\tvar actionByRoot = actionsByClip[ clipUuid ].actionByRoot,\r\n\t\t\t\taction = actionByRoot[ rootUuid ];\r\n\r\n\t\t\tif ( action !== undefined ) {\r\n\r\n\t\t\t\tthis._deactivateAction( action );\r\n\t\t\t\tthis._removeInactiveAction( action );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar bindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ];\r\n\r\n\t\tif ( bindingByName !== undefined ) {\r\n\r\n\t\t\tfor ( var trackName in bindingByName ) {\r\n\r\n\t\t\t\tvar binding = bindingByName[ trackName ];\r\n\t\t\t\tbinding.restoreOriginalState();\r\n\t\t\t\tthis._removeInactiveBinding( binding );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// remove a targeted clip from the cache\r\n\tuncacheAction: function( clip, optionalRoot ) {\r\n\r\n\t\tvar action = this.existingAction( clip, optionalRoot );\r\n\r\n\t\tif ( action !== null ) {\r\n\r\n\t\t\tthis._deactivateAction( action );\r\n\t\t\tthis._removeInactiveAction( action );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\r\n\r\nTHREE.AnimationMixer._Action = THREE.AnimationAction._new;\r\n\r\n// Implementation details:\r\n\r\nObject.assign( THREE.AnimationMixer.prototype, {\r\n\r\n\t_bindAction: function( action, prototypeAction ) {\r\n\r\n\t\tvar root = action._localRoot || this._root,\r\n\t\t\ttracks = action._clip.tracks,\r\n\t\t\tnTracks = tracks.length,\r\n\t\t\tbindings = action._propertyBindings,\r\n\t\t\tinterpolants = action._interpolants,\r\n\t\t\trootUuid = root.uuid,\r\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\tbindingsByName = bindingsByRoot[ rootUuid ];\r\n\r\n\t\tif ( bindingsByName === undefined ) {\r\n\r\n\t\t\tbindingsByName = {};\r\n\t\t\tbindingsByRoot[ rootUuid ] = bindingsByName;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i !== nTracks; ++ i ) {\r\n\r\n\t\t\tvar track = tracks[ i ],\r\n\t\t\t\ttrackName = track.name,\r\n\t\t\t\tbinding = bindingsByName[ trackName ];\r\n\r\n\t\t\tif ( binding !== undefined ) {\r\n\r\n\t\t\t\tbindings[ i ] = binding;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tbinding = bindings[ i ];\r\n\r\n\t\t\t\tif ( binding !== undefined ) {\r\n\r\n\t\t\t\t\t// existing binding, make sure the cache knows\r\n\r\n\t\t\t\t\tif ( binding._cacheIndex === null ) {\r\n\r\n\t\t\t\t\t\t++ binding.referenceCount;\r\n\t\t\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar path = prototypeAction && prototypeAction.\r\n\t\t\t\t\t\t_propertyBindings[ i ].binding.parsedPath;\r\n\r\n\t\t\t\tbinding = new THREE.PropertyMixer(\r\n\t\t\t\t\t\tTHREE.PropertyBinding.create( root, trackName, path ),\r\n\t\t\t\t\t\ttrack.ValueTypeName, track.getValueSize() );\r\n\r\n\t\t\t\t++ binding.referenceCount;\r\n\t\t\t\tthis._addInactiveBinding( binding, rootUuid, trackName );\r\n\r\n\t\t\t\tbindings[ i ] = binding;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tinterpolants[ i ].resultBuffer = binding.buffer;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t_activateAction: function( action ) {\r\n\r\n\t\tif ( ! this._isActiveAction( action ) ) {\r\n\r\n\t\t\tif ( action._cacheIndex === null ) {\r\n\r\n\t\t\t\t// this action has been forgotten by the cache, but the user\r\n\t\t\t\t// appears to be still using it -> rebind\r\n\r\n\t\t\t\tvar rootUuid = ( action._localRoot || this._root ).uuid,\r\n\t\t\t\t\tclipUuid = action._clip.uuid,\r\n\t\t\t\t\tactionsForClip = this._actionsByClip[ clipUuid ];\r\n\r\n\t\t\t\tthis._bindAction( action,\r\n\t\t\t\t\t\tactionsForClip && actionsForClip.knownActions[ 0 ] );\r\n\r\n\t\t\t\tthis._addInactiveAction( action, clipUuid, rootUuid );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar bindings = action._propertyBindings;\r\n\r\n\t\t\t// increment reference counts / sort out state\r\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\tvar binding = bindings[ i ];\r\n\r\n\t\t\t\tif ( binding.useCount ++ === 0 ) {\r\n\r\n\t\t\t\t\tthis._lendBinding( binding );\r\n\t\t\t\t\tbinding.saveOriginalState();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis._lendAction( action );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t_deactivateAction: function( action ) {\r\n\r\n\t\tif ( this._isActiveAction( action ) ) {\r\n\r\n\t\t\tvar bindings = action._propertyBindings;\r\n\r\n\t\t\t// decrement reference counts / sort out state\r\n\t\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\tvar binding = bindings[ i ];\r\n\r\n\t\t\t\tif ( -- binding.useCount === 0 ) {\r\n\r\n\t\t\t\t\tbinding.restoreOriginalState();\r\n\t\t\t\t\tthis._takeBackBinding( binding );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis._takeBackAction( action );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// Memory manager\r\n\r\n\t_initMemoryManager: function() {\r\n\r\n\t\tthis._actions = []; // 'nActiveActions' followed by inactive ones\r\n\t\tthis._nActiveActions = 0;\r\n\r\n\t\tthis._actionsByClip = {};\r\n\t\t// inside:\r\n\t\t// {\r\n\t\t// \t\tknownActions: Array< _Action >\t- used as prototypes\r\n\t\t// \t\tactionByRoot: _Action\t\t\t- lookup\r\n\t\t// }\r\n\r\n\r\n\t\tthis._bindings = []; // 'nActiveBindings' followed by inactive ones\r\n\t\tthis._nActiveBindings = 0;\r\n\r\n\t\tthis._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >\r\n\r\n\r\n\t\tthis._controlInterpolants = []; // same game as above\r\n\t\tthis._nActiveControlInterpolants = 0;\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tthis.stats = {\r\n\r\n\t\t\tactions: {\r\n\t\t\t\tget total() { return scope._actions.length; },\r\n\t\t\t\tget inUse() { return scope._nActiveActions; }\r\n\t\t\t},\r\n\t\t\tbindings: {\r\n\t\t\t\tget total() { return scope._bindings.length; },\r\n\t\t\t\tget inUse() { return scope._nActiveBindings; }\r\n\t\t\t},\r\n\t\t\tcontrolInterpolants: {\r\n\t\t\t\tget total() { return scope._controlInterpolants.length; },\r\n\t\t\t\tget inUse() { return scope._nActiveControlInterpolants; }\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t},\r\n\r\n\t// Memory management for _Action objects\r\n\r\n\t_isActiveAction: function( action ) {\r\n\r\n\t\tvar index = action._cacheIndex;\r\n\t\treturn index !== null && index < this._nActiveActions;\r\n\r\n\t},\r\n\r\n\t_addInactiveAction: function( action, clipUuid, rootUuid ) {\r\n\r\n\t\tvar actions = this._actions,\r\n\t\t\tactionsByClip = this._actionsByClip,\r\n\t\t\tactionsForClip = actionsByClip[ clipUuid ];\r\n\r\n\t\tif ( actionsForClip === undefined ) {\r\n\r\n\t\t\tactionsForClip = {\r\n\r\n\t\t\t\tknownActions: [ action ],\r\n\t\t\t\tactionByRoot: {}\r\n\r\n\t\t\t};\r\n\r\n\t\t\taction._byClipCacheIndex = 0;\r\n\r\n\t\t\tactionsByClip[ clipUuid ] = actionsForClip;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar knownActions = actionsForClip.knownActions;\r\n\r\n\t\t\taction._byClipCacheIndex = knownActions.length;\r\n\t\t\tknownActions.push( action );\r\n\r\n\t\t}\r\n\r\n\t\taction._cacheIndex = actions.length;\r\n\t\tactions.push( action );\r\n\r\n\t\tactionsForClip.actionByRoot[ rootUuid ] = action;\r\n\r\n\t},\r\n\r\n\t_removeInactiveAction: function( action ) {\r\n\r\n\t\tvar actions = this._actions,\r\n\t\t\tlastInactiveAction = actions[ actions.length - 1 ],\r\n\t\t\tcacheIndex = action._cacheIndex;\r\n\r\n\t\tlastInactiveAction._cacheIndex = cacheIndex;\r\n\t\tactions[ cacheIndex ] = lastInactiveAction;\r\n\t\tactions.pop();\r\n\r\n\t\taction._cacheIndex = null;\r\n\r\n\r\n\t\tvar clipUuid = action._clip.uuid,\r\n\t\t\tactionsByClip = this._actionsByClip,\r\n\t\t\tactionsForClip = actionsByClip[ clipUuid ],\r\n\t\t\tknownActionsForClip = actionsForClip.knownActions,\r\n\r\n\t\t\tlastKnownAction =\r\n\t\t\t\tknownActionsForClip[ knownActionsForClip.length - 1 ],\r\n\r\n\t\t\tbyClipCacheIndex = action._byClipCacheIndex;\r\n\r\n\t\tlastKnownAction._byClipCacheIndex = byClipCacheIndex;\r\n\t\tknownActionsForClip[ byClipCacheIndex ] = lastKnownAction;\r\n\t\tknownActionsForClip.pop();\r\n\r\n\t\taction._byClipCacheIndex = null;\r\n\r\n\r\n\t\tvar actionByRoot = actionsForClip.actionByRoot,\r\n\t\t\trootUuid = ( actions._localRoot || this._root ).uuid;\r\n\r\n\t\tdelete actionByRoot[ rootUuid ];\r\n\r\n\t\tif ( knownActionsForClip.length === 0 ) {\r\n\r\n\t\t\tdelete actionsByClip[ clipUuid ];\r\n\r\n\t\t}\r\n\r\n\t\tthis._removeInactiveBindingsForAction( action );\r\n\r\n\t},\r\n\r\n\t_removeInactiveBindingsForAction: function( action ) {\r\n\r\n\t\tvar bindings = action._propertyBindings;\r\n\t\tfor ( var i = 0, n = bindings.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar binding = bindings[ i ];\r\n\r\n\t\t\tif ( -- binding.referenceCount === 0 ) {\r\n\r\n\t\t\t\tthis._removeInactiveBinding( binding );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t_lendAction: function( action ) {\r\n\r\n\t\t// [ active actions |  inactive actions  ]\r\n\t\t// [  active actions >| inactive actions ]\r\n\t\t//                 s        a\r\n\t\t//                  <-swap->\r\n\t\t//                 a        s\r\n\r\n\t\tvar actions = this._actions,\r\n\t\t\tprevIndex = action._cacheIndex,\r\n\r\n\t\t\tlastActiveIndex = this._nActiveActions ++,\r\n\r\n\t\t\tfirstInactiveAction = actions[ lastActiveIndex ];\r\n\r\n\t\taction._cacheIndex = lastActiveIndex;\r\n\t\tactions[ lastActiveIndex ] = action;\r\n\r\n\t\tfirstInactiveAction._cacheIndex = prevIndex;\r\n\t\tactions[ prevIndex ] = firstInactiveAction;\r\n\r\n\t},\r\n\r\n\t_takeBackAction: function( action ) {\r\n\r\n\t\t// [  active actions  | inactive actions ]\r\n\t\t// [ active actions |< inactive actions  ]\r\n\t\t//        a        s\r\n\t\t//         <-swap->\r\n\t\t//        s        a\r\n\r\n\t\tvar actions = this._actions,\r\n\t\t\tprevIndex = action._cacheIndex,\r\n\r\n\t\t\tfirstInactiveIndex = -- this._nActiveActions,\r\n\r\n\t\t\tlastActiveAction = actions[ firstInactiveIndex ];\r\n\r\n\t\taction._cacheIndex = firstInactiveIndex;\r\n\t\tactions[ firstInactiveIndex ] = action;\r\n\r\n\t\tlastActiveAction._cacheIndex = prevIndex;\r\n\t\tactions[ prevIndex ] = lastActiveAction;\r\n\r\n\t},\r\n\r\n\t// Memory management for PropertyMixer objects\r\n\r\n\t_addInactiveBinding: function( binding, rootUuid, trackName ) {\r\n\r\n\t\tvar bindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\r\n\r\n\t\t\tbindings = this._bindings;\r\n\r\n\t\tif ( bindingByName === undefined ) {\r\n\r\n\t\t\tbindingByName = {};\r\n\t\t\tbindingsByRoot[ rootUuid ] = bindingByName;\r\n\r\n\t\t}\r\n\r\n\t\tbindingByName[ trackName ] = binding;\r\n\r\n\t\tbinding._cacheIndex = bindings.length;\r\n\t\tbindings.push( binding );\r\n\r\n\t},\r\n\r\n\t_removeInactiveBinding: function( binding ) {\r\n\r\n\t\tvar bindings = this._bindings,\r\n\t\t\tpropBinding = binding.binding,\r\n\t\t\trootUuid = propBinding.rootNode.uuid,\r\n\t\t\ttrackName = propBinding.path,\r\n\t\t\tbindingsByRoot = this._bindingsByRootAndName,\r\n\t\t\tbindingByName = bindingsByRoot[ rootUuid ],\r\n\r\n\t\t\tlastInactiveBinding = bindings[ bindings.length - 1 ],\r\n\t\t\tcacheIndex = binding._cacheIndex;\r\n\r\n\t\tlastInactiveBinding._cacheIndex = cacheIndex;\r\n\t\tbindings[ cacheIndex ] = lastInactiveBinding;\r\n\t\tbindings.pop();\r\n\r\n\t\tdelete bindingByName[ trackName ];\r\n\r\n\t\tremove_empty_map: {\r\n\r\n\t\t\tfor ( var _ in bindingByName ) break remove_empty_map;\r\n\r\n\t\t\tdelete bindingsByRoot[ rootUuid ];\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t_lendBinding: function( binding ) {\r\n\r\n\t\tvar bindings = this._bindings,\r\n\t\t\tprevIndex = binding._cacheIndex,\r\n\r\n\t\t\tlastActiveIndex = this._nActiveBindings ++,\r\n\r\n\t\t\tfirstInactiveBinding = bindings[ lastActiveIndex ];\r\n\r\n\t\tbinding._cacheIndex = lastActiveIndex;\r\n\t\tbindings[ lastActiveIndex ] = binding;\r\n\r\n\t\tfirstInactiveBinding._cacheIndex = prevIndex;\r\n\t\tbindings[ prevIndex ] = firstInactiveBinding;\r\n\r\n\t},\r\n\r\n\t_takeBackBinding: function( binding ) {\r\n\r\n\t\tvar bindings = this._bindings,\r\n\t\t\tprevIndex = binding._cacheIndex,\r\n\r\n\t\t\tfirstInactiveIndex = -- this._nActiveBindings,\r\n\r\n\t\t\tlastActiveBinding = bindings[ firstInactiveIndex ];\r\n\r\n\t\tbinding._cacheIndex = firstInactiveIndex;\r\n\t\tbindings[ firstInactiveIndex ] = binding;\r\n\r\n\t\tlastActiveBinding._cacheIndex = prevIndex;\r\n\t\tbindings[ prevIndex ] = lastActiveBinding;\r\n\r\n\t},\r\n\r\n\r\n\t// Memory management of Interpolants for weight and time scale\r\n\r\n\t_lendControlInterpolant: function() {\r\n\r\n\t\tvar interpolants = this._controlInterpolants,\r\n\t\t\tlastActiveIndex = this._nActiveControlInterpolants ++,\r\n\t\t\tinterpolant = interpolants[ lastActiveIndex ];\r\n\r\n\t\tif ( interpolant === undefined ) {\r\n\r\n\t\t\tinterpolant = new THREE.LinearInterpolant(\r\n\t\t\t\t\tnew Float32Array( 2 ), new Float32Array( 2 ),\r\n\t\t\t\t\t\t1, this._controlInterpolantsResultBuffer );\r\n\r\n\t\t\tinterpolant.__cacheIndex = lastActiveIndex;\r\n\t\t\tinterpolants[ lastActiveIndex ] = interpolant;\r\n\r\n\t\t}\r\n\r\n\t\treturn interpolant;\r\n\r\n\t},\r\n\r\n\t_takeBackControlInterpolant: function( interpolant ) {\r\n\r\n\t\tvar interpolants = this._controlInterpolants,\r\n\t\t\tprevIndex = interpolant.__cacheIndex,\r\n\r\n\t\t\tfirstInactiveIndex = -- this._nActiveControlInterpolants,\r\n\r\n\t\t\tlastActiveInterpolant = interpolants[ firstInactiveIndex ];\r\n\r\n\t\tinterpolant.__cacheIndex = firstInactiveIndex;\r\n\t\tinterpolants[ firstInactiveIndex ] = interpolant;\r\n\r\n\t\tlastActiveInterpolant.__cacheIndex = prevIndex;\r\n\t\tinterpolants[ prevIndex ] = lastActiveInterpolant;\r\n\r\n\t},\r\n\r\n\t_controlInterpolantsResultBuffer: new Float32Array( 1 )\r\n\r\n} );\r\n\r\n// File:src/animation/AnimationObjectGroup.js\r\n\r\n/**\r\n *\r\n * A group of objects that receives a shared animation state.\r\n *\r\n * Usage:\r\n *\r\n * \t-\tAdd objects you would otherwise pass as 'root' to the\r\n * \t\tconstructor or the .clipAction method of AnimationMixer.\r\n *\r\n * \t-\tInstead pass this object as 'root'.\r\n *\r\n * \t-\tYou can also add and remove objects later when the mixer\r\n * \t\tis running.\r\n *\r\n * Note:\r\n *\r\n *  \tObjects of this class appear as one object to the mixer,\r\n *  \tso cache control of the individual objects must be done\r\n *  \ton the group.\r\n *\r\n * Limitation:\r\n *\r\n * \t- \tThe animated properties must be compatible among the\r\n * \t\tall objects in the group.\r\n *\r\n *  -\tA single property can either be controlled through a\r\n *  \ttarget group or directly, but not both.\r\n *\r\n * @author tschw\r\n */\r\n\r\nTHREE.AnimationObjectGroup = function( var_args ) {\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\t// cached objects followed by the active ones\r\n\tthis._objects = Array.prototype.slice.call( arguments );\r\n\r\n\tthis.nCachedObjects_ = 0;\t\t\t// threshold\r\n\t// note: read by PropertyBinding.Composite\r\n\r\n\tvar indices = {};\r\n\tthis._indicesByUUID = indices;\t\t// for bookkeeping\r\n\r\n\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\r\n\t\tindices[ arguments[ i ].uuid ] = i;\r\n\r\n\t}\r\n\r\n\tthis._paths = [];\t\t\t\t\t// inside: string\r\n\tthis._parsedPaths = [];\t\t\t\t// inside: { we don't care, here }\r\n\tthis._bindings = []; \t\t\t\t// inside: Array< PropertyBinding >\r\n\tthis._bindingsIndicesByPath = {}; \t// inside: indices in these arrays\r\n\r\n\tvar scope = this;\r\n\r\n\tthis.stats = {\r\n\r\n\t\tobjects: {\r\n\t\t\tget total() { return scope._objects.length; },\r\n\t\t\tget inUse() { return this.total - scope.nCachedObjects_;  }\r\n\t\t},\r\n\r\n\t\tget bindingsPerObject() { return scope._bindings.length; }\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.AnimationObjectGroup.prototype = {\r\n\r\n\tconstructor: THREE.AnimationObjectGroup,\r\n\r\n\tadd: function( var_args ) {\r\n\r\n\t\tvar objects = this._objects,\r\n\t\t\tnObjects = objects.length,\r\n\t\t\tnCachedObjects = this.nCachedObjects_,\r\n\t\t\tindicesByUUID = this._indicesByUUID,\r\n\t\t\tpaths = this._paths,\r\n\t\t\tparsedPaths = this._parsedPaths,\r\n\t\t\tbindings = this._bindings,\r\n\t\t\tnBindings = bindings.length;\r\n\r\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar object = arguments[ i ],\r\n\t\t\t\tuuid = object.uuid,\r\n\t\t\t\tindex = indicesByUUID[ uuid ];\r\n\r\n\t\t\tif ( index === undefined ) {\r\n\r\n\t\t\t\t// unknown object -> add it to the ACTIVE region\r\n\r\n\t\t\t\tindex = nObjects ++;\r\n\t\t\t\tindicesByUUID[ uuid ] = index;\r\n\t\t\t\tobjects.push( object );\r\n\r\n\t\t\t\t// accounting is done, now do the same for all bindings\r\n\r\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\r\n\t\t\t\t\tbindings[ j ].push(\r\n\t\t\t\t\t\t\tnew THREE.PropertyBinding(\r\n\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( index < nCachedObjects ) {\r\n\r\n\t\t\t\tvar knownObject = objects[ index ];\r\n\r\n\t\t\t\t// move existing object to the ACTIVE region\r\n\r\n\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\r\n\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ];\r\n\r\n\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\r\n\t\t\t\tobjects[ index ] = lastCachedObject;\r\n\r\n\t\t\t\tindicesByUUID[ uuid ] = firstActiveIndex;\r\n\t\t\t\tobjects[ firstActiveIndex ] = object;\r\n\r\n\t\t\t\t// accounting is done, now do the same for all bindings\r\n\r\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\r\n\t\t\t\t\tvar bindingsForPath = bindings[ j ],\r\n\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\r\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\r\n\r\n\t\t\t\t\tbindingsForPath[ index ] = lastCached;\r\n\r\n\t\t\t\t\tif ( binding === undefined ) {\r\n\r\n\t\t\t\t\t\t// since we do not bother to create new bindings\r\n\t\t\t\t\t\t// for objects that are cached, the binding may\r\n\t\t\t\t\t\t// or may not exist\r\n\r\n\t\t\t\t\t\tbinding = new THREE.PropertyBinding(\r\n\t\t\t\t\t\t\t\tobject, paths[ j ], parsedPaths[ j ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = binding;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( objects[ index ] !== knownObject) {\r\n\r\n\t\t\t\tconsole.error( \"Different objects with the same UUID \" +\r\n\t\t\t\t\t\t\"detected. Clean the caches or recreate your \" +\r\n\t\t\t\t\t\t\"infrastructure when reloading scenes...\" );\r\n\r\n\t\t\t} // else the object is already where we want it to be\r\n\r\n\t\t} // for arguments\r\n\r\n\t\tthis.nCachedObjects_ = nCachedObjects;\r\n\r\n\t},\r\n\r\n\tremove: function( var_args ) {\r\n\r\n\t\tvar objects = this._objects,\r\n\t\t\tnObjects = objects.length,\r\n\t\t\tnCachedObjects = this.nCachedObjects_,\r\n\t\t\tindicesByUUID = this._indicesByUUID,\r\n\t\t\tbindings = this._bindings,\r\n\t\t\tnBindings = bindings.length;\r\n\r\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar object = arguments[ i ],\r\n\t\t\t\tuuid = object.uuid,\r\n\t\t\t\tindex = indicesByUUID[ uuid ];\r\n\r\n\t\t\tif ( index !== undefined && index >= nCachedObjects ) {\r\n\r\n\t\t\t\t// move existing object into the CACHED region\r\n\r\n\t\t\t\tvar lastCachedIndex = nCachedObjects ++,\r\n\t\t\t\t\tfirstActiveObject = objects[ lastCachedIndex ];\r\n\r\n\t\t\t\tindicesByUUID[ firstActiveObject.uuid ] = index;\r\n\t\t\t\tobjects[ index ] = firstActiveObject;\r\n\r\n\t\t\t\tindicesByUUID[ uuid ] = lastCachedIndex;\r\n\t\t\t\tobjects[ lastCachedIndex ] = object;\r\n\r\n\t\t\t\t// accounting is done, now do the same for all bindings\r\n\r\n\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\r\n\t\t\t\t\tvar bindingsForPath = bindings[ j ],\r\n\t\t\t\t\t\tfirstActive = bindingsForPath[ lastCachedIndex ],\r\n\t\t\t\t\t\tbinding = bindingsForPath[ index ];\r\n\r\n\t\t\t\t\tbindingsForPath[ index ] = firstActive;\r\n\t\t\t\t\tbindingsForPath[ lastCachedIndex ] = binding;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} // for arguments\r\n\r\n\t\tthis.nCachedObjects_ = nCachedObjects;\r\n\r\n\t},\r\n\r\n\t// remove & forget\r\n\tuncache: function( var_args ) {\r\n\r\n\t\tvar objects = this._objects,\r\n\t\t\tnObjects = objects.length,\r\n\t\t\tnCachedObjects = this.nCachedObjects_,\r\n\t\t\tindicesByUUID = this._indicesByUUID,\r\n\t\t\tbindings = this._bindings,\r\n\t\t\tnBindings = bindings.length;\r\n\r\n\t\tfor ( var i = 0, n = arguments.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar object = arguments[ i ],\r\n\t\t\t\tuuid = object.uuid,\r\n\t\t\t\tindex = indicesByUUID[ uuid ];\r\n\r\n\t\t\tif ( index !== undefined ) {\r\n\r\n\t\t\t\tdelete indicesByUUID[ uuid ];\r\n\r\n\t\t\t\tif ( index < nCachedObjects ) {\r\n\r\n\t\t\t\t\t// object is cached, shrink the CACHED region\r\n\r\n\t\t\t\t\tvar firstActiveIndex = -- nCachedObjects,\r\n\t\t\t\t\t\tlastCachedObject = objects[ firstActiveIndex ],\r\n\t\t\t\t\t\tlastIndex = -- nObjects,\r\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\r\n\r\n\t\t\t\t\t// last cached object takes this object's place\r\n\t\t\t\t\tindicesByUUID[ lastCachedObject.uuid ] = index;\r\n\t\t\t\t\tobjects[ index ] = lastCachedObject;\r\n\r\n\t\t\t\t\t// last object goes to the activated slot and pop\r\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = firstActiveIndex;\r\n\t\t\t\t\tobjects[ firstActiveIndex ] = lastObject;\r\n\t\t\t\t\tobjects.pop();\r\n\r\n\t\t\t\t\t// accounting is done, now do the same for all bindings\r\n\r\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\r\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ],\r\n\t\t\t\t\t\t\tlastCached = bindingsForPath[ firstActiveIndex ],\r\n\t\t\t\t\t\t\tlast = bindingsForPath[ lastIndex ];\r\n\r\n\t\t\t\t\t\tbindingsForPath[ index ] = lastCached;\r\n\t\t\t\t\t\tbindingsForPath[ firstActiveIndex ] = last;\r\n\t\t\t\t\t\tbindingsForPath.pop();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// object is active, just swap with the last and pop\r\n\r\n\t\t\t\t\tvar lastIndex = -- nObjects,\r\n\t\t\t\t\t\tlastObject = objects[ lastIndex ];\r\n\r\n\t\t\t\t\tindicesByUUID[ lastObject.uuid ] = index;\r\n\t\t\t\t\tobjects[ index ] = lastObject;\r\n\t\t\t\t\tobjects.pop();\r\n\r\n\t\t\t\t\t// accounting is done, now do the same for all bindings\r\n\r\n\t\t\t\t\tfor ( var j = 0, m = nBindings; j !== m; ++ j ) {\r\n\r\n\t\t\t\t\t\tvar bindingsForPath = bindings[ j ];\r\n\r\n\t\t\t\t\t\tbindingsForPath[ index ] = bindingsForPath[ lastIndex ];\r\n\t\t\t\t\t\tbindingsForPath.pop();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} // cached or active\r\n\r\n\t\t\t} // if object is known\r\n\r\n\t\t} // for arguments\r\n\r\n\t\tthis.nCachedObjects_ = nCachedObjects;\r\n\r\n\t},\r\n\r\n\t// Internal interface used by befriended PropertyBinding.Composite:\r\n\r\n\tsubscribe_: function( path, parsedPath ) {\r\n\t\t// returns an array of bindings for the given path that is changed\r\n\t\t// according to the contained objects in the group\r\n\r\n\t\tvar indicesByPath = this._bindingsIndicesByPath,\r\n\t\t\tindex = indicesByPath[ path ],\r\n\t\t\tbindings = this._bindings;\r\n\r\n\t\tif ( index !== undefined ) return bindings[ index ];\r\n\r\n\t\tvar paths = this._paths,\r\n\t\t\tparsedPaths = this._parsedPaths,\r\n\t\t\tobjects = this._objects,\r\n\t\t\tnObjects = objects.length,\r\n\t\t\tnCachedObjects = this.nCachedObjects_,\r\n\t\t\tbindingsForPath = new Array( nObjects );\r\n\r\n\t\tindex = bindings.length;\r\n\r\n\t\tindicesByPath[ path ] = index;\r\n\r\n\t\tpaths.push( path );\r\n\t\tparsedPaths.push( parsedPath );\r\n\t\tbindings.push( bindingsForPath );\r\n\r\n\t\tfor ( var i = nCachedObjects,\r\n\t\t\t\tn = objects.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar object = objects[ i ];\r\n\r\n\t\t\tbindingsForPath[ i ] =\r\n\t\t\t\t\tnew THREE.PropertyBinding( object, path, parsedPath );\r\n\r\n\t\t}\r\n\r\n\t\treturn bindingsForPath;\r\n\r\n\t},\r\n\r\n\tunsubscribe_: function( path ) {\r\n\t\t// tells the group to forget about a property path and no longer\r\n\t\t// update the array previously obtained with 'subscribe_'\r\n\r\n\t\tvar indicesByPath = this._bindingsIndicesByPath,\r\n\t\t\tindex = indicesByPath[ path ];\r\n\r\n\t\tif ( index !== undefined ) {\r\n\r\n\t\t\tvar paths = this._paths,\r\n\t\t\t\tparsedPaths = this._parsedPaths,\r\n\t\t\t\tbindings = this._bindings,\r\n\t\t\t\tlastBindingsIndex = bindings.length - 1,\r\n\t\t\t\tlastBindings = bindings[ lastBindingsIndex ],\r\n\t\t\t\tlastBindingsPath = path[ lastBindingsIndex ];\r\n\r\n\t\t\tindicesByPath[ lastBindingsPath ] = index;\r\n\r\n\t\t\tbindings[ index ] = lastBindings;\r\n\t\t\tbindings.pop();\r\n\r\n\t\t\tparsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];\r\n\t\t\tparsedPaths.pop();\r\n\r\n\t\t\tpaths[ index ] = paths[ lastBindingsIndex ];\r\n\t\t\tpaths.pop();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\n// File:src/animation/AnimationUtils.js\r\n\r\n/**\r\n * @author tschw\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n */\r\n\r\nTHREE.AnimationUtils = {\r\n\r\n\t// same as Array.prototype.slice, but also works on typed arrays\r\n\tarraySlice: function( array, from, to ) {\r\n\r\n\t\tif ( THREE.AnimationUtils.isTypedArray( array ) ) {\r\n\r\n\t\t\treturn new array.constructor( array.subarray( from, to ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn array.slice( from, to );\r\n\r\n\t},\r\n\r\n\t// converts an array to a specific type\r\n\tconvertArray: function( array, type, forceClone ) {\r\n\r\n\t\tif ( ! array || // let 'undefined' and 'null' pass\r\n\t\t\t\t! forceClone && array.constructor === type ) return array;\r\n\r\n\t\tif ( typeof type.BYTES_PER_ELEMENT === 'number' ) {\r\n\r\n\t\t\treturn new type( array ); // create typed array\r\n\r\n\t\t}\r\n\r\n\t\treturn Array.prototype.slice.call( array ); // create Array\r\n\r\n\t},\r\n\r\n\tisTypedArray: function( object ) {\r\n\r\n\t\treturn ArrayBuffer.isView( object ) &&\r\n\t\t\t\t! ( object instanceof DataView );\r\n\r\n\t},\r\n\r\n\t// returns an array by which times and values can be sorted\r\n\tgetKeyframeOrder: function( times ) {\r\n\r\n\t\tfunction compareTime( i, j ) {\r\n\r\n\t\t\treturn times[ i ] - times[ j ];\r\n\r\n\t\t}\r\n\r\n\t\tvar n = times.length;\r\n\t\tvar result = new Array( n );\r\n\t\tfor ( var i = 0; i !== n; ++ i ) result[ i ] = i;\r\n\r\n\t\tresult.sort( compareTime );\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\t// uses the array previously returned by 'getKeyframeOrder' to sort data\r\n\tsortedArray: function( values, stride, order ) {\r\n\r\n\t\tvar nValues = values.length;\r\n\t\tvar result = new values.constructor( nValues );\r\n\r\n\t\tfor ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {\r\n\r\n\t\t\tvar srcOffset = order[ i ] * stride;\r\n\r\n\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\r\n\r\n\t\t\t\tresult[ dstOffset ++ ] = values[ srcOffset + j ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t},\r\n\r\n\t// function for parsing AOS keyframe formats\r\n\tflattenJSON: function( jsonKeys, times, values, valuePropertyName ) {\r\n\r\n\t\tvar i = 1, key = jsonKeys[ 0 ];\r\n\r\n\t\twhile ( key !== undefined && key[ valuePropertyName ] === undefined ) {\r\n\r\n\t\t\tkey = jsonKeys[ i ++ ];\r\n\r\n\t\t}\r\n\r\n\t\tif ( key === undefined ) return; // no data\r\n\r\n\t\tvar value = key[ valuePropertyName ];\r\n\t\tif ( value === undefined ) return; // no data\r\n\r\n\t\tif ( Array.isArray( value ) ) {\r\n\r\n\t\t\tdo {\r\n\r\n\t\t\t\tvalue = key[ valuePropertyName ];\r\n\r\n\t\t\t\tif ( value !== undefined ) {\r\n\r\n\t\t\t\t\ttimes.push( key.time );\r\n\t\t\t\t\tvalues.push.apply( values, value ); // push all elements\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tkey = jsonKeys[ i ++ ];\r\n\r\n\t\t\t} while ( key !== undefined );\r\n\r\n\t\t} else if ( value.toArray !== undefined ) {\r\n\t\t\t// ...assume THREE.Math-ish\r\n\r\n\t\t\tdo {\r\n\r\n\t\t\t\tvalue = key[ valuePropertyName ];\r\n\r\n\t\t\t\tif ( value !== undefined ) {\r\n\r\n\t\t\t\t\ttimes.push( key.time );\r\n\t\t\t\t\tvalue.toArray( values, values.length );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tkey = jsonKeys[ i ++ ];\r\n\r\n\t\t\t} while ( key !== undefined );\r\n\r\n\t\t} else {\r\n\t\t\t// otherwise push as-is\r\n\r\n\t\t\tdo {\r\n\r\n\t\t\t\tvalue = key[ valuePropertyName ];\r\n\r\n\t\t\t\tif ( value !== undefined ) {\r\n\r\n\t\t\t\t\ttimes.push( key.time );\r\n\t\t\t\t\tvalues.push( value );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tkey = jsonKeys[ i ++ ];\r\n\r\n\t\t\t} while ( key !== undefined );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/animation/KeyframeTrack.js\r\n\r\n/**\r\n *\r\n * A timed sequence of keyframes for a specific property.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.KeyframeTrack = function ( name, times, values, interpolation ) {\r\n\r\n\tif( name === undefined ) throw new Error( \"track name is undefined\" );\r\n\r\n\tif( times === undefined || times.length === 0 ) {\r\n\r\n\t\tthrow new Error( \"no keyframes in track named \" + name );\r\n\r\n\t}\r\n\r\n\tthis.name = name;\r\n\r\n\tthis.times = THREE.AnimationUtils.convertArray( times, this.TimeBufferType );\r\n\tthis.values = THREE.AnimationUtils.convertArray( values, this.ValueBufferType );\r\n\r\n\tthis.setInterpolation( interpolation || this.DefaultInterpolation );\r\n\r\n\tthis.validate();\r\n\tthis.optimize();\r\n\r\n};\r\n\r\nTHREE.KeyframeTrack.prototype = {\r\n\r\n\tconstructor: THREE.KeyframeTrack,\r\n\r\n\tTimeBufferType: Float32Array,\r\n\tValueBufferType: Float32Array,\r\n\r\n\tDefaultInterpolation: THREE.InterpolateLinear,\r\n\r\n\tInterpolantFactoryMethodDiscrete: function( result ) {\r\n\r\n\t\treturn new THREE.DiscreteInterpolant(\r\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\r\n\r\n\t},\r\n\r\n\tInterpolantFactoryMethodLinear: function( result ) {\r\n\r\n\t\treturn new THREE.LinearInterpolant(\r\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\r\n\r\n\t},\r\n\r\n\tInterpolantFactoryMethodSmooth: function( result ) {\r\n\r\n\t\treturn new THREE.CubicInterpolant(\r\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\r\n\r\n\t},\r\n\r\n\tsetInterpolation: function( interpolation ) {\r\n\r\n\t\tvar factoryMethod;\r\n\r\n\t\tswitch ( interpolation ) {\r\n\r\n\t\t\tcase THREE.InterpolateDiscrete:\r\n\r\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodDiscrete;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase THREE.InterpolateLinear:\r\n\r\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodLinear;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase THREE.InterpolateSmooth:\r\n\r\n\t\t\t\tfactoryMethod = this.InterpolantFactoryMethodSmooth;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\tif ( factoryMethod === undefined ) {\r\n\r\n\t\t\tvar message = \"unsupported interpolation for \" +\r\n\t\t\t\t\tthis.ValueTypeName + \" keyframe track named \" + this.name;\r\n\r\n\t\t\tif ( this.createInterpolant === undefined ) {\r\n\r\n\t\t\t\t// fall back to default, unless the default itself is messed up\r\n\t\t\t\tif ( interpolation !== this.DefaultInterpolation ) {\r\n\r\n\t\t\t\t\tthis.setInterpolation( this.DefaultInterpolation );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tthrow new Error( message ); // fatal, in this case\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tconsole.warn( message );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tthis.createInterpolant = factoryMethod;\r\n\r\n\t},\r\n\r\n\tgetInterpolation: function() {\r\n\r\n\t\tswitch ( this.createInterpolant ) {\r\n\r\n\t\t\tcase this.InterpolantFactoryMethodDiscrete:\r\n\r\n\t\t\t\treturn THREE.InterpolateDiscrete;\r\n\r\n\t\t\tcase this.InterpolantFactoryMethodLinear:\r\n\r\n\t\t\t\treturn THREE.InterpolateLinear;\r\n\r\n\t\t\tcase this.InterpolantFactoryMethodSmooth:\r\n\r\n\t\t\t\treturn THREE.InterpolateSmooth;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetValueSize: function() {\r\n\r\n\t\treturn this.values.length / this.times.length;\r\n\r\n\t},\r\n\r\n\t// move all keyframes either forwards or backwards in time\r\n\tshift: function( timeOffset ) {\r\n\r\n\t\tif( timeOffset !== 0.0 ) {\r\n\r\n\t\t\tvar times = this.times;\r\n\r\n\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\ttimes[ i ] += timeOffset;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// scale all keyframe times by a factor (useful for frame <-> seconds conversions)\r\n\tscale: function( timeScale ) {\r\n\r\n\t\tif( timeScale !== 1.0 ) {\r\n\r\n\t\t\tvar times = this.times;\r\n\r\n\t\t\tfor( var i = 0, n = times.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\ttimes[ i ] *= timeScale;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// removes keyframes before and after animation without changing any values within the range [startTime, endTime].\r\n\t// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values\r\n\ttrim: function( startTime, endTime ) {\r\n\r\n\t\tvar times = this.times,\r\n\t\t\tnKeys = times.length,\r\n\t\t\tfrom = 0,\r\n\t\t\tto = nKeys - 1;\r\n\r\n\t\twhile ( from !== nKeys && times[ from ] < startTime ) ++ from;\r\n\t\twhile ( to !== -1 && times[ to ] > endTime ) -- to;\r\n\r\n\t\t++ to; // inclusive -> exclusive bound\r\n\r\n\t\tif( from !== 0 || to !== nKeys ) {\r\n\r\n\t\t\t// empty tracks are forbidden, so keep at least one keyframe\r\n\t\t\tif ( from >= to ) to = Math.max( to , 1 ), from = to - 1;\r\n\r\n\t\t\tvar stride = this.getValueSize();\r\n\t\t\tthis.times = THREE.AnimationUtils.arraySlice( times, from, to );\r\n\t\t\tthis.values = THREE.AnimationUtils.\r\n\t\t\t\t\tarraySlice( this.values, from * stride, to * stride );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable\r\n\tvalidate: function() {\r\n\r\n\t\tvar valid = true;\r\n\r\n\t\tvar valueSize = this.getValueSize();\r\n\t\tif ( valueSize - Math.floor( valueSize ) !== 0 ) {\r\n\r\n\t\t\tconsole.error( \"invalid value size in track\", this );\r\n\t\t\tvalid = false;\r\n\r\n\t\t}\r\n\r\n\t\tvar times = this.times,\r\n\t\t\tvalues = this.values,\r\n\r\n\t\t\tnKeys = times.length;\r\n\r\n\t\tif( nKeys === 0 ) {\r\n\r\n\t\t\tconsole.error( \"track is empty\", this );\r\n\t\t\tvalid = false;\r\n\r\n\t\t}\r\n\r\n\t\tvar prevTime = null;\r\n\r\n\t\tfor( var i = 0; i !== nKeys; i ++ ) {\r\n\r\n\t\t\tvar currTime = times[ i ];\r\n\r\n\t\t\tif ( typeof currTime === 'number' && isNaN( currTime ) ) {\r\n\r\n\t\t\t\tconsole.error( \"time is not a valid number\", this, i, currTime );\r\n\t\t\t\tvalid = false;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif( prevTime !== null && prevTime > currTime ) {\r\n\r\n\t\t\t\tconsole.error( \"out of order keys\", this, i, currTime, prevTime );\r\n\t\t\t\tvalid = false;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tprevTime = currTime;\r\n\r\n\t\t}\r\n\r\n\t\tif ( values !== undefined ) {\r\n\r\n\t\t\tif ( THREE.AnimationUtils.isTypedArray( values ) ) {\r\n\r\n\t\t\t\tfor ( var i = 0, n = values.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\t\tvar value = values[ i ];\r\n\r\n\t\t\t\t\tif ( isNaN( value ) ) {\r\n\r\n\t\t\t\t\t\tconsole.error( \"value is not a valid number\", this, i, value );\r\n\t\t\t\t\t\tvalid = false;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn valid;\r\n\r\n\t},\r\n\r\n\t// removes equivalent sequential keys as common in morph target sequences\r\n\t// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)\r\n\toptimize: function() {\r\n\r\n\t\tvar times = this.times,\r\n\t\t\tvalues = this.values,\r\n\t\t\tstride = this.getValueSize(),\r\n\r\n\t\t\twriteIndex = 1;\r\n\r\n\t\tfor( var i = 1, n = times.length - 1; i <= n; ++ i ) {\r\n\r\n\t\t\tvar keep = false;\r\n\r\n\t\t\tvar time = times[ i ];\r\n\t\t\tvar timeNext = times[ i + 1 ];\r\n\r\n\t\t\t// remove adjacent keyframes scheduled at the same time\r\n\r\n\t\t\tif ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {\r\n\r\n\t\t\t\t// remove unnecessary keyframes same as their neighbors\r\n\t\t\t\tvar offset = i * stride,\r\n\t\t\t\t\toffsetP = offset - stride,\r\n\t\t\t\t\toffsetN = offset + stride;\r\n\r\n\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\r\n\r\n\t\t\t\t\tvar value = values[ offset + j ];\r\n\r\n\t\t\t\t\tif ( value !== values[ offsetP + j ] ||\r\n\t\t\t\t\t\t\tvalue !== values[ offsetN + j ] ) {\r\n\r\n\t\t\t\t\t\tkeep = true;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// in-place compaction\r\n\r\n\t\t\tif ( keep ) {\r\n\r\n\t\t\t\tif ( i !== writeIndex ) {\r\n\r\n\t\t\t\t\ttimes[ writeIndex ] = times[ i ];\r\n\r\n\t\t\t\t\tvar readOffset = i * stride,\r\n\t\t\t\t\t\twriteOffset = writeIndex * stride;\r\n\r\n\t\t\t\t\tfor ( var j = 0; j !== stride; ++ j ) {\r\n\r\n\t\t\t\t\t\tvalues[ writeOffset + j ] = values[ readOffset + j ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t++ writeIndex;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( writeIndex !== times.length ) {\r\n\r\n\t\t\tthis.times = THREE.AnimationUtils.arraySlice( times, 0, writeIndex );\r\n\t\t\tthis.values = THREE.AnimationUtils.arraySlice( values, 0, writeIndex * stride );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// Static methods:\r\n\r\nObject.assign( THREE.KeyframeTrack, {\r\n\r\n\t// Serialization (in static context, because of constructor invocation\r\n\t// and automatic invocation of .toJSON):\r\n\r\n\tparse: function( json ) {\r\n\r\n\t\tif( json.type === undefined ) {\r\n\r\n\t\t\tthrow new Error( \"track type undefined, can not parse\" );\r\n\r\n\t\t}\r\n\r\n\t\tvar trackType = THREE.KeyframeTrack._getTrackTypeForValueTypeName( json.type );\r\n\r\n\t\tif ( json.times === undefined ) {\r\n\r\n\t\t\tvar times = [], values = [];\r\n\r\n\t\t\tTHREE.AnimationUtils.flattenJSON( json.keys, times, values, 'value' );\r\n\r\n\t\t\tjson.times = times;\r\n\t\t\tjson.values = values;\r\n\r\n\t\t}\r\n\r\n\t\t// derived classes can define a static parse method\r\n\t\tif ( trackType.parse !== undefined ) {\r\n\r\n\t\t\treturn trackType.parse( json );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// by default, we asssume a constructor compatible with the base\r\n\t\t\treturn new trackType(\r\n\t\t\t\t\tjson.name, json.times, json.values, json.interpolation );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttoJSON: function( track ) {\r\n\r\n\t\tvar trackType = track.constructor;\r\n\r\n\t\tvar json;\r\n\r\n\t\t// derived classes can define a static toJSON method\r\n\t\tif ( trackType.toJSON !== undefined ) {\r\n\r\n\t\t\tjson = trackType.toJSON( track );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// by default, we assume the data can be serialized as-is\r\n\t\t\tjson = {\r\n\r\n\t\t\t\t'name': track.name,\r\n\t\t\t\t'times': THREE.AnimationUtils.convertArray( track.times, Array ),\r\n\t\t\t\t'values': THREE.AnimationUtils.convertArray( track.values, Array )\r\n\r\n\t\t\t};\r\n\r\n\t\t\tvar interpolation = track.getInterpolation();\r\n\r\n\t\t\tif ( interpolation !== track.DefaultInterpolation ) {\r\n\r\n\t\t\t\tjson.interpolation = interpolation;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tjson.type = track.ValueTypeName; // mandatory\r\n\r\n\t\treturn json;\r\n\r\n\t},\r\n\r\n\t_getTrackTypeForValueTypeName: function( typeName ) {\r\n\r\n\t\tswitch( typeName.toLowerCase() ) {\r\n\r\n\t\t\tcase \"scalar\":\r\n\t\t\tcase \"double\":\r\n\t\t\tcase \"float\":\r\n\t\t\tcase \"number\":\r\n\t\t\tcase \"integer\":\r\n\r\n\t\t\t\treturn THREE.NumberKeyframeTrack;\r\n\r\n\t\t\tcase \"vector\":\r\n\t\t\tcase \"vector2\":\r\n\t\t\tcase \"vector3\":\r\n\t\t\tcase \"vector4\":\r\n\r\n\t\t\t\treturn THREE.VectorKeyframeTrack;\r\n\r\n\t\t\tcase \"color\":\r\n\r\n\t\t\t\treturn THREE.ColorKeyframeTrack;\r\n\r\n\t\t\tcase \"quaternion\":\r\n\r\n\t\t\t\treturn THREE.QuaternionKeyframeTrack;\r\n\r\n\t\t\tcase \"bool\":\r\n\t\t\tcase \"boolean\":\r\n\r\n\t\t\t\treturn THREE.BooleanKeyframeTrack;\r\n\r\n\t\t\tcase \"string\":\r\n\r\n\t\t\t\treturn THREE.StringKeyframeTrack;\r\n\r\n\t\t}\r\n\r\n\t\tthrow new Error( \"Unsupported typeName: \" + typeName );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/animation/PropertyBinding.js\r\n\r\n/**\r\n *\r\n * A reference to a real property in the scene graph.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.PropertyBinding = function ( rootNode, path, parsedPath ) {\r\n\r\n\tthis.path = path;\r\n\tthis.parsedPath = parsedPath ||\r\n\t\t\tTHREE.PropertyBinding.parseTrackName( path );\r\n\r\n\tthis.node = THREE.PropertyBinding.findNode(\r\n\t\t\trootNode, this.parsedPath.nodeName ) || rootNode;\r\n\r\n\tthis.rootNode = rootNode;\r\n\r\n};\r\n\r\nTHREE.PropertyBinding.prototype = {\r\n\r\n\tconstructor: THREE.PropertyBinding,\r\n\r\n\tgetValue: function getValue_unbound( targetArray, offset ) {\r\n\r\n\t\tthis.bind();\r\n\t\tthis.getValue( targetArray, offset );\r\n\r\n\t\t// Note: This class uses a State pattern on a per-method basis:\r\n\t\t// 'bind' sets 'this.getValue' / 'setValue' and shadows the\r\n\t\t// prototype version of these methods with one that represents\r\n\t\t// the bound state. When the property is not found, the methods\r\n\t\t// become no-ops.\r\n\r\n\t},\r\n\r\n\tsetValue: function getValue_unbound( sourceArray, offset ) {\r\n\r\n\t\tthis.bind();\r\n\t\tthis.setValue( sourceArray, offset );\r\n\r\n\t},\r\n\r\n\t// create getter / setter pair for a property in the scene graph\r\n\tbind: function() {\r\n\r\n\t\tvar targetObject = this.node,\r\n\t\t\tparsedPath = this.parsedPath,\r\n\r\n\t\t\tobjectName = parsedPath.objectName,\r\n\t\t\tpropertyName = parsedPath.propertyName,\r\n\t\t\tpropertyIndex = parsedPath.propertyIndex;\r\n\r\n\t\tif ( ! targetObject ) {\r\n\r\n\t\t\ttargetObject = THREE.PropertyBinding.findNode(\r\n\t\t\t\t\tthis.rootNode, parsedPath.nodeName ) || this.rootNode;\r\n\r\n\t\t\tthis.node = targetObject;\r\n\r\n\t\t}\r\n\r\n\t\t// set fail state so we can just 'return' on error\r\n\t\tthis.getValue = this._getValue_unavailable;\r\n\t\tthis.setValue = this._setValue_unavailable;\r\n\r\n \t\t// ensure there is a value node\r\n\t\tif ( ! targetObject ) {\r\n\r\n\t\t\tconsole.error( \"  trying to update node for track: \" + this.path + \" but it wasn't found.\" );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif( objectName ) {\r\n\r\n\t\t\tvar objectIndex = parsedPath.objectIndex;\r\n\r\n\t\t\t// special cases were we need to reach deeper into the hierarchy to get the face materials....\r\n\t\t\tswitch ( objectName ) {\r\n\r\n\t\t\t\tcase 'materials':\r\n\r\n\t\t\t\t\tif( ! targetObject.material ) {\r\n\r\n\t\t\t\t\t\tconsole.error( '  can not bind to material as node does not have a material', this );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif( ! targetObject.material.materials ) {\r\n\r\n\t\t\t\t\t\tconsole.error( '  can not bind to material.materials as node.material does not have a materials array', this );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttargetObject = targetObject.material.materials;\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'bones':\r\n\r\n\t\t\t\t\tif( ! targetObject.skeleton ) {\r\n\r\n\t\t\t\t\t\tconsole.error( '  can not bind to bones as node does not have a skeleton', this );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// potential future optimization: skip this if propertyIndex is already an integer\r\n\t\t\t\t\t// and convert the integer string to a true integer.\r\n\r\n\t\t\t\t\ttargetObject = targetObject.skeleton.bones;\r\n\r\n\t\t\t\t\t// support resolving morphTarget names into indices.\r\n\t\t\t\t\tfor ( var i = 0; i < targetObject.length; i ++ ) {\r\n\r\n\t\t\t\t\t\tif ( targetObject[i].name === objectIndex ) {\r\n\r\n\t\t\t\t\t\t\tobjectIndex = i;\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\r\n\t\t\t\t\tif ( targetObject[ objectName ] === undefined ) {\r\n\r\n\t\t\t\t\t\tconsole.error( '  can not bind to objectName of node, undefined', this );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\ttargetObject = targetObject[ objectName ];\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif ( objectIndex !== undefined ) {\r\n\r\n\t\t\t\tif( targetObject[ objectIndex ] === undefined ) {\r\n\r\n\t\t\t\t\tconsole.error( \"  trying to bind to objectIndex of objectName, but is undefined:\", this, targetObject );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttargetObject = targetObject[ objectIndex ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// resolve property\r\n\t\tvar nodeProperty = targetObject[ propertyName ];\r\n\r\n\t\tif ( ! nodeProperty ) {\r\n\r\n\t\t\tvar nodeName = parsedPath.nodeName;\r\n\r\n\t\t\tconsole.error( \"  trying to update property for track: \" + nodeName +\r\n\t\t\t\t\t'.' + propertyName + \" but it wasn't found.\", targetObject );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\t// determine versioning scheme\r\n\t\tvar versioning = this.Versioning.None;\r\n\r\n\t\tif ( targetObject.needsUpdate !== undefined ) { // material\r\n\r\n\t\t\tversioning = this.Versioning.NeedsUpdate;\r\n\t\t\tthis.targetObject = targetObject;\r\n\r\n\t\t} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform\r\n\r\n\t\t\tversioning = this.Versioning.MatrixWorldNeedsUpdate;\r\n\t\t\tthis.targetObject = targetObject;\r\n\r\n\t\t}\r\n\r\n\t\t// determine how the property gets bound\r\n\t\tvar bindingType = this.BindingType.Direct;\r\n\r\n\t\tif ( propertyIndex !== undefined ) {\r\n\t\t\t// access a sub element of the property array (only primitives are supported right now)\r\n\r\n\t\t\tif ( propertyName === \"morphTargetInfluences\" ) {\r\n\t\t\t\t// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.\r\n\r\n\t\t\t\t// support resolving morphTarget names into indices.\r\n\t\t\t\tif ( ! targetObject.geometry ) {\r\n\r\n\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( ! targetObject.geometry.morphTargets ) {\r\n\r\n\t\t\t\t\tconsole.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {\r\n\r\n\t\t\t\t\tif ( targetObject.geometry.morphTargets[i].name === propertyIndex ) {\r\n\r\n\t\t\t\t\t\tpropertyIndex = i;\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbindingType = this.BindingType.ArrayElement;\r\n\r\n\t\t\tthis.resolvedProperty = nodeProperty;\r\n\t\t\tthis.propertyIndex = propertyIndex;\r\n\r\n\t\t} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {\r\n\t\t\t// must use copy for Object3D.Euler/Quaternion\r\n\r\n\t\t\tbindingType = this.BindingType.HasFromToArray;\r\n\r\n\t\t\tthis.resolvedProperty = nodeProperty;\r\n\r\n\t\t} else if ( nodeProperty.length !== undefined ) {\r\n\r\n\t\t\tbindingType = this.BindingType.EntireArray;\r\n\r\n\t\t\tthis.resolvedProperty = nodeProperty;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.propertyName = propertyName;\r\n\r\n\t\t}\r\n\r\n\t\t// select getter / setter\r\n\t\tthis.getValue = this.GetterByBindingType[ bindingType ];\r\n\t\tthis.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];\r\n\r\n\t},\r\n\r\n\tunbind: function() {\r\n\r\n\t\tthis.node = null;\r\n\r\n\t\t// back to the prototype version of getValue / setValue\r\n\t\t// note: avoiding to mutate the shape of 'this' via 'delete'\r\n\t\tthis.getValue = this._getValue_unbound;\r\n\t\tthis.setValue = this._setValue_unbound;\r\n\r\n\t}\r\n\r\n};\r\n\r\nObject.assign( THREE.PropertyBinding.prototype, { // prototype, continued\r\n\r\n\t// these are used to \"bind\" a nonexistent property\r\n\t_getValue_unavailable: function() {},\r\n\t_setValue_unavailable: function() {},\r\n\r\n\t// initial state of these methods that calls 'bind'\r\n\t_getValue_unbound: THREE.PropertyBinding.prototype.getValue,\r\n\t_setValue_unbound: THREE.PropertyBinding.prototype.setValue,\r\n\r\n\tBindingType: {\r\n\t\tDirect: 0,\r\n\t\tEntireArray: 1,\r\n\t\tArrayElement: 2,\r\n\t\tHasFromToArray: 3\r\n\t},\r\n\r\n\tVersioning: {\r\n\t\tNone: 0,\r\n\t\tNeedsUpdate: 1,\r\n\t\tMatrixWorldNeedsUpdate: 2\r\n\t},\r\n\r\n\tGetterByBindingType: [\r\n\r\n\t\tfunction getValue_direct( buffer, offset ) {\r\n\r\n\t\t\tbuffer[ offset ] = this.node[ this.propertyName ];\r\n\r\n\t\t},\r\n\r\n\t\tfunction getValue_array( buffer, offset ) {\r\n\r\n\t\t\tvar source = this.resolvedProperty;\r\n\r\n\t\t\tfor ( var i = 0, n = source.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\tbuffer[ offset ++ ] = source[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tfunction getValue_arrayElement( buffer, offset ) {\r\n\r\n\t\t\tbuffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];\r\n\r\n\t\t},\r\n\r\n\t\tfunction getValue_toArray( buffer, offset ) {\r\n\r\n\t\t\tthis.resolvedProperty.toArray( buffer, offset );\r\n\r\n\t\t}\r\n\r\n\t],\r\n\r\n\tSetterByBindingTypeAndVersioning: [\r\n\r\n\t\t[\r\n\t\t\t// Direct\r\n\r\n\t\t\tfunction setValue_direct( buffer, offset ) {\r\n\r\n\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_direct_setNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\r\n\t\t\t\tthis.targetObject.needsUpdate = true;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tthis.node[ this.propertyName ] = buffer[ offset ];\r\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t], [\r\n\r\n\t\t\t// EntireArray\r\n\r\n\t\t\tfunction setValue_array( buffer, offset ) {\r\n\r\n\t\t\t\tvar dest = this.resolvedProperty;\r\n\r\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_array_setNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tvar dest = this.resolvedProperty;\r\n\r\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.targetObject.needsUpdate = true;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tvar dest = this.resolvedProperty;\r\n\r\n\t\t\t\tfor ( var i = 0, n = dest.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\t\tdest[ i ] = buffer[ offset ++ ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t], [\r\n\r\n\t\t\t// ArrayElement\r\n\r\n\t\t\tfunction setValue_arrayElement( buffer, offset ) {\r\n\r\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_arrayElement_setNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\r\n\t\t\t\tthis.targetObject.needsUpdate = true;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tthis.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];\r\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t], [\r\n\r\n\t\t\t// HasToFromArray\r\n\r\n\t\t\tfunction setValue_fromArray( buffer, offset ) {\r\n\r\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_fromArray_setNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\r\n\t\t\t\tthis.targetObject.needsUpdate = true;\r\n\r\n\t\t\t},\r\n\r\n\t\t\tfunction setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {\r\n\r\n\t\t\t\tthis.resolvedProperty.fromArray( buffer, offset );\r\n\t\t\t\tthis.targetObject.matrixWorldNeedsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t]\r\n\r\n\t]\r\n\r\n} );\r\n\r\nTHREE.PropertyBinding.Composite =\r\n\t\tfunction( targetGroup, path, optionalParsedPath ) {\r\n\r\n\tvar parsedPath = optionalParsedPath ||\r\n\t\t\tTHREE.PropertyBinding.parseTrackName( path );\r\n\r\n\tthis._targetGroup = targetGroup;\r\n\tthis._bindings = targetGroup.subscribe_( path, parsedPath );\r\n\r\n};\r\n\r\nTHREE.PropertyBinding.Composite.prototype = {\r\n\r\n\tconstructor: THREE.PropertyBinding.Composite,\r\n\r\n\tgetValue: function( array, offset ) {\r\n\r\n\t\tthis.bind(); // bind all binding\r\n\r\n\t\tvar firstValidIndex = this._targetGroup.nCachedObjects_,\r\n\t\t\tbinding = this._bindings[ firstValidIndex ];\r\n\r\n\t\t// and only call .getValue on the first\r\n\t\tif ( binding !== undefined ) binding.getValue( array, offset );\r\n\r\n\t},\r\n\r\n\tsetValue: function( array, offset ) {\r\n\r\n\t\tvar bindings = this._bindings;\r\n\r\n\t\tfor ( var i = this._targetGroup.nCachedObjects_,\r\n\t\t\t\tn = bindings.length; i !== n; ++ i ) {\r\n\r\n\t\t\tbindings[ i ].setValue( array, offset );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tbind: function() {\r\n\r\n\t\tvar bindings = this._bindings;\r\n\r\n\t\tfor ( var i = this._targetGroup.nCachedObjects_,\r\n\t\t\t\tn = bindings.length; i !== n; ++ i ) {\r\n\r\n\t\t\tbindings[ i ].bind();\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tunbind: function() {\r\n\r\n\t\tvar bindings = this._bindings;\r\n\r\n\t\tfor ( var i = this._targetGroup.nCachedObjects_,\r\n\t\t\t\tn = bindings.length; i !== n; ++ i ) {\r\n\r\n\t\t\tbindings[ i ].unbind();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.PropertyBinding.create = function( root, path, parsedPath ) {\r\n\r\n\tif ( ! ( root instanceof THREE.AnimationObjectGroup ) ) {\r\n\r\n\t\treturn new THREE.PropertyBinding( root, path, parsedPath );\r\n\r\n\t} else {\r\n\r\n\t\treturn new THREE.PropertyBinding.Composite( root, path, parsedPath );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.PropertyBinding.parseTrackName = function( trackName ) {\r\n\r\n\t// matches strings in the form of:\r\n\t//    nodeName.property\r\n\t//    nodeName.property[accessor]\r\n\t//    nodeName.material.property[accessor]\r\n\t//    uuid.property[accessor]\r\n\t//    uuid.objectName[objectIndex].propertyName[propertyIndex]\r\n\t//    parentName/nodeName.property\r\n\t//    parentName/parentName/nodeName.property[index]\r\n\t//\t  .bone[Armature.DEF_cog].position\r\n\t// created and tested via https://regex101.com/#javascript\r\n\r\n\tvar re = /^(([\\w]+\\/)*)([\\w-\\d]+)?(\\.([\\w]+)(\\[([\\w\\d\\[\\]\\_.:\\- ]+)\\])?)?(\\.([\\w.]+)(\\[([\\w\\d\\[\\]\\_. ]+)\\])?)$/;\r\n\tvar matches = re.exec(trackName);\r\n\r\n\tif( ! matches ) {\r\n\t\tthrow new Error( \"cannot parse trackName at all: \" + trackName );\r\n\t}\r\n\r\n    if (matches.index === re.lastIndex) {\r\n        re.lastIndex++;\r\n    }\r\n\r\n\tvar results = {\r\n\t\t// directoryName: matches[1], // (tschw) currently unused\r\n\t\tnodeName: matches[3], \t// allowed to be null, specified root node.\r\n\t\tobjectName: matches[5],\r\n\t\tobjectIndex: matches[7],\r\n\t\tpropertyName: matches[9],\r\n\t\tpropertyIndex: matches[11]\t// allowed to be null, specifies that the whole property is set.\r\n\t};\r\n\r\n\tif( results.propertyName === null || results.propertyName.length === 0 ) {\r\n\t\tthrow new Error( \"can not parse propertyName from trackName: \" + trackName );\r\n\t}\r\n\r\n\treturn results;\r\n\r\n};\r\n\r\nTHREE.PropertyBinding.findNode = function( root, nodeName ) {\r\n\r\n\tif( ! nodeName || nodeName === \"\" || nodeName === \"root\" || nodeName === \".\" || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {\r\n\r\n\t\treturn root;\r\n\r\n\t}\r\n\r\n\t// search into skeleton bones.\r\n\tif( root.skeleton ) {\r\n\r\n\t\tvar searchSkeleton = function( skeleton ) {\r\n\r\n\t\t\tfor( var i = 0; i < skeleton.bones.length; i ++ ) {\r\n\r\n\t\t\t\tvar bone = skeleton.bones[i];\r\n\r\n\t\t\t\tif( bone.name === nodeName ) {\r\n\r\n\t\t\t\t\treturn bone;\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t};\r\n\r\n\t\tvar bone = searchSkeleton( root.skeleton );\r\n\r\n\t\tif( bone ) {\r\n\r\n\t\t\treturn bone;\r\n\r\n\t\t}\r\n\t}\r\n\r\n\t// search into node subtree.\r\n\tif( root.children ) {\r\n\r\n\t\tvar searchNodeSubtree = function( children ) {\r\n\r\n\t\t\tfor( var i = 0; i < children.length; i ++ ) {\r\n\r\n\t\t\t\tvar childNode = children[i];\r\n\r\n\t\t\t\tif( childNode.name === nodeName || childNode.uuid === nodeName ) {\r\n\r\n\t\t\t\t\treturn childNode;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar result = searchNodeSubtree( childNode.children );\r\n\r\n\t\t\t\tif( result ) return result;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn null;\r\n\r\n\t\t};\r\n\r\n\t\tvar subTreeNode = searchNodeSubtree( root.children );\r\n\r\n\t\tif( subTreeNode ) {\r\n\r\n\t\t\treturn subTreeNode;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn null;\r\n\r\n};\r\n\r\n// File:src/animation/PropertyMixer.js\r\n\r\n/**\r\n *\r\n * Buffered scene graph property that allows weighted accumulation.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.PropertyMixer = function ( binding, typeName, valueSize ) {\r\n\r\n\tthis.binding = binding;\r\n\tthis.valueSize = valueSize;\r\n\r\n\tvar bufferType = Float64Array,\r\n\t\tmixFunction;\r\n\r\n\tswitch ( typeName ) {\r\n\r\n\t\tcase 'quaternion':\t\t\tmixFunction = this._slerp;\t\tbreak;\r\n\r\n\t\tcase 'string':\r\n\t\tcase 'bool':\r\n\r\n\t\t\tbufferType = Array,\t\tmixFunction = this._select;\t\tbreak;\r\n\r\n\t\tdefault:\t\t\t\t\tmixFunction = this._lerp;\r\n\r\n\t}\r\n\r\n\tthis.buffer = new bufferType( valueSize * 4 );\r\n\t// layout: [ incoming | accu0 | accu1 | orig ]\r\n\t//\r\n\t// interpolators can use .buffer as their .result\r\n\t// the data then goes to 'incoming'\r\n\t//\r\n\t// 'accu0' and 'accu1' are used frame-interleaved for\r\n\t// the cumulative result and are compared to detect\r\n\t// changes\r\n\t//\r\n\t// 'orig' stores the original state of the property\r\n\r\n\tthis._mixBufferRegion = mixFunction;\r\n\r\n\tthis.cumulativeWeight = 0;\r\n\r\n\tthis.useCount = 0;\r\n\tthis.referenceCount = 0;\r\n\r\n};\r\n\r\nTHREE.PropertyMixer.prototype = {\r\n\r\n\tconstructor: THREE.PropertyMixer,\r\n\r\n\t// accumulate data in the 'incoming' region into 'accu<i>'\r\n\taccumulate: function( accuIndex, weight ) {\r\n\r\n\t\t// note: happily accumulating nothing when weight = 0, the caller knows\r\n\t\t// the weight and shouldn't have made the call in the first place\r\n\r\n\t\tvar buffer = this.buffer,\r\n\t\t\tstride = this.valueSize,\r\n\t\t\toffset = accuIndex * stride + stride,\r\n\r\n\t\t\tcurrentWeight = this.cumulativeWeight;\r\n\r\n\t\tif ( currentWeight === 0 ) {\r\n\r\n\t\t\t// accuN := incoming * weight\r\n\r\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\r\n\t\t\t\tbuffer[ offset + i ] = buffer[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcurrentWeight = weight;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// accuN := accuN + incoming * weight\r\n\r\n\t\t\tcurrentWeight += weight;\r\n\t\t\tvar mix = weight / currentWeight;\r\n\t\t\tthis._mixBufferRegion( buffer, offset, 0, mix, stride );\r\n\r\n\t\t}\r\n\r\n\t\tthis.cumulativeWeight = currentWeight;\r\n\r\n\t},\r\n\r\n\t// apply the state of 'accu<i>' to the binding when accus differ\r\n\tapply: function( accuIndex ) {\r\n\r\n\t\tvar stride = this.valueSize,\r\n\t\t\tbuffer = this.buffer,\r\n\t\t\toffset = accuIndex * stride + stride,\r\n\r\n\t\t\tweight = this.cumulativeWeight,\r\n\r\n\t\t\tbinding = this.binding;\r\n\r\n\t\tthis.cumulativeWeight = 0;\r\n\r\n\t\tif ( weight < 1 ) {\r\n\r\n\t\t\t// accuN := accuN + original * ( 1 - cumulativeWeight )\r\n\r\n\t\t\tvar originalValueOffset = stride * 3;\r\n\r\n\t\t\tthis._mixBufferRegion(\r\n\t\t\t\t\tbuffer, offset, originalValueOffset, 1 - weight, stride );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = stride, e = stride + stride; i !== e; ++ i ) {\r\n\r\n\t\t\tif ( buffer[ i ] !== buffer[ i + stride ] ) {\r\n\r\n\t\t\t\t// value has changed -> update scene graph\r\n\r\n\t\t\t\tbinding.setValue( buffer, offset );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// remember the state of the bound property and copy it to both accus\r\n\tsaveOriginalState: function() {\r\n\r\n\t\tvar binding = this.binding;\r\n\r\n\t\tvar buffer = this.buffer,\r\n\t\t\tstride = this.valueSize,\r\n\r\n\t\t\toriginalValueOffset = stride * 3;\r\n\r\n\t\tbinding.getValue( buffer, originalValueOffset );\r\n\r\n\t\t// accu[0..1] := orig -- initially detect changes against the original\r\n\t\tfor ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {\r\n\r\n\t\t\tbuffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];\r\n\r\n\t\t}\r\n\r\n\t\tthis.cumulativeWeight = 0;\r\n\r\n\t},\r\n\r\n\t// apply the state previously taken via 'saveOriginalState' to the binding\r\n\trestoreOriginalState: function() {\r\n\r\n\t\tvar originalValueOffset = this.valueSize * 3;\r\n\t\tthis.binding.setValue( this.buffer, originalValueOffset );\r\n\r\n\t},\r\n\r\n\r\n\t// mix functions\r\n\r\n\t_select: function( buffer, dstOffset, srcOffset, t, stride ) {\r\n\r\n\t\tif ( t >= 0.5 ) {\r\n\r\n\t\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\r\n\t\t\t\tbuffer[ dstOffset + i ] = buffer[ srcOffset + i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {\r\n\r\n\t\tTHREE.Quaternion.slerpFlat( buffer, dstOffset,\r\n\t\t\t\tbuffer, dstOffset, buffer, srcOffset, t );\r\n\r\n\t},\r\n\r\n\t_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {\r\n\r\n\t\tvar s = 1 - t;\r\n\r\n\t\tfor ( var i = 0; i !== stride; ++ i ) {\r\n\r\n\t\t\tvar j = dstOffset + i;\r\n\r\n\t\t\tbuffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/animation/tracks/BooleanKeyframeTrack.js\r\n\r\n/**\r\n *\r\n * A Track of Boolean keyframe values.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.BooleanKeyframeTrack = function ( name, times, values ) {\r\n\r\n\tTHREE.KeyframeTrack.call( this, name, times, values );\r\n\r\n};\r\n\r\nTHREE.BooleanKeyframeTrack.prototype =\r\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\r\n\tconstructor: THREE.BooleanKeyframeTrack,\r\n\r\n\tValueTypeName: 'bool',\r\n\tValueBufferType: Array,\r\n\r\n\tDefaultInterpolation: THREE.InterpolateDiscrete,\r\n\r\n\tInterpolantFactoryMethodLinear: undefined,\r\n\tInterpolantFactoryMethodSmooth: undefined\r\n\r\n\t// Note: Actually this track could have a optimized / compressed\r\n\t// representation of a single value and a custom interpolant that\r\n\t// computes \"firstValue ^ isOdd( index )\".\r\n\r\n} );\r\n\r\n// File:src/animation/tracks/ColorKeyframeTrack.js\r\n\r\n/**\r\n *\r\n * A Track of keyframe values that represent color.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.ColorKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\r\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\r\n};\r\n\r\nTHREE.ColorKeyframeTrack.prototype =\r\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\r\n\tconstructor: THREE.ColorKeyframeTrack,\r\n\r\n\tValueTypeName: 'color'\r\n\r\n\t// ValueBufferType is inherited\r\n\r\n\t// DefaultInterpolation is inherited\r\n\r\n\r\n\t// Note: Very basic implementation and nothing special yet.\r\n\t// However, this is the place for color space parameterization.\r\n\r\n} );\r\n\r\n// File:src/animation/tracks/NumberKeyframeTrack.js\r\n\r\n/**\r\n *\r\n * A Track of numeric keyframe values.\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.NumberKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\r\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\r\n};\r\n\r\nTHREE.NumberKeyframeTrack.prototype =\r\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\r\n\tconstructor: THREE.NumberKeyframeTrack,\r\n\r\n\tValueTypeName: 'number',\r\n\r\n\t// ValueBufferType is inherited\r\n\r\n\t// DefaultInterpolation is inherited\r\n\r\n} );\r\n\r\n// File:src/animation/tracks/QuaternionKeyframeTrack.js\r\n\r\n/**\r\n *\r\n * A Track of quaternion keyframe values.\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.QuaternionKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\r\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\r\n};\r\n\r\nTHREE.QuaternionKeyframeTrack.prototype =\r\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\r\n\tconstructor: THREE.QuaternionKeyframeTrack,\r\n\r\n\tValueTypeName: 'quaternion',\r\n\r\n\t// ValueBufferType is inherited\r\n\r\n\tDefaultInterpolation: THREE.InterpolateLinear,\r\n\r\n\tInterpolantFactoryMethodLinear: function( result ) {\r\n\r\n\t\treturn new THREE.QuaternionLinearInterpolant(\r\n\t\t\t\tthis.times, this.values, this.getValueSize(), result );\r\n\r\n\t},\r\n\r\n\tInterpolantFactoryMethodSmooth: undefined // not yet implemented\r\n\r\n} );\r\n\r\n// File:src/animation/tracks/StringKeyframeTrack.js\r\n\r\n/**\r\n *\r\n * A Track that interpolates Strings\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.StringKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\r\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\r\n};\r\n\r\nTHREE.StringKeyframeTrack.prototype =\r\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\r\n\tconstructor: THREE.StringKeyframeTrack,\r\n\r\n\tValueTypeName: 'string',\r\n\tValueBufferType: Array,\r\n\r\n\tDefaultInterpolation: THREE.InterpolateDiscrete,\r\n\r\n\tInterpolantFactoryMethodLinear: undefined,\r\n\r\n\tInterpolantFactoryMethodSmooth: undefined\r\n\r\n} );\r\n\r\n// File:src/animation/tracks/VectorKeyframeTrack.js\r\n\r\n/**\r\n *\r\n * A Track of vectored keyframe values.\r\n *\r\n *\r\n * @author Ben Houston / http://clara.io/\r\n * @author David Sarno / http://lighthaus.us/\r\n * @author tschw\r\n */\r\n\r\nTHREE.VectorKeyframeTrack = function ( name, times, values, interpolation ) {\r\n\r\n\tTHREE.KeyframeTrack.call( this, name, times, values, interpolation );\r\n\r\n};\r\n\r\nTHREE.VectorKeyframeTrack.prototype =\r\n\t\tObject.assign( Object.create( THREE.KeyframeTrack.prototype ), {\r\n\r\n\tconstructor: THREE.VectorKeyframeTrack,\r\n\r\n\tValueTypeName: 'vector'\r\n\r\n\t// ValueBufferType is inherited\r\n\r\n\t// DefaultInterpolation is inherited\r\n\r\n} );\r\n\r\n// File:src/audio/Audio.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author Reece Aaron Lecrivain / http://reecenotes.com/\r\n */\r\n\r\nTHREE.Audio = function ( listener ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Audio';\r\n\r\n\tthis.context = listener.context;\r\n\tthis.source = this.context.createBufferSource();\r\n\tthis.source.onended = this.onEnded.bind( this );\r\n\r\n\tthis.gain = this.context.createGain();\r\n\tthis.gain.connect( listener.getInput() );\r\n\r\n\tthis.autoplay = false;\r\n\r\n\tthis.startTime = 0;\r\n\tthis.playbackRate = 1;\r\n\tthis.isPlaying = false;\r\n\tthis.hasPlaybackControl = true;\r\n\tthis.sourceType = 'empty';\r\n\r\n\tthis.filters = [];\r\n\r\n};\r\n\r\nTHREE.Audio.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\r\n\r\n\tconstructor: THREE.Audio,\r\n\r\n\tgetOutput: function () {\r\n\r\n\t\treturn this.gain;\r\n\r\n\t},\r\n\r\n\tsetNodeSource: function ( audioNode ) {\r\n\r\n\t\tthis.hasPlaybackControl = false;\r\n\t\tthis.sourceType = 'audioNode';\r\n\t\tthis.source = audioNode;\r\n\t\tthis.connect();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tsetBuffer: function ( audioBuffer ) {\r\n\r\n\t\tthis.source.buffer = audioBuffer;\r\n\t\tthis.sourceType = 'buffer';\r\n\r\n\t\tif ( this.autoplay ) this.play();\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tplay: function () {\r\n\r\n\t\tif ( this.isPlaying === true ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Audio: Audio is already playing.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.hasPlaybackControl === false ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar source = this.context.createBufferSource();\r\n\r\n\t\tsource.buffer = this.source.buffer;\r\n\t\tsource.loop = this.source.loop;\r\n\t\tsource.onended = this.source.onended;\r\n\t\tsource.start( 0, this.startTime );\r\n\t\tsource.playbackRate.value = this.playbackRate;\r\n\r\n\t\tthis.isPlaying = true;\r\n\r\n\t\tthis.source = source;\r\n\r\n\t\treturn this.connect();\r\n\r\n\t},\r\n\r\n\tpause: function () {\r\n\r\n\t\tif ( this.hasPlaybackControl === false ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tthis.source.stop();\r\n\t\tthis.startTime = this.context.currentTime;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tstop: function () {\r\n\r\n\t\tif ( this.hasPlaybackControl === false ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tthis.source.stop();\r\n\t\tthis.startTime = 0;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tconnect: function () {\r\n\r\n\t\tif ( this.filters.length > 0 ) {\r\n\r\n\t\t\tthis.source.connect( this.filters[ 0 ] );\r\n\r\n\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tthis.filters[ i - 1 ].connect( this.filters[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.filters[ this.filters.length - 1 ].connect( this.getOutput() );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.source.connect( this.getOutput() );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdisconnect: function () {\r\n\r\n\t\tif ( this.filters.length > 0 ) {\r\n\r\n\t\t\tthis.source.disconnect( this.filters[ 0 ] );\r\n\r\n\t\t\tfor ( var i = 1, l = this.filters.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tthis.filters[ i - 1 ].disconnect( this.filters[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.source.disconnect( this.getOutput() );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetFilters: function () {\r\n\r\n\t\treturn this.filters;\r\n\r\n\t},\r\n\r\n\tsetFilters: function ( value ) {\r\n\r\n\t\tif ( ! value ) value = [];\r\n\r\n\t\tif ( this.isPlaying === true ) {\r\n\r\n\t\t\tthis.disconnect();\r\n\t\t\tthis.filters = value;\r\n\t\t\tthis.connect();\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.filters = value;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetFilter: function () {\r\n\r\n\t\treturn this.getFilters()[ 0 ];\r\n\r\n\t},\r\n\r\n\tsetFilter: function ( filter ) {\r\n\r\n\t\treturn this.setFilters( filter ? [ filter ] : [] );\r\n\r\n\t},\r\n\r\n\tsetPlaybackRate: function ( value ) {\r\n\r\n\t\tif ( this.hasPlaybackControl === false ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tthis.playbackRate = value;\r\n\r\n\t\tif ( this.isPlaying === true ) {\r\n\r\n\t\t\tthis.source.playbackRate.value = this.playbackRate;\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tgetPlaybackRate: function () {\r\n\r\n\t\treturn this.playbackRate;\r\n\r\n\t},\r\n\r\n\tonEnded: function () {\r\n\r\n\t\tthis.isPlaying = false;\r\n\r\n\t},\r\n\r\n\tgetLoop: function () {\r\n\r\n\t\tif ( this.hasPlaybackControl === false ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\t\treturn false;\r\n\r\n\t\t}\r\n\r\n\t\treturn this.source.loop;\r\n\r\n\t},\r\n\r\n\tsetLoop: function ( value ) {\r\n\r\n\t\tif ( this.hasPlaybackControl === false ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.Audio: this Audio has no playback control.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tthis.source.loop = value;\r\n\r\n\t},\r\n\r\n\tgetVolume: function () {\r\n\r\n\t\treturn this.gain.gain.value;\r\n\r\n\t},\r\n\r\n\r\n\tsetVolume: function ( value ) {\r\n\r\n\t\tthis.gain.gain.value = value;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/audio/AudioAnalyser.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AudioAnalyser = function ( audio, fftSize ) {\r\n\r\n\tthis.analyser = audio.context.createAnalyser();\r\n\tthis.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;\r\n\r\n\tthis.data = new Uint8Array( this.analyser.frequencyBinCount );\r\n\r\n\taudio.getOutput().connect( this.analyser );\r\n\r\n};\r\n\r\nObject.assign( THREE.AudioAnalyser.prototype, {\r\n\r\n\tgetFrequencyData: function () {\r\n\r\n\t\tthis.analyser.getByteFrequencyData( this.data );\r\n\r\n\t\treturn this.data;\r\n\r\n\t},\r\n\r\n\tgetAverageFrequency: function () {\r\n\r\n\t\tvar value = 0, data = this.getFrequencyData();\r\n\r\n\t\tfor ( var i = 0; i < data.length; i ++ ) {\r\n\r\n\t\t\tvalue += data[ i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn value / data.length;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/audio/AudioContext.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nObject.defineProperty( THREE, 'AudioContext', {\r\n\r\n\tget: ( function () {\r\n\r\n\t\tvar context;\r\n\r\n\t\treturn function () {\r\n\r\n\t\t\tif ( context === undefined ) {\r\n\r\n\t\t\t\tcontext = new ( window.AudioContext || window.webkitAudioContext )();\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn context;\r\n\r\n\t\t};\r\n\r\n\t} )()\r\n\r\n} );\r\n\r\n// File:src/audio/PositionalAudio.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.PositionalAudio = function ( listener ) {\r\n\r\n\tTHREE.Audio.call( this, listener );\r\n\r\n\tthis.panner = this.context.createPanner();\r\n\tthis.panner.connect( this.gain );\r\n\r\n};\r\n\r\nTHREE.PositionalAudio.prototype = Object.assign( Object.create( THREE.Audio.prototype ), {\r\n\r\n\tconstructor: THREE.PositionalAudio,\r\n\r\n\tgetOutput: function () {\r\n\r\n\t\treturn this.panner;\r\n\r\n\t},\r\n\r\n\tgetRefDistance: function () {\r\n\r\n\t\treturn this.panner.refDistance;\r\n\r\n\t},\r\n\r\n\tsetRefDistance: function ( value ) {\r\n\r\n\t\tthis.panner.refDistance = value;\r\n\r\n\t},\r\n\r\n\tgetRolloffFactor: function () {\r\n\r\n\t\treturn this.panner.rolloffFactor;\r\n\r\n\t},\r\n\r\n\tsetRolloffFactor: function ( value ) {\r\n\r\n\t\tthis.panner.rolloffFactor = value;\r\n\r\n\t},\r\n\r\n\tgetDistanceModel: function () {\r\n\r\n\t\treturn this.panner.distanceModel;\r\n\r\n\t},\r\n\r\n\tsetDistanceModel: function ( value ) {\r\n\r\n\t\tthis.panner.distanceModel = value;\r\n\r\n\t},\r\n\r\n\tgetMaxDistance: function () {\r\n\r\n\t\treturn this.panner.maxDistance;\r\n\r\n\t},\r\n\r\n\tsetMaxDistance: function ( value ) {\r\n\r\n\t\tthis.panner.maxDistance = value;\r\n\r\n\t},\r\n\r\n\tupdateMatrixWorld: ( function () {\r\n\r\n\t\tvar position = new THREE.Vector3();\r\n\r\n\t\treturn function updateMatrixWorld( force ) {\r\n\r\n\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\r\n\r\n\t\t\tposition.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t\t\tthis.panner.setPosition( position.x, position.y, position.z );\r\n\r\n\t\t};\r\n\r\n\t} )()\r\n\r\n\r\n} );\r\n\r\n// File:src/audio/AudioListener.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AudioListener = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'AudioListener';\r\n\r\n\tthis.context = THREE.AudioContext;\r\n\r\n\tthis.gain = this.context.createGain();\r\n\tthis.gain.connect( this.context.destination );\r\n\r\n\tthis.filter = null;\r\n\r\n};\r\n\r\nTHREE.AudioListener.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\r\n\r\n\tconstructor: THREE.AudioListener,\r\n\r\n\tgetInput: function () {\r\n\r\n\t\treturn this.gain;\r\n\r\n\t},\r\n\r\n\tremoveFilter: function ( ) {\r\n\r\n\t\tif ( this.filter !== null ) {\r\n\r\n\t\t\tthis.gain.disconnect( this.filter );\r\n\t\t\tthis.filter.disconnect( this.context.destination );\r\n\t\t\tthis.gain.connect( this.context.destination );\r\n\t\t\tthis.filter = null;\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetFilter: function () {\r\n\r\n\t\treturn this.filter;\r\n\r\n\t},\r\n\r\n\tsetFilter: function ( value ) {\r\n\r\n\t\tif ( this.filter !== null ) {\r\n\r\n\t\t\tthis.gain.disconnect( this.filter );\r\n\t\t\tthis.filter.disconnect( this.context.destination );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.gain.disconnect( this.context.destination );\r\n\r\n\t\t}\r\n\r\n\t\tthis.filter = value;\r\n\t\tthis.gain.connect( this.filter );\r\n\t\tthis.filter.connect( this.context.destination );\r\n\r\n\t},\r\n\r\n\tgetMasterVolume: function () {\r\n\r\n\t\treturn this.gain.gain.value;\r\n\r\n\t},\r\n\r\n\tsetMasterVolume: function ( value ) {\r\n\r\n\t\tthis.gain.gain.value = value;\r\n\r\n\t},\r\n\r\n\tupdateMatrixWorld: ( function () {\r\n\r\n\t\tvar position = new THREE.Vector3();\r\n\t\tvar quaternion = new THREE.Quaternion();\r\n\t\tvar scale = new THREE.Vector3();\r\n\r\n\t\tvar orientation = new THREE.Vector3();\r\n\r\n\t\treturn function updateMatrixWorld( force ) {\r\n\r\n\t\t\tTHREE.Object3D.prototype.updateMatrixWorld.call( this, force );\r\n\r\n\t\t\tvar listener = this.context.listener;\r\n\t\t\tvar up = this.up;\r\n\r\n\t\t\tthis.matrixWorld.decompose( position, quaternion, scale );\r\n\r\n\t\t\torientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );\r\n\r\n\t\t\tlistener.setPosition( position.x, position.y, position.z );\r\n\t\t\tlistener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );\r\n\r\n\t\t};\r\n\r\n\t} )()\r\n\r\n} );\r\n\r\n// File:src/cameras/Camera.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.Camera = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Camera';\r\n\r\n\tthis.matrixWorldInverse = new THREE.Matrix4();\r\n\tthis.projectionMatrix = new THREE.Matrix4();\r\n\r\n};\r\n\r\nTHREE.Camera.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Camera.prototype.constructor = THREE.Camera;\r\n\r\nTHREE.Camera.prototype.getWorldDirection = function () {\r\n\r\n\tvar quaternion = new THREE.Quaternion();\r\n\r\n\treturn function ( optionalTarget ) {\r\n\r\n\t\tvar result = optionalTarget || new THREE.Vector3();\r\n\r\n\t\tthis.getWorldQuaternion( quaternion );\r\n\r\n\t\treturn result.set( 0, 0, - 1 ).applyQuaternion( quaternion );\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.Camera.prototype.lookAt = function () {\r\n\r\n\t// This routine does not support cameras with rotated and/or translated parent(s)\r\n\r\n\tvar m1 = new THREE.Matrix4();\r\n\r\n\treturn function ( vector ) {\r\n\r\n\t\tm1.lookAt( this.position, vector, this.up );\r\n\r\n\t\tthis.quaternion.setFromRotationMatrix( m1 );\r\n\r\n\t};\r\n\r\n}();\r\n\r\nTHREE.Camera.prototype.clone = function () {\r\n\r\n\treturn new this.constructor().copy( this );\r\n\r\n};\r\n\r\nTHREE.Camera.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Object3D.prototype.copy.call( this, source );\r\n\r\n\tthis.matrixWorldInverse.copy( source.matrixWorldInverse );\r\n\tthis.projectionMatrix.copy( source.projectionMatrix );\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/cameras/CubeCamera.js\r\n\r\n/**\r\n * Camera for rendering cube maps\r\n *\t- renders scene into axis-aligned cube\r\n *\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.CubeCamera = function ( near, far, cubeResolution ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'CubeCamera';\r\n\r\n\tvar fov = 90, aspect = 1;\r\n\r\n\tvar cameraPX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraPX.up.set( 0, - 1, 0 );\r\n\tcameraPX.lookAt( new THREE.Vector3( 1, 0, 0 ) );\r\n\tthis.add( cameraPX );\r\n\r\n\tvar cameraNX = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraNX.up.set( 0, - 1, 0 );\r\n\tcameraNX.lookAt( new THREE.Vector3( - 1, 0, 0 ) );\r\n\tthis.add( cameraNX );\r\n\r\n\tvar cameraPY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraPY.up.set( 0, 0, 1 );\r\n\tcameraPY.lookAt( new THREE.Vector3( 0, 1, 0 ) );\r\n\tthis.add( cameraPY );\r\n\r\n\tvar cameraNY = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraNY.up.set( 0, 0, - 1 );\r\n\tcameraNY.lookAt( new THREE.Vector3( 0, - 1, 0 ) );\r\n\tthis.add( cameraNY );\r\n\r\n\tvar cameraPZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraPZ.up.set( 0, - 1, 0 );\r\n\tcameraPZ.lookAt( new THREE.Vector3( 0, 0, 1 ) );\r\n\tthis.add( cameraPZ );\r\n\r\n\tvar cameraNZ = new THREE.PerspectiveCamera( fov, aspect, near, far );\r\n\tcameraNZ.up.set( 0, - 1, 0 );\r\n\tcameraNZ.lookAt( new THREE.Vector3( 0, 0, - 1 ) );\r\n\tthis.add( cameraNZ );\r\n\r\n\tvar options = { format: THREE.RGBFormat, magFilter: THREE.LinearFilter, minFilter: THREE.LinearFilter };\r\n\r\n\tthis.renderTarget = new THREE.WebGLRenderTargetCube( cubeResolution, cubeResolution, options );\r\n\r\n\tthis.updateCubeMap = function ( renderer, scene ) {\r\n\r\n\t\tif ( this.parent === null ) this.updateMatrixWorld();\r\n\r\n\t\tvar renderTarget = this.renderTarget;\r\n\t\tvar generateMipmaps = renderTarget.texture.generateMipmaps;\r\n\r\n\t\trenderTarget.texture.generateMipmaps = false;\r\n\r\n\t\trenderTarget.activeCubeFace = 0;\r\n\t\trenderer.render( scene, cameraPX, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 1;\r\n\t\trenderer.render( scene, cameraNX, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 2;\r\n\t\trenderer.render( scene, cameraPY, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 3;\r\n\t\trenderer.render( scene, cameraNY, renderTarget );\r\n\r\n\t\trenderTarget.activeCubeFace = 4;\r\n\t\trenderer.render( scene, cameraPZ, renderTarget );\r\n\r\n\t\trenderTarget.texture.generateMipmaps = generateMipmaps;\r\n\r\n\t\trenderTarget.activeCubeFace = 5;\r\n\t\trenderer.render( scene, cameraNZ, renderTarget );\r\n\r\n\t\trenderer.setRenderTarget( null );\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.CubeCamera.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.CubeCamera.prototype.constructor = THREE.CubeCamera;\r\n\r\n// File:src/cameras/OrthographicCamera.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.OrthographicCamera = function ( left, right, top, bottom, near, far ) {\r\n\r\n\tTHREE.Camera.call( this );\r\n\r\n\tthis.type = 'OrthographicCamera';\r\n\r\n\tthis.zoom = 1;\r\n\r\n\tthis.left = left;\r\n\tthis.right = right;\r\n\tthis.top = top;\r\n\tthis.bottom = bottom;\r\n\r\n\tthis.near = ( near !== undefined ) ? near : 0.1;\r\n\tthis.far = ( far !== undefined ) ? far : 2000;\r\n\r\n\tthis.updateProjectionMatrix();\r\n\r\n};\r\n\r\nTHREE.OrthographicCamera.prototype = Object.assign( Object.create( THREE.Camera.prototype ), {\r\n\r\n\tconstructor: THREE.OrthographicCamera,\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tTHREE.Camera.prototype.copy.call( this, source );\r\n\r\n\t\tthis.left = source.left;\r\n\t\tthis.right = source.right;\r\n\t\tthis.top = source.top;\r\n\t\tthis.bottom = source.bottom;\r\n\t\tthis.near = source.near;\r\n\t\tthis.far = source.far;\r\n\r\n\t\tthis.zoom = source.zoom;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tupdateProjectionMatrix: function () {\r\n\r\n\t\tvar dx = ( this.right - this.left ) / ( 2 * this.zoom );\r\n\t\tvar dy = ( this.top - this.bottom ) / ( 2 * this.zoom );\r\n\t\tvar cx = ( this.right + this.left ) / 2;\r\n\t\tvar cy = ( this.top + this.bottom ) / 2;\r\n\r\n\t\tthis.projectionMatrix.makeOrthographic( cx - dx, cx + dx, cy + dy, cy - dy, this.near, this.far );\r\n\r\n\t},\r\n\r\n\ttoJSON: function ( meta ) {\r\n\r\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\r\n\t\tdata.object.zoom = this.zoom;\r\n\t\tdata.object.left = this.left;\r\n\t\tdata.object.right = this.right;\r\n\t\tdata.object.top = this.top;\r\n\t\tdata.object.bottom = this.bottom;\r\n\t\tdata.object.near = this.near;\r\n\t\tdata.object.far = this.far;\r\n\r\n\t\treturn data;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/cameras/PerspectiveCamera.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author greggman / http://games.greggman.com/\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author tschw\r\n */\r\n\r\nTHREE.PerspectiveCamera = function( fov, aspect, near, far ) {\r\n\r\n\tTHREE.Camera.call( this );\r\n\r\n\tthis.type = 'PerspectiveCamera';\r\n\r\n\tthis.fov = fov !== undefined ? fov : 50;\r\n\tthis.zoom = 1;\r\n\r\n\tthis.near = near !== undefined ? near : 0.1;\r\n\tthis.far = far !== undefined ? far : 2000;\r\n\tthis.focus = 10;\r\n\r\n\tthis.aspect = aspect !== undefined ? aspect : 1;\r\n\tthis.view = null;\r\n\r\n\tthis.filmGauge = 35;\t// width of the film (default in millimeters)\r\n\tthis.filmOffset = 0;\t// horizontal film offset (same unit as gauge)\r\n\r\n\tthis.updateProjectionMatrix();\r\n\r\n};\r\n\r\nTHREE.PerspectiveCamera.prototype = Object.assign( Object.create( THREE.Camera.prototype ), {\r\n\r\n\tconstructor: THREE.PerspectiveCamera,\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tTHREE.Camera.prototype.copy.call( this, source );\r\n\r\n\t\tthis.fov = source.fov;\r\n\t\tthis.zoom = source.zoom;\r\n\r\n\t\tthis.near = source.near;\r\n\t\tthis.far = source.far;\r\n\t\tthis.focus = source.focus;\r\n\r\n\t\tthis.aspect = source.aspect;\r\n\t\tthis.view = source.view === null ? null : Object.assign( {}, source.view );\r\n\r\n\t\tthis.filmGauge = source.filmGauge;\r\n\t\tthis.filmOffset = source.filmOffset;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\t/**\r\n\t * Sets the FOV by focal length in respect to the current .filmGauge.\r\n\t *\r\n\t * The default film gauge is 35, so that the focal length can be specified for\r\n\t * a 35mm (full frame) camera.\r\n\t *\r\n\t * Values for focal length and film gauge must have the same unit.\r\n\t */\r\n\tsetFocalLength: function ( focalLength ) {\r\n\r\n\t\t// see http://www.bobatkins.com/photography/technical/field_of_view.html\r\n\t\tvar vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;\r\n\r\n\t\tthis.fov = THREE.Math.RAD2DEG * 2 * Math.atan( vExtentSlope );\r\n\t\tthis.updateProjectionMatrix();\r\n\r\n\t},\r\n\r\n\t/**\r\n\t * Calculates the focal length from the current .fov and .filmGauge.\r\n\t */\r\n\tgetFocalLength: function () {\r\n\r\n\t\tvar vExtentSlope = Math.tan( THREE.Math.DEG2RAD * 0.5 * this.fov );\r\n\r\n\t\treturn 0.5 * this.getFilmHeight() / vExtentSlope;\r\n\r\n\t},\r\n\r\n\tgetEffectiveFOV: function () {\r\n\r\n\t\treturn THREE.Math.RAD2DEG * 2 * Math.atan(\r\n\t\t\t\tMath.tan( THREE.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );\r\n\r\n\t},\r\n\r\n\tgetFilmWidth: function () {\r\n\r\n\t\t// film not completely covered in portrait format (aspect < 1)\r\n\t\treturn this.filmGauge * Math.min( this.aspect, 1 );\r\n\r\n\t},\r\n\r\n\tgetFilmHeight: function () {\r\n\r\n\t\t// film not completely covered in landscape format (aspect > 1)\r\n\t\treturn this.filmGauge / Math.max( this.aspect, 1 );\r\n\r\n\t},\r\n\r\n\t/**\r\n\t * Sets an offset in a larger frustum. This is useful for multi-window or\r\n\t * multi-monitor/multi-machine setups.\r\n\t *\r\n\t * For example, if you have 3x2 monitors and each monitor is 1920x1080 and\r\n\t * the monitors are in grid like this\r\n\t *\r\n\t *   +---+---+---+\r\n\t *   | A | B | C |\r\n\t *   +---+---+---+\r\n\t *   | D | E | F |\r\n\t *   +---+---+---+\r\n\t *\r\n\t * then for each monitor you would call it like this\r\n\t *\r\n\t *   var w = 1920;\r\n\t *   var h = 1080;\r\n\t *   var fullWidth = w * 3;\r\n\t *   var fullHeight = h * 2;\r\n\t *\r\n\t *   --A--\r\n\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );\r\n\t *   --B--\r\n\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );\r\n\t *   --C--\r\n\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );\r\n\t *   --D--\r\n\t *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );\r\n\t *   --E--\r\n\t *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );\r\n\t *   --F--\r\n\t *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );\r\n\t *\r\n\t *   Note there is no reason monitors have to be the same size or in a grid.\r\n\t */\r\n\tsetViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {\r\n\r\n\t\tthis.aspect = fullWidth / fullHeight;\r\n\r\n\t\tthis.view = {\r\n\t\t\tfullWidth: fullWidth,\r\n\t\t\tfullHeight: fullHeight,\r\n\t\t\toffsetX: x,\r\n\t\t\toffsetY: y,\r\n\t\t\twidth: width,\r\n\t\t\theight: height\r\n\t\t};\r\n\r\n\t\tthis.updateProjectionMatrix();\r\n\r\n\t},\r\n\r\n\tclearViewOffset: function() {\r\n\r\n\t\tthis.view = null;\r\n\t\tthis.updateProjectionMatrix();\r\n\r\n\t},\r\n\r\n\tupdateProjectionMatrix: function () {\r\n\r\n\t\tvar near = this.near,\r\n\t\t\ttop = near * Math.tan(\r\n\t\t\t\t\tTHREE.Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,\r\n\t\t\theight = 2 * top,\r\n\t\t\twidth = this.aspect * height,\r\n\t\t\tleft = - 0.5 * width,\r\n\t\t\tview = this.view;\r\n\r\n\t\tif ( view !== null ) {\r\n\r\n\t\t\tvar fullWidth = view.fullWidth,\r\n\t\t\t\tfullHeight = view.fullHeight;\r\n\r\n\t\t\tleft += view.offsetX * width / fullWidth;\r\n\t\t\ttop -= view.offsetY * height / fullHeight;\r\n\t\t\twidth *= view.width / fullWidth;\r\n\t\t\theight *= view.height / fullHeight;\r\n\r\n\t\t}\r\n\r\n\t\tvar skew = this.filmOffset;\r\n\t\tif ( skew !== 0 ) left += near * skew / this.getFilmWidth();\r\n\r\n\t\tthis.projectionMatrix.makeFrustum(\r\n\t\t\t\tleft, left + width, top - height, top, near, this.far );\r\n\r\n\t},\r\n\r\n\ttoJSON: function ( meta ) {\r\n\r\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\r\n\t\tdata.object.fov = this.fov;\r\n\t\tdata.object.zoom = this.zoom;\r\n\r\n\t\tdata.object.near = this.near;\r\n\t\tdata.object.far = this.far;\r\n\t\tdata.object.focus = this.focus;\r\n\r\n\t\tdata.object.aspect = this.aspect;\r\n\r\n\t\tif ( this.view !== null ) data.object.view = Object.assign( {}, this.view );\r\n\r\n\t\tdata.object.filmGauge = this.filmGauge;\r\n\t\tdata.object.filmOffset = this.filmOffset;\r\n\r\n\t\treturn data;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/cameras/StereoCamera.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.StereoCamera = function () {\r\n\r\n\tthis.type = 'StereoCamera';\r\n\r\n\tthis.aspect = 1;\r\n\r\n\tthis.cameraL = new THREE.PerspectiveCamera();\r\n\tthis.cameraL.layers.enable( 1 );\r\n\tthis.cameraL.matrixAutoUpdate = false;\r\n\r\n\tthis.cameraR = new THREE.PerspectiveCamera();\r\n\tthis.cameraR.layers.enable( 2 );\r\n\tthis.cameraR.matrixAutoUpdate = false;\r\n\r\n};\r\n\r\nObject.assign( THREE.StereoCamera.prototype, {\r\n\r\n\tupdate: ( function () {\r\n\r\n\t\tvar focus, fov, aspect, near, far;\r\n\r\n\t\tvar eyeRight = new THREE.Matrix4();\r\n\t\tvar eyeLeft = new THREE.Matrix4();\r\n\r\n\t\treturn function update ( camera ) {\r\n\r\n\t\t\tvar needsUpdate = focus !== camera.focus || fov !== camera.fov ||\r\n\t\t\t\t\t\t\t\t\t\t\t\taspect !== camera.aspect * this.aspect || near !== camera.near ||\r\n\t\t\t\t\t\t\t\t\t\t\t\tfar !== camera.far;\r\n\r\n\t\t\tif ( needsUpdate ) {\r\n\r\n\t\t\t\tfocus = camera.focus;\r\n\t\t\t\tfov = camera.fov;\r\n\t\t\t\taspect = camera.aspect * this.aspect;\r\n\t\t\t\tnear = camera.near;\r\n\t\t\t\tfar = camera.far;\r\n\r\n\t\t\t\t// Off-axis stereoscopic effect based on\r\n\t\t\t\t// http://paulbourke.net/stereographics/stereorender/\r\n\r\n\t\t\t\tvar projectionMatrix = camera.projectionMatrix.clone();\r\n\t\t\t\tvar eyeSep = 0.064 / 2;\r\n\t\t\t\tvar eyeSepOnProjection = eyeSep * near / focus;\r\n\t\t\t\tvar ymax = near * Math.tan( THREE.Math.DEG2RAD * fov * 0.5 );\r\n\t\t\t\tvar xmin, xmax;\r\n\r\n\t\t\t\t// translate xOffset\r\n\r\n\t\t\t\teyeLeft.elements[ 12 ] = - eyeSep;\r\n\t\t\t\teyeRight.elements[ 12 ] = eyeSep;\r\n\r\n\t\t\t\t// for left eye\r\n\r\n\t\t\t\txmin = - ymax * aspect + eyeSepOnProjection;\r\n\t\t\t\txmax = ymax * aspect + eyeSepOnProjection;\r\n\r\n\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\r\n\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\r\n\r\n\t\t\t\tthis.cameraL.projectionMatrix.copy( projectionMatrix );\r\n\r\n\t\t\t\t// for right eye\r\n\r\n\t\t\t\txmin = - ymax * aspect - eyeSepOnProjection;\r\n\t\t\t\txmax = ymax * aspect - eyeSepOnProjection;\r\n\r\n\t\t\t\tprojectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );\r\n\t\t\t\tprojectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );\r\n\r\n\t\t\t\tthis.cameraR.projectionMatrix.copy( projectionMatrix );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );\r\n\t\t\tthis.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );\r\n\r\n\t\t};\r\n\r\n\t} )()\r\n\r\n} );\r\n\r\n// File:src/lights/Light.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Light = function ( color, intensity ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Light';\r\n\r\n\tthis.color = new THREE.Color( color );\r\n\tthis.intensity = intensity !== undefined ? intensity : 1;\r\n\r\n\tthis.receiveShadow = undefined;\r\n\r\n};\r\n\r\nTHREE.Light.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\r\n\r\n\tconstructor: THREE.Light,\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\r\n\r\n\t\tthis.color.copy( source.color );\r\n\t\tthis.intensity = source.intensity;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoJSON: function ( meta ) {\r\n\r\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\r\n\t\tdata.object.color = this.color.getHex();\r\n\t\tdata.object.intensity = this.intensity;\r\n\r\n\t\tif ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();\r\n\r\n\t\tif ( this.distance !== undefined ) data.object.distance = this.distance;\r\n\t\tif ( this.angle !== undefined ) data.object.angle = this.angle;\r\n\t\tif ( this.decay !== undefined ) data.object.decay = this.decay;\r\n\t\tif ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;\r\n\r\n\t\treturn data;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/lights/LightShadow.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LightShadow = function ( camera ) {\r\n\r\n\tthis.camera = camera;\r\n\r\n\tthis.bias = 0;\r\n\tthis.radius = 1;\r\n\r\n\tthis.mapSize = new THREE.Vector2( 512, 512 );\r\n\r\n\tthis.map = null;\r\n\tthis.matrix = new THREE.Matrix4();\r\n\r\n};\r\n\r\nObject.assign( THREE.LightShadow.prototype, {\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.camera = source.camera.clone();\r\n\r\n\t\tthis.bias = source.bias;\r\n\t\tthis.radius = source.radius;\r\n\r\n\t\tthis.mapSize.copy( source.mapSize );\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/lights/AmbientLight.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AmbientLight = function ( color, intensity ) {\r\n\r\n\tTHREE.Light.call( this, color, intensity );\r\n\r\n\tthis.type = 'AmbientLight';\r\n\r\n\tthis.castShadow = undefined;\r\n\r\n};\r\n\r\nTHREE.AmbientLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\r\n\r\n\tconstructor: THREE.AmbientLight\r\n\r\n} );\r\n\r\n// File:src/lights/DirectionalLight.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.DirectionalLight = function ( color, intensity ) {\r\n\r\n\tTHREE.Light.call( this, color, intensity );\r\n\r\n\tthis.type = 'DirectionalLight';\r\n\r\n\tthis.position.set( 0, 1, 0 );\r\n\tthis.updateMatrix();\r\n\r\n\tthis.target = new THREE.Object3D();\r\n\r\n\tthis.shadow = new THREE.DirectionalLightShadow();\r\n\r\n};\r\n\r\nTHREE.DirectionalLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\r\n\r\n\tconstructor: THREE.DirectionalLight,\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tTHREE.Light.prototype.copy.call( this, source );\r\n\r\n\t\tthis.target = source.target.clone();\r\n\r\n\t\tthis.shadow = source.shadow.clone();\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/lights/DirectionalLightShadow.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.DirectionalLightShadow = function ( light ) {\r\n\r\n\tTHREE.LightShadow.call( this, new THREE.OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );\r\n\r\n};\r\n\r\nTHREE.DirectionalLightShadow.prototype = Object.assign( Object.create( THREE.LightShadow.prototype ), {\r\n\r\n\tconstructor: THREE.DirectionalLightShadow\r\n\r\n} );\r\n\r\n// File:src/lights/HemisphereLight.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.HemisphereLight = function ( skyColor, groundColor, intensity ) {\r\n\r\n\tTHREE.Light.call( this, skyColor, intensity );\r\n\r\n\tthis.type = 'HemisphereLight';\r\n\r\n\tthis.castShadow = undefined;\r\n\r\n\tthis.position.set( 0, 1, 0 );\r\n\tthis.updateMatrix();\r\n\r\n\tthis.groundColor = new THREE.Color( groundColor );\r\n\r\n};\r\n\r\nTHREE.HemisphereLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\r\n\r\n\tconstructor: THREE.HemisphereLight,\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tTHREE.Light.prototype.copy.call( this, source );\r\n\r\n\t\tthis.groundColor.copy( source.groundColor );\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/lights/PointLight.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\n\r\nTHREE.PointLight = function ( color, intensity, distance, decay ) {\r\n\r\n\tTHREE.Light.call( this, color, intensity );\r\n\r\n\tthis.type = 'PointLight';\r\n\r\n\tObject.defineProperty( this, 'power', {\r\n\t\tget: function () {\r\n\t\t\t// intensity = power per solid angle.\r\n\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\r\n\t\t\treturn this.intensity * 4 * Math.PI;\r\n\r\n\t\t},\r\n\t\tset: function ( power ) {\r\n\t\t\t// intensity = power per solid angle.\r\n\t\t\t// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\r\n\t\t\tthis.intensity = power / ( 4 * Math.PI );\r\n\t\t}\r\n\t} );\r\n\r\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\r\n\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\r\n\r\n\tthis.shadow = new THREE.LightShadow( new THREE.PerspectiveCamera( 90, 1, 0.5, 500 ) );\r\n\r\n};\r\n\r\nTHREE.PointLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\r\n\r\n\tconstructor: THREE.PointLight,\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tTHREE.Light.prototype.copy.call( this, source );\r\n\r\n\t\tthis.distance = source.distance;\r\n\t\tthis.decay = source.decay;\r\n\r\n\t\tthis.shadow = source.shadow.clone();\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/lights/SpotLight.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SpotLight = function ( color, intensity, distance, angle, penumbra, decay ) {\r\n\r\n\tTHREE.Light.call( this, color, intensity );\r\n\r\n\tthis.type = 'SpotLight';\r\n\r\n\tthis.position.set( 0, 1, 0 );\r\n\tthis.updateMatrix();\r\n\r\n\tthis.target = new THREE.Object3D();\r\n\r\n\tObject.defineProperty( this, 'power', {\r\n\t\tget: function () {\r\n\t\t\t// intensity = power per solid angle.\r\n\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\r\n\t\t\treturn this.intensity * Math.PI;\r\n\t\t},\r\n\t\tset: function ( power ) {\r\n\t\t\t// intensity = power per solid angle.\r\n\t\t\t// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf\r\n\t\t\tthis.intensity = power / Math.PI;\r\n\t\t}\r\n\t} );\r\n\r\n\tthis.distance = ( distance !== undefined ) ? distance : 0;\r\n\tthis.angle = ( angle !== undefined ) ? angle : Math.PI / 3;\r\n\tthis.penumbra = ( penumbra !== undefined ) ? penumbra : 0;\r\n\tthis.decay = ( decay !== undefined ) ? decay : 1;\t// for physically correct lights, should be 2.\r\n\r\n\tthis.shadow = new THREE.SpotLightShadow();\r\n\r\n};\r\n\r\nTHREE.SpotLight.prototype = Object.assign( Object.create( THREE.Light.prototype ), {\r\n\r\n\tconstructor: THREE.SpotLight,\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tTHREE.Light.prototype.copy.call( this, source );\r\n\r\n\t\tthis.distance = source.distance;\r\n\t\tthis.angle = source.angle;\r\n\t\tthis.penumbra = source.penumbra;\r\n\t\tthis.decay = source.decay;\r\n\r\n\t\tthis.target = source.target.clone();\r\n\r\n\t\tthis.shadow = source.shadow.clone();\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/lights/SpotLightShadow.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.SpotLightShadow = function () {\r\n\r\n\tTHREE.LightShadow.call( this, new THREE.PerspectiveCamera( 50, 1, 0.5, 500 ) );\r\n\r\n};\r\n\r\nTHREE.SpotLightShadow.prototype = Object.assign( Object.create( THREE.LightShadow.prototype ), {\r\n\r\n\tconstructor: THREE.SpotLightShadow,\r\n\r\n\tupdate: function ( light ) {\r\n\r\n\t\tvar fov = THREE.Math.RAD2DEG * 2 * light.angle;\r\n\t\tvar aspect = this.mapSize.width / this.mapSize.height;\r\n\t\tvar far = light.distance || 500;\r\n\r\n\t\tvar camera = this.camera;\r\n\r\n\t\tif ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {\r\n\r\n\t\t\tcamera.fov = fov;\r\n\t\t\tcamera.aspect = aspect;\r\n\t\t\tcamera.far = far;\r\n\t\t\tcamera.updateProjectionMatrix();\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/loaders/AudioLoader.js\r\n\r\n/**\r\n * @author Reece Aaron Lecrivain / http://reecenotes.com/\r\n */\r\n\r\nTHREE.AudioLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.AudioLoader.prototype = {\r\n\r\n\tconstructor: THREE.AudioLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar loader = new THREE.XHRLoader( this.manager );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\t\tloader.load( url, function ( buffer ) {\r\n\r\n\t\t\tvar context = THREE.AudioContext;\r\n\r\n\t\t\tcontext.decodeAudioData( buffer, function ( audioBuffer ) {\r\n\r\n\t\t\t\tonLoad( audioBuffer );\r\n\r\n\t\t\t} );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/Cache.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Cache = {\r\n\r\n\tenabled: false,\r\n\r\n\tfiles: {},\r\n\r\n\tadd: function ( key, file ) {\r\n\r\n\t\tif ( this.enabled === false ) return;\r\n\r\n\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\r\n\r\n\t\tthis.files[ key ] = file;\r\n\r\n\t},\r\n\r\n\tget: function ( key ) {\r\n\r\n\t\tif ( this.enabled === false ) return;\r\n\r\n\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\r\n\r\n\t\treturn this.files[ key ];\r\n\r\n\t},\r\n\r\n\tremove: function ( key ) {\r\n\r\n\t\tdelete this.files[ key ];\r\n\r\n\t},\r\n\r\n\tclear: function () {\r\n\r\n\t\tthis.files = {};\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/Loader.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Loader = function () {\r\n\r\n\tthis.onLoadStart = function () {};\r\n\tthis.onLoadProgress = function () {};\r\n\tthis.onLoadComplete = function () {};\r\n\r\n};\r\n\r\nTHREE.Loader.prototype = {\r\n\r\n\tconstructor: THREE.Loader,\r\n\r\n\tcrossOrigin: undefined,\r\n\r\n\textractUrlBase: function ( url ) {\r\n\r\n\t\tvar parts = url.split( '/' );\r\n\r\n\t\tif ( parts.length === 1 ) return './';\r\n\r\n\t\tparts.pop();\r\n\r\n\t\treturn parts.join( '/' ) + '/';\r\n\r\n\t},\r\n\r\n\tinitMaterials: function ( materials, texturePath, crossOrigin ) {\r\n\r\n\t\tvar array = [];\r\n\r\n\t\tfor ( var i = 0; i < materials.length; ++ i ) {\r\n\r\n\t\t\tarray[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );\r\n\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\r\n\t},\r\n\r\n\tcreateMaterial: ( function () {\r\n\r\n\t\tvar color, textureLoader, materialLoader;\r\n\r\n\t\treturn function ( m, texturePath, crossOrigin ) {\r\n\r\n\t\t\tif ( color === undefined ) color = new THREE.Color();\r\n\t\t\tif ( textureLoader === undefined ) textureLoader = new THREE.TextureLoader();\r\n\t\t\tif ( materialLoader === undefined ) materialLoader = new THREE.MaterialLoader();\r\n\r\n\t\t\t// convert from old material format\r\n\r\n\t\t\tvar textures = {};\r\n\r\n\t\t\tfunction loadTexture( path, repeat, offset, wrap, anisotropy ) {\r\n\r\n\t\t\t\tvar fullPath = texturePath + path;\r\n\t\t\t\tvar loader = THREE.Loader.Handlers.get( fullPath );\r\n\r\n\t\t\t\tvar texture;\r\n\r\n\t\t\t\tif ( loader !== null ) {\r\n\r\n\t\t\t\t\ttexture = loader.load( fullPath );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttextureLoader.setCrossOrigin( crossOrigin );\r\n\t\t\t\t\ttexture = textureLoader.load( fullPath );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( repeat !== undefined ) {\r\n\r\n\t\t\t\t\ttexture.repeat.fromArray( repeat );\r\n\r\n\t\t\t\t\tif ( repeat[ 0 ] !== 1 ) texture.wrapS = THREE.RepeatWrapping;\r\n\t\t\t\t\tif ( repeat[ 1 ] !== 1 ) texture.wrapT = THREE.RepeatWrapping;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( offset !== undefined ) {\r\n\r\n\t\t\t\t\ttexture.offset.fromArray( offset );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( wrap !== undefined ) {\r\n\r\n\t\t\t\t\tif ( wrap[ 0 ] === 'repeat' ) texture.wrapS = THREE.RepeatWrapping;\r\n\t\t\t\t\tif ( wrap[ 0 ] === 'mirror' ) texture.wrapS = THREE.MirroredRepeatWrapping;\r\n\r\n\t\t\t\t\tif ( wrap[ 1 ] === 'repeat' ) texture.wrapT = THREE.RepeatWrapping;\r\n\t\t\t\t\tif ( wrap[ 1 ] === 'mirror' ) texture.wrapT = THREE.MirroredRepeatWrapping;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( anisotropy !== undefined ) {\r\n\r\n\t\t\t\t\ttexture.anisotropy = anisotropy;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar uuid = THREE.Math.generateUUID();\r\n\r\n\t\t\t\ttextures[ uuid ] = texture;\r\n\r\n\t\t\t\treturn uuid;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//\r\n\r\n\t\t\tvar json = {\r\n\t\t\t\tuuid: THREE.Math.generateUUID(),\r\n\t\t\t\ttype: 'MeshLambertMaterial'\r\n\t\t\t};\r\n\r\n\t\t\tfor ( var name in m ) {\r\n\r\n\t\t\t\tvar value = m[ name ];\r\n\r\n\t\t\t\tswitch ( name ) {\r\n\t\t\t\t\tcase 'DbgColor':\r\n\t\t\t\t\tcase 'DbgIndex':\r\n\t\t\t\t\tcase 'opticalDensity':\r\n\t\t\t\t\tcase 'illumination':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'DbgName':\r\n\t\t\t\t\t\tjson.name = value;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'blending':\r\n\t\t\t\t\t\tjson.blending = THREE[ value ];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'colorAmbient':\r\n\t\t\t\t\tcase 'mapAmbient':\r\n\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'colorDiffuse':\r\n\t\t\t\t\t\tjson.color = color.fromArray( value ).getHex();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'colorSpecular':\r\n\t\t\t\t\t\tjson.specular = color.fromArray( value ).getHex();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'colorEmissive':\r\n\t\t\t\t\t\tjson.emissive = color.fromArray( value ).getHex();\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'specularCoef':\r\n\t\t\t\t\t\tjson.shininess = value;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'shading':\r\n\t\t\t\t\t\tif ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';\r\n\t\t\t\t\t\tif ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapDiffuse':\r\n\t\t\t\t\t\tjson.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapDiffuseRepeat':\r\n\t\t\t\t\tcase 'mapDiffuseOffset':\r\n\t\t\t\t\tcase 'mapDiffuseWrap':\r\n\t\t\t\t\tcase 'mapDiffuseAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapLight':\r\n\t\t\t\t\t\tjson.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapLightRepeat':\r\n\t\t\t\t\tcase 'mapLightOffset':\r\n\t\t\t\t\tcase 'mapLightWrap':\r\n\t\t\t\t\tcase 'mapLightAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapAO':\r\n\t\t\t\t\t\tjson.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapAORepeat':\r\n\t\t\t\t\tcase 'mapAOOffset':\r\n\t\t\t\t\tcase 'mapAOWrap':\r\n\t\t\t\t\tcase 'mapAOAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapBump':\r\n\t\t\t\t\t\tjson.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapBumpScale':\r\n\t\t\t\t\t\tjson.bumpScale = value;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapBumpRepeat':\r\n\t\t\t\t\tcase 'mapBumpOffset':\r\n\t\t\t\t\tcase 'mapBumpWrap':\r\n\t\t\t\t\tcase 'mapBumpAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapNormal':\r\n\t\t\t\t\t\tjson.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapNormalFactor':\r\n\t\t\t\t\t\tjson.normalScale = [ value, value ];\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapNormalRepeat':\r\n\t\t\t\t\tcase 'mapNormalOffset':\r\n\t\t\t\t\tcase 'mapNormalWrap':\r\n\t\t\t\t\tcase 'mapNormalAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapSpecular':\r\n\t\t\t\t\t\tjson.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapSpecularRepeat':\r\n\t\t\t\t\tcase 'mapSpecularOffset':\r\n\t\t\t\t\tcase 'mapSpecularWrap':\r\n\t\t\t\t\tcase 'mapSpecularAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapAlpha':\r\n\t\t\t\t\t\tjson.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'mapAlphaRepeat':\r\n\t\t\t\t\tcase 'mapAlphaOffset':\r\n\t\t\t\t\tcase 'mapAlphaWrap':\r\n\t\t\t\t\tcase 'mapAlphaAnisotropy':\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'flipSided':\r\n\t\t\t\t\t\tjson.side = THREE.BackSide;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'doubleSided':\r\n\t\t\t\t\t\tjson.side = THREE.DoubleSide;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'transparency':\r\n\t\t\t\t\t\tconsole.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );\r\n\t\t\t\t\t\tjson.opacity = value;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'depthTest':\r\n\t\t\t\t\tcase 'depthWrite':\r\n\t\t\t\t\tcase 'colorWrite':\r\n\t\t\t\t\tcase 'opacity':\r\n\t\t\t\t\tcase 'reflectivity':\r\n\t\t\t\t\tcase 'transparent':\r\n\t\t\t\t\tcase 'visible':\r\n\t\t\t\t\tcase 'wireframe':\r\n\t\t\t\t\t\tjson[ name ] = value;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tcase 'vertexColors':\r\n\t\t\t\t\t\tif ( value === true ) json.vertexColors = THREE.VertexColors;\r\n\t\t\t\t\t\tif ( value === 'face' ) json.vertexColors = THREE.FaceColors;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\tconsole.error( 'THREE.Loader.createMaterial: Unsupported', name, value );\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( json.type === 'MeshBasicMaterial' ) delete json.emissive;\r\n\t\t\tif ( json.type !== 'MeshPhongMaterial' ) delete json.specular;\r\n\r\n\t\t\tif ( json.opacity < 1 ) json.transparent = true;\r\n\r\n\t\t\tmaterialLoader.setTextures( textures );\r\n\r\n\t\t\treturn materialLoader.parse( json );\r\n\r\n\t\t};\r\n\r\n\t} )()\r\n\r\n};\r\n\r\nTHREE.Loader.Handlers = {\r\n\r\n\thandlers: [],\r\n\r\n\tadd: function ( regex, loader ) {\r\n\r\n\t\tthis.handlers.push( regex, loader );\r\n\r\n\t},\r\n\r\n\tget: function ( file ) {\r\n\r\n\t\tvar handlers = this.handlers;\r\n\r\n\t\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\r\n\r\n\t\t\tvar regex = handlers[ i ];\r\n\t\t\tvar loader  = handlers[ i + 1 ];\r\n\r\n\t\t\tif ( regex.test( file ) ) {\r\n\r\n\t\t\t\treturn loader;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/XHRLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.XHRLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.XHRLoader.prototype = {\r\n\r\n\tconstructor: THREE.XHRLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tif ( this.path !== undefined ) url = this.path + url;\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar cached = THREE.Cache.get( url );\r\n\r\n\t\tif ( cached !== undefined ) {\r\n\r\n\t\t\tif ( onLoad ) {\r\n\r\n\t\t\t\tsetTimeout( function () {\r\n\r\n\t\t\t\t\tonLoad( cached );\r\n\r\n\t\t\t\t}, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn cached;\r\n\r\n\t\t}\r\n\r\n\t\tvar request = new XMLHttpRequest();\r\n\t\trequest.overrideMimeType( 'text/plain' );\r\n\t\trequest.open( 'GET', url, true );\r\n\r\n\t\trequest.addEventListener( 'load', function ( event ) {\r\n\r\n\t\t\tvar response = event.target.response;\r\n\r\n\t\t\tTHREE.Cache.add( url, response );\r\n\r\n\t\t\tif ( this.status === 200 ) {\r\n\r\n\t\t\t\tif ( onLoad ) onLoad( response );\r\n\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t} else if ( this.status === 0 ) {\r\n\r\n\t\t\t\t// Some browsers return HTTP Status 0 when using non-http protocol\r\n\t\t\t\t// e.g. 'file://' or 'data://'. Handle as success.\r\n\r\n\t\t\t\tconsole.warn( 'THREE.XHRLoader: HTTP Status 0 received.' );\r\n\r\n\t\t\t\tif ( onLoad ) onLoad( response );\r\n\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( onError ) onError( event );\r\n\r\n\t\t\t\tscope.manager.itemError( url );\r\n\r\n\t\t\t}\r\n\r\n\t\t}, false );\r\n\r\n\t\tif ( onProgress !== undefined ) {\r\n\r\n\t\t\trequest.addEventListener( 'progress', function ( event ) {\r\n\r\n\t\t\t\tonProgress( event );\r\n\r\n\t\t\t}, false );\r\n\r\n\t\t}\r\n\r\n\t\trequest.addEventListener( 'error', function ( event ) {\r\n\r\n\t\t\tif ( onError ) onError( event );\r\n\r\n\t\t\tscope.manager.itemError( url );\r\n\r\n\t\t}, false );\r\n\r\n\t\tif ( this.responseType !== undefined ) request.responseType = this.responseType;\r\n\t\tif ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;\r\n\r\n\t\trequest.send( null );\r\n\r\n\t\tscope.manager.itemStart( url );\r\n\r\n\t\treturn request;\r\n\r\n\t},\r\n\r\n\tsetPath: function ( value ) {\r\n\r\n\t\tthis.path = value;\r\n\r\n\t},\r\n\r\n\tsetResponseType: function ( value ) {\r\n\r\n\t\tthis.responseType = value;\r\n\r\n\t},\r\n\r\n\tsetWithCredentials: function ( value ) {\r\n\r\n\t\tthis.withCredentials = value;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/FontLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.FontLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.FontLoader.prototype = {\r\n\r\n\tconstructor: THREE.FontLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.XHRLoader( this.manager );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tvar json;\r\n\r\n\t\t\ttry {\r\n\r\n\t\t\t\tjson = JSON.parse( text );\r\n\r\n\t\t\t} catch ( e ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );\r\n\t\t\t\tjson = JSON.parse( text.substring( 65, text.length - 2 ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar font = scope.parse( json );\r\n\r\n\t\t\tif ( onLoad ) onLoad( font );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tparse: function ( json ) {\r\n\r\n\t\treturn new THREE.Font( json );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/ImageLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.ImageLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.ImageLoader.prototype = {\r\n\r\n\tconstructor: THREE.ImageLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tif ( this.path !== undefined ) url = this.path + url;\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar cached = THREE.Cache.get( url );\r\n\r\n\t\tif ( cached !== undefined ) {\r\n\r\n\t\t\tscope.manager.itemStart( url );\r\n\r\n\t\t\tif ( onLoad ) {\r\n\r\n\t\t\t\tsetTimeout( function () {\r\n\r\n\t\t\t\t\tonLoad( cached );\r\n\r\n\t\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t\t}, 0 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn cached;\r\n\r\n\t\t}\r\n\r\n\t\tvar image = document.createElement( 'img' );\r\n\r\n\t\timage.addEventListener( 'load', function ( event ) {\r\n\r\n\t\t\tTHREE.Cache.add( url, this );\r\n\r\n\t\t\tif ( onLoad ) onLoad( this );\r\n\r\n\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t}, false );\r\n\r\n\t\tif ( onProgress !== undefined ) {\r\n\r\n\t\t\timage.addEventListener( 'progress', function ( event ) {\r\n\r\n\t\t\t\tonProgress( event );\r\n\r\n\t\t\t}, false );\r\n\r\n\t\t}\r\n\r\n\t\timage.addEventListener( 'error', function ( event ) {\r\n\r\n\t\t\tif ( onError ) onError( event );\r\n\r\n\t\t\tscope.manager.itemError( url );\r\n\r\n\t\t}, false );\r\n\r\n\t\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\r\n\r\n\t\tscope.manager.itemStart( url );\r\n\r\n\t\timage.src = url;\r\n\r\n\t\treturn image;\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\tsetPath: function ( value ) {\r\n\r\n\t\tthis.path = value;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/JSONLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.JSONLoader = function ( manager ) {\r\n\r\n\tif ( typeof manager === 'boolean' ) {\r\n\r\n\t\tconsole.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );\r\n\t\tmanager = undefined;\r\n\r\n\t}\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n\tthis.withCredentials = false;\r\n\r\n};\r\n\r\nTHREE.JSONLoader.prototype = {\r\n\r\n\tconstructor: THREE.JSONLoader,\r\n\r\n\t// Deprecated\r\n\r\n\tget statusDomElement () {\r\n\r\n\t\tif ( this._statusDomElement === undefined ) {\r\n\r\n\t\t\tthis._statusDomElement = document.createElement( 'div' );\r\n\r\n\t\t}\r\n\r\n\t\tconsole.warn( 'THREE.JSONLoader: .statusDomElement has been removed.' );\r\n\t\treturn this._statusDomElement;\r\n\r\n\t},\r\n\r\n\tload: function( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar texturePath = this.texturePath && ( typeof this.texturePath === \"string\" ) ? this.texturePath : THREE.Loader.prototype.extractUrlBase( url );\r\n\r\n\t\tvar loader = new THREE.XHRLoader( this.manager );\r\n\t\tloader.setWithCredentials( this.withCredentials );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tvar json = JSON.parse( text );\r\n\t\t\tvar metadata = json.metadata;\r\n\r\n\t\t\tif ( metadata !== undefined ) {\r\n\r\n\t\t\t\tvar type = metadata.type;\r\n\r\n\t\t\t\tif ( type !== undefined ) {\r\n\r\n\t\t\t\t\tif ( type.toLowerCase() === 'object' ) {\r\n\r\n\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( type.toLowerCase() === 'scene' ) {\r\n\r\n\t\t\t\t\t\tconsole.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );\r\n\t\t\t\t\t\treturn;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar object = scope.parse( json, texturePath );\r\n\t\t\tonLoad( object.geometry, object.materials );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tsetTexturePath: function ( value ) {\r\n\r\n\t\tthis.texturePath = value;\r\n\r\n\t},\r\n\r\n\tparse: function ( json, texturePath ) {\r\n\r\n\t\tvar geometry = new THREE.Geometry(),\r\n\t\tscale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;\r\n\r\n\t\tparseModel( scale );\r\n\r\n\t\tparseSkin();\r\n\t\tparseMorphing( scale );\r\n\t\tparseAnimations();\r\n\r\n\t\tgeometry.computeFaceNormals();\r\n\t\tgeometry.computeBoundingSphere();\r\n\r\n\t\tfunction parseModel( scale ) {\r\n\r\n\t\t\tfunction isBitSet( value, position ) {\r\n\r\n\t\t\t\treturn value & ( 1 << position );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar i, j, fi,\r\n\r\n\t\t\toffset, zLength,\r\n\r\n\t\tcolorIndex, normalIndex, uvIndex, materialIndex,\r\n\r\n\t\t\ttype,\r\n\t\t\tisQuad,\r\n\t\t\thasMaterial,\r\n\t\t\thasFaceVertexUv,\r\n\t\t\thasFaceNormal, hasFaceVertexNormal,\r\n\t\t\thasFaceColor, hasFaceVertexColor,\r\n\r\n\t\tvertex, face, faceA, faceB, hex, normal,\r\n\r\n\t\t\tuvLayer, uv, u, v,\r\n\r\n\t\t\tfaces = json.faces,\r\n\t\t\tvertices = json.vertices,\r\n\t\t\tnormals = json.normals,\r\n\t\t\tcolors = json.colors,\r\n\r\n\t\t\tnUvLayers = 0;\r\n\r\n\t\t\tif ( json.uvs !== undefined ) {\r\n\r\n\t\t\t\t// disregard empty arrays\r\n\r\n\t\t\t\tfor ( i = 0; i < json.uvs.length; i ++ ) {\r\n\r\n\t\t\t\t\tif ( json.uvs[ i ].length ) nUvLayers ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\r\n\t\t\t\t\tgeometry.faceVertexUvs[ i ] = [];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\toffset = 0;\r\n\t\t\tzLength = vertices.length;\r\n\r\n\t\t\twhile ( offset < zLength ) {\r\n\r\n\t\t\t\tvertex = new THREE.Vector3();\r\n\r\n\t\t\t\tvertex.x = vertices[ offset ++ ] * scale;\r\n\t\t\t\tvertex.y = vertices[ offset ++ ] * scale;\r\n\t\t\t\tvertex.z = vertices[ offset ++ ] * scale;\r\n\r\n\t\t\t\tgeometry.vertices.push( vertex );\r\n\r\n\t\t\t}\r\n\r\n\t\t\toffset = 0;\r\n\t\t\tzLength = faces.length;\r\n\r\n\t\t\twhile ( offset < zLength ) {\r\n\r\n\t\t\t\ttype = faces[ offset ++ ];\r\n\r\n\r\n\t\t\t\tisQuad              = isBitSet( type, 0 );\r\n\t\t\t\thasMaterial         = isBitSet( type, 1 );\r\n\t\t\t\thasFaceVertexUv     = isBitSet( type, 3 );\r\n\t\t\t\thasFaceNormal       = isBitSet( type, 4 );\r\n\t\t\t\thasFaceVertexNormal = isBitSet( type, 5 );\r\n\t\t\t\thasFaceColor\t     = isBitSet( type, 6 );\r\n\t\t\t\thasFaceVertexColor  = isBitSet( type, 7 );\r\n\r\n\t\t\t\t// console.log(\"type\", type, \"bits\", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);\r\n\r\n\t\t\t\tif ( isQuad ) {\r\n\r\n\t\t\t\t\tfaceA = new THREE.Face3();\r\n\t\t\t\t\tfaceA.a = faces[ offset ];\r\n\t\t\t\t\tfaceA.b = faces[ offset + 1 ];\r\n\t\t\t\t\tfaceA.c = faces[ offset + 3 ];\r\n\r\n\t\t\t\t\tfaceB = new THREE.Face3();\r\n\t\t\t\t\tfaceB.a = faces[ offset + 1 ];\r\n\t\t\t\t\tfaceB.b = faces[ offset + 2 ];\r\n\t\t\t\t\tfaceB.c = faces[ offset + 3 ];\r\n\r\n\t\t\t\t\toffset += 4;\r\n\r\n\t\t\t\t\tif ( hasMaterial ) {\r\n\r\n\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\tfaceA.materialIndex = materialIndex;\r\n\t\t\t\t\t\tfaceB.materialIndex = materialIndex;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// to get face <=> uv index correspondence\r\n\r\n\t\t\t\t\tfi = geometry.faces.length;\r\n\r\n\t\t\t\t\tif ( hasFaceVertexUv ) {\r\n\r\n\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\r\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\r\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi + 1 ] = [];\r\n\r\n\t\t\t\t\t\t\tfor ( j = 0; j < 4; j ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\r\n\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\r\n\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\r\n\r\n\t\t\t\t\t\t\t\tif ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n\t\t\t\t\t\t\t\tif ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( hasFaceNormal ) {\r\n\r\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\t\tfaceA.normal.set(\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tfaceB.normal.copy( faceA.normal );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\r\n\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\t\t\tnormal = new THREE.Vector3(\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t\t);\r\n\r\n\r\n\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexNormals.push( normal );\r\n\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexNormals.push( normal );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\tif ( hasFaceColor ) {\r\n\r\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\thex = colors[ colorIndex ];\r\n\r\n\t\t\t\t\t\tfaceA.color.setHex( hex );\r\n\t\t\t\t\t\tfaceB.color.setHex( hex );\r\n\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\tif ( hasFaceVertexColor ) {\r\n\r\n\t\t\t\t\t\tfor ( i = 0; i < 4; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\t\thex = colors[ colorIndex ];\r\n\r\n\t\t\t\t\t\t\tif ( i !== 2 ) faceA.vertexColors.push( new THREE.Color( hex ) );\r\n\t\t\t\t\t\t\tif ( i !== 0 ) faceB.vertexColors.push( new THREE.Color( hex ) );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tgeometry.faces.push( faceA );\r\n\t\t\t\t\tgeometry.faces.push( faceB );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tface = new THREE.Face3();\r\n\t\t\t\t\tface.a = faces[ offset ++ ];\r\n\t\t\t\t\tface.b = faces[ offset ++ ];\r\n\t\t\t\t\tface.c = faces[ offset ++ ];\r\n\r\n\t\t\t\t\tif ( hasMaterial ) {\r\n\r\n\t\t\t\t\t\tmaterialIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\tface.materialIndex = materialIndex;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// to get face <=> uv index correspondence\r\n\r\n\t\t\t\t\tfi = geometry.faces.length;\r\n\r\n\t\t\t\t\tif ( hasFaceVertexUv ) {\r\n\r\n\t\t\t\t\t\tfor ( i = 0; i < nUvLayers; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tuvLayer = json.uvs[ i ];\r\n\r\n\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ] = [];\r\n\r\n\t\t\t\t\t\t\tfor ( j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tuvIndex = faces[ offset ++ ];\r\n\r\n\t\t\t\t\t\t\t\tu = uvLayer[ uvIndex * 2 ];\r\n\t\t\t\t\t\t\t\tv = uvLayer[ uvIndex * 2 + 1 ];\r\n\r\n\t\t\t\t\t\t\t\tuv = new THREE.Vector2( u, v );\r\n\r\n\t\t\t\t\t\t\t\tgeometry.faceVertexUvs[ i ][ fi ].push( uv );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( hasFaceNormal ) {\r\n\r\n\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\t\tface.normal.set(\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif ( hasFaceVertexNormal ) {\r\n\r\n\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tnormalIndex = faces[ offset ++ ] * 3;\r\n\r\n\t\t\t\t\t\t\tnormal = new THREE.Vector3(\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ++ ],\r\n\t\t\t\t\t\t\t\tnormals[ normalIndex ]\r\n\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\tface.vertexNormals.push( normal );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\tif ( hasFaceColor ) {\r\n\r\n\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\tface.color.setHex( colors[ colorIndex ] );\r\n\r\n\t\t\t\t\t}\r\n\r\n\r\n\t\t\t\t\tif ( hasFaceVertexColor ) {\r\n\r\n\t\t\t\t\t\tfor ( i = 0; i < 3; i ++ ) {\r\n\r\n\t\t\t\t\t\t\tcolorIndex = faces[ offset ++ ];\r\n\t\t\t\t\t\t\tface.vertexColors.push( new THREE.Color( colors[ colorIndex ] ) );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tgeometry.faces.push( face );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseSkin() {\r\n\r\n\t\t\tvar influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;\r\n\r\n\t\t\tif ( json.skinWeights ) {\r\n\r\n\t\t\t\tfor ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {\r\n\r\n\t\t\t\t\tvar x =                               json.skinWeights[ i ];\r\n\t\t\t\t\tvar y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;\r\n\t\t\t\t\tvar z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;\r\n\t\t\t\t\tvar w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;\r\n\r\n\t\t\t\t\tgeometry.skinWeights.push( new THREE.Vector4( x, y, z, w ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( json.skinIndices ) {\r\n\r\n\t\t\t\tfor ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {\r\n\r\n\t\t\t\t\tvar a =                               json.skinIndices[ i ];\r\n\t\t\t\t\tvar b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;\r\n\t\t\t\t\tvar c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;\r\n\t\t\t\t\tvar d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;\r\n\r\n\t\t\t\t\tgeometry.skinIndices.push( new THREE.Vector4( a, b, c, d ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.bones = json.bones;\r\n\r\n\t\t\tif ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {\r\n\r\n\t\t\t\tconsole.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +\r\n\t\t\t\t\tgeometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseMorphing( scale ) {\r\n\r\n\t\t\tif ( json.morphTargets !== undefined ) {\r\n\r\n\t\t\t\tfor ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tgeometry.morphTargets[ i ] = {};\r\n\t\t\t\t\tgeometry.morphTargets[ i ].name = json.morphTargets[ i ].name;\r\n\t\t\t\t\tgeometry.morphTargets[ i ].vertices = [];\r\n\r\n\t\t\t\t\tvar dstVertices = geometry.morphTargets[ i ].vertices;\r\n\t\t\t\t\tvar srcVertices = json.morphTargets[ i ].vertices;\r\n\r\n\t\t\t\t\tfor ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {\r\n\r\n\t\t\t\t\t\tvar vertex = new THREE.Vector3();\r\n\t\t\t\t\t\tvertex.x = srcVertices[ v ] * scale;\r\n\t\t\t\t\t\tvertex.y = srcVertices[ v + 1 ] * scale;\r\n\t\t\t\t\t\tvertex.z = srcVertices[ v + 2 ] * scale;\r\n\r\n\t\t\t\t\t\tdstVertices.push( vertex );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( json.morphColors !== undefined && json.morphColors.length > 0 ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.JSONLoader: \"morphColors\" no longer supported. Using them as face colors.' );\r\n\r\n\t\t\t\tvar faces = geometry.faces;\r\n\t\t\t\tvar morphColors = json.morphColors[ 0 ].colors;\r\n\r\n\t\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tfaces[ i ].color.fromArray( morphColors, i * 3 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction parseAnimations() {\r\n\r\n\t\t\tvar outputAnimations = [];\r\n\r\n\t\t\t// parse old style Bone/Hierarchy animations\r\n\t\t\tvar animations = [];\r\n\r\n\t\t\tif ( json.animation !== undefined ) {\r\n\r\n\t\t\t\tanimations.push( json.animation );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( json.animations !== undefined ) {\r\n\r\n\t\t\t\tif ( json.animations.length ) {\r\n\r\n\t\t\t\t\tanimations = animations.concat( json.animations );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tanimations.push( json.animations );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0; i < animations.length; i ++ ) {\r\n\r\n\t\t\t\tvar clip = THREE.AnimationClip.parseAnimation( animations[ i ], geometry.bones );\r\n\t\t\t\tif ( clip ) outputAnimations.push( clip );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// parse implicit morph animations\r\n\t\t\tif ( geometry.morphTargets ) {\r\n\r\n\t\t\t\t// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.\r\n\t\t\t\tvar morphAnimationClips = THREE.AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );\r\n\t\t\t\toutputAnimations = outputAnimations.concat( morphAnimationClips );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.materials === undefined || json.materials.length === 0 ) {\r\n\r\n\t\t\treturn { geometry: geometry };\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar materials = THREE.Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );\r\n\r\n\t\t\treturn { geometry: geometry, materials: materials };\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/LoadingManager.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LoadingManager = function ( onLoad, onProgress, onError ) {\r\n\r\n\tvar scope = this;\r\n\r\n\tvar isLoading = false, itemsLoaded = 0, itemsTotal = 0;\r\n\r\n\tthis.onStart = undefined;\r\n\tthis.onLoad = onLoad;\r\n\tthis.onProgress = onProgress;\r\n\tthis.onError = onError;\r\n\r\n\tthis.itemStart = function ( url ) {\r\n\r\n\t\titemsTotal ++;\r\n\r\n\t\tif ( isLoading === false ) {\r\n\r\n\t\t\tif ( scope.onStart !== undefined ) {\r\n\r\n\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tisLoading = true;\r\n\r\n\t};\r\n\r\n\tthis.itemEnd = function ( url ) {\r\n\r\n\t\titemsLoaded ++;\r\n\r\n\t\tif ( scope.onProgress !== undefined ) {\r\n\r\n\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\r\n\r\n\t\t}\r\n\r\n\t\tif ( itemsLoaded === itemsTotal ) {\r\n\r\n\t\t\tisLoading = false;\r\n\r\n\t\t\tif ( scope.onLoad !== undefined ) {\r\n\r\n\t\t\t\tscope.onLoad();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.itemError = function ( url ) {\r\n\r\n\t\tif ( scope.onError !== undefined ) {\r\n\r\n\t\t\tscope.onError( url );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.DefaultLoadingManager = new THREE.LoadingManager();\r\n\r\n// File:src/loaders/BufferGeometryLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BufferGeometryLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.BufferGeometryLoader.prototype = {\r\n\r\n\tconstructor: THREE.BufferGeometryLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tparse: function ( json ) {\r\n\r\n\t\tvar geometry = new THREE.BufferGeometry();\r\n\r\n\t\tvar index = json.data.index;\r\n\r\n\t\tvar TYPED_ARRAYS = {\r\n\t\t\t'Int8Array': Int8Array,\r\n\t\t\t'Uint8Array': Uint8Array,\r\n\t\t\t'Uint8ClampedArray': Uint8ClampedArray,\r\n\t\t\t'Int16Array': Int16Array,\r\n\t\t\t'Uint16Array': Uint16Array,\r\n\t\t\t'Int32Array': Int32Array,\r\n\t\t\t'Uint32Array': Uint32Array,\r\n\t\t\t'Float32Array': Float32Array,\r\n\t\t\t'Float64Array': Float64Array\r\n\t\t};\r\n\r\n\t\tif ( index !== undefined ) {\r\n\r\n\t\t\tvar typedArray = new TYPED_ARRAYS[ index.type ]( index.array );\r\n\t\t\tgeometry.setIndex( new THREE.BufferAttribute( typedArray, 1 ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar attributes = json.data.attributes;\r\n\r\n\t\tfor ( var key in attributes ) {\r\n\r\n\t\t\tvar attribute = attributes[ key ];\r\n\t\t\tvar typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );\r\n\r\n\t\t\tgeometry.addAttribute( key, new THREE.BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );\r\n\r\n\t\t}\r\n\r\n\t\tvar groups = json.data.groups || json.data.drawcalls || json.data.offsets;\r\n\r\n\t\tif ( groups !== undefined ) {\r\n\r\n\t\t\tfor ( var i = 0, n = groups.length; i !== n; ++ i ) {\r\n\r\n\t\t\t\tvar group = groups[ i ];\r\n\r\n\t\t\t\tgeometry.addGroup( group.start, group.count, group.materialIndex );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar boundingSphere = json.data.boundingSphere;\r\n\r\n\t\tif ( boundingSphere !== undefined ) {\r\n\r\n\t\t\tvar center = new THREE.Vector3();\r\n\r\n\t\t\tif ( boundingSphere.center !== undefined ) {\r\n\r\n\t\t\t\tcenter.fromArray( boundingSphere.center );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgeometry.boundingSphere = new THREE.Sphere( center, boundingSphere.radius );\r\n\r\n\t\t}\r\n\r\n\t\treturn geometry;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/MaterialLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.MaterialLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\tthis.textures = {};\r\n\r\n};\r\n\r\nTHREE.MaterialLoader.prototype = {\r\n\r\n\tconstructor: THREE.MaterialLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tonLoad( scope.parse( JSON.parse( text ) ) );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tsetTextures: function ( value ) {\r\n\r\n\t\tthis.textures = value;\r\n\r\n\t},\r\n\r\n\tgetTexture: function ( name ) {\r\n\r\n\t\tvar textures = this.textures;\r\n\r\n\t\tif ( textures[ name ] === undefined ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.MaterialLoader: Undefined texture', name );\r\n\r\n\t\t}\r\n\r\n\t\treturn textures[ name ];\r\n\r\n\t},\r\n\r\n\tparse: function ( json ) {\r\n\r\n\t\tvar material = new THREE[ json.type ];\r\n\r\n\t\tif ( json.uuid !== undefined ) material.uuid = json.uuid;\r\n\t\tif ( json.name !== undefined ) material.name = json.name;\r\n\t\tif ( json.color !== undefined ) material.color.setHex( json.color );\r\n\t\tif ( json.roughness !== undefined ) material.roughness = json.roughness;\r\n\t\tif ( json.metalness !== undefined ) material.metalness = json.metalness;\r\n\t\tif ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );\r\n\t\tif ( json.specular !== undefined ) material.specular.setHex( json.specular );\r\n\t\tif ( json.shininess !== undefined ) material.shininess = json.shininess;\r\n\t\tif ( json.uniforms !== undefined ) material.uniforms = json.uniforms;\r\n\t\tif ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;\r\n\t\tif ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;\r\n\t\tif ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;\r\n\t\tif ( json.shading !== undefined ) material.shading = json.shading;\r\n\t\tif ( json.blending !== undefined ) material.blending = json.blending;\r\n\t\tif ( json.side !== undefined ) material.side = json.side;\r\n\t\tif ( json.opacity !== undefined ) material.opacity = json.opacity;\r\n\t\tif ( json.transparent !== undefined ) material.transparent = json.transparent;\r\n\t\tif ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;\r\n\t\tif ( json.depthTest !== undefined ) material.depthTest = json.depthTest;\r\n\t\tif ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;\r\n\t\tif ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;\r\n\t\tif ( json.wireframe !== undefined ) material.wireframe = json.wireframe;\r\n\t\tif ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;\r\n\r\n\t\t// for PointsMaterial\r\n\t\tif ( json.size !== undefined ) material.size = json.size;\r\n\t\tif ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;\r\n\r\n\t\t// maps\r\n\r\n\t\tif ( json.map !== undefined ) material.map = this.getTexture( json.map );\r\n\r\n\t\tif ( json.alphaMap !== undefined ) {\r\n\r\n\t\t\tmaterial.alphaMap = this.getTexture( json.alphaMap );\r\n\t\t\tmaterial.transparent = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.bumpMap !== undefined ) material.bumpMap = this.getTexture( json.bumpMap );\r\n\t\tif ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;\r\n\r\n\t\tif ( json.normalMap !== undefined ) material.normalMap = this.getTexture( json.normalMap );\r\n\t\tif ( json.normalScale !== undefined ) {\r\n\r\n\t\t\tvar normalScale = json.normalScale;\r\n\r\n\t\t\tif ( Array.isArray( normalScale ) === false ) {\r\n\r\n\t\t\t\t// Blender exporter used to export a scalar. See #7459\r\n\r\n\t\t\t\tnormalScale = [ normalScale, normalScale ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterial.normalScale = new THREE.Vector2().fromArray( normalScale );\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.displacementMap !== undefined ) material.displacementMap = this.getTexture( json.displacementMap );\r\n\t\tif ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;\r\n\t\tif ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;\r\n\r\n\t\tif ( json.roughnessMap !== undefined ) material.roughnessMap = this.getTexture( json.roughnessMap );\r\n\t\tif ( json.metalnessMap !== undefined ) material.metalnessMap = this.getTexture( json.metalnessMap );\r\n\r\n\t\tif ( json.emissiveMap !== undefined ) material.emissiveMap = this.getTexture( json.emissiveMap );\r\n\t\tif ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;\r\n\r\n\t\tif ( json.specularMap !== undefined ) material.specularMap = this.getTexture( json.specularMap );\r\n\r\n\t\tif ( json.envMap !== undefined ) {\r\n\r\n\t\t\tmaterial.envMap = this.getTexture( json.envMap );\r\n\t\t\tmaterial.combine = THREE.MultiplyOperation;\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.reflectivity ) material.reflectivity = json.reflectivity;\r\n\r\n\t\tif ( json.lightMap !== undefined ) material.lightMap = this.getTexture( json.lightMap );\r\n\t\tif ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;\r\n\r\n\t\tif ( json.aoMap !== undefined ) material.aoMap = this.getTexture( json.aoMap );\r\n\t\tif ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;\r\n\r\n\t\t// MultiMaterial\r\n\r\n\t\tif ( json.materials !== undefined ) {\r\n\r\n\t\t\tfor ( var i = 0, l = json.materials.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tmaterial.materials.push( this.parse( json.materials[ i ] ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/ObjectLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.ObjectLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\tthis.texturePath = '';\r\n\r\n};\r\n\r\nTHREE.ObjectLoader.prototype = {\r\n\r\n\tconstructor: THREE.ObjectLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tif ( this.texturePath === '' ) {\r\n\r\n\t\t\tthis.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );\r\n\r\n\t\t}\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar loader = new THREE.XHRLoader( scope.manager );\r\n\t\tloader.load( url, function ( text ) {\r\n\r\n\t\t\tscope.parse( JSON.parse( text ), onLoad );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t},\r\n\r\n\tsetTexturePath: function ( value ) {\r\n\r\n\t\tthis.texturePath = value;\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\tparse: function ( json, onLoad ) {\r\n\r\n\t\tvar geometries = this.parseGeometries( json.geometries );\r\n\r\n\t\tvar images = this.parseImages( json.images, function () {\r\n\r\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\r\n\r\n\t\t} );\r\n\r\n\t\tvar textures  = this.parseTextures( json.textures, images );\r\n\t\tvar materials = this.parseMaterials( json.materials, textures );\r\n\r\n\t\tvar object = this.parseObject( json.object, geometries, materials );\r\n\r\n\t\tif ( json.animations ) {\r\n\r\n\t\t\tobject.animations = this.parseAnimations( json.animations );\r\n\r\n\t\t}\r\n\r\n\t\tif ( json.images === undefined || json.images.length === 0 ) {\r\n\r\n\t\t\tif ( onLoad !== undefined ) onLoad( object );\r\n\r\n\t\t}\r\n\r\n\t\treturn object;\r\n\r\n\t},\r\n\r\n\tparseGeometries: function ( json ) {\r\n\r\n\t\tvar geometries = {};\r\n\r\n\t\tif ( json !== undefined ) {\r\n\r\n\t\t\tvar geometryLoader = new THREE.JSONLoader();\r\n\t\t\tvar bufferGeometryLoader = new THREE.BufferGeometryLoader();\r\n\r\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar geometry;\r\n\t\t\t\tvar data = json[ i ];\r\n\r\n\t\t\t\tswitch ( data.type ) {\r\n\r\n\t\t\t\t\tcase 'PlaneGeometry':\r\n\t\t\t\t\tcase 'PlaneBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\tdata.width,\r\n\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\tdata.heightSegments\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'BoxGeometry':\r\n\t\t\t\t\tcase 'BoxBufferGeometry':\r\n\t\t\t\t\tcase 'CubeGeometry': // backwards compatible\r\n\r\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\tdata.width,\r\n\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\tdata.depth,\r\n\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\tdata.depthSegments\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'CircleGeometry':\r\n\t\t\t\t\tcase 'CircleBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.segments,\r\n\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'CylinderGeometry':\r\n\t\t\t\t\tcase 'CylinderBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\tdata.radiusTop,\r\n\t\t\t\t\t\t\tdata.radiusBottom,\r\n\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\tdata.openEnded,\r\n\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'ConeGeometry':\r\n\t\t\t\t\tcase 'ConeBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE [ data.type ](\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.height,\r\n\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\tdata.openEnded,\r\n\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'SphereGeometry':\r\n\t\t\t\t\tcase 'SphereBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.widthSegments,\r\n\t\t\t\t\t\t\tdata.heightSegments,\r\n\t\t\t\t\t\t\tdata.phiStart,\r\n\t\t\t\t\t\t\tdata.phiLength,\r\n\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'DodecahedronGeometry':\r\n\t\t\t\t\tcase 'IcosahedronGeometry':\r\n\t\t\t\t\tcase 'OctahedronGeometry':\r\n\t\t\t\t\tcase 'TetrahedronGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.detail\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'RingGeometry':\r\n\t\t\t\t\tcase 'RingBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\tdata.innerRadius,\r\n\t\t\t\t\t\t\tdata.outerRadius,\r\n\t\t\t\t\t\t\tdata.thetaSegments,\r\n\t\t\t\t\t\t\tdata.phiSegments,\r\n\t\t\t\t\t\t\tdata.thetaStart,\r\n\t\t\t\t\t\t\tdata.thetaLength\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'TorusGeometry':\r\n\t\t\t\t\tcase 'TorusBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.tube,\r\n\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\tdata.tubularSegments,\r\n\t\t\t\t\t\t\tdata.arc\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'TorusKnotGeometry':\r\n\t\t\t\t\tcase 'TorusKnotBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\tdata.radius,\r\n\t\t\t\t\t\t\tdata.tube,\r\n\t\t\t\t\t\t\tdata.tubularSegments,\r\n\t\t\t\t\t\t\tdata.radialSegments,\r\n\t\t\t\t\t\t\tdata.p,\r\n\t\t\t\t\t\t\tdata.q\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'LatheGeometry':\r\n\t\t\t\t\tcase 'LatheBufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = new THREE[ data.type ](\r\n\t\t\t\t\t\t\tdata.points,\r\n\t\t\t\t\t\t\tdata.segments,\r\n\t\t\t\t\t\t\tdata.phiStart,\r\n\t\t\t\t\t\t\tdata.phiLength\r\n\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'BufferGeometry':\r\n\r\n\t\t\t\t\t\tgeometry = bufferGeometryLoader.parse( data );\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase 'Geometry':\r\n\r\n\t\t\t\t\t\tgeometry = geometryLoader.parse( data.data, this.texturePath ).geometry;\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Unsupported geometry type \"' + data.type + '\"' );\r\n\r\n\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tgeometry.uuid = data.uuid;\r\n\r\n\t\t\t\tif ( data.name !== undefined ) geometry.name = data.name;\r\n\r\n\t\t\t\tgeometries[ data.uuid ] = geometry;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn geometries;\r\n\r\n\t},\r\n\r\n\tparseMaterials: function ( json, textures ) {\r\n\r\n\t\tvar materials = {};\r\n\r\n\t\tif ( json !== undefined ) {\r\n\r\n\t\t\tvar loader = new THREE.MaterialLoader();\r\n\t\t\tloader.setTextures( textures );\r\n\r\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar material = loader.parse( json[ i ] );\r\n\t\t\t\tmaterials[ material.uuid ] = material;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn materials;\r\n\r\n\t},\r\n\r\n\tparseAnimations: function ( json ) {\r\n\r\n\t\tvar animations = [];\r\n\r\n\t\tfor ( var i = 0; i < json.length; i ++ ) {\r\n\r\n\t\t\tvar clip = THREE.AnimationClip.parse( json[ i ] );\r\n\r\n\t\t\tanimations.push( clip );\r\n\r\n\t\t}\r\n\r\n\t\treturn animations;\r\n\r\n\t},\r\n\r\n\tparseImages: function ( json, onLoad ) {\r\n\r\n\t\tvar scope = this;\r\n\t\tvar images = {};\r\n\r\n\t\tfunction loadImage( url ) {\r\n\r\n\t\t\tscope.manager.itemStart( url );\r\n\r\n\t\t\treturn loader.load( url, function () {\r\n\r\n\t\t\t\tscope.manager.itemEnd( url );\r\n\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\tif ( json !== undefined && json.length > 0 ) {\r\n\r\n\t\t\tvar manager = new THREE.LoadingManager( onLoad );\r\n\r\n\t\t\tvar loader = new THREE.ImageLoader( manager );\r\n\t\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\r\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar image = json[ i ];\r\n\t\t\t\tvar path = /^(\\/\\/)|([a-z]+:(\\/\\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;\r\n\r\n\t\t\t\timages[ image.uuid ] = loadImage( path );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn images;\r\n\r\n\t},\r\n\r\n\tparseTextures: function ( json, images ) {\r\n\r\n\t\tfunction parseConstant( value ) {\r\n\r\n\t\t\tif ( typeof( value ) === 'number' ) return value;\r\n\r\n\t\t\tconsole.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );\r\n\r\n\t\t\treturn THREE[ value ];\r\n\r\n\t\t}\r\n\r\n\t\tvar textures = {};\r\n\r\n\t\tif ( json !== undefined ) {\r\n\r\n\t\t\tfor ( var i = 0, l = json.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar data = json[ i ];\r\n\r\n\t\t\t\tif ( data.image === undefined ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: No \"image\" specified for', data.uuid );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( images[ data.image ] === undefined ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined image', data.image );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar texture = new THREE.Texture( images[ data.image ] );\r\n\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\ttexture.uuid = data.uuid;\r\n\r\n\t\t\t\tif ( data.name !== undefined ) texture.name = data.name;\r\n\t\t\t\tif ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping );\r\n\t\t\t\tif ( data.offset !== undefined ) texture.offset = new THREE.Vector2( data.offset[ 0 ], data.offset[ 1 ] );\r\n\t\t\t\tif ( data.repeat !== undefined ) texture.repeat = new THREE.Vector2( data.repeat[ 0 ], data.repeat[ 1 ] );\r\n\t\t\t\tif ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter );\r\n\t\t\t\tif ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter );\r\n\t\t\t\tif ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;\r\n\t\t\t\tif ( Array.isArray( data.wrap ) ) {\r\n\r\n\t\t\t\t\ttexture.wrapS = parseConstant( data.wrap[ 0 ] );\r\n\t\t\t\t\ttexture.wrapT = parseConstant( data.wrap[ 1 ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttextures[ data.uuid ] = texture;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn textures;\r\n\r\n\t},\r\n\r\n\tparseObject: function () {\r\n\r\n\t\tvar matrix = new THREE.Matrix4();\r\n\r\n\t\treturn function ( data, geometries, materials ) {\r\n\r\n\t\t\tvar object;\r\n\r\n\t\t\tfunction getGeometry( name ) {\r\n\r\n\t\t\t\tif ( geometries[ name ] === undefined ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined geometry', name );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn geometries[ name ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction getMaterial( name ) {\r\n\r\n\t\t\t\tif ( name === undefined ) return undefined;\r\n\r\n\t\t\t\tif ( materials[ name ] === undefined ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.ObjectLoader: Undefined material', name );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn materials[ name ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tswitch ( data.type ) {\r\n\r\n\t\t\t\tcase 'Scene':\r\n\r\n\t\t\t\t\tobject = new THREE.Scene();\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'PerspectiveCamera':\r\n\r\n\t\t\t\t\tobject = new THREE.PerspectiveCamera( data.fov, data.aspect, data.near, data.far );\r\n\r\n\t\t\t\t\tif ( data.focus !== undefined ) object.focus = data.focus;\r\n\t\t\t\t\tif ( data.zoom !== undefined ) object.zoom = data.zoom;\r\n\t\t\t\t\tif ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;\r\n\t\t\t\t\tif ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;\r\n\t\t\t\t\tif ( data.view !== undefined ) object.view = Object.assign( {}, data.view );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'OrthographicCamera':\r\n\r\n\t\t\t\t\tobject = new THREE.OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'AmbientLight':\r\n\r\n\t\t\t\t\tobject = new THREE.AmbientLight( data.color, data.intensity );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'DirectionalLight':\r\n\r\n\t\t\t\t\tobject = new THREE.DirectionalLight( data.color, data.intensity );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'PointLight':\r\n\r\n\t\t\t\t\tobject = new THREE.PointLight( data.color, data.intensity, data.distance, data.decay );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'SpotLight':\r\n\r\n\t\t\t\t\tobject = new THREE.SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'HemisphereLight':\r\n\r\n\t\t\t\t\tobject = new THREE.HemisphereLight( data.color, data.groundColor, data.intensity );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'Mesh':\r\n\r\n\t\t\t\t\tvar geometry = getGeometry( data.geometry );\r\n\t\t\t\t\tvar material = getMaterial( data.material );\r\n\r\n\t\t\t\t\tif ( geometry.bones && geometry.bones.length > 0 ) {\r\n\r\n\t\t\t\t\t\tobject = new THREE.SkinnedMesh( geometry, material );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tobject = new THREE.Mesh( geometry, material );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'LOD':\r\n\r\n\t\t\t\t\tobject = new THREE.LOD();\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'Line':\r\n\r\n\t\t\t\t\tobject = new THREE.Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'PointCloud':\r\n\t\t\t\tcase 'Points':\r\n\r\n\t\t\t\t\tobject = new THREE.Points( getGeometry( data.geometry ), getMaterial( data.material ) );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'Sprite':\r\n\r\n\t\t\t\t\tobject = new THREE.Sprite( getMaterial( data.material ) );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase 'Group':\r\n\r\n\t\t\t\t\tobject = new THREE.Group();\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tdefault:\r\n\r\n\t\t\t\t\tobject = new THREE.Object3D();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tobject.uuid = data.uuid;\r\n\r\n\t\t\tif ( data.name !== undefined ) object.name = data.name;\r\n\t\t\tif ( data.matrix !== undefined ) {\r\n\r\n\t\t\t\tmatrix.fromArray( data.matrix );\r\n\t\t\t\tmatrix.decompose( object.position, object.quaternion, object.scale );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( data.position !== undefined ) object.position.fromArray( data.position );\r\n\t\t\t\tif ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );\r\n\t\t\t\tif ( data.scale !== undefined ) object.scale.fromArray( data.scale );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( data.castShadow !== undefined ) object.castShadow = data.castShadow;\r\n\t\t\tif ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;\r\n\r\n\t\t\tif ( data.visible !== undefined ) object.visible = data.visible;\r\n\t\t\tif ( data.userData !== undefined ) object.userData = data.userData;\r\n\r\n\t\t\tif ( data.children !== undefined ) {\r\n\r\n\t\t\t\tfor ( var child in data.children ) {\r\n\r\n\t\t\t\t\tobject.add( this.parseObject( data.children[ child ], geometries, materials ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( data.type === 'LOD' ) {\r\n\r\n\t\t\t\tvar levels = data.levels;\r\n\r\n\t\t\t\tfor ( var l = 0; l < levels.length; l ++ ) {\r\n\r\n\t\t\t\t\tvar level = levels[ l ];\r\n\t\t\t\t\tvar child = object.getObjectByProperty( 'uuid', level.object );\r\n\r\n\t\t\t\t\tif ( child !== undefined ) {\r\n\r\n\t\t\t\t\t\tobject.addLevel( child, level.distance );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn object;\r\n\r\n\t\t};\r\n\r\n\t}()\r\n\r\n};\r\n\r\n// File:src/loaders/TextureLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.TextureLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.TextureLoader.prototype = {\r\n\r\n\tconstructor: THREE.TextureLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar texture = new THREE.Texture();\r\n\r\n\t\tvar loader = new THREE.ImageLoader( this.manager );\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\tloader.setPath( this.path );\r\n\t\tloader.load( url, function ( image ) {\r\n\r\n\t\t\ttexture.image = image;\r\n\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\tif ( onLoad !== undefined ) {\r\n\r\n\t\t\t\tonLoad( texture );\r\n\r\n\t\t\t}\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\tsetPath: function ( value ) {\r\n\r\n\t\tthis.path = value;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/CubeTextureLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CubeTextureLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n};\r\n\r\nTHREE.CubeTextureLoader.prototype = {\r\n\r\n\tconstructor: THREE.CubeTextureLoader,\r\n\r\n\tload: function ( urls, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar texture = new THREE.CubeTexture();\r\n\r\n\t\tvar loader = new THREE.ImageLoader( this.manager );\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\t\tloader.setPath( this.path );\r\n\r\n\t\tvar loaded = 0;\r\n\r\n\t\tfunction loadTexture( i ) {\r\n\r\n\t\t\tloader.load( urls[ i ], function ( image ) {\r\n\r\n\t\t\t\ttexture.images[ i ] = image;\r\n\r\n\t\t\t\tloaded ++;\r\n\r\n\t\t\t\tif ( loaded === 6 ) {\r\n\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, undefined, onError );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i < urls.length; ++ i ) {\r\n\r\n\t\t\tloadTexture( i );\r\n\r\n\t\t}\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tsetCrossOrigin: function ( value ) {\r\n\r\n\t\tthis.crossOrigin = value;\r\n\r\n\t},\r\n\r\n\tsetPath: function ( value ) {\r\n\r\n\t\tthis.path = value;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/BinaryTextureLoader.js\r\n\r\n/**\r\n * @author Nikos M. / https://github.com/foo123/\r\n *\r\n * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)\r\n */\r\n\r\nTHREE.DataTextureLoader = THREE.BinaryTextureLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n\t// override in sub classes\r\n\tthis._parser = null;\r\n\r\n};\r\n\r\nTHREE.BinaryTextureLoader.prototype = {\r\n\r\n\tconstructor: THREE.BinaryTextureLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar texture = new THREE.DataTexture();\r\n\r\n\t\tvar loader = new THREE.XHRLoader( this.manager );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\r\n\t\tloader.load( url, function ( buffer ) {\r\n\r\n\t\t\tvar texData = scope._parser( buffer );\r\n\r\n\t\t\tif ( ! texData ) return;\r\n\r\n\t\t\tif ( undefined !== texData.image ) {\r\n\r\n\t\t\t\ttexture.image = texData.image;\r\n\r\n\t\t\t} else if ( undefined !== texData.data ) {\r\n\r\n\t\t\t\ttexture.image.width = texData.width;\r\n\t\t\t\ttexture.image.height = texData.height;\r\n\t\t\t\ttexture.image.data = texData.data;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttexture.wrapS = undefined !== texData.wrapS ? texData.wrapS : THREE.ClampToEdgeWrapping;\r\n\t\t\ttexture.wrapT = undefined !== texData.wrapT ? texData.wrapT : THREE.ClampToEdgeWrapping;\r\n\r\n\t\t\ttexture.magFilter = undefined !== texData.magFilter ? texData.magFilter : THREE.LinearFilter;\r\n\t\t\ttexture.minFilter = undefined !== texData.minFilter ? texData.minFilter : THREE.LinearMipMapLinearFilter;\r\n\r\n\t\t\ttexture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;\r\n\r\n\t\t\tif ( undefined !== texData.format ) {\r\n\r\n\t\t\t\ttexture.format = texData.format;\r\n\r\n\t\t\t}\r\n\t\t\tif ( undefined !== texData.type ) {\r\n\r\n\t\t\t\ttexture.type = texData.type;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( undefined !== texData.mipmaps ) {\r\n\r\n\t\t\t\ttexture.mipmaps = texData.mipmaps;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( 1 === texData.mipmapCount ) {\r\n\r\n\t\t\t\ttexture.minFilter = THREE.LinearFilter;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\tif ( onLoad ) onLoad( texture, texData );\r\n\r\n\t\t}, onProgress, onError );\r\n\r\n\r\n\t\treturn texture;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/loaders/CompressedTextureLoader.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n *\r\n * Abstract Base class to block based textures loader (dds, pvr, ...)\r\n */\r\n\r\nTHREE.CompressedTextureLoader = function ( manager ) {\r\n\r\n\tthis.manager = ( manager !== undefined ) ? manager : THREE.DefaultLoadingManager;\r\n\r\n\t// override in sub classes\r\n\tthis._parser = null;\r\n\r\n};\r\n\r\n\r\nTHREE.CompressedTextureLoader.prototype = {\r\n\r\n\tconstructor: THREE.CompressedTextureLoader,\r\n\r\n\tload: function ( url, onLoad, onProgress, onError ) {\r\n\r\n\t\tvar scope = this;\r\n\r\n\t\tvar images = [];\r\n\r\n\t\tvar texture = new THREE.CompressedTexture();\r\n\t\ttexture.image = images;\r\n\r\n\t\tvar loader = new THREE.XHRLoader( this.manager );\r\n\t\tloader.setPath( this.path );\r\n\t\tloader.setResponseType( 'arraybuffer' );\r\n\r\n\t\tfunction loadTexture( i ) {\r\n\r\n\t\t\tloader.load( url[ i ], function ( buffer ) {\r\n\r\n\t\t\t\tvar texDatas = scope._parser( buffer, true );\r\n\r\n\t\t\t\timages[ i ] = {\r\n\t\t\t\t\twidth: texDatas.width,\r\n\t\t\t\t\theight: texDatas.height,\r\n\t\t\t\t\tformat: texDatas.format,\r\n\t\t\t\t\tmipmaps: texDatas.mipmaps\r\n\t\t\t\t};\r\n\r\n\t\t\t\tloaded += 1;\r\n\r\n\t\t\t\tif ( loaded === 6 ) {\r\n\r\n\t\t\t\t\tif ( texDatas.mipmapCount === 1 )\r\n\t\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\r\n\r\n\t\t\t\t\ttexture.format = texDatas.format;\r\n\t\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}, onProgress, onError );\r\n\r\n\t\t}\r\n\r\n\t\tif ( Array.isArray( url ) ) {\r\n\r\n\t\t\tvar loaded = 0;\r\n\r\n\t\t\tfor ( var i = 0, il = url.length; i < il; ++ i ) {\r\n\r\n\t\t\t\tloadTexture( i );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// compressed cubemap texture stored in a single DDS file\r\n\r\n\t\t\tloader.load( url, function ( buffer ) {\r\n\r\n\t\t\t\tvar texDatas = scope._parser( buffer, true );\r\n\r\n\t\t\t\tif ( texDatas.isCubemap ) {\r\n\r\n\t\t\t\t\tvar faces = texDatas.mipmaps.length / texDatas.mipmapCount;\r\n\r\n\t\t\t\t\tfor ( var f = 0; f < faces; f ++ ) {\r\n\r\n\t\t\t\t\t\timages[ f ] = { mipmaps : [] };\r\n\r\n\t\t\t\t\t\tfor ( var i = 0; i < texDatas.mipmapCount; i ++ ) {\r\n\r\n\t\t\t\t\t\t\timages[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );\r\n\t\t\t\t\t\t\timages[ f ].format = texDatas.format;\r\n\t\t\t\t\t\t\timages[ f ].width = texDatas.width;\r\n\t\t\t\t\t\t\timages[ f ].height = texDatas.height;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\ttexture.image.width = texDatas.width;\r\n\t\t\t\t\ttexture.image.height = texDatas.height;\r\n\t\t\t\t\ttexture.mipmaps = texDatas.mipmaps;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( texDatas.mipmapCount === 1 ) {\r\n\r\n\t\t\t\t\ttexture.minFilter = THREE.LinearFilter;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture.format = texDatas.format;\r\n\t\t\t\ttexture.needsUpdate = true;\r\n\r\n\t\t\t\tif ( onLoad ) onLoad( texture );\r\n\r\n\t\t\t}, onProgress, onError );\r\n\r\n\t\t}\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tsetPath: function ( value ) {\r\n\r\n\t\tthis.path = value;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/materials/Material.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Material = function () {\r\n\r\n\tObject.defineProperty( this, 'id', { value: THREE.MaterialIdCount ++ } );\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.type = 'Material';\r\n\r\n\tthis.fog = true;\r\n\tthis.lights = true;\r\n\r\n\tthis.blending = THREE.NormalBlending;\r\n\tthis.side = THREE.FrontSide;\r\n\tthis.shading = THREE.SmoothShading; // THREE.FlatShading, THREE.SmoothShading\r\n\tthis.vertexColors = THREE.NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors\r\n\r\n\tthis.opacity = 1;\r\n\tthis.transparent = false;\r\n\r\n\tthis.blendSrc = THREE.SrcAlphaFactor;\r\n\tthis.blendDst = THREE.OneMinusSrcAlphaFactor;\r\n\tthis.blendEquation = THREE.AddEquation;\r\n\tthis.blendSrcAlpha = null;\r\n\tthis.blendDstAlpha = null;\r\n\tthis.blendEquationAlpha = null;\r\n\r\n\tthis.depthFunc = THREE.LessEqualDepth;\r\n\tthis.depthTest = true;\r\n\tthis.depthWrite = true;\r\n\r\n\tthis.clippingPlanes = null;\r\n\tthis.clipShadows = false;\r\n\r\n\tthis.colorWrite = true;\r\n\r\n\tthis.precision = null; // override the renderer's default precision for this material\r\n\r\n\tthis.polygonOffset = false;\r\n\tthis.polygonOffsetFactor = 0;\r\n\tthis.polygonOffsetUnits = 0;\r\n\r\n\tthis.alphaTest = 0;\r\n\tthis.premultipliedAlpha = false;\r\n\r\n\tthis.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer\r\n\r\n\tthis.visible = true;\r\n\r\n\tthis._needsUpdate = true;\r\n\r\n};\r\n\r\nTHREE.Material.prototype = {\r\n\r\n\tconstructor: THREE.Material,\r\n\r\n\tget needsUpdate() {\r\n\r\n\t\treturn this._needsUpdate;\r\n\r\n\t},\r\n\r\n\tset needsUpdate( value ) {\r\n\r\n\t\tif ( value === true ) this.update();\r\n\t\tthis._needsUpdate = value;\r\n\r\n\t},\r\n\r\n\tsetValues: function ( values ) {\r\n\r\n\t\tif ( values === undefined ) return;\r\n\r\n\t\tfor ( var key in values ) {\r\n\r\n\t\t\tvar newValue = values[ key ];\r\n\r\n\t\t\tif ( newValue === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( \"THREE.Material: '\" + key + \"' parameter is undefined.\" );\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar currentValue = this[ key ];\r\n\r\n\t\t\tif ( currentValue === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( \"THREE.\" + this.type + \": '\" + key + \"' is not a property of this material.\" );\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( currentValue instanceof THREE.Color ) {\r\n\r\n\t\t\t\tcurrentValue.set( newValue );\r\n\r\n\t\t\t} else if ( currentValue instanceof THREE.Vector3 && newValue instanceof THREE.Vector3 ) {\r\n\r\n\t\t\t\tcurrentValue.copy( newValue );\r\n\r\n\t\t\t} else if ( key === 'overdraw' ) {\r\n\r\n\t\t\t\t// ensure overdraw is backwards-compatible with legacy boolean type\r\n\t\t\t\tthis[ key ] = Number( newValue );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis[ key ] = newValue;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\ttoJSON: function ( meta ) {\r\n\r\n\t\tvar isRoot = meta === undefined;\r\n\r\n\t\tif ( isRoot ) {\r\n\r\n\t\t\tmeta = {\r\n\t\t\t\ttextures: {},\r\n\t\t\t\timages: {}\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tvar data = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.4,\r\n\t\t\t\ttype: 'Material',\r\n\t\t\t\tgenerator: 'Material.toJSON'\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// standard Material serialization\r\n\t\tdata.uuid = this.uuid;\r\n\t\tdata.type = this.type;\r\n\r\n\t\tif ( this.name !== '' ) data.name = this.name;\r\n\r\n\t\tif ( this.color instanceof THREE.Color ) data.color = this.color.getHex();\r\n\r\n\t\tif ( this.roughness !== 0.5 ) data.roughness = this.roughness;\r\n\t\tif ( this.metalness !== 0.5 ) data.metalness = this.metalness;\r\n\r\n\t\tif ( this.emissive instanceof THREE.Color ) data.emissive = this.emissive.getHex();\r\n\t\tif ( this.specular instanceof THREE.Color ) data.specular = this.specular.getHex();\r\n\t\tif ( this.shininess !== undefined ) data.shininess = this.shininess;\r\n\r\n\t\tif ( this.map instanceof THREE.Texture ) data.map = this.map.toJSON( meta ).uuid;\r\n\t\tif ( this.alphaMap instanceof THREE.Texture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;\r\n\t\tif ( this.lightMap instanceof THREE.Texture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;\r\n\t\tif ( this.bumpMap instanceof THREE.Texture ) {\r\n\r\n\t\t\tdata.bumpMap = this.bumpMap.toJSON( meta ).uuid;\r\n\t\t\tdata.bumpScale = this.bumpScale;\r\n\r\n\t\t}\r\n\t\tif ( this.normalMap instanceof THREE.Texture ) {\r\n\r\n\t\t\tdata.normalMap = this.normalMap.toJSON( meta ).uuid;\r\n\t\t\tdata.normalScale = this.normalScale.toArray();\r\n\r\n\t\t}\r\n\t\tif ( this.displacementMap instanceof THREE.Texture ) {\r\n\r\n\t\t\tdata.displacementMap = this.displacementMap.toJSON( meta ).uuid;\r\n\t\t\tdata.displacementScale = this.displacementScale;\r\n\t\t\tdata.displacementBias = this.displacementBias;\r\n\r\n\t\t}\r\n\t\tif ( this.roughnessMap instanceof THREE.Texture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;\r\n\t\tif ( this.metalnessMap instanceof THREE.Texture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;\r\n\r\n\t\tif ( this.emissiveMap instanceof THREE.Texture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;\r\n\t\tif ( this.specularMap instanceof THREE.Texture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;\r\n\r\n\t\tif ( this.envMap instanceof THREE.Texture ) {\r\n\r\n\t\t\tdata.envMap = this.envMap.toJSON( meta ).uuid;\r\n\t\t\tdata.reflectivity = this.reflectivity; // Scale behind envMap\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.size !== undefined ) data.size = this.size;\r\n\t\tif ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;\r\n\r\n\t\tif ( this.blending !== THREE.NormalBlending ) data.blending = this.blending;\r\n\t\tif ( this.shading !== THREE.SmoothShading ) data.shading = this.shading;\r\n\t\tif ( this.side !== THREE.FrontSide ) data.side = this.side;\r\n\t\tif ( this.vertexColors !== THREE.NoColors ) data.vertexColors = this.vertexColors;\r\n\r\n\t\tif ( this.opacity < 1 ) data.opacity = this.opacity;\r\n\t\tif ( this.transparent === true ) data.transparent = this.transparent;\r\n\t\tif ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;\r\n\t\tif ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;\r\n\t\tif ( this.wireframe === true ) data.wireframe = this.wireframe;\r\n\t\tif ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;\r\n\r\n\t\t// TODO: Copied from Object3D.toJSON\r\n\r\n\t\tfunction extractFromCache ( cache ) {\r\n\r\n\t\t\tvar values = [];\r\n\r\n\t\t\tfor ( var key in cache ) {\r\n\r\n\t\t\t\tvar data = cache[ key ];\r\n\t\t\t\tdelete data.metadata;\r\n\t\t\t\tvalues.push( data );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn values;\r\n\r\n\t\t}\r\n\r\n\t\tif ( isRoot ) {\r\n\r\n\t\t\tvar textures = extractFromCache( meta.textures );\r\n\t\t\tvar images = extractFromCache( meta.images );\r\n\r\n\t\t\tif ( textures.length > 0 ) data.textures = textures;\r\n\t\t\tif ( images.length > 0 ) data.images = images;\r\n\r\n\t\t}\r\n\r\n\t\treturn data;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.name = source.name;\r\n\r\n\t\tthis.fog = source.fog;\r\n\t\tthis.lights = source.lights;\r\n\r\n\t\tthis.blending = source.blending;\r\n\t\tthis.side = source.side;\r\n\t\tthis.vertexColors = source.vertexColors;\r\n\r\n\t\tthis.opacity = source.opacity;\r\n\t\tthis.transparent = source.transparent;\r\n\r\n\t\tthis.blendSrc = source.blendSrc;\r\n\t\tthis.blendDst = source.blendDst;\r\n\t\tthis.blendEquation = source.blendEquation;\r\n\t\tthis.blendSrcAlpha = source.blendSrcAlpha;\r\n\t\tthis.blendDstAlpha = source.blendDstAlpha;\r\n\t\tthis.blendEquationAlpha = source.blendEquationAlpha;\r\n\r\n\t\tthis.depthFunc = source.depthFunc;\r\n\t\tthis.depthTest = source.depthTest;\r\n\t\tthis.depthWrite = source.depthWrite;\r\n\r\n\t\tthis.colorWrite = source.colorWrite;\r\n\r\n\t\tthis.precision = source.precision;\r\n\r\n\t\tthis.polygonOffset = source.polygonOffset;\r\n\t\tthis.polygonOffsetFactor = source.polygonOffsetFactor;\r\n\t\tthis.polygonOffsetUnits = source.polygonOffsetUnits;\r\n\r\n\t\tthis.alphaTest = source.alphaTest;\r\n\r\n\t\tthis.premultipliedAlpha = source.premultipliedAlpha;\r\n\r\n\t\tthis.overdraw = source.overdraw;\r\n\r\n\t\tthis.visible = source.visible;\r\n\t\tthis.clipShadows = source.clipShadows;\r\n\r\n\t\tvar srcPlanes = source.clippingPlanes,\r\n\t\t\tdstPlanes = null;\r\n\r\n\t\tif ( srcPlanes !== null ) {\r\n\r\n\t\t\tvar n = srcPlanes.length;\r\n\t\t\tdstPlanes = new Array( n );\r\n\r\n\t\t\tfor ( var i = 0; i !== n; ++ i )\r\n\t\t\t\tdstPlanes[ i ] = srcPlanes[ i ].clone();\r\n\r\n\t\t}\r\n\r\n\t\tthis.clippingPlanes = dstPlanes;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tupdate: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'update' } );\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n};\r\n\r\nObject.assign( THREE.Material.prototype, THREE.EventDispatcher.prototype );\r\n\r\nTHREE.MaterialIdCount = 0;\r\n\r\n// File:src/materials/LineBasicMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  linewidth: <float>,\r\n *  linecap: \"round\",\r\n *  linejoin: \"round\"\r\n * }\r\n */\r\n\r\nTHREE.LineBasicMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'LineBasicMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\r\n\tthis.linewidth = 1;\r\n\tthis.linecap = 'round';\r\n\tthis.linejoin = 'round';\r\n\r\n\tthis.lights = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.LineBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.LineBasicMaterial.prototype.constructor = THREE.LineBasicMaterial;\r\n\r\nTHREE.LineBasicMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\r\n\tthis.linewidth = source.linewidth;\r\n\tthis.linecap = source.linecap;\r\n\tthis.linejoin = source.linejoin;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/materials/LineDashedMaterial.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  linewidth: <float>,\r\n *\r\n *  scale: <float>,\r\n *  dashSize: <float>,\r\n *  gapSize: <float>\r\n * }\r\n */\r\n\r\nTHREE.LineDashedMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'LineDashedMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\r\n\tthis.linewidth = 1;\r\n\r\n\tthis.scale = 1;\r\n\tthis.dashSize = 3;\r\n\tthis.gapSize = 1;\r\n\r\n\tthis.lights = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.LineDashedMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.LineDashedMaterial.prototype.constructor = THREE.LineDashedMaterial;\r\n\r\nTHREE.LineDashedMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\r\n\tthis.linewidth = source.linewidth;\r\n\r\n\tthis.scale = source.scale;\r\n\tthis.dashSize = source.dashSize;\r\n\tthis.gapSize = source.gapSize;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshBasicMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  aoMap: new THREE.Texture( <Image> ),\r\n *  aoMapIntensity: <float>\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  shading: THREE.SmoothShading,\r\n *  depthTest: <bool>,\r\n *  depthWrite: <bool>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshBasicMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'MeshBasicMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff ); // emissive\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.aoMap = null;\r\n\tthis.aoMapIntensity = 1.0;\r\n\r\n\tthis.specularMap = null;\r\n\r\n\tthis.alphaMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.combine = THREE.MultiplyOperation;\r\n\tthis.reflectivity = 1;\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\r\n\tthis.lights = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshBasicMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshBasicMaterial.prototype.constructor = THREE.MeshBasicMaterial;\r\n\r\nTHREE.MeshBasicMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\r\n\tthis.map = source.map;\r\n\r\n\tthis.aoMap = source.aoMap;\r\n\tthis.aoMapIntensity = source.aoMapIntensity;\r\n\r\n\tthis.specularMap = source.specularMap;\r\n\r\n\tthis.alphaMap = source.alphaMap;\r\n\r\n\tthis.envMap = source.envMap;\r\n\tthis.combine = source.combine;\r\n\tthis.reflectivity = source.reflectivity;\r\n\tthis.refractionRatio = source.refractionRatio;\r\n\r\n\tthis.wireframe = source.wireframe;\r\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\tthis.wireframeLinecap = source.wireframeLinecap;\r\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\r\n\r\n\tthis.skinning = source.skinning;\r\n\tthis.morphTargets = source.morphTargets;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshDepthMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author bhouston / https://clara.io\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n * parameters = {\r\n *\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  displacementMap: new THREE.Texture( <Image> ),\r\n *  displacementScale: <float>,\r\n *  displacementBias: <float>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>\r\n * }\r\n */\r\n\r\nTHREE.MeshDepthMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'MeshDepthMaterial';\r\n\r\n\tthis.depthPacking = THREE.BasicDepthPacking;\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.alphaMap = null;\r\n\r\n\tthis.displacementMap = null;\r\n\tthis.displacementScale = 1;\r\n\tthis.displacementBias = 0;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\r\n\tthis.fog = false;\r\n\tthis.lights = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshDepthMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshDepthMaterial.prototype.constructor = THREE.MeshDepthMaterial;\r\n\r\nTHREE.MeshDepthMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.depthPacking = source.depthPacking;\r\n\r\n\tthis.skinning = source.skinning;\r\n\tthis.morphTargets = source.morphTargets;\r\n\r\n\tthis.map = source.map;\r\n\r\n\tthis.alphaMap = source.alphaMap;\r\n\r\n\tthis.displacementMap = source.displacementMap;\r\n\tthis.displacementScale = source.displacementScale;\r\n\tthis.displacementBias = source.displacementBias;\r\n\r\n\tthis.wireframe = source.wireframe;\r\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshLambertMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *  lightMapIntensity: <float>\r\n *\r\n *  aoMap: new THREE.Texture( <Image> ),\r\n *  aoMapIntensity: <float>\r\n *\r\n *  emissive: <hex>,\r\n *  emissiveIntensity: <float>\r\n *  emissiveMap: new THREE.Texture( <Image> ),\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshLambertMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'MeshLambertMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.lightMap = null;\r\n\tthis.lightMapIntensity = 1.0;\r\n\r\n\tthis.aoMap = null;\r\n\tthis.aoMapIntensity = 1.0;\r\n\r\n\tthis.emissive = new THREE.Color( 0x000000 );\r\n\tthis.emissiveIntensity = 1.0;\r\n\tthis.emissiveMap = null;\r\n\r\n\tthis.specularMap = null;\r\n\r\n\tthis.alphaMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.combine = THREE.MultiplyOperation;\r\n\tthis.reflectivity = 1;\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\tthis.morphNormals = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshLambertMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshLambertMaterial.prototype.constructor = THREE.MeshLambertMaterial;\r\n\r\nTHREE.MeshLambertMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\r\n\tthis.map = source.map;\r\n\r\n\tthis.lightMap = source.lightMap;\r\n\tthis.lightMapIntensity = source.lightMapIntensity;\r\n\r\n\tthis.aoMap = source.aoMap;\r\n\tthis.aoMapIntensity = source.aoMapIntensity;\r\n\r\n\tthis.emissive.copy( source.emissive );\r\n\tthis.emissiveMap = source.emissiveMap;\r\n\tthis.emissiveIntensity = source.emissiveIntensity;\r\n\r\n\tthis.specularMap = source.specularMap;\r\n\r\n\tthis.alphaMap = source.alphaMap;\r\n\r\n\tthis.envMap = source.envMap;\r\n\tthis.combine = source.combine;\r\n\tthis.reflectivity = source.reflectivity;\r\n\tthis.refractionRatio = source.refractionRatio;\r\n\r\n\tthis.wireframe = source.wireframe;\r\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\tthis.wireframeLinecap = source.wireframeLinecap;\r\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\r\n\r\n\tthis.skinning = source.skinning;\r\n\tthis.morphTargets = source.morphTargets;\r\n\tthis.morphNormals = source.morphNormals;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshNormalMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n *\r\n * parameters = {\r\n *  opacity: <float>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>\r\n * }\r\n */\r\n\r\nTHREE.MeshNormalMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this, parameters );\r\n\r\n\tthis.type = 'MeshNormalMaterial';\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\r\n\tthis.fog = false;\r\n\tthis.lights = false;\r\n\tthis.morphTargets = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshNormalMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshNormalMaterial.prototype.constructor = THREE.MeshNormalMaterial;\r\n\r\nTHREE.MeshNormalMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.wireframe = source.wireframe;\r\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshPhongMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  specular: <hex>,\r\n *  shininess: <float>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *  lightMapIntensity: <float>\r\n *\r\n *  aoMap: new THREE.Texture( <Image> ),\r\n *  aoMapIntensity: <float>\r\n *\r\n *  emissive: <hex>,\r\n *  emissiveIntensity: <float>\r\n *  emissiveMap: new THREE.Texture( <Image> ),\r\n *\r\n *  bumpMap: new THREE.Texture( <Image> ),\r\n *  bumpScale: <float>,\r\n *\r\n *  normalMap: new THREE.Texture( <Image> ),\r\n *  normalScale: <Vector2>,\r\n *\r\n *  displacementMap: new THREE.Texture( <Image> ),\r\n *  displacementScale: <float>,\r\n *  displacementBias: <float>,\r\n *\r\n *  specularMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),\r\n *  combine: THREE.Multiply,\r\n *  reflectivity: <float>,\r\n *  refractionRatio: <float>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshPhongMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'MeshPhongMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\tthis.specular = new THREE.Color( 0x111111 );\r\n\tthis.shininess = 30;\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.lightMap = null;\r\n\tthis.lightMapIntensity = 1.0;\r\n\r\n\tthis.aoMap = null;\r\n\tthis.aoMapIntensity = 1.0;\r\n\r\n\tthis.emissive = new THREE.Color( 0x000000 );\r\n\tthis.emissiveIntensity = 1.0;\r\n\tthis.emissiveMap = null;\r\n\r\n\tthis.bumpMap = null;\r\n\tthis.bumpScale = 1;\r\n\r\n\tthis.normalMap = null;\r\n\tthis.normalScale = new THREE.Vector2( 1, 1 );\r\n\r\n\tthis.displacementMap = null;\r\n\tthis.displacementScale = 1;\r\n\tthis.displacementBias = 0;\r\n\r\n\tthis.specularMap = null;\r\n\r\n\tthis.alphaMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.combine = THREE.MultiplyOperation;\r\n\tthis.reflectivity = 1;\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\tthis.morphNormals = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshPhongMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshPhongMaterial.prototype.constructor = THREE.MeshPhongMaterial;\r\n\r\nTHREE.MeshPhongMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\tthis.specular.copy( source.specular );\r\n\tthis.shininess = source.shininess;\r\n\r\n\tthis.map = source.map;\r\n\r\n\tthis.lightMap = source.lightMap;\r\n\tthis.lightMapIntensity = source.lightMapIntensity;\r\n\r\n\tthis.aoMap = source.aoMap;\r\n\tthis.aoMapIntensity = source.aoMapIntensity;\r\n\r\n\tthis.emissive.copy( source.emissive );\r\n\tthis.emissiveMap = source.emissiveMap;\r\n\tthis.emissiveIntensity = source.emissiveIntensity;\r\n\r\n\tthis.bumpMap = source.bumpMap;\r\n\tthis.bumpScale = source.bumpScale;\r\n\r\n\tthis.normalMap = source.normalMap;\r\n\tthis.normalScale.copy( source.normalScale );\r\n\r\n\tthis.displacementMap = source.displacementMap;\r\n\tthis.displacementScale = source.displacementScale;\r\n\tthis.displacementBias = source.displacementBias;\r\n\r\n\tthis.specularMap = source.specularMap;\r\n\r\n\tthis.alphaMap = source.alphaMap;\r\n\r\n\tthis.envMap = source.envMap;\r\n\tthis.combine = source.combine;\r\n\tthis.reflectivity = source.reflectivity;\r\n\tthis.refractionRatio = source.refractionRatio;\r\n\r\n\tthis.wireframe = source.wireframe;\r\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\tthis.wireframeLinecap = source.wireframeLinecap;\r\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\r\n\r\n\tthis.skinning = source.skinning;\r\n\tthis.morphTargets = source.morphTargets;\r\n\tthis.morphNormals = source.morphNormals;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshStandardMaterial.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  roughness: <float>,\r\n *  metalness: <float>,\r\n *  opacity: <float>,\r\n *\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  lightMap: new THREE.Texture( <Image> ),\r\n *  lightMapIntensity: <float>\r\n *\r\n *  aoMap: new THREE.Texture( <Image> ),\r\n *  aoMapIntensity: <float>\r\n *\r\n *  emissive: <hex>,\r\n *  emissiveIntensity: <float>\r\n *  emissiveMap: new THREE.Texture( <Image> ),\r\n *\r\n *  bumpMap: new THREE.Texture( <Image> ),\r\n *  bumpScale: <float>,\r\n *\r\n *  normalMap: new THREE.Texture( <Image> ),\r\n *  normalScale: <Vector2>,\r\n *\r\n *  displacementMap: new THREE.Texture( <Image> ),\r\n *  displacementScale: <float>,\r\n *  displacementBias: <float>,\r\n *\r\n *  roughnessMap: new THREE.Texture( <Image> ),\r\n *\r\n *  metalnessMap: new THREE.Texture( <Image> ),\r\n *\r\n *  alphaMap: new THREE.Texture( <Image> ),\r\n *\r\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\r\n *  envMapIntensity: <float>\r\n *\r\n *  refractionRatio: <float>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>\r\n * }\r\n */\r\n\r\nTHREE.MeshStandardMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.defines = { 'STANDARD': '' };\r\n\r\n\tthis.type = 'MeshStandardMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff ); // diffuse\r\n\tthis.roughness = 0.5;\r\n\tthis.metalness = 0.5;\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.lightMap = null;\r\n\tthis.lightMapIntensity = 1.0;\r\n\r\n\tthis.aoMap = null;\r\n\tthis.aoMapIntensity = 1.0;\r\n\r\n\tthis.emissive = new THREE.Color( 0x000000 );\r\n\tthis.emissiveIntensity = 1.0;\r\n\tthis.emissiveMap = null;\r\n\r\n\tthis.bumpMap = null;\r\n\tthis.bumpScale = 1;\r\n\r\n\tthis.normalMap = null;\r\n\tthis.normalScale = new THREE.Vector2( 1, 1 );\r\n\r\n\tthis.displacementMap = null;\r\n\tthis.displacementScale = 1;\r\n\tthis.displacementBias = 0;\r\n\r\n\tthis.roughnessMap = null;\r\n\r\n\tthis.metalnessMap = null;\r\n\r\n\tthis.alphaMap = null;\r\n\r\n\tthis.envMap = null;\r\n\tthis.envMapIntensity = 1.0;\r\n\r\n\tthis.refractionRatio = 0.98;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\tthis.wireframeLinecap = 'round';\r\n\tthis.wireframeLinejoin = 'round';\r\n\r\n\tthis.skinning = false;\r\n\tthis.morphTargets = false;\r\n\tthis.morphNormals = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshStandardMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.MeshStandardMaterial.prototype.constructor = THREE.MeshStandardMaterial;\r\n\r\nTHREE.MeshStandardMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.defines = { 'STANDARD': '' };\r\n\r\n\tthis.color.copy( source.color );\r\n\tthis.roughness = source.roughness;\r\n\tthis.metalness = source.metalness;\r\n\r\n\tthis.map = source.map;\r\n\r\n\tthis.lightMap = source.lightMap;\r\n\tthis.lightMapIntensity = source.lightMapIntensity;\r\n\r\n\tthis.aoMap = source.aoMap;\r\n\tthis.aoMapIntensity = source.aoMapIntensity;\r\n\r\n\tthis.emissive.copy( source.emissive );\r\n\tthis.emissiveMap = source.emissiveMap;\r\n\tthis.emissiveIntensity = source.emissiveIntensity;\r\n\r\n\tthis.bumpMap = source.bumpMap;\r\n\tthis.bumpScale = source.bumpScale;\r\n\r\n\tthis.normalMap = source.normalMap;\r\n\tthis.normalScale.copy( source.normalScale );\r\n\r\n\tthis.displacementMap = source.displacementMap;\r\n\tthis.displacementScale = source.displacementScale;\r\n\tthis.displacementBias = source.displacementBias;\r\n\r\n\tthis.roughnessMap = source.roughnessMap;\r\n\r\n\tthis.metalnessMap = source.metalnessMap;\r\n\r\n\tthis.alphaMap = source.alphaMap;\r\n\r\n\tthis.envMap = source.envMap;\r\n\tthis.envMapIntensity = source.envMapIntensity;\r\n\r\n\tthis.refractionRatio = source.refractionRatio;\r\n\r\n\tthis.wireframe = source.wireframe;\r\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\tthis.wireframeLinecap = source.wireframeLinecap;\r\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\r\n\r\n\tthis.skinning = source.skinning;\r\n\tthis.morphTargets = source.morphTargets;\r\n\tthis.morphNormals = source.morphNormals;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/materials/MeshPhysicalMaterial.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n *\r\n * parameters = {\r\n *  reflectivity: <float>\r\n * }\r\n */\r\n\r\nTHREE.MeshPhysicalMaterial = function ( parameters ) {\r\n\r\n\tTHREE.MeshStandardMaterial.call( this );\r\n\r\n\tthis.defines = { 'PHYSICAL': '' };\r\n\r\n\tthis.type = 'MeshPhysicalMaterial';\r\n\r\n\tthis.reflectivity = 0.5; // maps to F0 = 0.04\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.MeshPhysicalMaterial.prototype = Object.create( THREE.MeshStandardMaterial.prototype );\r\nTHREE.MeshPhysicalMaterial.prototype.constructor = THREE.MeshPhysicalMaterial;\r\n\r\nTHREE.MeshPhysicalMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.MeshStandardMaterial.prototype.copy.call( this, source );\r\n\r\n\tthis.defines = { 'PHYSICAL': '' };\r\n\r\n\tthis.reflectivity = source.reflectivity;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/materials/MultiMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.MultiMaterial = function ( materials ) {\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.type = 'MultiMaterial';\r\n\r\n\tthis.materials = materials instanceof Array ? materials : [];\r\n\r\n\tthis.visible = true;\r\n\r\n};\r\n\r\nTHREE.MultiMaterial.prototype = {\r\n\r\n\tconstructor: THREE.MultiMaterial,\r\n\r\n\ttoJSON: function ( meta ) {\r\n\r\n\t\tvar output = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.2,\r\n\t\t\t\ttype: 'material',\r\n\t\t\t\tgenerator: 'MaterialExporter'\r\n\t\t\t},\r\n\t\t\tuuid: this.uuid,\r\n\t\t\ttype: this.type,\r\n\t\t\tmaterials: []\r\n\t\t};\r\n\r\n\t\tvar materials = this.materials;\r\n\r\n\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar material = materials[ i ].toJSON( meta );\r\n\t\t\tdelete material.metadata;\r\n\r\n\t\t\toutput.materials.push( material );\r\n\r\n\t\t}\r\n\r\n\t\toutput.visible = this.visible;\r\n\r\n\t\treturn output;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\tvar material = new this.constructor();\r\n\r\n\t\tfor ( var i = 0; i < this.materials.length; i ++ ) {\r\n\r\n\t\t\tmaterial.materials.push( this.materials[ i ].clone() );\r\n\r\n\t\t}\r\n\r\n\t\tmaterial.visible = this.visible;\r\n\r\n\t\treturn material;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/materials/PointsMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *  size: <float>,\r\n *  sizeAttenuation: <bool>\r\n * }\r\n */\r\n\r\nTHREE.PointsMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'PointsMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\r\n\tthis.map = null;\r\n\r\n\tthis.size = 1;\r\n\tthis.sizeAttenuation = true;\r\n\r\n\tthis.lights = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.PointsMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.PointsMaterial.prototype.constructor = THREE.PointsMaterial;\r\n\r\nTHREE.PointsMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\r\n\tthis.map = source.map;\r\n\r\n\tthis.size = source.size;\r\n\tthis.sizeAttenuation = source.sizeAttenuation;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/materials/ShaderMaterial.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  defines: { \"label\" : \"value\" },\r\n *  uniforms: { \"parameter1\": { type: \"1f\", value: 1.0 }, \"parameter2\": { type: \"1i\" value2: 2 } },\r\n *\r\n *  fragmentShader: <string>,\r\n *  vertexShader: <string>,\r\n *\r\n *  wireframe: <boolean>,\r\n *  wireframeLinewidth: <float>,\r\n *\r\n *  lights: <bool>,\r\n *\r\n *  skinning: <bool>,\r\n *  morphTargets: <bool>,\r\n *  morphNormals: <bool>\r\n * }\r\n */\r\n\r\nTHREE.ShaderMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'ShaderMaterial';\r\n\r\n\tthis.defines = {};\r\n\tthis.uniforms = {};\r\n\r\n\tthis.vertexShader = 'void main() {\\n\\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\n}';\r\n\tthis.fragmentShader = 'void main() {\\n\\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\n}';\r\n\r\n\tthis.linewidth = 1;\r\n\r\n\tthis.wireframe = false;\r\n\tthis.wireframeLinewidth = 1;\r\n\r\n\tthis.fog = false; // set to use scene fog\r\n\tthis.lights = false; // set to use scene lights\r\n\tthis.clipping = false; // set to use user-defined clipping planes\r\n\r\n\tthis.skinning = false; // set to use skinning attribute streams\r\n\tthis.morphTargets = false; // set to use morph targets\r\n\tthis.morphNormals = false; // set to use morph normals\r\n\r\n\tthis.extensions = {\r\n\t\tderivatives: false, // set to use derivatives\r\n\t\tfragDepth: false, // set to use fragment depth values\r\n\t\tdrawBuffers: false, // set to use draw buffers\r\n\t\tshaderTextureLOD: false // set to use shader texture LOD\r\n\t};\r\n\r\n\t// When rendered geometry doesn't include these attributes but the material does,\r\n\t// use these default values in WebGL. This avoids errors when buffer data is missing.\r\n\tthis.defaultAttributeValues = {\r\n\t\t'color': [ 1, 1, 1 ],\r\n\t\t'uv': [ 0, 0 ],\r\n\t\t'uv2': [ 0, 0 ]\r\n\t};\r\n\r\n\tthis.index0AttributeName = undefined;\r\n\r\n\tif ( parameters !== undefined ) {\r\n\r\n\t\tif ( parameters.attributes !== undefined ) {\r\n\r\n\t\t\tconsole.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );\r\n\r\n\t\t}\r\n\r\n\t\tthis.setValues( parameters );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.ShaderMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.ShaderMaterial.prototype.constructor = THREE.ShaderMaterial;\r\n\r\nTHREE.ShaderMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.fragmentShader = source.fragmentShader;\r\n\tthis.vertexShader = source.vertexShader;\r\n\r\n\tthis.uniforms = THREE.UniformsUtils.clone( source.uniforms );\r\n\r\n\tthis.defines = source.defines;\r\n\r\n\tthis.wireframe = source.wireframe;\r\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\r\n\r\n\tthis.lights = source.lights;\r\n\tthis.clipping = source.clipping;\r\n\r\n\tthis.skinning = source.skinning;\r\n\r\n\tthis.morphTargets = source.morphTargets;\r\n\tthis.morphNormals = source.morphNormals;\r\n\r\n\tthis.extensions = source.extensions;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\nTHREE.ShaderMaterial.prototype.toJSON = function ( meta ) {\r\n\r\n\tvar data = THREE.Material.prototype.toJSON.call( this, meta );\r\n\r\n\tdata.uniforms = this.uniforms;\r\n\tdata.vertexShader = this.vertexShader;\r\n\tdata.fragmentShader = this.fragmentShader;\r\n\r\n\treturn data;\r\n\r\n};\r\n\r\n// File:src/materials/RawShaderMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.RawShaderMaterial = function ( parameters ) {\r\n\r\n\tTHREE.ShaderMaterial.call( this, parameters );\r\n\r\n\tthis.type = 'RawShaderMaterial';\r\n\r\n};\r\n\r\nTHREE.RawShaderMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\r\nTHREE.RawShaderMaterial.prototype.constructor = THREE.RawShaderMaterial;\r\n\r\n// File:src/materials/SpriteMaterial.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * parameters = {\r\n *  color: <hex>,\r\n *  opacity: <float>,\r\n *  map: new THREE.Texture( <Image> ),\r\n *\r\n *\tuvOffset: new THREE.Vector2(),\r\n *\tuvScale: new THREE.Vector2()\r\n * }\r\n */\r\n\r\nTHREE.SpriteMaterial = function ( parameters ) {\r\n\r\n\tTHREE.Material.call( this );\r\n\r\n\tthis.type = 'SpriteMaterial';\r\n\r\n\tthis.color = new THREE.Color( 0xffffff );\r\n\tthis.map = null;\r\n\r\n\tthis.rotation = 0;\r\n\r\n\tthis.fog = false;\r\n\tthis.lights = false;\r\n\r\n\tthis.setValues( parameters );\r\n\r\n};\r\n\r\nTHREE.SpriteMaterial.prototype = Object.create( THREE.Material.prototype );\r\nTHREE.SpriteMaterial.prototype.constructor = THREE.SpriteMaterial;\r\n\r\nTHREE.SpriteMaterial.prototype.copy = function ( source ) {\r\n\r\n\tTHREE.Material.prototype.copy.call( this, source );\r\n\r\n\tthis.color.copy( source.color );\r\n\tthis.map = source.map;\r\n\r\n\tthis.rotation = source.rotation;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/materials/ShadowMaterial.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.ShadowMaterial = function () {\r\n\r\n\tTHREE.ShaderMaterial.call( this, {\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\t\t\tTHREE.UniformsLib[ \"lights\" ],\r\n\t\t\t{\r\n\t\t\t\topacity: { value: 1.0 }\r\n\t\t\t}\r\n\t\t] ),\r\n\t\tvertexShader: THREE.ShaderChunk[ 'shadow_vert' ],\r\n\t\tfragmentShader: THREE.ShaderChunk[ 'shadow_frag' ]\r\n\t} );\r\n\r\n\tthis.lights = true;\r\n\tthis.transparent = true;\r\n\r\n\tObject.defineProperties( this, {\r\n\t\topacity: {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function () {\r\n\t\t\t\treturn this.uniforms.opacity.value;\r\n\t\t\t},\r\n\t\t\tset: function ( value ) {\r\n\t\t\t\tthis.uniforms.opacity.value = value;\r\n\t\t\t}\r\n\t\t}\r\n\t} );\r\n\r\n};\r\n\r\nTHREE.ShadowMaterial.prototype = Object.create( THREE.ShaderMaterial.prototype );\r\nTHREE.ShadowMaterial.prototype.constructor = THREE.ShadowMaterial;\r\n\r\n// File:src/textures/Texture.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author szimek / https://github.com/szimek/\r\n */\r\n\r\nTHREE.Texture = function ( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\r\n\r\n\tObject.defineProperty( this, 'id', { value: THREE.TextureIdCount ++ } );\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.name = '';\r\n\tthis.sourceFile = '';\r\n\r\n\tthis.image = image !== undefined ? image : THREE.Texture.DEFAULT_IMAGE;\r\n\tthis.mipmaps = [];\r\n\r\n\tthis.mapping = mapping !== undefined ? mapping : THREE.Texture.DEFAULT_MAPPING;\r\n\r\n\tthis.wrapS = wrapS !== undefined ? wrapS : THREE.ClampToEdgeWrapping;\r\n\tthis.wrapT = wrapT !== undefined ? wrapT : THREE.ClampToEdgeWrapping;\r\n\r\n\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.LinearFilter;\r\n\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.LinearMipMapLinearFilter;\r\n\r\n\tthis.anisotropy = anisotropy !== undefined ? anisotropy : 1;\r\n\r\n\tthis.format = format !== undefined ? format : THREE.RGBAFormat;\r\n\tthis.type = type !== undefined ? type : THREE.UnsignedByteType;\r\n\r\n\tthis.offset = new THREE.Vector2( 0, 0 );\r\n\tthis.repeat = new THREE.Vector2( 1, 1 );\r\n\r\n\tthis.generateMipmaps = true;\r\n\tthis.premultiplyAlpha = false;\r\n\tthis.flipY = true;\r\n\tthis.unpackAlignment = 4;\t// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)\r\n\r\n\r\n\t// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.\r\n\t//\r\n\t// Also changing the encoding after already used by a Material will not automatically make the Material\r\n\t// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.\r\n\tthis.encoding = encoding !== undefined ? encoding :  THREE.LinearEncoding;\r\n\r\n\tthis.version = 0;\r\n\tthis.onUpdate = null;\r\n\r\n};\r\n\r\nTHREE.Texture.DEFAULT_IMAGE = undefined;\r\nTHREE.Texture.DEFAULT_MAPPING = THREE.UVMapping;\r\n\r\nTHREE.Texture.prototype = {\r\n\r\n\tconstructor: THREE.Texture,\r\n\r\n\tset needsUpdate( value ) {\r\n\r\n\t\tif ( value === true ) this.version ++;\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.image = source.image;\r\n\t\tthis.mipmaps = source.mipmaps.slice( 0 );\r\n\r\n\t\tthis.mapping = source.mapping;\r\n\r\n\t\tthis.wrapS = source.wrapS;\r\n\t\tthis.wrapT = source.wrapT;\r\n\r\n\t\tthis.magFilter = source.magFilter;\r\n\t\tthis.minFilter = source.minFilter;\r\n\r\n\t\tthis.anisotropy = source.anisotropy;\r\n\r\n\t\tthis.format = source.format;\r\n\t\tthis.type = source.type;\r\n\r\n\t\tthis.offset.copy( source.offset );\r\n\t\tthis.repeat.copy( source.repeat );\r\n\r\n\t\tthis.generateMipmaps = source.generateMipmaps;\r\n\t\tthis.premultiplyAlpha = source.premultiplyAlpha;\r\n\t\tthis.flipY = source.flipY;\r\n\t\tthis.unpackAlignment = source.unpackAlignment;\r\n\t\tthis.encoding = source.encoding;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\ttoJSON: function ( meta ) {\r\n\r\n\t\tif ( meta.textures[ this.uuid ] !== undefined ) {\r\n\r\n\t\t\treturn meta.textures[ this.uuid ];\r\n\r\n\t\t}\r\n\r\n\t\tfunction getDataURL( image ) {\r\n\r\n\t\t\tvar canvas;\r\n\r\n\t\t\tif ( image.toDataURL !== undefined ) {\r\n\r\n\t\t\t\tcanvas = image;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tcanvas = document.createElement( 'canvas' );\r\n\t\t\t\tcanvas.width = image.width;\r\n\t\t\t\tcanvas.height = image.height;\r\n\r\n\t\t\t\tcanvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( canvas.width > 2048 || canvas.height > 2048 ) {\r\n\r\n\t\t\t\treturn canvas.toDataURL( 'image/jpeg', 0.6 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\treturn canvas.toDataURL( 'image/png' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar output = {\r\n\t\t\tmetadata: {\r\n\t\t\t\tversion: 4.4,\r\n\t\t\t\ttype: 'Texture',\r\n\t\t\t\tgenerator: 'Texture.toJSON'\r\n\t\t\t},\r\n\r\n\t\t\tuuid: this.uuid,\r\n\t\t\tname: this.name,\r\n\r\n\t\t\tmapping: this.mapping,\r\n\r\n\t\t\trepeat: [ this.repeat.x, this.repeat.y ],\r\n\t\t\toffset: [ this.offset.x, this.offset.y ],\r\n\t\t\twrap: [ this.wrapS, this.wrapT ],\r\n\r\n\t\t\tminFilter: this.minFilter,\r\n\t\t\tmagFilter: this.magFilter,\r\n\t\t\tanisotropy: this.anisotropy\r\n\t\t};\r\n\r\n\t\tif ( this.image !== undefined ) {\r\n\r\n\t\t\t// TODO: Move to THREE.Image\r\n\r\n\t\t\tvar image = this.image;\r\n\r\n\t\t\tif ( image.uuid === undefined ) {\r\n\r\n\t\t\t\timage.uuid = THREE.Math.generateUUID(); // UGH\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( meta.images[ image.uuid ] === undefined ) {\r\n\r\n\t\t\t\tmeta.images[ image.uuid ] = {\r\n\t\t\t\t\tuuid: image.uuid,\r\n\t\t\t\t\turl: getDataURL( image )\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t\toutput.image = image.uuid;\r\n\r\n\t\t}\r\n\r\n\t\tmeta.textures[ this.uuid ] = output;\r\n\r\n\t\treturn output;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t},\r\n\r\n\ttransformUv: function ( uv ) {\r\n\r\n\t\tif ( this.mapping !== THREE.UVMapping )  return;\r\n\r\n\t\tuv.multiply( this.repeat );\r\n\t\tuv.add( this.offset );\r\n\r\n\t\tif ( uv.x < 0 || uv.x > 1 ) {\r\n\r\n\t\t\tswitch ( this.wrapS ) {\r\n\r\n\t\t\t\tcase THREE.RepeatWrapping:\r\n\r\n\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.ClampToEdgeWrapping:\r\n\r\n\t\t\t\t\tuv.x = uv.x < 0 ? 0 : 1;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.MirroredRepeatWrapping:\r\n\r\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {\r\n\r\n\t\t\t\t\t\tuv.x = Math.ceil( uv.x ) - uv.x;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tuv.x = uv.x - Math.floor( uv.x );\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( uv.y < 0 || uv.y > 1 ) {\r\n\r\n\t\t\tswitch ( this.wrapT ) {\r\n\r\n\t\t\t\tcase THREE.RepeatWrapping:\r\n\r\n\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.ClampToEdgeWrapping:\r\n\r\n\t\t\t\t\tuv.y = uv.y < 0 ? 0 : 1;\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.MirroredRepeatWrapping:\r\n\r\n\t\t\t\t\tif ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {\r\n\r\n\t\t\t\t\t\tuv.y = Math.ceil( uv.y ) - uv.y;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tuv.y = uv.y - Math.floor( uv.y );\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.flipY ) {\r\n\r\n\t\t\tuv.y = 1 - uv.y;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nObject.assign( THREE.Texture.prototype, THREE.EventDispatcher.prototype );\r\n\r\nTHREE.TextureIdCount = 0;\r\n\r\n// File:src/textures/DepthTexture.js\r\n\r\n/**\r\n * @author Matt DesLauriers / @mattdesl\r\n */\r\n\r\nTHREE.DepthTexture = function ( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy ) {\r\n\r\n  THREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, THREE.DepthFormat, type, anisotropy );\r\n\r\n  this.image = { width: width, height: height };\r\n\r\n  this.type = type !== undefined ? type : THREE.UnsignedShortType;\r\n\r\n  this.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;\r\n  this.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;\r\n\r\n  this.flipY = false;\r\n  this.generateMipmaps  = false;\r\n\r\n};\r\n\r\nTHREE.DepthTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.DepthTexture.prototype.constructor = THREE.DepthTexture;\r\n\r\n// File:src/textures/CanvasTexture.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CanvasTexture = function ( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\r\n\tTHREE.Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n\tthis.needsUpdate = true;\r\n\r\n};\r\n\r\nTHREE.CanvasTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.CanvasTexture.prototype.constructor = THREE.CanvasTexture;\r\n\r\n// File:src/textures/CubeTexture.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CubeTexture = function ( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {\r\n\r\n\timages = images !== undefined ? images : [];\r\n\tmapping = mapping !== undefined ? mapping : THREE.CubeReflectionMapping;\r\n\r\n\tTHREE.Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\r\n\r\n\tthis.flipY = false;\r\n\r\n};\r\n\r\nTHREE.CubeTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.CubeTexture.prototype.constructor = THREE.CubeTexture;\r\n\r\nObject.defineProperty( THREE.CubeTexture.prototype, 'images', {\r\n\r\n\tget: function () {\r\n\r\n\t\treturn this.image;\r\n\r\n\t},\r\n\r\n\tset: function ( value ) {\r\n\r\n\t\tthis.image = value;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/textures/CompressedTexture.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.CompressedTexture = function ( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\r\n\r\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\r\n\r\n\tthis.image = { width: width, height: height };\r\n\tthis.mipmaps = mipmaps;\r\n\r\n\t// no flipping for cube textures\r\n\t// (also flipping doesn't work for compressed textures )\r\n\r\n\tthis.flipY = false;\r\n\r\n\t// can't generate mipmaps for compressed textures\r\n\t// mips must be embedded in DDS files\r\n\r\n\tthis.generateMipmaps = false;\r\n\r\n};\r\n\r\nTHREE.CompressedTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.CompressedTexture.prototype.constructor = THREE.CompressedTexture;\r\n\r\n// File:src/textures/DataTexture.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.DataTexture = function ( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {\r\n\r\n\tTHREE.Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );\r\n\r\n\tthis.image = { data: data, width: width, height: height };\r\n\r\n\tthis.magFilter = magFilter !== undefined ? magFilter : THREE.NearestFilter;\r\n\tthis.minFilter = minFilter !== undefined ? minFilter : THREE.NearestFilter;\r\n\r\n\tthis.flipY = false;\r\n\tthis.generateMipmaps  = false;\r\n\r\n};\r\n\r\nTHREE.DataTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.DataTexture.prototype.constructor = THREE.DataTexture;\r\n\r\n// File:src/textures/VideoTexture.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.VideoTexture = function ( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\r\n\r\n\tTHREE.Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\r\n\r\n\tthis.generateMipmaps = false;\r\n\r\n\tvar scope = this;\r\n\r\n\tfunction update() {\r\n\r\n\t\trequestAnimationFrame( update );\r\n\r\n\t\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\r\n\r\n\t\t\tscope.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tupdate();\r\n\r\n};\r\n\r\nTHREE.VideoTexture.prototype = Object.create( THREE.Texture.prototype );\r\nTHREE.VideoTexture.prototype.constructor = THREE.VideoTexture;\r\n\r\n// File:src/objects/Group.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Group = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Group';\r\n\r\n};\r\n\r\nTHREE.Group.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\r\n\r\n\tconstructor: THREE.Group\r\n\r\n} );\r\n\r\n// File:src/objects/Points.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Points = function ( geometry, material ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Points';\r\n\r\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();\r\n\tthis.material = material !== undefined ? material : new THREE.PointsMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n};\r\n\r\nTHREE.Points.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\r\n\r\n\tconstructor: THREE.Points,\r\n\r\n\traycast: ( function () {\r\n\r\n\t\tvar inverseMatrix = new THREE.Matrix4();\r\n\t\tvar ray = new THREE.Ray();\r\n\t\tvar sphere = new THREE.Sphere();\r\n\r\n\t\treturn function raycast( raycaster, intersects ) {\r\n\r\n\t\t\tvar object = this;\r\n\t\t\tvar geometry = this.geometry;\r\n\t\t\tvar matrixWorld = this.matrixWorld;\r\n\t\t\tvar threshold = raycaster.params.Points.threshold;\r\n\r\n\t\t\t// Checking boundingSphere distance to ray\r\n\r\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n\t\t\tsphere.copy( geometry.boundingSphere );\r\n\t\t\tsphere.applyMatrix4( matrixWorld );\r\n\r\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\r\n\r\n\t\t\t//\r\n\r\n\t\t\tinverseMatrix.getInverse( matrixWorld );\r\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n\t\t\tvar localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );\r\n\t\t\tvar localThresholdSq = localThreshold * localThreshold;\r\n\t\t\tvar position = new THREE.Vector3();\r\n\r\n\t\t\tfunction testPoint( point, index ) {\r\n\r\n\t\t\t\tvar rayPointDistanceSq = ray.distanceSqToPoint( point );\r\n\r\n\t\t\t\tif ( rayPointDistanceSq < localThresholdSq ) {\r\n\r\n\t\t\t\t\tvar intersectPoint = ray.closestPointToPoint( point );\r\n\t\t\t\t\tintersectPoint.applyMatrix4( matrixWorld );\r\n\r\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectPoint );\r\n\r\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return;\r\n\r\n\t\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\tdistanceToRay: Math.sqrt( rayPointDistanceSq ),\r\n\t\t\t\t\t\tpoint: intersectPoint.clone(),\r\n\t\t\t\t\t\tindex: index,\r\n\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\tobject: object\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\tvar index = geometry.index;\r\n\t\t\t\tvar attributes = geometry.attributes;\r\n\t\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\t\tif ( index !== null ) {\r\n\r\n\t\t\t\t\tvar indices = index.array;\r\n\r\n\t\t\t\t\tfor ( var i = 0, il = indices.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\t\tvar a = indices[ i ];\r\n\r\n\t\t\t\t\t\tposition.fromArray( positions, a * 3 );\r\n\r\n\t\t\t\t\t\ttestPoint( position, a );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tfor ( var i = 0, l = positions.length / 3; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\tposition.fromArray( positions, i * 3 );\r\n\r\n\t\t\t\t\t\ttestPoint( position, i );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvar vertices = geometry.vertices;\r\n\r\n\t\t\t\tfor ( var i = 0, l = vertices.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\ttestPoint( vertices[ i ], i );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}() ),\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/objects/Line.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Line = function ( geometry, material, mode ) {\r\n\r\n\tif ( mode === 1 ) {\r\n\r\n\t\tconsole.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );\r\n\t\treturn new THREE.LineSegments( geometry, material );\r\n\r\n\t}\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Line';\r\n\r\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();\r\n\tthis.material = material !== undefined ? material : new THREE.LineBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n};\r\n\r\nTHREE.Line.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\r\n\r\n\tconstructor: THREE.Line,\r\n\r\n\traycast: ( function () {\r\n\r\n\t\tvar inverseMatrix = new THREE.Matrix4();\r\n\t\tvar ray = new THREE.Ray();\r\n\t\tvar sphere = new THREE.Sphere();\r\n\r\n\t\treturn function raycast( raycaster, intersects ) {\r\n\r\n\t\t\tvar precision = raycaster.linePrecision;\r\n\t\t\tvar precisionSq = precision * precision;\r\n\r\n\t\t\tvar geometry = this.geometry;\r\n\t\t\tvar matrixWorld = this.matrixWorld;\r\n\r\n\t\t\t// Checking boundingSphere distance to ray\r\n\r\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n\t\t\tsphere.copy( geometry.boundingSphere );\r\n\t\t\tsphere.applyMatrix4( matrixWorld );\r\n\r\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\r\n\r\n\t\t\t//\r\n\r\n\t\t\tinverseMatrix.getInverse( matrixWorld );\r\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n\t\t\tvar vStart = new THREE.Vector3();\r\n\t\t\tvar vEnd = new THREE.Vector3();\r\n\t\t\tvar interSegment = new THREE.Vector3();\r\n\t\t\tvar interRay = new THREE.Vector3();\r\n\t\t\tvar step = this instanceof THREE.LineSegments ? 2 : 1;\r\n\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\tvar index = geometry.index;\r\n\t\t\t\tvar attributes = geometry.attributes;\r\n\t\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\t\tif ( index !== null ) {\r\n\r\n\t\t\t\t\tvar indices = index.array;\r\n\r\n\t\t\t\t\tfor ( var i = 0, l = indices.length - 1; i < l; i += step ) {\r\n\r\n\t\t\t\t\t\tvar a = indices[ i ];\r\n\t\t\t\t\t\tvar b = indices[ i + 1 ];\r\n\r\n\t\t\t\t\t\tvStart.fromArray( positions, a * 3 );\r\n\t\t\t\t\t\tvEnd.fromArray( positions, b * 3 );\r\n\r\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\r\n\r\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\r\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\r\n\r\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\r\n\r\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n\t\t\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\t\tobject: this\r\n\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tfor ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {\r\n\r\n\t\t\t\t\t\tvStart.fromArray( positions, 3 * i );\r\n\t\t\t\t\t\tvEnd.fromArray( positions, 3 * i + 3 );\r\n\r\n\t\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );\r\n\r\n\t\t\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\r\n\t\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\r\n\r\n\t\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\r\n\r\n\t\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n\t\t\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\t\tobject: this\r\n\r\n\t\t\t\t\t\t} );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\t\tvar vertices = geometry.vertices;\r\n\t\t\t\tvar nbVertices = vertices.length;\r\n\r\n\t\t\t\tfor ( var i = 0; i < nbVertices - 1; i += step ) {\r\n\r\n\t\t\t\t\tvar distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );\r\n\r\n\t\t\t\t\tif ( distSq > precisionSq ) continue;\r\n\r\n\t\t\t\t\tinterRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation\r\n\r\n\t\t\t\t\tvar distance = raycaster.ray.origin.distanceTo( interRay );\r\n\r\n\t\t\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) continue;\r\n\r\n\t\t\t\t\tintersects.push( {\r\n\r\n\t\t\t\t\t\tdistance: distance,\r\n\t\t\t\t\t\t// What do we want? intersection point on the ray or on the segment??\r\n\t\t\t\t\t\t// point: raycaster.ray.at( distance ),\r\n\t\t\t\t\t\tpoint: interSegment.clone().applyMatrix4( this.matrixWorld ),\r\n\t\t\t\t\t\tindex: i,\r\n\t\t\t\t\t\tface: null,\r\n\t\t\t\t\t\tfaceIndex: null,\r\n\t\t\t\t\t\tobject: this\r\n\r\n\t\t\t\t\t} );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}() ),\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/objects/LineSegments.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LineSegments = function ( geometry, material ) {\r\n\r\n\tTHREE.Line.call( this, geometry, material );\r\n\r\n\tthis.type = 'LineSegments';\r\n\r\n};\r\n\r\nTHREE.LineSegments.prototype = Object.assign( Object.create( THREE.Line.prototype ), {\r\n\r\n\tconstructor: THREE.LineSegments\r\n\r\n} );\r\n\r\n// File:src/objects/Mesh.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author jonobr1 / http://jonobr1.com/\r\n */\r\n\r\nTHREE.Mesh = function ( geometry, material ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Mesh';\r\n\r\n\tthis.geometry = geometry !== undefined ? geometry : new THREE.BufferGeometry();\r\n\tthis.material = material !== undefined ? material : new THREE.MeshBasicMaterial( { color: Math.random() * 0xffffff } );\r\n\r\n\tthis.drawMode = THREE.TrianglesDrawMode;\r\n\r\n\tthis.updateMorphTargets();\r\n\r\n};\r\n\r\nTHREE.Mesh.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\r\n\r\n\tconstructor: THREE.Mesh,\r\n\r\n\tsetDrawMode: function ( value ) {\r\n\r\n\t\tthis.drawMode = value;\r\n\r\n\t},\r\n\r\n\tupdateMorphTargets: function () {\r\n\r\n\t\tif ( this.geometry.morphTargets !== undefined && this.geometry.morphTargets.length > 0 ) {\r\n\r\n\t\t\tthis.morphTargetBase = - 1;\r\n\t\t\tthis.morphTargetInfluences = [];\r\n\t\t\tthis.morphTargetDictionary = {};\r\n\r\n\t\t\tfor ( var m = 0, ml = this.geometry.morphTargets.length; m < ml; m ++ ) {\r\n\r\n\t\t\t\tthis.morphTargetInfluences.push( 0 );\r\n\t\t\t\tthis.morphTargetDictionary[ this.geometry.morphTargets[ m ].name ] = m;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tgetMorphTargetIndexByName: function ( name ) {\r\n\r\n\t\tif ( this.morphTargetDictionary[ name ] !== undefined ) {\r\n\r\n\t\t\treturn this.morphTargetDictionary[ name ];\r\n\r\n\t\t}\r\n\r\n\t\tconsole.warn( 'THREE.Mesh.getMorphTargetIndexByName: morph target ' + name + ' does not exist. Returning 0.' );\r\n\r\n\t\treturn 0;\r\n\r\n\t},\r\n\r\n\traycast: ( function () {\r\n\r\n\t\tvar inverseMatrix = new THREE.Matrix4();\r\n\t\tvar ray = new THREE.Ray();\r\n\t\tvar sphere = new THREE.Sphere();\r\n\r\n\t\tvar vA = new THREE.Vector3();\r\n\t\tvar vB = new THREE.Vector3();\r\n\t\tvar vC = new THREE.Vector3();\r\n\r\n\t\tvar tempA = new THREE.Vector3();\r\n\t\tvar tempB = new THREE.Vector3();\r\n\t\tvar tempC = new THREE.Vector3();\r\n\r\n\t\tvar uvA = new THREE.Vector2();\r\n\t\tvar uvB = new THREE.Vector2();\r\n\t\tvar uvC = new THREE.Vector2();\r\n\r\n\t\tvar barycoord = new THREE.Vector3();\r\n\r\n\t\tvar intersectionPoint = new THREE.Vector3();\r\n\t\tvar intersectionPointWorld = new THREE.Vector3();\r\n\r\n\t\tfunction uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {\r\n\r\n\t\t\tTHREE.Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );\r\n\r\n\t\t\tuv1.multiplyScalar( barycoord.x );\r\n\t\t\tuv2.multiplyScalar( barycoord.y );\r\n\t\t\tuv3.multiplyScalar( barycoord.z );\r\n\r\n\t\t\tuv1.add( uv2 ).add( uv3 );\r\n\r\n\t\t\treturn uv1.clone();\r\n\r\n\t\t}\r\n\r\n\t\tfunction checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {\r\n\r\n\t\t\tvar intersect;\r\n\t\t\tvar material = object.material;\r\n\r\n\t\t\tif ( material.side === THREE.BackSide ) {\r\n\r\n\t\t\t\tintersect = ray.intersectTriangle( pC, pB, pA, true, point );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tintersect = ray.intersectTriangle( pA, pB, pC, material.side !== THREE.DoubleSide, point );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( intersect === null ) return null;\r\n\r\n\t\t\tintersectionPointWorld.copy( point );\r\n\t\t\tintersectionPointWorld.applyMatrix4( object.matrixWorld );\r\n\r\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );\r\n\r\n\t\t\tif ( distance < raycaster.near || distance > raycaster.far ) return null;\r\n\r\n\t\t\treturn {\r\n\t\t\t\tdistance: distance,\r\n\t\t\t\tpoint: intersectionPointWorld.clone(),\r\n\t\t\t\tobject: object\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\tfunction checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {\r\n\r\n\t\t\tvA.fromArray( positions, a * 3 );\r\n\t\t\tvB.fromArray( positions, b * 3 );\r\n\t\t\tvC.fromArray( positions, c * 3 );\r\n\r\n\t\t\tvar intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );\r\n\r\n\t\t\tif ( intersection ) {\r\n\r\n\t\t\t\tif ( uvs ) {\r\n\r\n\t\t\t\t\tuvA.fromArray( uvs, a * 2 );\r\n\t\t\t\t\tuvB.fromArray( uvs, b * 2 );\r\n\t\t\t\t\tuvC.fromArray( uvs, c * 2 );\r\n\r\n\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tintersection.face = new THREE.Face3( a, b, c, THREE.Triangle.normal( vA, vB, vC ) );\r\n\t\t\t\tintersection.faceIndex = a;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn intersection;\r\n\r\n\t\t}\r\n\r\n\t\treturn function raycast( raycaster, intersects ) {\r\n\r\n\t\t\tvar geometry = this.geometry;\r\n\t\t\tvar material = this.material;\r\n\t\t\tvar matrixWorld = this.matrixWorld;\r\n\r\n\t\t\tif ( material === undefined ) return;\r\n\r\n\t\t\t// Checking boundingSphere distance to ray\r\n\r\n\t\t\tif ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();\r\n\r\n\t\t\tsphere.copy( geometry.boundingSphere );\r\n\t\t\tsphere.applyMatrix4( matrixWorld );\r\n\r\n\t\t\tif ( raycaster.ray.intersectsSphere( sphere ) === false ) return;\r\n\r\n\t\t\t//\r\n\r\n\t\t\tinverseMatrix.getInverse( matrixWorld );\r\n\t\t\tray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );\r\n\r\n\t\t\t// Check boundingBox before continuing\r\n\r\n\t\t\tif ( geometry.boundingBox !== null ) {\r\n\r\n\t\t\t\tif ( ray.intersectsBox( geometry.boundingBox ) === false ) return;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar uvs, intersection;\r\n\r\n\t\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\t\tvar a, b, c;\r\n\t\t\t\tvar index = geometry.index;\r\n\t\t\t\tvar attributes = geometry.attributes;\r\n\t\t\t\tvar positions = attributes.position.array;\r\n\r\n\t\t\t\tif ( attributes.uv !== undefined ) {\r\n\r\n\t\t\t\t\tuvs = attributes.uv.array;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( index !== null ) {\r\n\r\n\t\t\t\t\tvar indices = index.array;\r\n\r\n\t\t\t\t\tfor ( var i = 0, l = indices.length; i < l; i += 3 ) {\r\n\r\n\t\t\t\t\t\ta = indices[ i ];\r\n\t\t\t\t\t\tb = indices[ i + 1 ];\r\n\t\t\t\t\t\tc = indices[ i + 2 ];\r\n\r\n\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\r\n\r\n\t\t\t\t\t\tif ( intersection ) {\r\n\r\n\t\t\t\t\t\t\tintersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics\r\n\t\t\t\t\t\t\tintersects.push( intersection );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\r\n\t\t\t\t\tfor ( var i = 0, l = positions.length; i < l; i += 9 ) {\r\n\r\n\t\t\t\t\t\ta = i / 3;\r\n\t\t\t\t\t\tb = a + 1;\r\n\t\t\t\t\t\tc = a + 2;\r\n\r\n\t\t\t\t\t\tintersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );\r\n\r\n\t\t\t\t\t\tif ( intersection ) {\r\n\r\n\t\t\t\t\t\t\tintersection.index = a; // triangle number in positions buffer semantics\r\n\t\t\t\t\t\t\tintersects.push( intersection );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\t\tvar fvA, fvB, fvC;\r\n\t\t\t\tvar isFaceMaterial = material instanceof THREE.MultiMaterial;\r\n\t\t\t\tvar materials = isFaceMaterial === true ? material.materials : null;\r\n\r\n\t\t\t\tvar vertices = geometry.vertices;\r\n\t\t\t\tvar faces = geometry.faces;\r\n\t\t\t\tvar faceVertexUvs = geometry.faceVertexUvs[ 0 ];\r\n\t\t\t\tif ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;\r\n\r\n\t\t\t\tfor ( var f = 0, fl = faces.length; f < fl; f ++ ) {\r\n\r\n\t\t\t\t\tvar face = faces[ f ];\r\n\t\t\t\t\tvar faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;\r\n\r\n\t\t\t\t\tif ( faceMaterial === undefined ) continue;\r\n\r\n\t\t\t\t\tfvA = vertices[ face.a ];\r\n\t\t\t\t\tfvB = vertices[ face.b ];\r\n\t\t\t\t\tfvC = vertices[ face.c ];\r\n\r\n\t\t\t\t\tif ( faceMaterial.morphTargets === true ) {\r\n\r\n\t\t\t\t\t\tvar morphTargets = geometry.morphTargets;\r\n\t\t\t\t\t\tvar morphInfluences = this.morphTargetInfluences;\r\n\r\n\t\t\t\t\t\tvA.set( 0, 0, 0 );\r\n\t\t\t\t\t\tvB.set( 0, 0, 0 );\r\n\t\t\t\t\t\tvC.set( 0, 0, 0 );\r\n\r\n\t\t\t\t\t\tfor ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar influence = morphInfluences[ t ];\r\n\r\n\t\t\t\t\t\t\tif ( influence === 0 ) continue;\r\n\r\n\t\t\t\t\t\t\tvar targets = morphTargets[ t ].vertices;\r\n\r\n\t\t\t\t\t\t\tvA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );\r\n\t\t\t\t\t\t\tvB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );\r\n\t\t\t\t\t\t\tvC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvA.add( fvA );\r\n\t\t\t\t\t\tvB.add( fvB );\r\n\t\t\t\t\t\tvC.add( fvC );\r\n\r\n\t\t\t\t\t\tfvA = vA;\r\n\t\t\t\t\t\tfvB = vB;\r\n\t\t\t\t\t\tfvC = vC;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tintersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );\r\n\r\n\t\t\t\t\tif ( intersection ) {\r\n\r\n\t\t\t\t\t\tif ( uvs ) {\r\n\r\n\t\t\t\t\t\t\tvar uvs_f = uvs[ f ];\r\n\t\t\t\t\t\t\tuvA.copy( uvs_f[ 0 ] );\r\n\t\t\t\t\t\t\tuvB.copy( uvs_f[ 1 ] );\r\n\t\t\t\t\t\t\tuvC.copy( uvs_f[ 2 ] );\r\n\r\n\t\t\t\t\t\t\tintersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tintersection.face = face;\r\n\t\t\t\t\t\tintersection.faceIndex = f;\r\n\t\t\t\t\t\tintersects.push( intersection );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}() ),\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.geometry, this.material ).copy( this );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/objects/Bone.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.Bone = function ( skin ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Bone';\r\n\r\n\tthis.skin = skin;\r\n\r\n};\r\n\r\nTHREE.Bone.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\r\n\r\n\tconstructor: THREE.Bone,\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\r\n\r\n\t\tthis.skin = source.skin;\r\n\r\n\t\treturn this;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/objects/Skeleton.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author michael guerrero / http://realitymeltdown.com\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.Skeleton = function ( bones, boneInverses, useVertexTexture ) {\r\n\r\n\tthis.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;\r\n\r\n\tthis.identityMatrix = new THREE.Matrix4();\r\n\r\n\t// copy the bone array\r\n\r\n\tbones = bones || [];\r\n\r\n\tthis.bones = bones.slice( 0 );\r\n\r\n\t// create a bone texture or an array of floats\r\n\r\n\tif ( this.useVertexTexture ) {\r\n\r\n\t\t// layout (1 matrix = 4 pixels)\r\n\t\t//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)\r\n\t\t//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)\r\n\t\t//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)\r\n\t\t//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)\r\n\t\t//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)\r\n\r\n\r\n\t\tvar size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix\r\n\t\tsize = THREE.Math.nextPowerOfTwo( Math.ceil( size ) );\r\n\t\tsize = Math.max( size, 4 );\r\n\r\n\t\tthis.boneTextureWidth = size;\r\n\t\tthis.boneTextureHeight = size;\r\n\r\n\t\tthis.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel\r\n\t\tthis.boneTexture = new THREE.DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, THREE.RGBAFormat, THREE.FloatType );\r\n\r\n\t} else {\r\n\r\n\t\tthis.boneMatrices = new Float32Array( 16 * this.bones.length );\r\n\r\n\t}\r\n\r\n\t// use the supplied bone inverses or calculate the inverses\r\n\r\n\tif ( boneInverses === undefined ) {\r\n\r\n\t\tthis.calculateInverses();\r\n\r\n\t} else {\r\n\r\n\t\tif ( this.bones.length === boneInverses.length ) {\r\n\r\n\t\t\tthis.boneInverses = boneInverses.slice( 0 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( 'THREE.Skeleton bonInverses is the wrong length.' );\r\n\r\n\t\t\tthis.boneInverses = [];\r\n\r\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\t\t\tthis.boneInverses.push( new THREE.Matrix4() );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nObject.assign( THREE.Skeleton.prototype, {\r\n\r\n\tcalculateInverses: function () {\r\n\r\n\t\tthis.boneInverses = [];\r\n\r\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\t\tvar inverse = new THREE.Matrix4();\r\n\r\n\t\t\tif ( this.bones[ b ] ) {\r\n\r\n\t\t\t\tinverse.getInverse( this.bones[ b ].matrixWorld );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.boneInverses.push( inverse );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tpose: function () {\r\n\r\n\t\tvar bone;\r\n\r\n\t\t// recover the bind-time world matrices\r\n\r\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\t\tbone = this.bones[ b ];\r\n\r\n\t\t\tif ( bone ) {\r\n\r\n\t\t\t\tbone.matrixWorld.getInverse( this.boneInverses[ b ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// compute the local matrices, positions, rotations and scales\r\n\r\n\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\t\tbone = this.bones[ b ];\r\n\r\n\t\t\tif ( bone ) {\r\n\r\n\t\t\t\tif ( bone.parent ) {\r\n\r\n\t\t\t\t\tbone.matrix.getInverse( bone.parent.matrixWorld );\r\n\t\t\t\t\tbone.matrix.multiply( bone.matrixWorld );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tbone.matrix.copy( bone.matrixWorld );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbone.matrix.decompose( bone.position, bone.quaternion, bone.scale );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tupdate: ( function () {\r\n\r\n\t\tvar offsetMatrix = new THREE.Matrix4();\r\n\r\n\t\treturn function update() {\r\n\r\n\t\t\t// flatten bone matrices to array\r\n\r\n\t\t\tfor ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {\r\n\r\n\t\t\t\t// compute the offset between the current and the original transform\r\n\r\n\t\t\t\tvar matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;\r\n\r\n\t\t\t\toffsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );\r\n\t\t\t\toffsetMatrix.toArray( this.boneMatrices, b * 16 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.useVertexTexture ) {\r\n\r\n\t\t\t\tthis.boneTexture.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new THREE.Skeleton( this.bones, this.boneInverses, this.useVertexTexture );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/objects/SkinnedMesh.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.SkinnedMesh = function ( geometry, material, useVertexTexture ) {\r\n\r\n\tTHREE.Mesh.call( this, geometry, material );\r\n\r\n\tthis.type = 'SkinnedMesh';\r\n\r\n\tthis.bindMode = \"attached\";\r\n\tthis.bindMatrix = new THREE.Matrix4();\r\n\tthis.bindMatrixInverse = new THREE.Matrix4();\r\n\r\n\t// init bones\r\n\r\n\t// TODO: remove bone creation as there is no reason (other than\r\n\t// convenience) for THREE.SkinnedMesh to do this.\r\n\r\n\tvar bones = [];\r\n\r\n\tif ( this.geometry && this.geometry.bones !== undefined ) {\r\n\r\n\t\tvar bone, gbone;\r\n\r\n\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\r\n\r\n\t\t\tgbone = this.geometry.bones[ b ];\r\n\r\n\t\t\tbone = new THREE.Bone( this );\r\n\t\t\tbones.push( bone );\r\n\r\n\t\t\tbone.name = gbone.name;\r\n\t\t\tbone.position.fromArray( gbone.pos );\r\n\t\t\tbone.quaternion.fromArray( gbone.rotq );\r\n\t\t\tif ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {\r\n\r\n\t\t\tgbone = this.geometry.bones[ b ];\r\n\r\n\t\t\tif ( gbone.parent !== - 1 && gbone.parent !== null &&\r\n\t\t\t\t\tbones[ gbone.parent ] !== undefined ) {\r\n\r\n\t\t\t\tbones[ gbone.parent ].add( bones[ b ] );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthis.add( bones[ b ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.normalizeSkinWeights();\r\n\r\n\tthis.updateMatrixWorld( true );\r\n\tthis.bind( new THREE.Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );\r\n\r\n};\r\n\r\n\r\nTHREE.SkinnedMesh.prototype = Object.assign( Object.create( THREE.Mesh.prototype ), {\r\n\r\n\tconstructor: THREE.SkinnedMesh,\r\n\r\n\tbind: function( skeleton, bindMatrix ) {\r\n\r\n\t\tthis.skeleton = skeleton;\r\n\r\n\t\tif ( bindMatrix === undefined ) {\r\n\r\n\t\t\tthis.updateMatrixWorld( true );\r\n\r\n\t\t\tthis.skeleton.calculateInverses();\r\n\r\n\t\t\tbindMatrix = this.matrixWorld;\r\n\r\n\t\t}\r\n\r\n\t\tthis.bindMatrix.copy( bindMatrix );\r\n\t\tthis.bindMatrixInverse.getInverse( bindMatrix );\r\n\r\n\t},\r\n\r\n\tpose: function () {\r\n\r\n\t\tthis.skeleton.pose();\r\n\r\n\t},\r\n\r\n\tnormalizeSkinWeights: function () {\r\n\r\n\t\tif ( this.geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\tfor ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {\r\n\r\n\t\t\t\tvar sw = this.geometry.skinWeights[ i ];\r\n\r\n\t\t\t\tvar scale = 1.0 / sw.lengthManhattan();\r\n\r\n\t\t\t\tif ( scale !== Infinity ) {\r\n\r\n\t\t\t\t\tsw.multiplyScalar( scale );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tsw.set( 1, 0, 0, 0 ); // do something reasonable\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( this.geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\tvar vec = new THREE.Vector4();\r\n\r\n\t\t\tvar skinWeight = this.geometry.attributes.skinWeight;\r\n\r\n\t\t\tfor ( var i = 0; i < skinWeight.count; i ++ ) {\r\n\r\n\t\t\t\tvec.x = skinWeight.getX( i );\r\n\t\t\t\tvec.y = skinWeight.getY( i );\r\n\t\t\t\tvec.z = skinWeight.getZ( i );\r\n\t\t\t\tvec.w = skinWeight.getW( i );\r\n\r\n\t\t\t\tvar scale = 1.0 / vec.lengthManhattan();\r\n\r\n\t\t\t\tif ( scale !== Infinity ) {\r\n\r\n\t\t\t\t\tvec.multiplyScalar( scale );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tvec.set( 1, 0, 0, 0 ); // do something reasonable\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tskinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tupdateMatrixWorld: function( force ) {\r\n\r\n\t\tTHREE.Mesh.prototype.updateMatrixWorld.call( this, true );\r\n\r\n\t\tif ( this.bindMode === \"attached\" ) {\r\n\r\n\t\t\tthis.bindMatrixInverse.getInverse( this.matrixWorld );\r\n\r\n\t\t} else if ( this.bindMode === \"detached\" ) {\r\n\r\n\t\t\tthis.bindMatrixInverse.getInverse( this.bindMatrix );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tconsole.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tclone: function() {\r\n\r\n\t\treturn new this.constructor( this.geometry, this.material, this.useVertexTexture ).copy( this );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/objects/LOD.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.LOD = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'LOD';\r\n\r\n\tObject.defineProperties( this, {\r\n\t\tlevels: {\r\n\t\t\tenumerable: true,\r\n\t\t\tvalue: []\r\n\t\t}\r\n\t} );\r\n\r\n};\r\n\r\n\r\nTHREE.LOD.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\r\n\r\n\tconstructor: THREE.LOD,\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tTHREE.Object3D.prototype.copy.call( this, source, false );\r\n\r\n\t\tvar levels = source.levels;\r\n\r\n\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar level = levels[ i ];\r\n\r\n\t\t\tthis.addLevel( level.object.clone(), level.distance );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\taddLevel: function ( object, distance ) {\r\n\r\n\t\tif ( distance === undefined ) distance = 0;\r\n\r\n\t\tdistance = Math.abs( distance );\r\n\r\n\t\tvar levels = this.levels;\r\n\r\n\t\tfor ( var l = 0; l < levels.length; l ++ ) {\r\n\r\n\t\t\tif ( distance < levels[ l ].distance ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tlevels.splice( l, 0, { distance: distance, object: object } );\r\n\r\n\t\tthis.add( object );\r\n\r\n\t},\r\n\r\n\tgetObjectForDistance: function ( distance ) {\r\n\r\n\t\tvar levels = this.levels;\r\n\r\n\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\r\n\r\n\t\t\tif ( distance < levels[ i ].distance ) {\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn levels[ i - 1 ].object;\r\n\r\n\t},\r\n\r\n\traycast: ( function () {\r\n\r\n\t\tvar matrixPosition = new THREE.Vector3();\r\n\r\n\t\treturn function raycast( raycaster, intersects ) {\r\n\r\n\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t\t\tvar distance = raycaster.ray.origin.distanceTo( matrixPosition );\r\n\r\n\t\t\tthis.getObjectForDistance( distance ).raycast( raycaster, intersects );\r\n\r\n\t\t};\r\n\r\n\t}() ),\r\n\r\n\tupdate: function () {\r\n\r\n\t\tvar v1 = new THREE.Vector3();\r\n\t\tvar v2 = new THREE.Vector3();\r\n\r\n\t\treturn function update( camera ) {\r\n\r\n\t\t\tvar levels = this.levels;\r\n\r\n\t\t\tif ( levels.length > 1 ) {\r\n\r\n\t\t\t\tv1.setFromMatrixPosition( camera.matrixWorld );\r\n\t\t\t\tv2.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t\t\t\tvar distance = v1.distanceTo( v2 );\r\n\r\n\t\t\t\tlevels[ 0 ].object.visible = true;\r\n\r\n\t\t\t\tfor ( var i = 1, l = levels.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tif ( distance >= levels[ i ].distance ) {\r\n\r\n\t\t\t\t\t\tlevels[ i - 1 ].object.visible = false;\r\n\t\t\t\t\t\tlevels[ i ].object.visible = true;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( ; i < l; i ++ ) {\r\n\r\n\t\t\t\t\tlevels[ i ].object.visible = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}(),\r\n\r\n\ttoJSON: function ( meta ) {\r\n\r\n\t\tvar data = THREE.Object3D.prototype.toJSON.call( this, meta );\r\n\r\n\t\tdata.object.levels = [];\r\n\r\n\t\tvar levels = this.levels;\r\n\r\n\t\tfor ( var i = 0, l = levels.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar level = levels[ i ];\r\n\r\n\t\t\tdata.object.levels.push( {\r\n\t\t\t\tobject: level.object.uuid,\r\n\t\t\t\tdistance: level.distance\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\treturn data;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/objects/Sprite.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Sprite = function ( material ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Sprite';\r\n\r\n\tthis.material = ( material !== undefined ) ? material : new THREE.SpriteMaterial();\r\n\r\n};\r\n\r\nTHREE.Sprite.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\r\n\r\n\tconstructor: THREE.Sprite,\r\n\r\n\traycast: ( function () {\r\n\r\n\t\tvar matrixPosition = new THREE.Vector3();\r\n\r\n\t\treturn function raycast( raycaster, intersects ) {\r\n\r\n\t\t\tmatrixPosition.setFromMatrixPosition( this.matrixWorld );\r\n\r\n\t\t\tvar distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );\r\n\t\t\tvar guessSizeSq = this.scale.x * this.scale.y / 4;\r\n\r\n\t\t\tif ( distanceSq > guessSizeSq ) {\r\n\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tintersects.push( {\r\n\r\n\t\t\t\tdistance: Math.sqrt( distanceSq ),\r\n\t\t\t\tpoint: this.position,\r\n\t\t\t\tface: null,\r\n\t\t\t\tobject: this\r\n\r\n\t\t\t} );\r\n\r\n\t\t};\r\n\r\n\t}() ),\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor( this.material ).copy( this );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/objects/LensFlare.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.LensFlare = function ( texture, size, distance, blending, color ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.lensFlares = [];\r\n\r\n\tthis.positionScreen = new THREE.Vector3();\r\n\tthis.customUpdateCallback = undefined;\r\n\r\n\tif ( texture !== undefined ) {\r\n\r\n\t\tthis.add( texture, size, distance, blending, color );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.LensFlare.prototype = Object.assign( Object.create( THREE.Object3D.prototype ), {\r\n\r\n\tconstructor: THREE.LensFlare,\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tTHREE.Object3D.prototype.copy.call( this, source );\r\n\r\n\t\tthis.positionScreen.copy( source.positionScreen );\r\n\t\tthis.customUpdateCallback = source.customUpdateCallback;\r\n\r\n\t\tfor ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis.lensFlares.push( source.lensFlares[ i ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tadd: function ( texture, size, distance, blending, color, opacity ) {\r\n\r\n\t\tif ( size === undefined ) size = - 1;\r\n\t\tif ( distance === undefined ) distance = 0;\r\n\t\tif ( opacity === undefined ) opacity = 1;\r\n\t\tif ( color === undefined ) color = new THREE.Color( 0xffffff );\r\n\t\tif ( blending === undefined ) blending = THREE.NormalBlending;\r\n\r\n\t\tdistance = Math.min( distance, Math.max( 0, distance ) );\r\n\r\n\t\tthis.lensFlares.push( {\r\n\t\t\ttexture: texture,\t// THREE.Texture\r\n\t\t\tsize: size, \t\t// size in pixels (-1 = use texture.width)\r\n\t\t\tdistance: distance, \t// distance (0-1) from light source (0=at light source)\r\n\t\t\tx: 0, y: 0, z: 0,\t// screen position (-1 => 1) z = 0 is in front z = 1 is back\r\n\t\t\tscale: 1, \t\t// scale\r\n\t\t\trotation: 0, \t\t// rotation\r\n\t\t\topacity: opacity,\t// opacity\r\n\t\t\tcolor: color,\t\t// color\r\n\t\t\tblending: blending\t// blending\r\n\t\t} );\r\n\r\n\t},\r\n\r\n\t/*\r\n\t * Update lens flares update positions on all flares based on the screen position\r\n\t * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.\r\n\t */\r\n\r\n\tupdateLensFlares: function () {\r\n\r\n\t\tvar f, fl = this.lensFlares.length;\r\n\t\tvar flare;\r\n\t\tvar vecX = - this.positionScreen.x * 2;\r\n\t\tvar vecY = - this.positionScreen.y * 2;\r\n\r\n\t\tfor ( f = 0; f < fl; f ++ ) {\r\n\r\n\t\t\tflare = this.lensFlares[ f ];\r\n\r\n\t\t\tflare.x = this.positionScreen.x + vecX * flare.distance;\r\n\t\t\tflare.y = this.positionScreen.y + vecY * flare.distance;\r\n\r\n\t\t\tflare.wantedRotation = flare.x * Math.PI * 0.25;\r\n\t\t\tflare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/scenes/Scene.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Scene = function () {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.type = 'Scene';\r\n\r\n\tthis.fog = null;\r\n\tthis.overrideMaterial = null;\r\n\r\n\tthis.autoUpdate = true; // checked by the renderer\r\n\r\n};\r\n\r\nTHREE.Scene.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.Scene.prototype.constructor = THREE.Scene;\r\n\r\nTHREE.Scene.prototype.copy = function ( source, recursive ) {\r\n\r\n\tTHREE.Object3D.prototype.copy.call( this, source, recursive );\r\n\r\n\tif ( source.fog !== null ) this.fog = source.fog.clone();\r\n\tif ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();\r\n\r\n\tthis.autoUpdate = source.autoUpdate;\r\n\tthis.matrixAutoUpdate = source.matrixAutoUpdate;\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n// File:src/scenes/Fog.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.Fog = function ( color, near, far ) {\r\n\r\n\tthis.name = '';\r\n\r\n\tthis.color = new THREE.Color( color );\r\n\r\n\tthis.near = ( near !== undefined ) ? near : 1;\r\n\tthis.far = ( far !== undefined ) ? far : 1000;\r\n\r\n};\r\n\r\nTHREE.Fog.prototype.clone = function () {\r\n\r\n\treturn new THREE.Fog( this.color.getHex(), this.near, this.far );\r\n\r\n};\r\n\r\n// File:src/scenes/FogExp2.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.FogExp2 = function ( color, density ) {\r\n\r\n\tthis.name = '';\r\n\r\n\tthis.color = new THREE.Color( color );\r\n\tthis.density = ( density !== undefined ) ? density : 0.00025;\r\n\r\n};\r\n\r\nTHREE.FogExp2.prototype.clone = function () {\r\n\r\n\treturn new THREE.FogExp2( this.color.getHex(), this.density );\r\n\r\n};\r\n\r\n// File:src/renderers/shaders/ShaderChunk.js\r\n\r\nTHREE.ShaderChunk = {};\r\n\r\n// File:src/renderers/shaders/ShaderChunk/alphamap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'alphamap_fragment' ] = \"#ifdef USE_ALPHAMAP\\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/alphamap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'alphamap_pars_fragment' ] = \"#ifdef USE_ALPHAMAP\\n\tuniform sampler2D alphaMap;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/alphatest_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'alphatest_fragment' ] = \"#ifdef ALPHATEST\\n\tif ( diffuseColor.a < ALPHATEST ) discard;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/aomap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'aomap_fragment' ] = \"#ifdef USE_AOMAP\\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/aomap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'aomap_pars_fragment' ] = \"#ifdef USE_AOMAP\\n\tuniform sampler2D aoMap;\\n\tuniform float aoMapIntensity;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/begin_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'begin_vertex' ] = \"\\nvec3 transformed = vec3( position );\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/beginnormal_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'beginnormal_vertex' ] = \"\\nvec3 objectNormal = vec3( normal );\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/bsdfs.glsl\r\n\r\nTHREE.ShaderChunk[ 'bsdfs' ] = \"bool testLightInRange( const in float lightDistance, const in float cutoffDistance ) {\\n\treturn any( bvec2( cutoffDistance == 0.0, lightDistance < cutoffDistance ) );\\n}\\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\\n\t\tif( decayExponent > 0.0 ) {\\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\\n#else\\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\\n#endif\\n\t\t}\\n\t\treturn 1.0;\\n}\\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\\n\treturn RECIPROCAL_PI * diffuseColor;\\n}\\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\\n}\\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\treturn 1.0 / ( gl * gv );\\n}\\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\\n\treturn 0.5 / max( gv + gl, EPSILON );\\n}\\nfloat D_GGX( const in float alpha, const in float dotNH ) {\\n\tfloat a2 = pow2( alpha );\\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\\n}\\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\tfloat alpha = pow2( roughness );\\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\\n\tfloat D = D_GGX( alpha, dotNH );\\n\treturn F * ( G * D );\\n}\\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\\n\tvec4 r = roughness * c0 + c1;\\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\\n\treturn specularColor * AB.x + AB.y;\\n}\\nfloat G_BlinnPhong_Implicit( ) {\\n\treturn 0.25;\\n}\\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\\n}\\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\\n\tvec3 F = F_Schlick( specularColor, dotLH );\\n\tfloat G = G_BlinnPhong_Implicit( );\\n\tfloat D = D_BlinnPhong( shininess, dotNH );\\n\treturn F * ( G * D );\\n}\\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\\n}\\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/bumpmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'bumpmap_pars_fragment' ] = \"#ifdef USE_BUMPMAP\\n\tuniform sampler2D bumpMap;\\n\tuniform float bumpScale;\\n\tvec2 dHdxy_fwd() {\\n\t\tvec2 dSTdx = dFdx( vUv );\\n\t\tvec2 dSTdy = dFdy( vUv );\\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\\n\t\treturn vec2( dBx, dBy );\\n\t}\\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\\n\t\tvec3 vSigmaX = dFdx( surf_pos );\\n\t\tvec3 vSigmaY = dFdy( surf_pos );\\n\t\tvec3 vN = surf_norm;\\n\t\tvec3 R1 = cross( vSigmaY, vN );\\n\t\tvec3 R2 = cross( vN, vSigmaX );\\n\t\tfloat fDet = dot( vSigmaX, R1 );\\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\\n\t}\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'clipping_planes_fragment' ] = \"#if NUM_CLIPPING_PLANES > 0\\n\tfor ( int i = 0; i < NUM_CLIPPING_PLANES; ++ i ) {\\n\t\tvec4 plane = clippingPlanes[ i ];\\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\\n\t}\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'clipping_planes_pars_fragment' ] = \"#if NUM_CLIPPING_PLANES > 0\\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\\n\t\tvarying vec3 vViewPosition;\\n\t#endif\\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'clipping_planes_pars_vertex' ] = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\tvarying vec3 vViewPosition;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/clipping_planes_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'clipping_planes_vertex' ] = \"#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\\n\tvViewPosition = - mvPosition.xyz;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_fragment' ] = \"#ifdef USE_COLOR\\n\tdiffuseColor.rgb *= vColor;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_pars_fragment' ] = \"#ifdef USE_COLOR\\n\tvarying vec3 vColor;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_pars_vertex' ] = \"#ifdef USE_COLOR\\n\tvarying vec3 vColor;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/color_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'color_vertex' ] = \"#ifdef USE_COLOR\\n\tvColor.xyz = color.xyz;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/common.glsl\r\n\r\nTHREE.ShaderChunk[ 'common' ] = \"#define PI 3.14159265359\\n#define PI2 6.28318530718\\n#define RECIPROCAL_PI 0.31830988618\\n#define RECIPROCAL_PI2 0.15915494\\n#define LOG2 1.442695\\n#define EPSILON 1e-6\\n#define saturate(a) clamp( a, 0.0, 1.0 )\\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\\nfloat pow2( const in float x ) { return x*x; }\\nfloat pow3( const in float x ) { return x*x*x; }\\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\\nhighp float rand( const in vec2 uv ) {\\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\\n\treturn fract(sin(sn) * c);\\n}\\nstruct IncidentLight {\\n\tvec3 color;\\n\tvec3 direction;\\n\tbool visible;\\n};\\nstruct ReflectedLight {\\n\tvec3 directDiffuse;\\n\tvec3 directSpecular;\\n\tvec3 indirectDiffuse;\\n\tvec3 indirectSpecular;\\n};\\nstruct GeometricContext {\\n\tvec3 position;\\n\tvec3 normal;\\n\tvec3 viewDir;\\n};\\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\\n}\\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\\n}\\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\\n\treturn - distance * planeNormal + point;\\n}\\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\\n}\\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/cube_uv_reflection_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'cube_uv_reflection_fragment' ] = \"#ifdef ENVMAP_TYPE_CUBE_UV\\n#define cubeUV_textureSize (1024.0)\\nint getFaceFromDirection(vec3 direction) {\\n\tvec3 absDirection = abs(direction);\\n\tint face = -1;\\n\tif( absDirection.x > absDirection.z ) {\\n\t\tif(absDirection.x > absDirection.y )\\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\\n\t\telse\\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\\n\t}\\n\telse {\\n\t\tif(absDirection.z > absDirection.y )\\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\\n\t\telse\\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\\n\t}\\n\treturn face;\\n}\\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\\n\tfloat dxRoughness = dFdx(roughness);\\n\tfloat dyRoughness = dFdy(roughness);\\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\\n\tfloat mipLevel = 0.5 * log2(d);\\n\treturn vec2(floor(mipLevel), fract(mipLevel));\\n}\\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\\n\tbool bRes = mipLevel == 0.0;\\n\tscale =  bRes && (scale < a) ? a : scale;\\n\tvec3 r;\\n\tvec2 offset;\\n\tint face = getFaceFromDirection(direction);\\n\tfloat rcpPowScale = 1.0 / powScale;\\n\tif( face == 0) {\\n\t\tr = vec3(direction.x, -direction.z, direction.y);\\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 1) {\\n\t\tr = vec3(direction.y, direction.x, direction.z);\\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 2) {\\n\t\tr = vec3(direction.z, direction.x, direction.y);\\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\\n\t}\\n\telse if( face == 3) {\\n\t\tr = vec3(direction.x, direction.z, direction.y);\\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\telse if( face == 4) {\\n\t\tr = vec3(direction.y, direction.x, -direction.z);\\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\telse {\\n\t\tr = vec3(direction.z, -direction.x, direction.y);\\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\\n\t}\\n\tr = normalize(r);\\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\\n\tvec2 base = offset + vec2( texelOffset );\\n\treturn base + s * ( scale - 2.0 * texelOffset );\\n}\\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\\n\tfloat r1 = floor(roughnessVal);\\n\tfloat r2 = r1 + 1.0;\\n\tfloat t = fract(roughnessVal);\\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\\n\tfloat s = mipInfo.y;\\n\tfloat level0 = mipInfo.x;\\n\tfloat level1 = level0 + 1.0;\\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\\n\tvec4 result = mix(color10, color20, t);\\n\treturn vec4(result.rgb, 1.0);\\n}\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/defaultnormal_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'defaultnormal_vertex' ] = \"#ifdef FLIP_SIDED\\n\tobjectNormal = -objectNormal;\\n#endif\\nvec3 transformedNormal = normalMatrix * objectNormal;\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/displacementmap_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'displacementmap_vertex' ] = \"#ifdef USE_DISPLACEMENTMAP\\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/displacementmap_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'displacementmap_pars_vertex' ] = \"#ifdef USE_DISPLACEMENTMAP\\n\tuniform sampler2D displacementMap;\\n\tuniform float displacementScale;\\n\tuniform float displacementBias;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/emissivemap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'emissivemap_fragment' ] = \"#ifdef USE_EMISSIVEMAP\\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/emissivemap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'emissivemap_pars_fragment' ] = \"#ifdef USE_EMISSIVEMAP\\n\tuniform sampler2D emissiveMap;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/encodings_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'encodings_pars_fragment' ] = \"\\nvec4 LinearToLinear( in vec4 value ) {\\n  return value;\\n}\\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\\n}\\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\\n}\\nvec4 sRGBToLinear( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\\n}\\nvec4 LinearTosRGB( in vec4 value ) {\\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\\n}\\nvec4 RGBEToLinear( in vec4 value ) {\\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\\n}\\nvec4 LinearToRGBE( in vec4 value ) {\\n  float maxComponent = max( max( value.r, value.g ), value.b );\\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\\n}\\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\\n}\\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\\n  float maxRGB = max( value.x, max( value.g, value.b ) );\\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\\n  M            = ceil( M * 255.0 ) / 255.0;\\n  return vec4( value.rgb / ( M * maxRange ), M );\\n}\\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\\n}\\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\\n    float maxRGB = max( value.x, max( value.g, value.b ) );\\n    float D      = max( maxRange / maxRGB, 1.0 );\\n    D            = min( floor( D ) / 255.0, 1.0 );\\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\\n}\\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\\nvec4 LinearToLogLuv( in vec4 value )  {\\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\\n  vec4 vResult;\\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\\n  vResult.w = fract(Le);\\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\\n  return vResult;\\n}\\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\\nvec4 LogLuvToLinear( in vec4 value ) {\\n  float Le = value.z * 255.0 + value.w;\\n  vec3 Xp_Y_XYZp;\\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\\n  return vec4( max(vRGB, 0.0), 1.0 );\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/encodings_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'encodings_fragment' ] = \"  gl_FragColor = linearToOutputTexel( gl_FragColor );\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_fragment' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\\n\t\t#endif\\n\t#else\\n\t\tvec3 reflectVec = vReflect;\\n\t#endif\\n\t#ifdef DOUBLE_SIDED\\n\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\t#else\\n\t\tfloat flipNormal = 1.0;\\n\t#endif\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\tvec2 sampleUV;\\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\\n\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\\n\t#endif\\n\tenvColor = envMapTexelToLinear( envColor );\\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_MIX )\\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\\n\t#elif defined( ENVMAP_BLENDING_ADD )\\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_pars_fragment' ] = \"#if defined( USE_ENVMAP ) || defined( PHYSICAL )\\n\tuniform float reflectivity;\\n\tuniform float envMapIntenstiy;\\n#endif\\n#ifdef USE_ENVMAP\\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\\n\t\tvarying vec3 vWorldPosition;\\n\t#endif\\n\t#ifdef ENVMAP_TYPE_CUBE\\n\t\tuniform samplerCube envMap;\\n\t#else\\n\t\tuniform sampler2D envMap;\\n\t#endif\\n\tuniform float flipEnvMap;\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\\n\t\tuniform float refractionRatio;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_pars_vertex' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvarying vec3 vWorldPosition;\\n\t#else\\n\t\tvarying vec3 vReflect;\\n\t\tuniform float refractionRatio;\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/envmap_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'envmap_vertex' ] = \"#ifdef USE_ENVMAP\\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\\n\t\tvWorldPosition = worldPosition.xyz;\\n\t#else\\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\\n\t\t#else\\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\\n\t\t#endif\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/fog_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'fog_fragment' ] = \"#ifdef USE_FOG\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\\n\t#else\\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\\n\t#endif\\n\t#ifdef FOG_EXP2\\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\\n\t#else\\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\\n\t#endif\\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/fog_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'fog_pars_fragment' ] = \"#ifdef USE_FOG\\n\tuniform vec3 fogColor;\\n\t#ifdef FOG_EXP2\\n\t\tuniform float fogDensity;\\n\t#else\\n\t\tuniform float fogNear;\\n\t\tuniform float fogFar;\\n\t#endif\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lightmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lightmap_fragment' ] = \"#ifdef USE_LIGHTMAP\\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lightmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lightmap_pars_fragment' ] = \"#ifdef USE_LIGHTMAP\\n\tuniform sampler2D lightMap;\\n\tuniform float lightMapIntensity;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_lambert_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_lambert_vertex' ] = \"vec3 diffuse = vec3( 1.0 );\\nGeometricContext geometry;\\ngeometry.position = mvPosition.xyz;\\ngeometry.normal = normalize( transformedNormal );\\ngeometry.viewDir = normalize( -mvPosition.xyz );\\nGeometricContext backGeometry;\\nbackGeometry.position = geometry.position;\\nbackGeometry.normal = -geometry.normal;\\nbackGeometry.viewDir = geometry.viewDir;\\nvLightFront = vec3( 0.0 );\\n#ifdef DOUBLE_SIDED\\n\tvLightBack = vec3( 0.0 );\\n#endif\\nIncidentLight directLight;\\nfloat dotNL;\\nvec3 directLightColor_Diffuse;\\n#if NUM_POINT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_DIR_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\\n\t\tdotNL = dot( geometry.normal, directLight.direction );\\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\\n\t\t#endif\\n\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\\n\t\t#endif\\n\t}\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_pars.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_pars' ] = \"uniform vec3 ambientLightColor;\\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\\n\tvec3 irradiance = ambientLightColor;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treturn irradiance;\\n}\\n#if NUM_DIR_LIGHTS > 0\\n\tstruct DirectionalLight {\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\t\tdirectLight.color = directionalLight.color;\\n\t\tdirectLight.direction = directionalLight.direction;\\n\t\tdirectLight.visible = true;\\n\t}\\n#endif\\n#if NUM_POINT_LIGHTS > 0\\n\tstruct PointLight {\\n\t\tvec3 position;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\\n\t\tvec3 lVector = pointLight.position - geometry.position;\\n\t\tdirectLight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tif ( testLightInRange( lightDistance, pointLight.distance ) ) {\\n\t\t\tdirectLight.color = pointLight.color;\\n\t\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\\n\t\t\tdirectLight.visible = true;\\n\t\t} else {\\n\t\t\tdirectLight.color = vec3( 0.0 );\\n\t\t\tdirectLight.visible = false;\\n\t\t}\\n\t}\\n#endif\\n#if NUM_SPOT_LIGHTS > 0\\n\tstruct SpotLight {\\n\t\tvec3 position;\\n\t\tvec3 direction;\\n\t\tvec3 color;\\n\t\tfloat distance;\\n\t\tfloat decay;\\n\t\tfloat coneCos;\\n\t\tfloat penumbraCos;\\n\t\tint shadow;\\n\t\tfloat shadowBias;\\n\t\tfloat shadowRadius;\\n\t\tvec2 shadowMapSize;\\n\t};\\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\\n\t\tvec3 lVector = spotLight.position - geometry.position;\\n\t\tdirectLight.direction = normalize( lVector );\\n\t\tfloat lightDistance = length( lVector );\\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\\n\t\tif ( all( bvec2( angleCos > spotLight.coneCos, testLightInRange( lightDistance, spotLight.distance ) ) ) ) {\\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\\n\t\t\tdirectLight.color = spotLight.color;\\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\\n\t\t\tdirectLight.visible = true;\\n\t\t} else {\\n\t\t\tdirectLight.color = vec3( 0.0 );\\n\t\t\tdirectLight.visible = false;\\n\t\t}\\n\t}\\n#endif\\n#if NUM_HEMI_LIGHTS > 0\\n\tstruct HemisphereLight {\\n\t\tvec3 direction;\\n\t\tvec3 skyColor;\\n\t\tvec3 groundColor;\\n\t};\\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tirradiance *= PI;\\n\t\t#endif\\n\t\treturn irradiance;\\n\t}\\n#endif\\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\t\t#else\\n\t\t\tfloat flipNormal = 1.0;\\n\t\t#endif\\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\\n\t\t#ifdef ENVMAP_TYPE_CUBE\\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\t\tvec3 queryVec = flipNormal * vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\\n\t\t#else\\n\t\t\tvec4 envMapColor = vec4( 0.0 );\\n\t\t#endif\\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\\n\t}\\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\\n\t}\\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\\n\t\t#ifdef ENVMAP_MODE_REFLECTION\\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\\n\t\t#else\\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\\n\t\t#endif\\n\t\t#ifdef DOUBLE_SIDED\\n\t\t\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\\n\t\t#else\\n\t\t\tfloat flipNormal = 1.0;\\n\t\t#endif\\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\\n\t\t#ifdef ENVMAP_TYPE_CUBE\\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\\n\t\t\tvec2 sampleUV;\\n\t\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\\n\t\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\\n\t\t\tvec3 reflectView = flipNormal * normalize((viewMatrix * vec4( reflectVec, 0.0 )).xyz + vec3(0.0,0.0,1.0));\\n\t\t\t#ifdef TEXTURE_LOD_EXT\\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\t\t\t#else\\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\\n\t\t\t#endif\\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\\n\t\t#endif\\n\t\treturn envMapColor.rgb * envMapIntensity;\\n\t}\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_phong_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_phong_fragment' ] = \"BlinnPhongMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb;\\nmaterial.specularColor = specular;\\nmaterial.specularShininess = shininess;\\nmaterial.specularStrength = specularStrength;\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_phong_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_phong_pars_fragment' ] = \"varying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\nstruct BlinnPhongMaterial {\\n\tvec3\tdiffuseColor;\\n\tvec3\tspecularColor;\\n\tfloat\tspecularShininess;\\n\tfloat\tspecularStrength;\\n};\\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\\n}\\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\\n#define Material_LightProbeLOD( material )\t(0)\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_physical_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_physical_fragment' ] = \"PhysicalMaterial material;\\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\\n#ifdef STANDARD\\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\\n#else\\n\tmaterial.specularColor = mix( vec3( 0.16 * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_physical_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_physical_pars_fragment' ] = \"struct PhysicalMaterial {\\n\tvec3\tdiffuseColor;\\n\tfloat\tspecularRoughness;\\n\tvec3\tspecularColor;\\n\t#ifndef STANDARD\\n\t#endif\\n};\\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\\n\tvec3 irradiance = dotNL * directLight.color;\\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\tirradiance *= PI;\\n\t#endif\\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\\n}\\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\\n}\\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\\n\treflectedLight.indirectSpecular += radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\\n}\\n#define RE_Direct\t\t\t\tRE_Direct_Physical\\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/lights_template.glsl\r\n\r\nTHREE.ShaderChunk[ 'lights_template' ] = \"\\nGeometricContext geometry;\\ngeometry.position = - vViewPosition;\\ngeometry.normal = normal;\\ngeometry.viewDir = normalize( vViewPosition );\\nIncidentLight directLight;\\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tPointLight pointLight;\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i ];\\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\\n\tSpotLight spotLight;\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tspotLight = spotLights[ i ];\\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\\n\tDirectionalLight directionalLight;\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectionalLight = directionalLights[ i ];\\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\\n\t\t#ifdef USE_SHADOWMAP\\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t\t#endif\\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\\n\t}\\n#endif\\n#if defined( RE_IndirectDiffuse )\\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\\n\t#ifdef USE_LIGHTMAP\\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\\n\t\t\tlightMapIrradiance *= PI;\\n\t\t#endif\\n\t\tirradiance += lightMapIrradiance;\\n\t#endif\\n\t#if ( NUM_HEMI_LIGHTS > 0 )\\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\\n\t\t}\\n\t#endif\\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\\n\t#endif\\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\\n#endif\\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\\n\tRE_IndirectSpecular( radiance, geometry, material, reflectedLight );\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_fragment' ] = \"#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_pars_fragment' ] = \"#ifdef USE_LOGDEPTHBUF\\n\tuniform float logDepthBufFC;\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvarying float vFragDepth;\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_pars_vertex' ] = \"#ifdef USE_LOGDEPTHBUF\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvarying float vFragDepth;\\n\t#endif\\n\tuniform float logDepthBufFC;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/logdepthbuf_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'logdepthbuf_vertex' ] = \"#ifdef USE_LOGDEPTHBUF\\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\\n\t#ifdef USE_LOGDEPTHBUF_EXT\\n\t\tvFragDepth = 1.0 + gl_Position.w;\\n\t#else\\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_fragment' ] = \"#ifdef USE_MAP\\n\tvec4 texelColor = texture2D( map, vUv );\\n\ttexelColor = mapTexelToLinear( texelColor );\\n\tdiffuseColor *= texelColor;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_pars_fragment' ] = \"#ifdef USE_MAP\\n\tuniform sampler2D map;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_particle_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_particle_fragment' ] = \"#ifdef USE_MAP\\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/map_particle_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'map_particle_pars_fragment' ] = \"#ifdef USE_MAP\\n\tuniform vec4 offsetRepeat;\\n\tuniform sampler2D map;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/metalnessmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'metalnessmap_fragment' ] = \"float metalnessFactor = metalness;\\n#ifdef USE_METALNESSMAP\\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\tmetalnessFactor *= texelMetalness.r;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/metalnessmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'metalnessmap_pars_fragment' ] = \"#ifdef USE_METALNESSMAP\\n\tuniform sampler2D metalnessMap;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/morphnormal_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'morphnormal_vertex' ] = \"#ifdef USE_MORPHNORMALS\\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/morphtarget_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'morphtarget_pars_vertex' ] = \"#ifdef USE_MORPHTARGETS\\n\t#ifndef USE_MORPHNORMALS\\n\tuniform float morphTargetInfluences[ 8 ];\\n\t#else\\n\tuniform float morphTargetInfluences[ 4 ];\\n\t#endif\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/morphtarget_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'morphtarget_vertex' ] = \"#ifdef USE_MORPHTARGETS\\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\\n\t#ifndef USE_MORPHNORMALS\\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/normal_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'normal_fragment' ] = \"#ifdef FLAT_SHADED\\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\\n\tvec3 normal = normalize( cross( fdx, fdy ) );\\n#else\\n\tvec3 normal = normalize( vNormal );\\n\t#ifdef DOUBLE_SIDED\\n\t\tnormal = normal * ( -1.0 + 2.0 * float( gl_FrontFacing ) );\\n\t#endif\\n#endif\\n#ifdef USE_NORMALMAP\\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\\n#elif defined( USE_BUMPMAP )\\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/normalmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'normalmap_pars_fragment' ] = \"#ifdef USE_NORMALMAP\\n\tuniform sampler2D normalMap;\\n\tuniform vec2 normalScale;\\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\\n\t\tvec2 st0 = dFdx( vUv.st );\\n\t\tvec2 st1 = dFdy( vUv.st );\\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\\n\t\tvec3 N = normalize( surf_norm );\\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\\n\t\tmapN.xy = normalScale * mapN.xy;\\n\t\tmat3 tsn = mat3( S, T, N );\\n\t\treturn normalize( tsn * mapN );\\n\t}\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/packing.glsl\r\n\r\nTHREE.ShaderChunk[ 'packing' ] = \"vec3 packNormalToRGB( const in vec3 normal ) {\\n  return normalize( normal ) * 0.5 + 0.5;\\n}\\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\\n  return 1.0 - 2.0 * rgb.xyz;\\n}\\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\\nconst float ShiftRight8 = 1. / 256.;\\nvec4 packDepthToRGBA( const in float v ) {\\n\tvec4 r = vec4( fract( v * PackFactors ), v );\\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\\n}\\nfloat unpackRGBAToDepth( const in vec4 v ) {\\n\treturn dot( v, UnpackFactors );\\n}\\nfloat viewZToOrthoDepth( const in float viewZ, const in float near, const in float far ) {\\n  return ( viewZ + near ) / ( near - far );\\n}\\nfloat OrthoDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\\n  return linearClipZ * ( near - far ) - near;\\n}\\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\\n}\\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/premultiplied_alpha_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'premultiplied_alpha_fragment' ] = \"#ifdef PREMULTIPLIED_ALPHA\\n\tgl_FragColor.rgb *= gl_FragColor.a;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/project_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'project_vertex' ] = \"#ifdef USE_SKINNING\\n\tvec4 mvPosition = modelViewMatrix * skinned;\\n#else\\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\\n#endif\\ngl_Position = projectionMatrix * mvPosition;\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/roughnessmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'roughnessmap_fragment' ] = \"float roughnessFactor = roughness;\\n#ifdef USE_ROUGHNESSMAP\\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\troughnessFactor *= texelRoughness.r;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/roughnessmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'roughnessmap_pars_fragment' ] = \"#ifdef USE_ROUGHNESSMAP\\n\tuniform sampler2D roughnessMap;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmap_pars_fragment' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\t#endif\\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\\n\t}\\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\\n\t\tvec2 f = fract( uv * size + 0.5 );\\n\t\tfloat a = mix( lb, lt, f.y );\\n\t\tfloat b = mix( rb, rt, f.y );\\n\t\tfloat c = mix( a, b, f.x );\\n\t\treturn c;\\n\t}\\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\t\tshadowCoord.xyz /= shadowCoord.w;\\n\t\tshadowCoord.z += shadowBias;\\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\\n\t\tbool inFrustum = all( inFrustumVec );\\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\\n\t\tbool frustumTest = all( frustumTestVec );\\n\t\tif ( frustumTest ) {\\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\\n\t\t\treturn (\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\\n\t\t\treturn (\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#else\\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\\n\t\t#endif\\n\t\t}\\n\t\treturn 1.0;\\n\t}\\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\\n\t\tvec3 absV = abs( v );\\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\\n\t\tabsV *= scaleToCube;\\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\\n\t\tvec2 planar = v.xy;\\n\t\tfloat almostATexel = 1.5 * texelSizeY;\\n\t\tfloat almostOne = 1.0 - almostATexel;\\n\t\tif ( absV.z >= almostOne ) {\\n\t\t\tif ( v.z > 0.0 )\\n\t\t\t\tplanar.x = 4.0 - v.x;\\n\t\t} else if ( absV.x >= almostOne ) {\\n\t\t\tfloat signX = sign( v.x );\\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\\n\t\t} else if ( absV.y >= almostOne ) {\\n\t\t\tfloat signY = sign( v.y );\\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\\n\t\t\tplanar.y = v.z * signY - 2.0;\\n\t\t}\\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\\n\t}\\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\\n\t\tvec3 lightToPosition = shadowCoord.xyz;\\n\t\tvec3 bd3D = normalize( lightToPosition );\\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\\n\t\t\treturn (\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\\n\t\t\t) * ( 1.0 / 9.0 );\\n\t\t#else\\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\\n\t\t#endif\\n\t}\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmap_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmap_pars_vertex' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmap_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmap_vertex' ] = \"#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\\n\t}\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/shadowmask_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadowmask_pars_fragment' ] = \"float getShadowMask() {\\n\tfloat shadow = 1.0;\\n\t#ifdef USE_SHADOWMAP\\n\t#if NUM_DIR_LIGHTS > 0\\n\tDirectionalLight directionalLight;\\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\\n\t\tdirectionalLight = directionalLights[ i ];\\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#if NUM_SPOT_LIGHTS > 0\\n\tSpotLight spotLight;\\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\\n\t\tspotLight = spotLights[ i ];\\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#if NUM_POINT_LIGHTS > 0\\n\tPointLight pointLight;\\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\\n\t\tpointLight = pointLights[ i ];\\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\\n\t}\\n\t#endif\\n\t#endif\\n\treturn shadow;\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinbase_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinbase_vertex' ] = \"#ifdef USE_SKINNING\\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinning_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinning_pars_vertex' ] = \"#ifdef USE_SKINNING\\n\tuniform mat4 bindMatrix;\\n\tuniform mat4 bindMatrixInverse;\\n\t#ifdef BONE_TEXTURE\\n\t\tuniform sampler2D boneTexture;\\n\t\tuniform int boneTextureWidth;\\n\t\tuniform int boneTextureHeight;\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\t\t\tfloat j = i * 4.0;\\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\\n\t\t\ty = dy * ( y + 0.5 );\\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\\n\t\t\treturn bone;\\n\t\t}\\n\t#else\\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\\n\t\tmat4 getBoneMatrix( const in float i ) {\\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\\n\t\t\treturn bone;\\n\t\t}\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinning_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinning_vertex' ] = \"#ifdef USE_SKINNING\\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\\n\tvec4 skinned = vec4( 0.0 );\\n\tskinned += boneMatX * skinVertex * skinWeight.x;\\n\tskinned += boneMatY * skinVertex * skinWeight.y;\\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\\n\tskinned += boneMatW * skinVertex * skinWeight.w;\\n\tskinned  = bindMatrixInverse * skinned;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/skinnormal_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'skinnormal_vertex' ] = \"#ifdef USE_SKINNING\\n\tmat4 skinMatrix = mat4( 0.0 );\\n\tskinMatrix += skinWeight.x * boneMatX;\\n\tskinMatrix += skinWeight.y * boneMatY;\\n\tskinMatrix += skinWeight.z * boneMatZ;\\n\tskinMatrix += skinWeight.w * boneMatW;\\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/specularmap_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'specularmap_fragment' ] = \"float specularStrength;\\n#ifdef USE_SPECULARMAP\\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\\n\tspecularStrength = texelSpecular.r;\\n#else\\n\tspecularStrength = 1.0;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/specularmap_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'specularmap_pars_fragment' ] = \"#ifdef USE_SPECULARMAP\\n\tuniform sampler2D specularMap;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/tonemapping_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'tonemapping_fragment' ] = \"#if defined( TONE_MAPPING )\\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/tonemapping_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'tonemapping_pars_fragment' ] = \"#define saturate(a) clamp( a, 0.0, 1.0 )\\nuniform float toneMappingExposure;\\nuniform float toneMappingWhitePoint;\\nvec3 LinearToneMapping( vec3 color ) {\\n  return toneMappingExposure * color;\\n}\\nvec3 ReinhardToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( color / ( vec3( 1.0 ) + color ) );\\n}\\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\\nvec3 Uncharted2ToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\\n}\\nvec3 OptimizedCineonToneMapping( vec3 color ) {\\n  color *= toneMappingExposure;\\n  color = max( vec3( 0.0 ), color - 0.004 );\\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/uv2_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'uv2_pars_fragment' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tvarying vec2 vUv2;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/uv2_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'uv2_pars_vertex' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tattribute vec2 uv2;\\n\tvarying vec2 vUv2;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/uv2_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'uv2_vertex' ] = \"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\\n\tvUv2 = uv2;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/uv_pars_fragment.glsl\r\n\r\nTHREE.ShaderChunk[ 'uv_pars_fragment' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvarying vec2 vUv;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/uv_pars_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'uv_pars_vertex' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvarying vec2 vUv;\\n\tuniform vec4 offsetRepeat;\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/uv_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'uv_vertex' ] = \"#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\\n#endif\";\r\n\r\n// File:src/renderers/shaders/ShaderChunk/worldpos_vertex.glsl\r\n\r\nTHREE.ShaderChunk[ 'worldpos_vertex' ] = \"#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\\n\t#ifdef USE_SKINNING\\n\t\tvec4 worldPosition = modelMatrix * skinned;\\n\t#else\\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\\n\t#endif\\n#endif\\n\";\r\n\r\n// File:src/renderers/shaders/UniformsUtils.js\r\n\r\n/**\r\n * Uniform Utilities\r\n */\r\n\r\nTHREE.UniformsUtils = {\r\n\r\n\tmerge: function ( uniforms ) {\r\n\r\n\t\tvar merged = {};\r\n\r\n\t\tfor ( var u = 0; u < uniforms.length; u ++ ) {\r\n\r\n\t\t\tvar tmp = this.clone( uniforms[ u ] );\r\n\r\n\t\t\tfor ( var p in tmp ) {\r\n\r\n\t\t\t\tmerged[ p ] = tmp[ p ];\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn merged;\r\n\r\n\t},\r\n\r\n\tclone: function ( uniforms_src ) {\r\n\r\n\t\tvar uniforms_dst = {};\r\n\r\n\t\tfor ( var u in uniforms_src ) {\r\n\r\n\t\t\tuniforms_dst[ u ] = {};\r\n\r\n\t\t\tfor ( var p in uniforms_src[ u ] ) {\r\n\r\n\t\t\t\tvar parameter_src = uniforms_src[ u ][ p ];\r\n\r\n\t\t\t\tif ( parameter_src instanceof THREE.Color ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Vector2 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Vector3 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Vector4 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Matrix3 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Matrix4 ||\r\n\t\t\t\t\t parameter_src instanceof THREE.Texture ) {\r\n\r\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.clone();\r\n\r\n\t\t\t\t} else if ( Array.isArray( parameter_src ) ) {\r\n\r\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src.slice();\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tuniforms_dst[ u ][ p ] = parameter_src;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn uniforms_dst;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/renderers/shaders/UniformsLib.js\r\n\r\n/**\r\n * Uniforms library for shared webgl shaders\r\n */\r\n\r\nTHREE.UniformsLib = {\r\n\r\n\tcommon: {\r\n\r\n\t\t\"diffuse\": { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n\t\t\"opacity\": { type: \"1f\", value: 1.0 },\r\n\r\n\t\t\"map\": { type: \"t\", value: null },\r\n\t\t\"offsetRepeat\": { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) },\r\n\r\n\t\t\"specularMap\": { type: \"t\", value: null },\r\n\t\t\"alphaMap\": { type: \"t\", value: null },\r\n\r\n\t\t\"envMap\": { type: \"t\", value: null },\r\n\t\t\"flipEnvMap\": { type: \"1f\", value: - 1 },\r\n\t\t\"reflectivity\": { type: \"1f\", value: 1.0 },\r\n\t\t\"refractionRatio\": { type: \"1f\", value: 0.98 }\r\n\r\n\t},\r\n\r\n\taomap: {\r\n\r\n\t\t\"aoMap\": { type: \"t\", value: null },\r\n\t\t\"aoMapIntensity\": { type: \"1f\", value: 1 }\r\n\r\n\t},\r\n\r\n\tlightmap: {\r\n\r\n\t\t\"lightMap\": { type: \"t\", value: null },\r\n\t\t\"lightMapIntensity\": { type: \"1f\", value: 1 }\r\n\r\n\t},\r\n\r\n\temissivemap: {\r\n\r\n\t\t\"emissiveMap\": { type: \"t\", value: null }\r\n\r\n\t},\r\n\r\n\tbumpmap: {\r\n\r\n\t\t\"bumpMap\": { type: \"t\", value: null },\r\n\t\t\"bumpScale\": { type: \"1f\", value: 1 }\r\n\r\n\t},\r\n\r\n\tnormalmap: {\r\n\r\n\t\t\"normalMap\": { type: \"t\", value: null },\r\n\t\t\"normalScale\": { type: \"v2\", value: new THREE.Vector2( 1, 1 ) }\r\n\r\n\t},\r\n\r\n\tdisplacementmap: {\r\n\r\n\t\t\"displacementMap\": { type: \"t\", value: null },\r\n\t\t\"displacementScale\": { type: \"1f\", value: 1 },\r\n\t\t\"displacementBias\": { type: \"1f\", value: 0 }\r\n\r\n\t},\r\n\r\n\troughnessmap: {\r\n\r\n\t\t\"roughnessMap\": { type: \"t\", value: null }\r\n\r\n\t},\r\n\r\n\tmetalnessmap: {\r\n\r\n\t\t\"metalnessMap\": { type: \"t\", value: null }\r\n\r\n\t},\r\n\r\n\tfog: {\r\n\r\n\t\t\"fogDensity\": { type: \"1f\", value: 0.00025 },\r\n\t\t\"fogNear\": { type: \"1f\", value: 1 },\r\n\t\t\"fogFar\": { type: \"1f\", value: 2000 },\r\n\t\t\"fogColor\": { type: \"c\", value: new THREE.Color( 0xffffff ) }\r\n\r\n\t},\r\n\r\n\tlights: {\r\n\r\n\t\t\"ambientLightColor\": { type: \"3fv\", value: [] },\r\n\r\n\t\t\"directionalLights\": { type: \"sa\", value: [], properties: {\r\n\t\t\t\"direction\": { type: \"v3\" },\r\n\t\t\t\"color\": { type: \"c\" },\r\n\r\n\t\t\t\"shadow\": { type: \"1i\" },\r\n\t\t\t\"shadowBias\": { type: \"1f\" },\r\n\t\t\t\"shadowRadius\": { type: \"1f\" },\r\n\t\t\t\"shadowMapSize\": { type: \"v2\" }\r\n\t\t} },\r\n\r\n\t\t\"directionalShadowMap\": { type: \"tv\", value: [] },\r\n\t\t\"directionalShadowMatrix\": { type: \"m4v\", value: [] },\r\n\r\n\t\t\"spotLights\": { type: \"sa\", value: [], properties: {\r\n\t\t\t\"color\": { type: \"c\" },\r\n\t\t\t\"position\": { type: \"v3\" },\r\n\t\t\t\"direction\": { type: \"v3\" },\r\n\t\t\t\"distance\": { type: \"1f\" },\r\n\t\t\t\"coneCos\": { type: \"1f\" },\r\n\t\t\t\"penumbraCos\": { type: \"1f\" },\r\n\t\t\t\"decay\": { type: \"1f\" },\r\n\r\n\t\t\t\"shadow\": { type: \"1i\" },\r\n\t\t\t\"shadowBias\": { type: \"1f\" },\r\n\t\t\t\"shadowRadius\": { type: \"1f\" },\r\n\t\t\t\"shadowMapSize\": { type: \"v2\" }\r\n\t\t} },\r\n\r\n\t\t\"spotShadowMap\": { type: \"tv\", value: [] },\r\n\t\t\"spotShadowMatrix\": { type: \"m4v\", value: [] },\r\n\r\n\t\t\"pointLights\": { type: \"sa\", value: [], properties: {\r\n\t\t\t\"color\": { type: \"c\" },\r\n\t\t\t\"position\": { type: \"v3\" },\r\n\t\t\t\"decay\": { type: \"1f\" },\r\n\t\t\t\"distance\": { type: \"1f\" },\r\n\r\n\t\t\t\"shadow\": { type: \"1i\" },\r\n\t\t\t\"shadowBias\": { type: \"1f\" },\r\n\t\t\t\"shadowRadius\": { type: \"1f\" },\r\n\t\t\t\"shadowMapSize\": { type: \"v2\" }\r\n\t\t} },\r\n\r\n\t\t\"pointShadowMap\": { type: \"tv\", value: [] },\r\n\t\t\"pointShadowMatrix\": { type: \"m4v\", value: [] },\r\n\r\n\t\t\"hemisphereLights\": { type: \"sa\", value: [], properties: {\r\n\t\t\t\"direction\": { type: \"v3\" },\r\n\t\t\t\"skyColor\": { type: \"c\" },\r\n\t\t\t\"groundColor\": { type: \"c\" }\r\n\t\t} }\r\n\r\n\t},\r\n\r\n\tpoints: {\r\n\r\n\t\t\"diffuse\": { type: \"c\", value: new THREE.Color( 0xeeeeee ) },\r\n\t\t\"opacity\": { type: \"1f\", value: 1.0 },\r\n\t\t\"size\": { type: \"1f\", value: 1.0 },\r\n\t\t\"scale\": { type: \"1f\", value: 1.0 },\r\n\t\t\"map\": { type: \"t\", value: null },\r\n\t\t\"offsetRepeat\": { type: \"v4\", value: new THREE.Vector4( 0, 0, 1, 1 ) }\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/renderers/shaders/ShaderLib/cube_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'cube_frag' ] = \"uniform samplerCube tCube;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/cube_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'cube_vert' ] = \"varying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvWorldPosition = transformDirection( position, modelMatrix );\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/depth_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'depth_frag' ] = \"#if DEPTH_PACKING == 3200\\n\tuniform float opacity;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <uv_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( 1.0 );\\n\t#if DEPTH_PACKING == 3200\\n\t\tdiffuseColor.a = opacity;\\n\t#endif\\n\t#include <map_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <logdepthbuf_fragment>\\n\t#if DEPTH_PACKING == 3200\\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\\n\t#elif DEPTH_PACKING == 3201\\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\\n\t#endif\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/depth_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'depth_vert' ] = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/distanceRGBA_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'distanceRGBA_frag' ] = \"uniform vec3 lightPos;\\nvarying vec4 vWorldPosition;\\n#include <common>\\n#include <packing>\\n#include <clipping_planes_pars_fragment>\\nvoid main () {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/distanceRGBA_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'distanceRGBA_vert' ] = \"varying vec4 vWorldPosition;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <skinbase_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvWorldPosition = worldPosition;\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/equirect_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'equirect_frag' ] = \"uniform sampler2D tEquirect;\\nuniform float tFlip;\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec3 direction = normalize( vWorldPosition );\\n\tvec2 sampleUV;\\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/equirect_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'equirect_vert' ] = \"varying vec3 vWorldPosition;\\n#include <common>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvWorldPosition = transformDirection( position, modelMatrix );\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/linedashed_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'linedashed_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\nuniform float dashSize;\\nuniform float totalSize;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\\n\t\tdiscard;\\n\t}\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <color_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/linedashed_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'linedashed_vert' ] = \"uniform float scale;\\nattribute float lineDistance;\\nvarying float vLineDistance;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <color_vertex>\\n\tvLineDistance = scale * lineDistance;\\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\\n\tgl_Position = projectionMatrix * mvPosition;\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/meshbasic_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'meshbasic_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\tReflectedLight reflectedLight;\\n\treflectedLight.directDiffuse = vec3( 0.0 );\\n\treflectedLight.directSpecular = vec3( 0.0 );\\n\treflectedLight.indirectDiffuse = diffuseColor.rgb;\\n\treflectedLight.indirectSpecular = vec3( 0.0 );\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/meshbasic_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'meshbasic_vert' ] = \"#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <skinbase_vertex>\\n\t#ifdef USE_ENVMAP\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#endif\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <envmap_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/meshlambert_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'meshlambert_frag' ] = \"uniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float opacity;\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <emissivemap_fragment>\\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\\n\t#include <lightmap_fragment>\\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\\n\t#ifdef DOUBLE_SIDED\\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\\n\t#else\\n\t\treflectedLight.directDiffuse = vLightFront;\\n\t#endif\\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/meshlambert_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'meshlambert_vert' ] = \"#define LAMBERT\\nvarying vec3 vLightFront;\\n#ifdef DOUBLE_SIDED\\n\tvarying vec3 vLightBack;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <lights_lambert_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/meshphong_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'meshphong_frag' ] = \"#define PHONG\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform vec3 specular;\\nuniform float shininess;\\nuniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <lights_phong_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <normal_fragment>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_phong_fragment>\\n\t#include <lights_template>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\t#include <envmap_fragment>\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/meshphong_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'meshphong_vert' ] = \"#define PHONG\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <envmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n#endif\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <envmap_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/meshphysical_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'meshphysical_frag' ] = \"#define PHYSICAL\\nuniform vec3 diffuse;\\nuniform vec3 emissive;\\nuniform float roughness;\\nuniform float metalness;\\nuniform float opacity;\\nuniform float envMapIntensity;\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <packing>\\n#include <color_pars_fragment>\\n#include <uv_pars_fragment>\\n#include <uv2_pars_fragment>\\n#include <map_pars_fragment>\\n#include <alphamap_pars_fragment>\\n#include <aomap_pars_fragment>\\n#include <lightmap_pars_fragment>\\n#include <emissivemap_pars_fragment>\\n#include <envmap_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <bsdfs>\\n#include <cube_uv_reflection_fragment>\\n#include <lights_pars>\\n#include <lights_physical_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <bumpmap_pars_fragment>\\n#include <normalmap_pars_fragment>\\n#include <roughnessmap_pars_fragment>\\n#include <metalnessmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\\n\tvec3 totalEmissiveRadiance = emissive;\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_fragment>\\n\t#include <color_fragment>\\n\t#include <alphamap_fragment>\\n\t#include <alphatest_fragment>\\n\t#include <specularmap_fragment>\\n\t#include <roughnessmap_fragment>\\n\t#include <metalnessmap_fragment>\\n\t#include <normal_fragment>\\n\t#include <emissivemap_fragment>\\n\t#include <lights_physical_fragment>\\n\t#include <lights_template>\\n\t#include <aomap_fragment>\\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/meshphysical_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'meshphysical_vert' ] = \"#define PHYSICAL\\nvarying vec3 vViewPosition;\\n#ifndef FLAT_SHADED\\n\tvarying vec3 vNormal;\\n#endif\\n#include <common>\\n#include <uv_pars_vertex>\\n#include <uv2_pars_vertex>\\n#include <displacementmap_pars_vertex>\\n#include <color_pars_vertex>\\n#include <morphtarget_pars_vertex>\\n#include <skinning_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <specularmap_pars_fragment>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <uv_vertex>\\n\t#include <uv2_vertex>\\n\t#include <color_vertex>\\n\t#include <beginnormal_vertex>\\n\t#include <morphnormal_vertex>\\n\t#include <skinbase_vertex>\\n\t#include <skinnormal_vertex>\\n\t#include <defaultnormal_vertex>\\n#ifndef FLAT_SHADED\\n\tvNormal = normalize( transformedNormal );\\n#endif\\n\t#include <begin_vertex>\\n\t#include <displacementmap_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <skinning_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\tvViewPosition = - mvPosition.xyz;\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/normal_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'normal_frag' ] = \"uniform float opacity;\\nvarying vec3 vNormal;\\n#include <common>\\n#include <packing>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tgl_FragColor = vec4( packNormalToRGB( vNormal ), opacity );\\n\t#include <logdepthbuf_fragment>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/normal_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'normal_vert' ] = \"varying vec3 vNormal;\\n#include <common>\\n#include <morphtarget_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\tvNormal = normalize( normalMatrix * normal );\\n\t#include <begin_vertex>\\n\t#include <morphtarget_vertex>\\n\t#include <project_vertex>\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/points_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'points_frag' ] = \"uniform vec3 diffuse;\\nuniform float opacity;\\n#include <common>\\n#include <color_pars_fragment>\\n#include <map_particle_pars_fragment>\\n#include <fog_pars_fragment>\\n#include <shadowmap_pars_fragment>\\n#include <logdepthbuf_pars_fragment>\\n#include <clipping_planes_pars_fragment>\\nvoid main() {\\n\t#include <clipping_planes_fragment>\\n\tvec3 outgoingLight = vec3( 0.0 );\\n\tvec4 diffuseColor = vec4( diffuse, opacity );\\n\t#include <logdepthbuf_fragment>\\n\t#include <map_particle_fragment>\\n\t#include <color_fragment>\\n\t#include <alphatest_fragment>\\n\toutgoingLight = diffuseColor.rgb;\\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\\n\t#include <premultiplied_alpha_fragment>\\n\t#include <tonemapping_fragment>\\n\t#include <encodings_fragment>\\n\t#include <fog_fragment>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/points_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'points_vert' ] = \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <color_pars_vertex>\\n#include <shadowmap_pars_vertex>\\n#include <logdepthbuf_pars_vertex>\\n#include <clipping_planes_pars_vertex>\\nvoid main() {\\n\t#include <color_vertex>\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#ifdef USE_SIZEATTENUATION\\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\\n\t#else\\n\t\tgl_PointSize = size;\\n\t#endif\\n\t#include <logdepthbuf_vertex>\\n\t#include <clipping_planes_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/shadow_frag.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadow_frag' ] = \"uniform float opacity;\\n#include <common>\\n#include <packing>\\n#include <bsdfs>\\n#include <lights_pars>\\n#include <shadowmap_pars_fragment>\\n#include <shadowmask_pars_fragment>\\nvoid main() {\\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib/shadow_vert.glsl\r\n\r\nTHREE.ShaderChunk[ 'shadow_vert' ] = \"#include <shadowmap_pars_vertex>\\nvoid main() {\\n\t#include <begin_vertex>\\n\t#include <project_vertex>\\n\t#include <worldpos_vertex>\\n\t#include <shadowmap_vertex>\\n}\\n\";\r\n\r\n// File:src/renderers/shaders/ShaderLib.js\r\n\r\n/**\r\n * Webgl Shader Library for three.js\r\n *\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author mikael emtinger / http://gomo.se/\r\n */\r\n\r\n\r\nTHREE.ShaderLib = {\r\n\r\n\t'basic': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ 'common' ],\r\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\r\n\t\t\tTHREE.UniformsLib[ 'fog' ]\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: THREE.ShaderChunk[ 'meshbasic_vert' ],\r\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshbasic_frag' ]\r\n\r\n\t},\r\n\r\n\t'lambert': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ 'common' ],\r\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\r\n\t\t\tTHREE.UniformsLib[ 'lightmap' ],\r\n\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\r\n\t\t\tTHREE.UniformsLib[ 'fog' ],\r\n\t\t\tTHREE.UniformsLib[ 'lights' ],\r\n\r\n\t\t\t{\r\n\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) }\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: THREE.ShaderChunk[ 'meshlambert_vert' ],\r\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshlambert_frag' ]\r\n\r\n\t},\r\n\r\n\t'phong': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ 'common' ],\r\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\r\n\t\t\tTHREE.UniformsLib[ 'lightmap' ],\r\n\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\r\n\t\t\tTHREE.UniformsLib[ 'bumpmap' ],\r\n\t\t\tTHREE.UniformsLib[ 'normalmap' ],\r\n\t\t\tTHREE.UniformsLib[ 'displacementmap' ],\r\n\t\t\tTHREE.UniformsLib[ 'fog' ],\r\n\t\t\tTHREE.UniformsLib[ 'lights' ],\r\n\r\n\t\t\t{\r\n\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n\t\t\t\t\"specular\" : { type: \"c\", value: new THREE.Color( 0x111111 ) },\r\n\t\t\t\t\"shininess\": { type: \"1f\", value: 30 }\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: THREE.ShaderChunk[ 'meshphong_vert' ],\r\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshphong_frag' ]\r\n\r\n\t},\r\n\r\n\t'standard': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ 'common' ],\r\n\t\t\tTHREE.UniformsLib[ 'aomap' ],\r\n\t\t\tTHREE.UniformsLib[ 'lightmap' ],\r\n\t\t\tTHREE.UniformsLib[ 'emissivemap' ],\r\n\t\t\tTHREE.UniformsLib[ 'bumpmap' ],\r\n\t\t\tTHREE.UniformsLib[ 'normalmap' ],\r\n\t\t\tTHREE.UniformsLib[ 'displacementmap' ],\r\n\t\t\tTHREE.UniformsLib[ 'roughnessmap' ],\r\n\t\t\tTHREE.UniformsLib[ 'metalnessmap' ],\r\n\t\t\tTHREE.UniformsLib[ 'fog' ],\r\n\t\t\tTHREE.UniformsLib[ 'lights' ],\r\n\r\n\t\t\t{\r\n\t\t\t\t\"emissive\" : { type: \"c\", value: new THREE.Color( 0x000000 ) },\r\n\t\t\t\t\"roughness\": { type: \"1f\", value: 0.5 },\r\n\t\t\t\t\"metalness\": { type: \"1f\", value: 0 },\r\n\t\t\t\t\"envMapIntensity\" : { type: \"1f\", value: 1 } // temporary\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: THREE.ShaderChunk[ 'meshphysical_vert' ],\r\n\t\tfragmentShader: THREE.ShaderChunk[ 'meshphysical_frag' ]\r\n\r\n\t},\r\n\r\n\t'points': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ 'points' ],\r\n\t\t\tTHREE.UniformsLib[ 'fog' ]\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: THREE.ShaderChunk[ 'points_vert' ],\r\n\t\tfragmentShader: THREE.ShaderChunk[ 'points_frag' ]\r\n\r\n\t},\r\n\r\n\t'dashed': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ 'common' ],\r\n\t\t\tTHREE.UniformsLib[ 'fog' ],\r\n\r\n\t\t\t{\r\n\t\t\t\t\"scale\"    : { type: \"1f\", value: 1 },\r\n\t\t\t\t\"dashSize\" : { type: \"1f\", value: 1 },\r\n\t\t\t\t\"totalSize\": { type: \"1f\", value: 2 }\r\n\t\t\t}\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: THREE.ShaderChunk[ 'linedashed_vert' ],\r\n\t\tfragmentShader: THREE.ShaderChunk[ 'linedashed_frag' ]\r\n\r\n\t},\r\n\r\n\t'depth': {\r\n\r\n\t\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\t\tTHREE.UniformsLib[ 'common' ],\r\n\t\t\tTHREE.UniformsLib[ 'displacementmap' ]\r\n\r\n\t\t] ),\r\n\r\n\t\tvertexShader: THREE.ShaderChunk[ 'depth_vert' ],\r\n\t\tfragmentShader: THREE.ShaderChunk[ 'depth_frag' ]\r\n\r\n\t},\r\n\r\n\t'normal': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"opacity\" : { type: \"1f\", value: 1.0 }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: THREE.ShaderChunk[ 'normal_vert' ],\r\n\t\tfragmentShader: THREE.ShaderChunk[ 'normal_frag' ]\r\n\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tCube map shader\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'cube': {\r\n\r\n\t\tuniforms: {\r\n\t\t\t\"tCube\": { type: \"t\", value: null },\r\n\t\t\t\"tFlip\": { type: \"1f\", value: - 1 }\r\n\t\t},\r\n\r\n\t\tvertexShader: THREE.ShaderChunk[ 'cube_vert' ],\r\n\t\tfragmentShader: THREE.ShaderChunk[ 'cube_frag' ]\r\n\r\n\t},\r\n\r\n\t/* -------------------------------------------------------------------------\r\n\t//\tCube map shader\r\n\t ------------------------------------------------------------------------- */\r\n\r\n\t'equirect': {\r\n\r\n\t\tuniforms: {\r\n\t\t\t\"tEquirect\": { type: \"t\", value: null },\r\n\t\t\t\"tFlip\": { type: \"1f\", value: - 1 }\r\n\t\t},\r\n\r\n\t\tvertexShader: THREE.ShaderChunk[ 'equirect_vert' ],\r\n\t\tfragmentShader: THREE.ShaderChunk[ 'equirect_frag' ]\r\n\r\n\t},\r\n\r\n\t'distanceRGBA': {\r\n\r\n\t\tuniforms: {\r\n\r\n\t\t\t\"lightPos\": { type: \"v3\", value: new THREE.Vector3() }\r\n\r\n\t\t},\r\n\r\n\t\tvertexShader: THREE.ShaderChunk[ 'distanceRGBA_vert' ],\r\n\t\tfragmentShader: THREE.ShaderChunk[ 'distanceRGBA_frag' ]\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.ShaderLib[ 'physical' ] = {\r\n\r\n\tuniforms: THREE.UniformsUtils.merge( [\r\n\r\n\t\tTHREE.ShaderLib[ 'standard' ].uniforms,\r\n\r\n\t\t{\r\n\t\t\t// future\r\n\t\t}\r\n\r\n\t] ),\r\n\r\n\tvertexShader: THREE.ShaderChunk[ 'meshphysical_vert' ],\r\n\tfragmentShader: THREE.ShaderChunk[ 'meshphysical_frag' ]\r\n\r\n};\r\n\r\n\r\n// File:src/renderers/WebGLRenderer.js\r\n\r\n/**\r\n * @author supereggbert / http://www.paulbrunt.co.uk/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author szimek / https://github.com/szimek/\r\n * @author tschw\r\n */\r\n\r\nTHREE.WebGLRenderer = function ( parameters ) {\r\n\r\n\tconsole.log( 'THREE.WebGLRenderer', THREE.REVISION );\r\n\r\n\tparameters = parameters || {};\r\n\r\n\tvar _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElement( 'canvas' ),\r\n\t_context = parameters.context !== undefined ? parameters.context : null,\r\n\r\n\t_alpha = parameters.alpha !== undefined ? parameters.alpha : false,\r\n\t_depth = parameters.depth !== undefined ? parameters.depth : true,\r\n\t_stencil = parameters.stencil !== undefined ? parameters.stencil : true,\r\n\t_antialias = parameters.antialias !== undefined ? parameters.antialias : false,\r\n\t_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,\r\n\t_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;\r\n\r\n\tvar lights = [];\r\n\r\n\tvar opaqueObjects = [];\r\n\tvar opaqueObjectsLastIndex = - 1;\r\n\tvar transparentObjects = [];\r\n\tvar transparentObjectsLastIndex = - 1;\r\n\r\n\tvar morphInfluences = new Float32Array( 8 );\r\n\r\n\tvar sprites = [];\r\n\tvar lensFlares = [];\r\n\r\n\t// public properties\r\n\r\n\tthis.domElement = _canvas;\r\n\tthis.context = null;\r\n\r\n\t// clearing\r\n\r\n\tthis.autoClear = true;\r\n\tthis.autoClearColor = true;\r\n\tthis.autoClearDepth = true;\r\n\tthis.autoClearStencil = true;\r\n\r\n\t// scene graph\r\n\r\n\tthis.sortObjects = true;\r\n\r\n\t// user-defined clipping\r\n\r\n\tthis.clippingPlanes = [];\r\n\tthis.localClippingEnabled = false;\r\n\r\n\t// physically based shading\r\n\r\n\tthis.gammaFactor = 2.0;\t// for backwards compatibility\r\n\tthis.gammaInput = false;\r\n\tthis.gammaOutput = false;\r\n\r\n\t// physical lights\r\n\r\n\tthis.physicallyCorrectLights = false;\r\n\r\n\t// tone mapping\r\n\r\n\tthis.toneMapping = THREE.LinearToneMapping;\r\n\tthis.toneMappingExposure = 1.0;\r\n\tthis.toneMappingWhitePoint = 1.0;\r\n\r\n\t// morphs\r\n\r\n\tthis.maxMorphTargets = 8;\r\n\tthis.maxMorphNormals = 4;\r\n\r\n\t// flags\r\n\r\n\tthis.autoScaleCubemaps = true;\r\n\r\n\t// internal properties\r\n\r\n\tvar _this = this,\r\n\r\n\t// internal state cache\r\n\r\n\t_currentProgram = null,\r\n\t_currentRenderTarget = null,\r\n\t_currentFramebuffer = null,\r\n\t_currentMaterialId = - 1,\r\n\t_currentGeometryProgram = '',\r\n\t_currentCamera = null,\r\n\r\n\t_currentScissor = new THREE.Vector4(),\r\n\t_currentScissorTest = null,\r\n\r\n\t_currentViewport = new THREE.Vector4(),\r\n\r\n\t//\r\n\r\n\t_usedTextureUnits = 0,\r\n\r\n\t//\r\n\r\n\t_clearColor = new THREE.Color( 0x000000 ),\r\n\t_clearAlpha = 0,\r\n\r\n\t_width = _canvas.width,\r\n\t_height = _canvas.height,\r\n\r\n\t_pixelRatio = 1,\r\n\r\n\t_scissor = new THREE.Vector4( 0, 0, _width, _height ),\r\n\t_scissorTest = false,\r\n\r\n\t_viewport = new THREE.Vector4( 0, 0, _width, _height ),\r\n\r\n\t// frustum\r\n\r\n\t_frustum = new THREE.Frustum(),\r\n\r\n\t// clipping\r\n\r\n\t_clipping = new THREE.WebGLClipping(),\r\n\t_clippingEnabled = false,\r\n\t_localClippingEnabled = false,\r\n\r\n\t_sphere = new THREE.Sphere(),\r\n\r\n\t// camera matrices cache\r\n\r\n\t_projScreenMatrix = new THREE.Matrix4(),\r\n\r\n\t_vector3 = new THREE.Vector3(),\r\n\r\n\t// light arrays cache\r\n\r\n\t_lights = {\r\n\r\n\t\thash: '',\r\n\r\n\t\tambient: [ 0, 0, 0 ],\r\n\t\tdirectional: [],\r\n\t\tdirectionalShadowMap: [],\r\n\t\tdirectionalShadowMatrix: [],\r\n\t\tspot: [],\r\n\t\tspotShadowMap: [],\r\n\t\tspotShadowMatrix: [],\r\n\t\tpoint: [],\r\n\t\tpointShadowMap: [],\r\n\t\tpointShadowMatrix: [],\r\n\t\themi: [],\r\n\r\n\t\tshadows: []\r\n\r\n\t},\r\n\r\n\t// info\r\n\r\n\t_infoMemory = {\r\n\r\n\t\tgeometries: 0,\r\n\t\ttextures: 0\r\n\r\n\t},\r\n\r\n\t_infoRender = {\r\n\r\n\t\tcalls: 0,\r\n\t\tvertices: 0,\r\n\t\tfaces: 0,\r\n\t\tpoints: 0\r\n\r\n\t};\r\n\r\n\tthis.info = {\r\n\r\n\t\trender: _infoRender,\r\n\t\tmemory: _infoMemory,\r\n\t\tprograms: null\r\n\r\n\t};\r\n\r\n\r\n\t// initialize\r\n\r\n\tvar _gl;\r\n\r\n\ttry {\r\n\r\n\t\tvar attributes = {\r\n\t\t\talpha: _alpha,\r\n\t\t\tdepth: _depth,\r\n\t\t\tstencil: _stencil,\r\n\t\t\tantialias: _antialias,\r\n\t\t\tpremultipliedAlpha: _premultipliedAlpha,\r\n\t\t\tpreserveDrawingBuffer: _preserveDrawingBuffer\r\n\t\t};\r\n\r\n\t\t_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );\r\n\r\n\t\tif ( _gl === null ) {\r\n\r\n\t\t\tif ( _canvas.getContext( 'webgl' ) !== null ) {\r\n\r\n\t\t\t\tthrow 'Error creating WebGL context with your selected attributes.';\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tthrow 'Error creating WebGL context.';\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Some experimental-webgl implementations do not have getShaderPrecisionFormat\r\n\r\n\t\tif ( _gl.getShaderPrecisionFormat === undefined ) {\r\n\r\n\t\t\t_gl.getShaderPrecisionFormat = function () {\r\n\r\n\t\t\t\treturn { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };\r\n\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\t_canvas.addEventListener( 'webglcontextlost', onContextLost, false );\r\n\r\n\t} catch ( error ) {\r\n\r\n\t\tconsole.error( 'THREE.WebGLRenderer: ' + error );\r\n\r\n\t}\r\n\r\n\tvar _isWebGL2 = (typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext);\r\n\tvar extensions = new THREE.WebGLExtensions( _gl );\r\n\r\n\textensions.get( 'WEBGL_depth_texture' );\r\n\textensions.get( 'OES_texture_float' );\r\n\textensions.get( 'OES_texture_float_linear' );\r\n\textensions.get( 'OES_texture_half_float' );\r\n\textensions.get( 'OES_texture_half_float_linear' );\r\n\textensions.get( 'OES_standard_derivatives' );\r\n\textensions.get( 'ANGLE_instanced_arrays' );\r\n\r\n\tif ( extensions.get( 'OES_element_index_uint' ) ) {\r\n\r\n\t\tTHREE.BufferGeometry.MaxIndex = 4294967296;\r\n\r\n\t}\r\n\r\n\tvar capabilities = new THREE.WebGLCapabilities( _gl, extensions, parameters );\r\n\r\n\tvar state = new THREE.WebGLState( _gl, extensions, paramThreeToGL );\r\n\tvar properties = new THREE.WebGLProperties();\r\n\tvar objects = new THREE.WebGLObjects( _gl, properties, this.info );\r\n\tvar programCache = new THREE.WebGLPrograms( this, capabilities );\r\n\tvar lightCache = new THREE.WebGLLights();\r\n\r\n\tthis.info.programs = programCache.programs;\r\n\r\n\tvar bufferRenderer = new THREE.WebGLBufferRenderer( _gl, extensions, _infoRender );\r\n\tvar indexedBufferRenderer = new THREE.WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );\r\n\r\n\t//\r\n\r\n\tfunction getTargetPixelRatio() {\r\n\r\n\t\treturn _currentRenderTarget === null ? _pixelRatio : 1;\r\n\r\n\t}\r\n\r\n\tfunction glClearColor( r, g, b, a ) {\r\n\r\n\t\tif ( _premultipliedAlpha === true ) {\r\n\r\n\t\t\tr *= a; g *= a; b *= a;\r\n\r\n\t\t}\r\n\r\n\t\tstate.clearColor( r, g, b, a );\r\n\r\n\t}\r\n\r\n\tfunction setDefaultGLState() {\r\n\r\n\t\tstate.init();\r\n\r\n\t\tstate.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );\r\n\t\tstate.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );\r\n\r\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n\t}\r\n\r\n\tfunction resetGLState() {\r\n\r\n\t\t_currentProgram = null;\r\n\t\t_currentCamera = null;\r\n\r\n\t\t_currentGeometryProgram = '';\r\n\t\t_currentMaterialId = - 1;\r\n\r\n\t\tstate.reset();\r\n\r\n\t}\r\n\r\n\tsetDefaultGLState();\r\n\r\n\tthis.context = _gl;\r\n\tthis.capabilities = capabilities;\r\n\tthis.extensions = extensions;\r\n\tthis.properties = properties;\r\n\tthis.state = state;\r\n\r\n\t// shadow map\r\n\r\n\tvar shadowMap = new THREE.WebGLShadowMap( this, _lights, objects );\r\n\r\n\tthis.shadowMap = shadowMap;\r\n\r\n\r\n\t// Plugins\r\n\r\n\tvar spritePlugin = new THREE.SpritePlugin( this, sprites );\r\n\tvar lensFlarePlugin = new THREE.LensFlarePlugin( this, lensFlares );\r\n\r\n\t// API\r\n\r\n\tthis.getContext = function () {\r\n\r\n\t\treturn _gl;\r\n\r\n\t};\r\n\r\n\tthis.getContextAttributes = function () {\r\n\r\n\t\treturn _gl.getContextAttributes();\r\n\r\n\t};\r\n\r\n\tthis.forceContextLoss = function () {\r\n\r\n\t\textensions.get( 'WEBGL_lose_context' ).loseContext();\r\n\r\n\t};\r\n\r\n\tthis.getMaxAnisotropy = ( function () {\r\n\r\n\t\tvar value;\r\n\r\n\t\treturn function getMaxAnisotropy() {\r\n\r\n\t\t\tif ( value !== undefined ) return value;\r\n\r\n\t\t\tvar extension = extensions.get( 'EXT_texture_filter_anisotropic' );\r\n\r\n\t\t\tif ( extension !== null ) {\r\n\r\n\t\t\t\tvalue = _gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tvalue = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn value;\r\n\r\n\t\t};\r\n\r\n\t} )();\r\n\r\n\tthis.getPrecision = function () {\r\n\r\n\t\treturn capabilities.precision;\r\n\r\n\t};\r\n\r\n\tthis.getPixelRatio = function () {\r\n\r\n\t\treturn _pixelRatio;\r\n\r\n\t};\r\n\r\n\tthis.setPixelRatio = function ( value ) {\r\n\r\n\t\tif ( value === undefined ) return;\r\n\r\n\t\t_pixelRatio = value;\r\n\r\n\t\tthis.setSize( _viewport.z, _viewport.w, false );\r\n\r\n\t};\r\n\r\n\tthis.getSize = function () {\r\n\r\n\t\treturn {\r\n\t\t\twidth: _width,\r\n\t\t\theight: _height\r\n\t\t};\r\n\r\n\t};\r\n\r\n\tthis.setSize = function ( width, height, updateStyle ) {\r\n\r\n\t\t_width = width;\r\n\t\t_height = height;\r\n\r\n\t\t_canvas.width = width * _pixelRatio;\r\n\t\t_canvas.height = height * _pixelRatio;\r\n\r\n\t\tif ( updateStyle !== false ) {\r\n\r\n\t\t\t_canvas.style.width = width + 'px';\r\n\t\t\t_canvas.style.height = height + 'px';\r\n\r\n\t\t}\r\n\r\n\t\tthis.setViewport( 0, 0, width, height );\r\n\r\n\t};\r\n\r\n\tthis.setViewport = function ( x, y, width, height ) {\r\n\r\n\t\tstate.viewport( _viewport.set( x, y, width, height ) );\r\n\r\n\t};\r\n\r\n\tthis.setScissor = function ( x, y, width, height ) {\r\n\r\n\t\tstate.scissor( _scissor.set( x, y, width, height ) );\r\n\r\n\t};\r\n\r\n\tthis.setScissorTest = function ( boolean ) {\r\n\r\n\t\tstate.setScissorTest( _scissorTest = boolean );\r\n\r\n\t};\r\n\r\n\t// Clearing\r\n\r\n\tthis.getClearColor = function () {\r\n\r\n\t\treturn _clearColor;\r\n\r\n\t};\r\n\r\n\tthis.setClearColor = function ( color, alpha ) {\r\n\r\n\t\t_clearColor.set( color );\r\n\r\n\t\t_clearAlpha = alpha !== undefined ? alpha : 1;\r\n\r\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n\t};\r\n\r\n\tthis.getClearAlpha = function () {\r\n\r\n\t\treturn _clearAlpha;\r\n\r\n\t};\r\n\r\n\tthis.setClearAlpha = function ( alpha ) {\r\n\r\n\t\t_clearAlpha = alpha;\r\n\r\n\t\tglClearColor( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha );\r\n\r\n\t};\r\n\r\n\tthis.clear = function ( color, depth, stencil ) {\r\n\r\n\t\tvar bits = 0;\r\n\r\n\t\tif ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;\r\n\t\tif ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;\r\n\t\tif ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;\r\n\r\n\t\t_gl.clear( bits );\r\n\r\n\t};\r\n\r\n\tthis.clearColor = function () {\r\n\r\n\t\tthis.clear( true, false, false );\r\n\r\n\t};\r\n\r\n\tthis.clearDepth = function () {\r\n\r\n\t\tthis.clear( false, true, false );\r\n\r\n\t};\r\n\r\n\tthis.clearStencil = function () {\r\n\r\n\t\tthis.clear( false, false, true );\r\n\r\n\t};\r\n\r\n\tthis.clearTarget = function ( renderTarget, color, depth, stencil ) {\r\n\r\n\t\tthis.setRenderTarget( renderTarget );\r\n\t\tthis.clear( color, depth, stencil );\r\n\r\n\t};\r\n\r\n\t// Reset\r\n\r\n\tthis.resetGLState = resetGLState;\r\n\r\n\tthis.dispose = function() {\r\n\r\n\t\t_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );\r\n\r\n\t};\r\n\r\n\t// Events\r\n\r\n\tfunction onContextLost( event ) {\r\n\r\n\t\tevent.preventDefault();\r\n\r\n\t\tresetGLState();\r\n\t\tsetDefaultGLState();\r\n\r\n\t\tproperties.clear();\r\n\r\n\t}\r\n\r\n\tfunction onTextureDispose( event ) {\r\n\r\n\t\tvar texture = event.target;\r\n\r\n\t\ttexture.removeEventListener( 'dispose', onTextureDispose );\r\n\r\n\t\tdeallocateTexture( texture );\r\n\r\n\t\t_infoMemory.textures --;\r\n\r\n\r\n\t}\r\n\r\n\tfunction onRenderTargetDispose( event ) {\r\n\r\n\t\tvar renderTarget = event.target;\r\n\r\n\t\trenderTarget.removeEventListener( 'dispose', onRenderTargetDispose );\r\n\r\n\t\tdeallocateRenderTarget( renderTarget );\r\n\r\n\t\t_infoMemory.textures --;\r\n\r\n\t}\r\n\r\n\tfunction onMaterialDispose( event ) {\r\n\r\n\t\tvar material = event.target;\r\n\r\n\t\tmaterial.removeEventListener( 'dispose', onMaterialDispose );\r\n\r\n\t\tdeallocateMaterial( material );\r\n\r\n\t}\r\n\r\n\t// Buffer deallocation\r\n\r\n\tfunction deallocateTexture( texture ) {\r\n\r\n\t\tvar textureProperties = properties.get( texture );\r\n\r\n\t\tif ( texture.image && textureProperties.__image__webglTextureCube ) {\r\n\r\n\t\t\t// cube texture\r\n\r\n\t\t\t_gl.deleteTexture( textureProperties.__image__webglTextureCube );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// 2D texture\r\n\r\n\t\t\tif ( textureProperties.__webglInit === undefined ) return;\r\n\r\n\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\r\n\r\n\t\t}\r\n\r\n\t\t// remove all webgl properties\r\n\t\tproperties.delete( texture );\r\n\r\n\t}\r\n\r\n\tfunction deallocateRenderTarget( renderTarget ) {\r\n\r\n\t\tvar renderTargetProperties = properties.get( renderTarget );\r\n\t\tvar textureProperties = properties.get( renderTarget.texture );\r\n\r\n\t\tif ( ! renderTarget ) return;\r\n\r\n\t\tif ( textureProperties.__webglTexture !== undefined ) {\r\n\r\n\t\t\t_gl.deleteTexture( textureProperties.__webglTexture );\r\n\r\n\t\t}\r\n\r\n\t\tif ( renderTarget.depthTexture ) {\r\n\r\n\t\t\trenderTarget.depthTexture.dispose();\r\n\r\n\t\t}\r\n\r\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTargetCube ) {\r\n\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );\r\n\t\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );\r\n\t\t\tif ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );\r\n\r\n\t\t}\r\n\r\n\t\tproperties.delete( renderTarget.texture );\r\n\t\tproperties.delete( renderTarget );\r\n\r\n\t}\r\n\r\n\tfunction deallocateMaterial( material ) {\r\n\r\n\t\treleaseMaterialProgramReference( material );\r\n\r\n\t\tproperties.delete( material );\r\n\r\n\t}\r\n\r\n\r\n\tfunction releaseMaterialProgramReference( material ) {\r\n\r\n\t\tvar programInfo = properties.get( material ).program;\r\n\r\n\t\tmaterial.program = undefined;\r\n\r\n\t\tif ( programInfo !== undefined ) {\r\n\r\n\t\t\tprogramCache.releaseProgram( programInfo );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Buffer rendering\r\n\r\n\tthis.renderBufferImmediate = function ( object, program, material ) {\r\n\r\n\t\tstate.initAttributes();\r\n\r\n\t\tvar buffers = properties.get( object );\r\n\r\n\t\tif ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();\r\n\t\tif ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();\r\n\t\tif ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();\r\n\t\tif ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();\r\n\r\n\t\tvar attributes = program.getAttributes();\r\n\r\n\t\tif ( object.hasPositions ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );\r\n\r\n\t\t\tstate.enableAttribute( attributes.position );\r\n\t\t\t_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.hasNormals ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );\r\n\r\n\t\t\tif ( material.type !== 'MeshPhongMaterial' && material.type !== 'MeshStandardMaterial' && material.type !== 'MeshPhysicalMaterial' && material.shading === THREE.FlatShading ) {\r\n\r\n\t\t\t\tfor ( var i = 0, l = object.count * 3; i < l; i += 9 ) {\r\n\r\n\t\t\t\t\tvar array = object.normalArray;\r\n\r\n\t\t\t\t\tvar nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;\r\n\t\t\t\t\tvar ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;\r\n\t\t\t\t\tvar nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;\r\n\r\n\t\t\t\t\tarray[ i + 0 ] = nx;\r\n\t\t\t\t\tarray[ i + 1 ] = ny;\r\n\t\t\t\t\tarray[ i + 2 ] = nz;\r\n\r\n\t\t\t\t\tarray[ i + 3 ] = nx;\r\n\t\t\t\t\tarray[ i + 4 ] = ny;\r\n\t\t\t\t\tarray[ i + 5 ] = nz;\r\n\r\n\t\t\t\t\tarray[ i + 6 ] = nx;\r\n\t\t\t\t\tarray[ i + 7 ] = ny;\r\n\t\t\t\t\tarray[ i + 8 ] = nz;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );\r\n\r\n\t\t\tstate.enableAttribute( attributes.normal );\r\n\r\n\t\t\t_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.hasUvs && material.map ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );\r\n\r\n\t\t\tstate.enableAttribute( attributes.uv );\r\n\r\n\t\t\t_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( object.hasColors && material.vertexColors !== THREE.NoColors ) {\r\n\r\n\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );\r\n\t\t\t_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );\r\n\r\n\t\t\tstate.enableAttribute( attributes.color );\r\n\r\n\t\t\t_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tstate.disableUnusedAttributes();\r\n\r\n\t\t_gl.drawArrays( _gl.TRIANGLES, 0, object.count );\r\n\r\n\t\tobject.count = 0;\r\n\r\n\t};\r\n\r\n\tthis.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {\r\n\r\n\t\tsetMaterial( material );\r\n\r\n\t\tvar program = setProgram( camera, fog, material, object );\r\n\r\n\t\tvar updateBuffers = false;\r\n\t\tvar geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;\r\n\r\n\t\tif ( geometryProgram !== _currentGeometryProgram ) {\r\n\r\n\t\t\t_currentGeometryProgram = geometryProgram;\r\n\t\t\tupdateBuffers = true;\r\n\r\n\t\t}\r\n\r\n\t\t// morph targets\r\n\r\n\t\tvar morphTargetInfluences = object.morphTargetInfluences;\r\n\r\n\t\tif ( morphTargetInfluences !== undefined ) {\r\n\r\n\t\t\tvar activeInfluences = [];\r\n\r\n\t\t\tfor ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar influence = morphTargetInfluences[ i ];\r\n\t\t\t\tactiveInfluences.push( [ influence, i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tactiveInfluences.sort( absNumericalSort );\r\n\r\n\t\t\tif ( activeInfluences.length > 8 ) {\r\n\r\n\t\t\t\tactiveInfluences.length = 8;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar morphAttributes = geometry.morphAttributes;\r\n\r\n\t\t\tfor ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar influence = activeInfluences[ i ];\r\n\t\t\t\tmorphInfluences[ i ] = influence[ 0 ];\r\n\r\n\t\t\t\tif ( influence[ 0 ] !== 0 ) {\r\n\r\n\t\t\t\t\tvar index = influence[ 1 ];\r\n\r\n\t\t\t\t\tif ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );\r\n\t\t\t\t\tif ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );\r\n\t\t\t\t\tif ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tprogram.getUniforms().setValue(\r\n\t\t\t\t\t_gl, 'morphTargetInfluences', morphInfluences );\r\n\r\n\t\t\tupdateBuffers = true;\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tvar index = geometry.index;\r\n\t\tvar position = geometry.attributes.position;\r\n\r\n\t\tif ( material.wireframe === true ) {\r\n\r\n\t\t\tindex = objects.getWireframeAttribute( geometry );\r\n\r\n\t\t}\r\n\r\n\t\tvar renderer;\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\trenderer = indexedBufferRenderer;\r\n\t\t\trenderer.setIndex( index );\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer = bufferRenderer;\r\n\r\n\t\t}\r\n\r\n\t\tif ( updateBuffers ) {\r\n\r\n\t\t\tsetupVertexAttributes( material, program, geometry );\r\n\r\n\t\t\tif ( index !== null ) {\r\n\r\n\t\t\t\t_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tvar dataStart = 0;\r\n\t\tvar dataCount = Infinity;\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\tdataCount = index.count;\r\n\r\n\t\t} else if ( position !== undefined ) {\r\n\r\n\t\t\tdataCount = position.count;\r\n\r\n\t\t}\r\n\r\n\t\tvar rangeStart = geometry.drawRange.start;\r\n\t\tvar rangeCount = geometry.drawRange.count;\r\n\r\n\t\tvar groupStart = group !== null ? group.start : 0;\r\n\t\tvar groupCount = group !== null ? group.count : Infinity;\r\n\r\n\t\tvar drawStart = Math.max( dataStart, rangeStart, groupStart );\r\n\t\tvar drawEnd = Math.min( dataStart + dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;\r\n\r\n\t\tvar drawCount = Math.max( 0, drawEnd - drawStart + 1 );\r\n\r\n\t\t//\r\n\r\n\t\tif ( object instanceof THREE.Mesh ) {\r\n\r\n\t\t\tif ( material.wireframe === true ) {\r\n\r\n\t\t\t\tstate.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );\r\n\t\t\t\trenderer.setMode( _gl.LINES );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tswitch ( object.drawMode ) {\r\n\r\n\t\t\t\t\tcase THREE.TrianglesDrawMode:\r\n\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLES );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase THREE.TriangleStripDrawMode:\r\n\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_STRIP );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase THREE.TriangleFanDrawMode:\r\n\t\t\t\t\t\trenderer.setMode( _gl.TRIANGLE_FAN );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t} else if ( object instanceof THREE.Line ) {\r\n\r\n\t\t\tvar lineWidth = material.linewidth;\r\n\r\n\t\t\tif ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material\r\n\r\n\t\t\tstate.setLineWidth( lineWidth * getTargetPixelRatio() );\r\n\r\n\t\t\tif ( object instanceof THREE.LineSegments ) {\r\n\r\n\t\t\t\trenderer.setMode( _gl.LINES );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\trenderer.setMode( _gl.LINE_STRIP );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( object instanceof THREE.Points ) {\r\n\r\n\t\t\trenderer.setMode( _gl.POINTS );\r\n\r\n\t\t}\r\n\r\n\t\tif ( geometry instanceof THREE.InstancedBufferGeometry ) {\r\n\r\n\t\t\tif ( geometry.maxInstancedCount > 0 ) {\r\n\r\n\t\t\t\trenderer.renderInstances( geometry, drawStart, drawCount );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderer.render( drawStart, drawCount );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction setupVertexAttributes( material, program, geometry, startIndex ) {\r\n\r\n\t\tvar extension;\r\n\r\n\t\tif ( geometry instanceof THREE.InstancedBufferGeometry ) {\r\n\r\n\t\t\textension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\r\n\t\t\tif ( extension === null ) {\r\n\r\n\t\t\t\tconsole.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( startIndex === undefined ) startIndex = 0;\r\n\r\n\t\tstate.initAttributes();\r\n\r\n\t\tvar geometryAttributes = geometry.attributes;\r\n\r\n\t\tvar programAttributes = program.getAttributes();\r\n\r\n\t\tvar materialDefaultAttributeValues = material.defaultAttributeValues;\r\n\r\n\t\tfor ( var name in programAttributes ) {\r\n\r\n\t\t\tvar programAttribute = programAttributes[ name ];\r\n\r\n\t\t\tif ( programAttribute >= 0 ) {\r\n\r\n\t\t\t\tvar geometryAttribute = geometryAttributes[ name ];\r\n\r\n\t\t\t\tif ( geometryAttribute !== undefined ) {\r\n\r\n\t\t\t\t\tvar type = _gl.FLOAT;\r\n\t\t\t\t\tvar array = geometryAttribute.array;\r\n\t\t\t\t\tvar normalized = geometryAttribute.normalized;\r\n\r\n\t\t\t\t\tif ( array instanceof Float32Array ) {\r\n\r\n\t\t\t\t\t\ttype = _gl.FLOAT;\r\n\r\n\t\t\t\t\t} else if ( array instanceof Float64Array ) {\r\n\r\n\t\t\t\t\t\tconsole.warn(\"Unsupported data buffer format: Float64Array\");\r\n\r\n\t\t\t\t\t} else if ( array instanceof Uint16Array ) {\r\n\r\n\t\t\t\t\t\ttype = _gl.UNSIGNED_SHORT;\r\n\r\n\t\t\t\t\t} else if ( array instanceof Int16Array ) {\r\n\r\n\t\t\t\t\t\ttype = _gl.SHORT;\r\n\r\n\t\t\t\t\t} else if ( array instanceof Uint32Array ) {\r\n\r\n\t\t\t\t\t\ttype = _gl.UNSIGNED_INT;\r\n\r\n\t\t\t\t\t} else if ( array instanceof Int32Array ) {\r\n\r\n\t\t\t\t\t\ttype = _gl.INT;\r\n\r\n\t\t\t\t\t} else if ( array instanceof Int8Array ) {\r\n\r\n\t\t\t\t\t\ttype = _gl.BYTE;\r\n\r\n\t\t\t\t\t} else if ( array instanceof Uint8Array ) {\r\n\r\n\t\t\t\t\t\ttype = _gl.UNSIGNED_BYTE;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tvar size = geometryAttribute.itemSize;\r\n\t\t\t\t\tvar buffer = objects.getAttributeBuffer( geometryAttribute );\r\n\r\n\t\t\t\t\tif ( geometryAttribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\r\n\t\t\t\t\t\tvar data = geometryAttribute.data;\r\n\t\t\t\t\t\tvar stride = data.stride;\r\n\t\t\t\t\t\tvar offset = geometryAttribute.offset;\r\n\r\n\t\t\t\t\t\tif ( data instanceof THREE.InstancedInterleavedBuffer ) {\r\n\r\n\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );\r\n\r\n\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = data.meshPerAttribute * data.count;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * data.array.BYTES_PER_ELEMENT, ( startIndex * stride + offset ) * data.array.BYTES_PER_ELEMENT );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tif ( geometryAttribute instanceof THREE.InstancedBufferAttribute ) {\r\n\r\n\t\t\t\t\t\t\tstate.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );\r\n\r\n\t\t\t\t\t\t\tif ( geometry.maxInstancedCount === undefined ) {\r\n\r\n\t\t\t\t\t\t\t\tgeometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tstate.enableAttribute( programAttribute );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );\r\n\t\t\t\t\t\t_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * geometryAttribute.array.BYTES_PER_ELEMENT );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else if ( materialDefaultAttributeValues !== undefined ) {\r\n\r\n\t\t\t\t\tvar value = materialDefaultAttributeValues[ name ];\r\n\r\n\t\t\t\t\tif ( value !== undefined ) {\r\n\r\n\t\t\t\t\t\tswitch ( value.length ) {\r\n\r\n\t\t\t\t\t\t\tcase 2:\r\n\t\t\t\t\t\t\t\t_gl.vertexAttrib2fv( programAttribute, value );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 3:\r\n\t\t\t\t\t\t\t\t_gl.vertexAttrib3fv( programAttribute, value );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tcase 4:\r\n\t\t\t\t\t\t\t\t_gl.vertexAttrib4fv( programAttribute, value );\r\n\t\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t\t\t_gl.vertexAttrib1fv( programAttribute, value );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tstate.disableUnusedAttributes();\r\n\r\n\t}\r\n\r\n\t// Sorting\r\n\r\n\tfunction absNumericalSort( a, b ) {\r\n\r\n\t\treturn Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );\r\n\r\n\t}\r\n\r\n\tfunction painterSortStable ( a, b ) {\r\n\r\n\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\r\n\r\n\t\t\treturn a.object.renderOrder - b.object.renderOrder;\r\n\r\n\t\t} else if ( a.material.id !== b.material.id ) {\r\n\r\n\t\t\treturn a.material.id - b.material.id;\r\n\r\n\t\t} else if ( a.z !== b.z ) {\r\n\r\n\t\t\treturn a.z - b.z;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn a.id - b.id;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction reversePainterSortStable ( a, b ) {\r\n\r\n\t\tif ( a.object.renderOrder !== b.object.renderOrder ) {\r\n\r\n\t\t\treturn a.object.renderOrder - b.object.renderOrder;\r\n\r\n\t\t} if ( a.z !== b.z ) {\r\n\r\n\t\t\treturn b.z - a.z;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn a.id - b.id;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Rendering\r\n\r\n\tthis.render = function ( scene, camera, renderTarget, forceClear ) {\r\n\r\n\t\tif ( camera instanceof THREE.Camera === false ) {\r\n\r\n\t\t\tconsole.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar fog = scene.fog;\r\n\r\n\t\t// reset caching for this frame\r\n\r\n\t\t_currentGeometryProgram = '';\r\n\t\t_currentMaterialId = - 1;\r\n\t\t_currentCamera = null;\r\n\r\n\t\t// update scene graph\r\n\r\n\t\tif ( scene.autoUpdate === true ) scene.updateMatrixWorld();\r\n\r\n\t\t// update camera matrices and frustum\r\n\r\n\t\tif ( camera.parent === null ) camera.updateMatrixWorld();\r\n\r\n\t\tcamera.matrixWorldInverse.getInverse( camera.matrixWorld );\r\n\r\n\t\t_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );\r\n\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\r\n\t\tlights.length = 0;\r\n\r\n\t\topaqueObjectsLastIndex = - 1;\r\n\t\ttransparentObjectsLastIndex = - 1;\r\n\r\n\t\tsprites.length = 0;\r\n\t\tlensFlares.length = 0;\r\n\r\n\t\t_localClippingEnabled = this.localClippingEnabled;\r\n\t\t_clippingEnabled = _clipping.init(\r\n\t\t\t\tthis.clippingPlanes, _localClippingEnabled, camera );\r\n\r\n\t\tprojectObject( scene, camera );\r\n\r\n\r\n\t\topaqueObjects.length = opaqueObjectsLastIndex + 1;\r\n\t\ttransparentObjects.length = transparentObjectsLastIndex + 1;\r\n\r\n\t\tif ( _this.sortObjects === true ) {\r\n\r\n\t\t\topaqueObjects.sort( painterSortStable );\r\n\t\t\ttransparentObjects.sort( reversePainterSortStable );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( _clippingEnabled ) _clipping.beginShadows();\r\n\r\n\t\tsetupShadows( lights );\r\n\r\n\t\tshadowMap.render( scene, camera );\r\n\r\n\t\tsetupLights( lights, camera );\r\n\r\n\t\tif ( _clippingEnabled ) _clipping.endShadows();\r\n\r\n\t\t//\r\n\r\n\t\t_infoRender.calls = 0;\r\n\t\t_infoRender.vertices = 0;\r\n\t\t_infoRender.faces = 0;\r\n\t\t_infoRender.points = 0;\r\n\r\n\t\tif ( renderTarget === undefined ) {\r\n\r\n\t\t\trenderTarget = null;\r\n\r\n\t\t}\r\n\r\n\t\tthis.setRenderTarget( renderTarget );\r\n\r\n\t\tif ( this.autoClear || forceClear ) {\r\n\r\n\t\t\tthis.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( scene.overrideMaterial ) {\r\n\r\n\t\t\tvar overrideMaterial = scene.overrideMaterial;\r\n\r\n\t\t\trenderObjects( opaqueObjects, camera, fog, overrideMaterial );\r\n\t\t\trenderObjects( transparentObjects, camera, fog, overrideMaterial );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// opaque pass (front-to-back order)\r\n\r\n\t\t\tstate.setBlending( THREE.NoBlending );\r\n\t\t\trenderObjects( opaqueObjects, camera, fog );\r\n\r\n\t\t\t// transparent pass (back-to-front order)\r\n\r\n\t\t\trenderObjects( transparentObjects, camera, fog );\r\n\r\n\t\t}\r\n\r\n\t\t// custom render plugins (post pass)\r\n\r\n\t\tspritePlugin.render( scene, camera );\r\n\t\tlensFlarePlugin.render( scene, camera, _currentViewport );\r\n\r\n\t\t// Generate mipmap if we're using any kind of mipmap filtering\r\n\r\n\t\tif ( renderTarget ) {\r\n\r\n\t\t\tvar texture = renderTarget.texture;\r\n\r\n\t\t\tif ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&\r\n\t\t\t\t\ttexture.minFilter !== THREE.NearestFilter &&\r\n\t\t\t\t\ttexture.minFilter !== THREE.LinearFilter ) {\r\n\r\n\t\t\t\tupdateRenderTargetMipmap( renderTarget );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Ensure depth buffer writing is enabled so it can be cleared on next render\r\n\r\n\t\tstate.setDepthTest( true );\r\n\t\tstate.setDepthWrite( true );\r\n\t\tstate.setColorWrite( true );\r\n\r\n\t\t// _gl.finish();\r\n\r\n\t};\r\n\r\n\tfunction pushRenderItem( object, geometry, material, z, group ) {\r\n\r\n\t\tvar array, index;\r\n\r\n\t\t// allocate the next position in the appropriate array\r\n\r\n\t\tif ( material.transparent ) {\r\n\r\n\t\t\tarray = transparentObjects;\r\n\t\t\tindex = ++ transparentObjectsLastIndex;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tarray = opaqueObjects;\r\n\t\t\tindex = ++ opaqueObjectsLastIndex;\r\n\r\n\t\t}\r\n\r\n\t\t// recycle existing render item or grow the array\r\n\r\n\t\tvar renderItem = array[ index ];\r\n\r\n\t\tif ( renderItem !== undefined ) {\r\n\r\n\t\t\trenderItem.id = object.id;\r\n\t\t\trenderItem.object = object;\r\n\t\t\trenderItem.geometry = geometry;\r\n\t\t\trenderItem.material = material;\r\n\t\t\trenderItem.z = _vector3.z;\r\n\t\t\trenderItem.group = group;\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderItem = {\r\n\t\t\t\tid: object.id,\r\n\t\t\t\tobject: object,\r\n\t\t\t\tgeometry: geometry,\r\n\t\t\t\tmaterial: material,\r\n\t\t\t\tz: _vector3.z,\r\n\t\t\t\tgroup: group\r\n\t\t\t};\r\n\r\n\t\t\t// assert( index === array.length );\r\n\t\t\tarray.push( renderItem );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// TODO Duplicated code (Frustum)\r\n\r\n\tfunction isObjectViewable( object ) {\r\n\r\n\t\tvar geometry = object.geometry;\r\n\r\n\t\tif ( geometry.boundingSphere === null )\r\n\t\t\tgeometry.computeBoundingSphere();\r\n\r\n\t\t_sphere.copy( geometry.boundingSphere ).\r\n\t\t\tapplyMatrix4( object.matrixWorld );\r\n\r\n\t\treturn isSphereViewable( _sphere );\r\n\r\n\t}\r\n\r\n\tfunction isSpriteViewable( sprite ) {\r\n\r\n\t\t_sphere.center.set( 0, 0, 0 );\r\n\t\t_sphere.radius = 0.7071067811865476;\r\n\t\t_sphere.applyMatrix4( sprite.matrixWorld );\r\n\r\n\t\treturn isSphereViewable( _sphere );\r\n\r\n\t}\r\n\r\n\tfunction isSphereViewable( sphere ) {\r\n\r\n\t\tif ( ! _frustum.intersectsSphere( sphere ) ) return false;\r\n\r\n\t\tvar numPlanes = _clipping.numPlanes;\r\n\r\n\t\tif ( numPlanes === 0 ) return true;\r\n\r\n\t\tvar planes = _this.clippingPlanes,\r\n\r\n\t\t\tcenter = sphere.center,\r\n\t\t\tnegRad = - sphere.radius,\r\n\t\t\ti = 0;\r\n\r\n\t\tdo {\r\n\r\n\t\t\t// out when deeper than radius in the negative halfspace\r\n\t\t\tif ( planes[ i ].distanceToPoint( center ) < negRad ) return false;\r\n\r\n\t\t} while ( ++ i !== numPlanes );\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\tfunction projectObject( object, camera ) {\r\n\r\n\t\tif ( object.visible === false ) return;\r\n\r\n\t\tif ( object.layers.test( camera.layers ) ) {\r\n\r\n\t\t\tif ( object instanceof THREE.Light ) {\r\n\r\n\t\t\t\tlights.push( object );\r\n\r\n\t\t\t} else if ( object instanceof THREE.Sprite ) {\r\n\r\n\t\t\t\tif ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {\r\n\r\n\t\t\t\t\tsprites.push( object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( object instanceof THREE.LensFlare ) {\r\n\r\n\t\t\t\tlensFlares.push( object );\r\n\r\n\t\t\t} else if ( object instanceof THREE.ImmediateRenderObject ) {\r\n\r\n\t\t\t\tif ( _this.sortObjects === true ) {\r\n\r\n\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\r\n\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tpushRenderItem( object, null, object.material, _vector3.z, null );\r\n\r\n\t\t\t} else if ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) {\r\n\r\n\t\t\t\tif ( object instanceof THREE.SkinnedMesh ) {\r\n\r\n\t\t\t\t\tobject.skeleton.update();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( object.frustumCulled === false || isObjectViewable( object ) === true ) {\r\n\r\n\t\t\t\t\tvar material = object.material;\r\n\r\n\t\t\t\t\tif ( material.visible === true ) {\r\n\r\n\t\t\t\t\t\tif ( _this.sortObjects === true ) {\r\n\r\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( object.matrixWorld );\r\n\t\t\t\t\t\t\t_vector3.applyProjection( _projScreenMatrix );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar geometry = objects.update( object );\r\n\r\n\t\t\t\t\t\tif ( material instanceof THREE.MultiMaterial ) {\r\n\r\n\t\t\t\t\t\t\tvar groups = geometry.groups;\r\n\t\t\t\t\t\t\tvar materials = material.materials;\r\n\r\n\t\t\t\t\t\t\tfor ( var i = 0, l = groups.length; i < l; i ++ ) {\r\n\r\n\t\t\t\t\t\t\t\tvar group = groups[ i ];\r\n\t\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\r\n\r\n\t\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\r\n\r\n\t\t\t\t\t\t\t\t\tpushRenderItem( object, geometry, groupMaterial, _vector3.z, group );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tpushRenderItem( object, geometry, material, _vector3.z, null );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar children = object.children;\r\n\r\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tprojectObject( children[ i ], camera );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction renderObjects( renderList, camera, fog, overrideMaterial ) {\r\n\r\n\t\tfor ( var i = 0, l = renderList.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar renderItem = renderList[ i ];\r\n\r\n\t\t\tvar object = renderItem.object;\r\n\t\t\tvar geometry = renderItem.geometry;\r\n\t\t\tvar material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;\r\n\t\t\tvar group = renderItem.group;\r\n\r\n\t\t\tobject.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );\r\n\t\t\tobject.normalMatrix.getNormalMatrix( object.modelViewMatrix );\r\n\r\n\t\t\tif ( object instanceof THREE.ImmediateRenderObject ) {\r\n\r\n\t\t\t\tsetMaterial( material );\r\n\r\n\t\t\t\tvar program = setProgram( camera, fog, material, object );\r\n\r\n\t\t\t\t_currentGeometryProgram = '';\r\n\r\n\t\t\t\tobject.render( function ( object ) {\r\n\r\n\t\t\t\t\t_this.renderBufferImmediate( object, program, material );\r\n\r\n\t\t\t\t} );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_this.renderBufferDirect( camera, fog, geometry, material, object, group );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction initMaterial( material, fog, object ) {\r\n\r\n\t\tvar materialProperties = properties.get( material );\r\n\r\n\t\tvar parameters = programCache.getParameters(\r\n\t\t\t\tmaterial, _lights, fog, _clipping.numPlanes, object );\r\n\r\n\t\tvar code = programCache.getProgramCode( material, parameters );\r\n\r\n\t\tvar program = materialProperties.program;\r\n\t\tvar programChange = true;\r\n\r\n\t\tif ( program === undefined ) {\r\n\r\n\t\t\t// new material\r\n\t\t\tmaterial.addEventListener( 'dispose', onMaterialDispose );\r\n\r\n\t\t} else if ( program.code !== code ) {\r\n\r\n\t\t\t// changed glsl or parameters\r\n\t\t\treleaseMaterialProgramReference( material );\r\n\r\n\t\t} else if ( parameters.shaderID !== undefined ) {\r\n\r\n\t\t\t// same glsl and uniform list\r\n\t\t\treturn;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// only rebuild uniform list\r\n\t\t\tprogramChange = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( programChange ) {\r\n\r\n\t\t\tif ( parameters.shaderID ) {\r\n\r\n\t\t\t\tvar shader = THREE.ShaderLib[ parameters.shaderID ];\r\n\r\n\t\t\t\tmaterialProperties.__webglShader = {\r\n\t\t\t\t\tname: material.type,\r\n\t\t\t\t\tuniforms: THREE.UniformsUtils.clone( shader.uniforms ),\r\n\t\t\t\t\tvertexShader: shader.vertexShader,\r\n\t\t\t\t\tfragmentShader: shader.fragmentShader\r\n\t\t\t\t};\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tmaterialProperties.__webglShader = {\r\n\t\t\t\t\tname: material.type,\r\n\t\t\t\t\tuniforms: material.uniforms,\r\n\t\t\t\t\tvertexShader: material.vertexShader,\r\n\t\t\t\t\tfragmentShader: material.fragmentShader\r\n\t\t\t\t};\r\n\r\n\t\t\t}\r\n\r\n\t\t\tmaterial.__webglShader = materialProperties.__webglShader;\r\n\r\n\t\t\tprogram = programCache.acquireProgram( material, parameters, code );\r\n\r\n\t\t\tmaterialProperties.program = program;\r\n\t\t\tmaterial.program = program;\r\n\r\n\t\t}\r\n\r\n\t\tvar attributes = program.getAttributes();\r\n\r\n\t\tif ( material.morphTargets ) {\r\n\r\n\t\t\tmaterial.numSupportedMorphTargets = 0;\r\n\r\n\t\t\tfor ( var i = 0; i < _this.maxMorphTargets; i ++ ) {\r\n\r\n\t\t\t\tif ( attributes[ 'morphTarget' + i ] >= 0 ) {\r\n\r\n\t\t\t\t\tmaterial.numSupportedMorphTargets ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.morphNormals ) {\r\n\r\n\t\t\tmaterial.numSupportedMorphNormals = 0;\r\n\r\n\t\t\tfor ( var i = 0; i < _this.maxMorphNormals; i ++ ) {\r\n\r\n\t\t\t\tif ( attributes[ 'morphNormal' + i ] >= 0 ) {\r\n\r\n\t\t\t\t\tmaterial.numSupportedMorphNormals ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar uniforms = materialProperties.__webglShader.uniforms;\r\n\r\n\t\tif ( ! ( material instanceof THREE.ShaderMaterial ) &&\r\n\t\t\t\t! ( material instanceof THREE.RawShaderMaterial ) ||\r\n\t\t\t\tmaterial.clipping === true ) {\r\n\r\n\t\t\tmaterialProperties.numClippingPlanes = _clipping.numPlanes;\r\n\t\t\tuniforms.clippingPlanes = _clipping.uniform;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.lights ) {\r\n\r\n\t\t\t// store the light setup it was created for\r\n\r\n\t\t\tmaterialProperties.lightsHash = _lights.hash;\r\n\r\n\t\t\t// wire up the material to this renderer's lighting state\r\n\r\n\t\t\tuniforms.ambientLightColor.value = _lights.ambient;\r\n\t\t\tuniforms.directionalLights.value = _lights.directional;\r\n\t\t\tuniforms.spotLights.value = _lights.spot;\r\n\t\t\tuniforms.pointLights.value = _lights.point;\r\n\t\t\tuniforms.hemisphereLights.value = _lights.hemi;\r\n\r\n\t\t\tuniforms.directionalShadowMap.value = _lights.directionalShadowMap;\r\n\t\t\tuniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;\r\n\t\t\tuniforms.spotShadowMap.value = _lights.spotShadowMap;\r\n\t\t\tuniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;\r\n\t\t\tuniforms.pointShadowMap.value = _lights.pointShadowMap;\r\n\t\t\tuniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;\r\n\r\n\t\t}\r\n\r\n\t\tvar progUniforms = materialProperties.program.getUniforms(),\r\n\t\t\tuniformsList =\r\n\t\t\t\t\tTHREE.WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );\r\n\r\n\t\tmaterialProperties.uniformsList = uniformsList;\r\n\t\tmaterialProperties.dynamicUniforms =\r\n\t\t\t\tTHREE.WebGLUniforms.splitDynamic( uniformsList, uniforms );\r\n\r\n\t}\r\n\r\n\tfunction setMaterial( material ) {\r\n\r\n\t\tif ( material.side !== THREE.DoubleSide )\r\n\t\t\tstate.enable( _gl.CULL_FACE );\r\n\t\telse\r\n\t\t\tstate.disable( _gl.CULL_FACE );\r\n\r\n\t\tstate.setFlipSided( material.side === THREE.BackSide );\r\n\r\n\t\tif ( material.transparent === true ) {\r\n\r\n\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tstate.setBlending( THREE.NoBlending );\r\n\r\n\t\t}\r\n\r\n\t\tstate.setDepthFunc( material.depthFunc );\r\n\t\tstate.setDepthTest( material.depthTest );\r\n\t\tstate.setDepthWrite( material.depthWrite );\r\n\t\tstate.setColorWrite( material.colorWrite );\r\n\t\tstate.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );\r\n\r\n\t}\r\n\r\n\tfunction setProgram( camera, fog, material, object ) {\r\n\r\n\t\t_usedTextureUnits = 0;\r\n\r\n\t\tvar materialProperties = properties.get( material );\r\n\r\n\t\tif ( _clippingEnabled ) {\r\n\r\n\t\t\tif ( _localClippingEnabled || camera !== _currentCamera ) {\r\n\r\n\t\t\t\tvar useCache =\r\n\t\t\t\t\t\tcamera === _currentCamera &&\r\n\t\t\t\t\t\tmaterial.id === _currentMaterialId;\r\n\r\n\t\t\t\t// we might want to call this function with some ClippingGroup\r\n\t\t\t\t// object instead of the material, once it becomes feasible\r\n\t\t\t\t// (#8465, #8379)\r\n\t\t\t\t_clipping.setState(\r\n\t\t\t\t\t\tmaterial.clippingPlanes, material.clipShadows,\r\n\t\t\t\t\t\tcamera, materialProperties, useCache );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( materialProperties.numClippingPlanes !== undefined &&\r\n\t\t\t\tmaterialProperties.numClippingPlanes !== _clipping.numPlanes ) {\r\n\r\n\t\t\t\tmaterial.needsUpdate = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialProperties.program === undefined ) {\r\n\r\n\t\t\tmaterial.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( materialProperties.lightsHash !== undefined &&\r\n\t\t\tmaterialProperties.lightsHash !== _lights.hash ) {\r\n\r\n\t\t\tmaterial.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.needsUpdate ) {\r\n\r\n\t\t\tinitMaterial( material, fog, object );\r\n\t\t\tmaterial.needsUpdate = false;\r\n\r\n\t\t}\r\n\r\n\t\tvar refreshProgram = false;\r\n\t\tvar refreshMaterial = false;\r\n\t\tvar refreshLights = false;\r\n\r\n\t\tvar program = materialProperties.program,\r\n\t\t\tp_uniforms = program.getUniforms(),\r\n\t\t\tm_uniforms = materialProperties.__webglShader.uniforms;\r\n\r\n\t\tif ( program.id !== _currentProgram ) {\r\n\r\n\t\t\t_gl.useProgram( program.program );\r\n\t\t\t_currentProgram = program.id;\r\n\r\n\t\t\trefreshProgram = true;\r\n\t\t\trefreshMaterial = true;\r\n\t\t\trefreshLights = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.id !== _currentMaterialId ) {\r\n\r\n\t\t\t_currentMaterialId = material.id;\r\n\r\n\t\t\trefreshMaterial = true;\r\n\r\n\t\t}\r\n\r\n\t\tif ( refreshProgram || camera !== _currentCamera ) {\r\n\r\n\t\t\tp_uniforms.set( _gl, camera, 'projectionMatrix' );\r\n\r\n\t\t\tif ( capabilities.logarithmicDepthBuffer ) {\r\n\r\n\t\t\t\tp_uniforms.setValue( _gl, 'logDepthBufFC',\r\n\t\t\t\t\t\t2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );\r\n\r\n\t\t\t}\r\n\r\n\r\n\t\t\tif ( camera !== _currentCamera ) {\r\n\r\n\t\t\t\t_currentCamera = camera;\r\n\r\n\t\t\t\t// lighting uniforms depend on the camera so enforce an update\r\n\t\t\t\t// now, in case this material supports lights - or later, when\r\n\t\t\t\t// the next material that does gets activated:\r\n\r\n\t\t\t\trefreshMaterial = true;\t\t// set to true on material change\r\n\t\t\t\trefreshLights = true;\t\t// remains set until update done\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// load material specific uniforms\r\n\t\t\t// (shader material also gets them for the sake of genericity)\r\n\r\n\t\t\tif ( material instanceof THREE.ShaderMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\r\n\t\t\t\t material.envMap ) {\r\n\r\n\t\t\t\tvar uCamPos = p_uniforms.map.cameraPosition;\r\n\r\n\t\t\t\tif ( uCamPos !== undefined ) {\r\n\r\n\t\t\t\t\tuCamPos.setValue( _gl,\r\n\t\t\t\t\t\t\t_vector3.setFromMatrixPosition( camera.matrixWorld ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshBasicMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\r\n\t\t\t\t material instanceof THREE.ShaderMaterial ||\r\n\t\t\t\t material.skinning ) {\r\n\r\n\t\t\t\tp_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tp_uniforms.set( _gl, _this, 'toneMappingExposure' );\r\n\t\t\tp_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );\r\n\r\n\t\t}\r\n\r\n\t\t// skinning uniforms must be set even if material didn't change\r\n\t\t// auto-setting of texture unit for bone texture must go before other textures\r\n\t\t// not sure why, but otherwise weird things happen\r\n\r\n\t\tif ( material.skinning ) {\r\n\r\n\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrix' );\r\n\t\t\tp_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );\r\n\r\n\t\t\tvar skeleton = object.skeleton;\r\n\r\n\t\t\tif ( skeleton ) {\r\n\r\n\t\t\t\tif ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {\r\n\r\n\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTexture' );\r\n\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureWidth' );\r\n\t\t\t\t\tp_uniforms.set( _gl, skeleton, 'boneTextureHeight' );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tp_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( refreshMaterial ) {\r\n\r\n\t\t\tif ( material.lights ) {\r\n\r\n\t\t\t\t// the current material requires lighting info\r\n\r\n\t\t\t\t// note: all lighting uniforms are always set correctly\r\n\t\t\t\t// they simply reference the renderer's state for their\r\n\t\t\t\t// values\r\n\t\t\t\t//\r\n\t\t\t\t// use the current material's .needsUpdate flags to set\r\n\t\t\t\t// the GL state when required\r\n\r\n\t\t\t\tmarkUniformsLightsNeedsUpdate( m_uniforms, refreshLights );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// refresh uniforms common to several materials\r\n\r\n\t\t\tif ( fog && material.fog ) {\r\n\r\n\t\t\t\trefreshUniformsFog( m_uniforms, fog );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material instanceof THREE.MeshBasicMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshLambertMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshPhongMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshStandardMaterial ||\r\n\t\t\t\t material instanceof THREE.MeshDepthMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsCommon( m_uniforms, material );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// refresh single material specific uniforms\r\n\r\n\t\t\tif ( material instanceof THREE.LineBasicMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.LineDashedMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsLine( m_uniforms, material );\r\n\t\t\t\trefreshUniformsDash( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.PointsMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsPoints( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshLambertMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsLambert( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshPhongMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsPhong( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshPhysicalMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsPhysical( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshStandardMaterial ) {\r\n\r\n\t\t\t\trefreshUniformsStandard( m_uniforms, material );\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshDepthMaterial ) {\r\n\r\n\t\t\t\tif ( material.displacementMap ) {\r\n\r\n\t\t\t\t\tm_uniforms.displacementMap.value = material.displacementMap;\r\n\t\t\t\t\tm_uniforms.displacementScale.value = material.displacementScale;\r\n\t\t\t\t\tm_uniforms.displacementBias.value = material.displacementBias;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( material instanceof THREE.MeshNormalMaterial ) {\r\n\r\n\t\t\t\tm_uniforms.opacity.value = material.opacity;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tTHREE.WebGLUniforms.upload(\r\n\t\t\t\t\t_gl, materialProperties.uniformsList, m_uniforms, _this );\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// common matrices\r\n\r\n\t\tp_uniforms.set( _gl, object, 'modelViewMatrix' );\r\n\t\tp_uniforms.set( _gl, object, 'normalMatrix' );\r\n\t\tp_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );\r\n\r\n\r\n\t\t// dynamic uniforms\r\n\r\n\t\tvar dynUniforms = materialProperties.dynamicUniforms;\r\n\r\n\t\tif ( dynUniforms !== null ) {\r\n\r\n\t\t\tTHREE.WebGLUniforms.evalDynamic(\r\n\t\t\t\t\tdynUniforms, m_uniforms, object, camera );\r\n\r\n\t\t\tTHREE.WebGLUniforms.upload( _gl, dynUniforms, m_uniforms, _this );\r\n\r\n\t\t}\r\n\r\n\t\treturn program;\r\n\r\n\t}\r\n\r\n\t// Uniforms (refresh uniforms objects)\r\n\r\n\tfunction refreshUniformsCommon ( uniforms, material ) {\r\n\r\n\t\tuniforms.opacity.value = material.opacity;\r\n\r\n\t\tuniforms.diffuse.value = material.color;\r\n\r\n\t\tif ( material.emissive ) {\r\n\r\n\t\t\tuniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );\r\n\r\n\t\t}\r\n\r\n\t\tuniforms.map.value = material.map;\r\n\t\tuniforms.specularMap.value = material.specularMap;\r\n\t\tuniforms.alphaMap.value = material.alphaMap;\r\n\r\n\t\tif ( material.aoMap ) {\r\n\r\n\t\t\tuniforms.aoMap.value = material.aoMap;\r\n\t\t\tuniforms.aoMapIntensity.value = material.aoMapIntensity;\r\n\r\n\t\t}\r\n\r\n\t\t// uv repeat and offset setting priorities\r\n\t\t// 1. color map\r\n\t\t// 2. specular map\r\n\t\t// 3. normal map\r\n\t\t// 4. bump map\r\n\t\t// 5. alpha map\r\n\t\t// 6. emissive map\r\n\r\n\t\tvar uvScaleMap;\r\n\r\n\t\tif ( material.map ) {\r\n\r\n\t\t\tuvScaleMap = material.map;\r\n\r\n\t\t} else if ( material.specularMap ) {\r\n\r\n\t\t\tuvScaleMap = material.specularMap;\r\n\r\n\t\t} else if ( material.displacementMap ) {\r\n\r\n\t\t\tuvScaleMap = material.displacementMap;\r\n\r\n\t\t} else if ( material.normalMap ) {\r\n\r\n\t\t\tuvScaleMap = material.normalMap;\r\n\r\n\t\t} else if ( material.bumpMap ) {\r\n\r\n\t\t\tuvScaleMap = material.bumpMap;\r\n\r\n\t\t} else if ( material.roughnessMap ) {\r\n\r\n\t\t\tuvScaleMap = material.roughnessMap;\r\n\r\n\t\t} else if ( material.metalnessMap ) {\r\n\r\n\t\t\tuvScaleMap = material.metalnessMap;\r\n\r\n\t\t} else if ( material.alphaMap ) {\r\n\r\n\t\t\tuvScaleMap = material.alphaMap;\r\n\r\n\t\t} else if ( material.emissiveMap ) {\r\n\r\n\t\t\tuvScaleMap = material.emissiveMap;\r\n\r\n\t\t}\r\n\r\n\t\tif ( uvScaleMap !== undefined ) {\r\n\r\n\t\t\t// backwards compatibility\r\n\t\t\tif ( uvScaleMap instanceof THREE.WebGLRenderTarget ) {\r\n\r\n\t\t\t\tuvScaleMap = uvScaleMap.texture;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar offset = uvScaleMap.offset;\r\n\t\t\tvar repeat = uvScaleMap.repeat;\r\n\r\n\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\r\n\r\n\t\t}\r\n\r\n\t\tuniforms.envMap.value = material.envMap;\r\n\r\n\t\t// don't flip CubeTexture envMaps, flip everything else:\r\n\t\t//  WebGLRenderTargetCube will be flipped for backwards compatibility\r\n\t\t//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture\r\n\t\t// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future\r\n\t\tuniforms.flipEnvMap.value = ( ! ( material.envMap instanceof THREE.CubeTexture ) ) ? 1 : - 1;\r\n\r\n\t\tuniforms.reflectivity.value = material.reflectivity;\r\n\t\tuniforms.refractionRatio.value = material.refractionRatio;\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsLine ( uniforms, material ) {\r\n\r\n\t\tuniforms.diffuse.value = material.color;\r\n\t\tuniforms.opacity.value = material.opacity;\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsDash ( uniforms, material ) {\r\n\r\n\t\tuniforms.dashSize.value = material.dashSize;\r\n\t\tuniforms.totalSize.value = material.dashSize + material.gapSize;\r\n\t\tuniforms.scale.value = material.scale;\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsPoints ( uniforms, material ) {\r\n\r\n\t\tuniforms.diffuse.value = material.color;\r\n\t\tuniforms.opacity.value = material.opacity;\r\n\t\tuniforms.size.value = material.size * _pixelRatio;\r\n\t\tuniforms.scale.value = _canvas.clientHeight * 0.5;\r\n\r\n\t\tuniforms.map.value = material.map;\r\n\r\n\t\tif ( material.map !== null ) {\r\n\r\n\t\t\tvar offset = material.map.offset;\r\n\t\t\tvar repeat = material.map.repeat;\r\n\r\n\t\t\tuniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsFog ( uniforms, fog ) {\r\n\r\n\t\tuniforms.fogColor.value = fog.color;\r\n\r\n\t\tif ( fog instanceof THREE.Fog ) {\r\n\r\n\t\t\tuniforms.fogNear.value = fog.near;\r\n\t\t\tuniforms.fogFar.value = fog.far;\r\n\r\n\t\t} else if ( fog instanceof THREE.FogExp2 ) {\r\n\r\n\t\t\tuniforms.fogDensity.value = fog.density;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsLambert ( uniforms, material ) {\r\n\r\n\t\tif ( material.lightMap ) {\r\n\r\n\t\t\tuniforms.lightMap.value = material.lightMap;\r\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.emissiveMap ) {\r\n\r\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsPhong ( uniforms, material ) {\r\n\r\n\t\tuniforms.specular.value = material.specular;\r\n\t\tuniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )\r\n\r\n\t\tif ( material.lightMap ) {\r\n\r\n\t\t\tuniforms.lightMap.value = material.lightMap;\r\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.emissiveMap ) {\r\n\r\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.bumpMap ) {\r\n\r\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\r\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.normalMap ) {\r\n\r\n\t\t\tuniforms.normalMap.value = material.normalMap;\r\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.displacementMap ) {\r\n\r\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\r\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\r\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsStandard ( uniforms, material ) {\r\n\r\n\t\tuniforms.roughness.value = material.roughness;\r\n\t\tuniforms.metalness.value = material.metalness;\r\n\r\n\t\tif ( material.roughnessMap ) {\r\n\r\n\t\t\tuniforms.roughnessMap.value = material.roughnessMap;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.metalnessMap ) {\r\n\r\n\t\t\tuniforms.metalnessMap.value = material.metalnessMap;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.lightMap ) {\r\n\r\n\t\t\tuniforms.lightMap.value = material.lightMap;\r\n\t\t\tuniforms.lightMapIntensity.value = material.lightMapIntensity;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.emissiveMap ) {\r\n\r\n\t\t\tuniforms.emissiveMap.value = material.emissiveMap;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.bumpMap ) {\r\n\r\n\t\t\tuniforms.bumpMap.value = material.bumpMap;\r\n\t\t\tuniforms.bumpScale.value = material.bumpScale;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.normalMap ) {\r\n\r\n\t\t\tuniforms.normalMap.value = material.normalMap;\r\n\t\t\tuniforms.normalScale.value.copy( material.normalScale );\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.displacementMap ) {\r\n\r\n\t\t\tuniforms.displacementMap.value = material.displacementMap;\r\n\t\t\tuniforms.displacementScale.value = material.displacementScale;\r\n\t\t\tuniforms.displacementBias.value = material.displacementBias;\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.envMap ) {\r\n\r\n\t\t\t//uniforms.envMap.value = material.envMap; // part of uniforms common\r\n\t\t\tuniforms.envMapIntensity.value = material.envMapIntensity;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction refreshUniformsPhysical ( uniforms, material ) {\r\n\r\n\t\trefreshUniformsStandard( uniforms, material );\r\n\r\n\t}\r\n\r\n\t// If uniforms are marked as clean, they don't need to be loaded to the GPU.\r\n\r\n\tfunction markUniformsLightsNeedsUpdate ( uniforms, value ) {\r\n\r\n\t\tuniforms.ambientLightColor.needsUpdate = value;\r\n\r\n\t\tuniforms.directionalLights.needsUpdate = value;\r\n\t\tuniforms.pointLights.needsUpdate = value;\r\n\t\tuniforms.spotLights.needsUpdate = value;\r\n\t\tuniforms.hemisphereLights.needsUpdate = value;\r\n\r\n\t}\r\n\r\n\t// Lighting\r\n\r\n\tfunction setupShadows ( lights ) {\r\n\r\n\t\tvar lightShadowsLength = 0;\r\n\r\n\t\tfor ( var i = 0, l = lights.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar light = lights[ i ];\r\n\r\n\t\t\tif ( light.castShadow ) {\r\n\r\n\t\t\t\t_lights.shadows[ lightShadowsLength ++ ] = light;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t_lights.shadows.length = lightShadowsLength;\r\n\r\n\t}\r\n\r\n\tfunction setupLights ( lights, camera ) {\r\n\r\n\t\tvar l, ll, light,\r\n\t\tr = 0, g = 0, b = 0,\r\n\t\tcolor,\r\n\t\tintensity,\r\n\t\tdistance,\r\n\t\tshadowMap,\r\n\r\n\t\tviewMatrix = camera.matrixWorldInverse,\r\n\r\n\t\tdirectionalLength = 0,\r\n\t\tpointLength = 0,\r\n\t\tspotLength = 0,\r\n\t\themiLength = 0;\r\n\r\n\t\tfor ( l = 0, ll = lights.length; l < ll; l ++ ) {\r\n\r\n\t\t\tlight = lights[ l ];\r\n\r\n\t\t\tcolor = light.color;\r\n\t\t\tintensity = light.intensity;\r\n\t\t\tdistance = light.distance;\r\n\r\n\t\t\tshadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;\r\n\r\n\t\t\tif ( light instanceof THREE.AmbientLight ) {\r\n\r\n\t\t\t\tr += color.r * intensity;\r\n\t\t\t\tg += color.g * intensity;\r\n\t\t\t\tb += color.b * intensity;\r\n\r\n\t\t\t} else if ( light instanceof THREE.DirectionalLight ) {\r\n\r\n\t\t\t\tvar uniforms = lightCache.get( light );\r\n\r\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\r\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\tuniforms.direction.sub( _vector3 );\r\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\r\n\r\n\t\t\t\tuniforms.shadow = light.castShadow;\r\n\r\n\t\t\t\tif ( light.castShadow ) {\r\n\r\n\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\r\n\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\r\n\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_lights.directionalShadowMap[ directionalLength ] = shadowMap;\r\n\t\t\t\t_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;\r\n\t\t\t\t_lights.directional[ directionalLength ++ ] = uniforms;\r\n\r\n\t\t\t} else if ( light instanceof THREE.SpotLight ) {\r\n\r\n\t\t\t\tvar uniforms = lightCache.get( light );\r\n\r\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\r\n\r\n\t\t\t\tuniforms.color.copy( color ).multiplyScalar( intensity );\r\n\t\t\t\tuniforms.distance = distance;\r\n\r\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\t_vector3.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\tuniforms.direction.sub( _vector3 );\r\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\r\n\r\n\t\t\t\tuniforms.coneCos = Math.cos( light.angle );\r\n\t\t\t\tuniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );\r\n\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\r\n\r\n\t\t\t\tuniforms.shadow = light.castShadow;\r\n\r\n\t\t\t\tif ( light.castShadow ) {\r\n\r\n\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\r\n\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\r\n\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_lights.spotShadowMap[ spotLength ] = shadowMap;\r\n\t\t\t\t_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;\r\n\t\t\t\t_lights.spot[ spotLength ++ ] = uniforms;\r\n\r\n\t\t\t} else if ( light instanceof THREE.PointLight ) {\r\n\r\n\t\t\t\tvar uniforms = lightCache.get( light );\r\n\r\n\t\t\t\tuniforms.position.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\tuniforms.position.applyMatrix4( viewMatrix );\r\n\r\n\t\t\t\tuniforms.color.copy( light.color ).multiplyScalar( light.intensity );\r\n\t\t\t\tuniforms.distance = light.distance;\r\n\t\t\t\tuniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;\r\n\r\n\t\t\t\tuniforms.shadow = light.castShadow;\r\n\r\n\t\t\t\tif ( light.castShadow ) {\r\n\r\n\t\t\t\t\tuniforms.shadowBias = light.shadow.bias;\r\n\t\t\t\t\tuniforms.shadowRadius = light.shadow.radius;\r\n\t\t\t\t\tuniforms.shadowMapSize = light.shadow.mapSize;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t_lights.pointShadowMap[ pointLength ] = shadowMap;\r\n\r\n\t\t\t\tif ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {\r\n\r\n\t\t\t\t\t_lights.pointShadowMatrix[ pointLength ] = new THREE.Matrix4();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// for point lights we set the shadow matrix to be a translation-only matrix\r\n\t\t\t\t// equal to inverse of the light's position\r\n\t\t\t\t_vector3.setFromMatrixPosition( light.matrixWorld ).negate();\r\n\t\t\t\t_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );\r\n\r\n\t\t\t\t_lights.point[ pointLength ++ ] = uniforms;\r\n\r\n\t\t\t} else if ( light instanceof THREE.HemisphereLight ) {\r\n\r\n\t\t\t\tvar uniforms = lightCache.get( light );\r\n\r\n\t\t\t\tuniforms.direction.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\t\tuniforms.direction.transformDirection( viewMatrix );\r\n\t\t\t\tuniforms.direction.normalize();\r\n\r\n\t\t\t\tuniforms.skyColor.copy( light.color ).multiplyScalar( intensity );\r\n\t\t\t\tuniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );\r\n\r\n\t\t\t\t_lights.hemi[ hemiLength ++ ] = uniforms;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t_lights.ambient[ 0 ] = r;\r\n\t\t_lights.ambient[ 1 ] = g;\r\n\t\t_lights.ambient[ 2 ] = b;\r\n\r\n\t\t_lights.directional.length = directionalLength;\r\n\t\t_lights.spot.length = spotLength;\r\n\t\t_lights.point.length = pointLength;\r\n\t\t_lights.hemi.length = hemiLength;\r\n\r\n\t\t_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + hemiLength + ',' + _lights.shadows.length;\r\n\r\n\t}\r\n\r\n\t// GL state setting\r\n\r\n\tthis.setFaceCulling = function ( cullFace, frontFaceDirection ) {\r\n\r\n\t\tstate.setCullFace( cullFace );\r\n\t\tstate.setFlipSided( frontFaceDirection === THREE.FrontFaceDirectionCW );\r\n\r\n\t};\r\n\r\n\t// Textures\r\n\r\n\tfunction allocTextureUnit() {\r\n\r\n\t\tvar textureUnit = _usedTextureUnits;\r\n\r\n\t\tif ( textureUnit >= capabilities.maxTextures ) {\r\n\r\n\t\t\tconsole.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );\r\n\r\n\t\t}\r\n\r\n\t\t_usedTextureUnits += 1;\r\n\r\n\t\treturn textureUnit;\r\n\r\n\t}\r\n\r\n\tfunction setTextureParameters ( textureType, texture, isPowerOfTwoImage ) {\r\n\r\n\t\tvar extension;\r\n\r\n\t\tif ( isPowerOfTwoImage ) {\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );\r\n\r\n\t\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );\r\n\t\t\t_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );\r\n\r\n\t\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\textension = extensions.get( 'EXT_texture_filter_anisotropic' );\r\n\r\n\t\tif ( extension ) {\r\n\r\n\t\t\tif ( texture.type === THREE.FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;\r\n\t\t\tif ( texture.type === THREE.HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;\r\n\r\n\t\t\tif ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {\r\n\r\n\t\t\t\t_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, _this.getMaxAnisotropy() ) );\r\n\t\t\t\tproperties.get( texture ).__currentAnisotropy = texture.anisotropy;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction uploadTexture( textureProperties, texture, slot ) {\r\n\r\n\t\tif ( textureProperties.__webglInit === undefined ) {\r\n\r\n\t\t\ttextureProperties.__webglInit = true;\r\n\r\n\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\r\n\r\n\t\t\ttextureProperties.__webglTexture = _gl.createTexture();\r\n\r\n\t\t\t_infoMemory.textures ++;\r\n\r\n\t\t}\r\n\r\n\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\r\n\r\n\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\t\t_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );\r\n\t\t_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );\r\n\r\n\t\tvar image = clampToMaxSize( texture.image, capabilities.maxTextureSize );\r\n\r\n\t\tif ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {\r\n\r\n\t\t\timage = makePowerOfTwo( image );\r\n\r\n\t\t}\r\n\r\n\t\tvar isPowerOfTwoImage = isPowerOfTwo( image ),\r\n\t\tglFormat = paramThreeToGL( texture.format ),\r\n\t\tglType = paramThreeToGL( texture.type );\r\n\r\n\t\tsetTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );\r\n\r\n\t\tvar mipmap, mipmaps = texture.mipmaps;\r\n\r\n\t\tif ( texture instanceof THREE.DepthTexture ) {\r\n\r\n\t\t\t// populate depth texture with dummy data\r\n\r\n\t\t\tvar internalFormat = _gl.DEPTH_COMPONENT;\r\n\r\n\t\t\tif ( texture.type === THREE.FloatType ) {\r\n\r\n\t\t\t\tif ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');\r\n\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT32F;\r\n\r\n\t\t\t} else if ( _isWebGL2 ) {\r\n\r\n\t\t\t\t// WebGL 2.0 requires signed internalformat for glTexImage2D\r\n\t\t\t\tinternalFormat = _gl.DEPTH_COMPONENT16;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );\r\n\r\n\t\t} else if ( texture instanceof THREE.DataTexture ) {\r\n\r\n\t\t\t// use manually created mipmaps if available\r\n\t\t\t// if there are no manual mipmaps\r\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\r\n\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\r\n\r\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture.generateMipmaps = false;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( texture instanceof THREE.CompressedTexture ) {\r\n\r\n\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tmipmap = mipmaps[ i ];\r\n\r\n\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\r\n\r\n\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\r\n\r\n\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()\" );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// regular Texture (image, video, canvas)\r\n\r\n\t\t\t// use manually created mipmaps if available\r\n\t\t\t// if there are no manual mipmaps\r\n\t\t\t// set 0 level mipmap and then use GL to generate other mipmap levels\r\n\r\n\t\t\tif ( mipmaps.length > 0 && isPowerOfTwoImage ) {\r\n\r\n\t\t\t\tfor ( var i = 0, il = mipmaps.length; i < il; i ++ ) {\r\n\r\n\t\t\t\t\tmipmap = mipmaps[ i ];\r\n\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture.generateMipmaps = false;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tstate.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n\r\n\t\ttextureProperties.__version = texture.version;\r\n\r\n\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\r\n\r\n\t}\r\n\r\n\tfunction setTexture2D( texture, slot ) {\r\n\r\n\t\tvar textureProperties = properties.get( texture );\r\n\r\n\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\r\n\r\n\t\t\tvar image = texture.image;\r\n\r\n\t\t\tif ( image === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( image.complete === false ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );\r\n\t\t\t\treturn;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuploadTexture( textureProperties, texture, slot );\r\n\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\r\n\r\n\t}\r\n\r\n\tfunction clampToMaxSize ( image, maxSize ) {\r\n\r\n\t\tif ( image.width > maxSize || image.height > maxSize ) {\r\n\r\n\t\t\t// Warning: Scaling through the canvas will only work with images that use\r\n\t\t\t// premultiplied alpha.\r\n\r\n\t\t\tvar scale = maxSize / Math.max( image.width, image.height );\r\n\r\n\t\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\t\tcanvas.width = Math.floor( image.width * scale );\r\n\t\t\tcanvas.height = Math.floor( image.height * scale );\r\n\r\n\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\tcontext.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );\r\n\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\r\n\r\n\t\t\treturn canvas;\r\n\r\n\t\t}\r\n\r\n\t\treturn image;\r\n\r\n\t}\r\n\r\n\tfunction isPowerOfTwo( image ) {\r\n\r\n\t\treturn THREE.Math.isPowerOfTwo( image.width ) && THREE.Math.isPowerOfTwo( image.height );\r\n\r\n\t}\r\n\r\n\tfunction textureNeedsPowerOfTwo( texture ) {\r\n\r\n\t\tif ( texture.wrapS !== THREE.ClampToEdgeWrapping || texture.wrapT !== THREE.ClampToEdgeWrapping ) return true;\r\n\t\tif ( texture.minFilter !== THREE.NearestFilter && texture.minFilter !== THREE.LinearFilter ) return true;\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tfunction makePowerOfTwo( image ) {\r\n\r\n\t\tif ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {\r\n\r\n\t\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\t\tcanvas.width = THREE.Math.nearestPowerOfTwo( image.width );\r\n\t\t\tcanvas.height = THREE.Math.nearestPowerOfTwo( image.height );\r\n\r\n\t\t\tvar context = canvas.getContext( '2d' );\r\n\t\t\tcontext.drawImage( image, 0, 0, canvas.width, canvas.height );\r\n\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );\r\n\r\n\t\t\treturn canvas;\r\n\r\n\t\t}\r\n\r\n\t\treturn image;\r\n\r\n\t}\r\n\r\n\tfunction setTextureCube ( texture, slot ) {\r\n\r\n\t\tvar textureProperties = properties.get( texture );\r\n\r\n\t\tif ( texture.image.length === 6 ) {\r\n\r\n\t\t\tif ( texture.version > 0 && textureProperties.__version !== texture.version ) {\r\n\r\n\t\t\t\tif ( ! textureProperties.__image__webglTextureCube ) {\r\n\r\n\t\t\t\t\ttexture.addEventListener( 'dispose', onTextureDispose );\r\n\r\n\t\t\t\t\ttextureProperties.__image__webglTextureCube = _gl.createTexture();\r\n\r\n\t\t\t\t\t_infoMemory.textures ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\r\n\r\n\t\t\t\t_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );\r\n\r\n\t\t\t\tvar isCompressed = texture instanceof THREE.CompressedTexture;\r\n\t\t\t\tvar isDataTexture = texture.image[ 0 ] instanceof THREE.DataTexture;\r\n\r\n\t\t\t\tvar cubeImage = [];\r\n\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t\tif ( _this.autoScaleCubemaps && ! isCompressed && ! isDataTexture ) {\r\n\r\n\t\t\t\t\t\tcubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tcubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tvar image = cubeImage[ 0 ],\r\n\t\t\t\tisPowerOfTwoImage = isPowerOfTwo( image ),\r\n\t\t\t\tglFormat = paramThreeToGL( texture.format ),\r\n\t\t\t\tglType = paramThreeToGL( texture.type );\r\n\r\n\t\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );\r\n\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t\tif ( ! isCompressed ) {\r\n\r\n\t\t\t\t\t\tif ( isDataTexture ) {\r\n\r\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );\r\n\r\n\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tvar mipmap, mipmaps = cubeImage[ i ].mipmaps;\r\n\r\n\t\t\t\t\t\tfor ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\t\t\tmipmap = mipmaps[ j ];\r\n\r\n\t\t\t\t\t\t\tif ( texture.format !== THREE.RGBAFormat && texture.format !== THREE.RGBFormat ) {\r\n\r\n\t\t\t\t\t\t\t\tif ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {\r\n\r\n\t\t\t\t\t\t\t\t\tstate.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );\r\n\r\n\t\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()\" );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tstate.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( texture.generateMipmaps && isPowerOfTwoImage ) {\r\n\r\n\t\t\t\t\t_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttextureProperties.__version = texture.version;\r\n\r\n\t\t\t\tif ( texture.onUpdate ) texture.onUpdate( texture );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction setTextureCubeDynamic ( texture, slot ) {\r\n\r\n\t\tstate.activeTexture( _gl.TEXTURE0 + slot );\r\n\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );\r\n\r\n\t}\r\n\r\n\tthis.allocTextureUnit = allocTextureUnit;\r\n\r\n\t//this.setTexture2D = setTexture2D;\r\n\tthis.setTexture2D = ( function() {\r\n\r\n\t\tvar warned = false;\r\n\r\n\t\t// backwards compatibility: peel texture.texture\r\n\t\treturn function( texture, slot ) {\r\n\r\n\t\t\tif ( texture instanceof THREE.WebGLRenderTarget ) {\r\n\r\n\t\t\t\tif ( ! warned ) {\r\n\r\n\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead.\" );\r\n\t\t\t\t\twarned = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture = texture.texture;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tsetTexture2D( texture, slot );\r\n\r\n\t\t};\r\n\r\n\t}() );\r\n\r\n\tthis.setTexture = ( function() {\r\n\r\n\t\tvar warned = false;\r\n\r\n\t\treturn function( texture, slot ) {\r\n\r\n\t\t\tif ( ! warned ) {\r\n\r\n\t\t\t\tconsole.warn( \"THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead.\" );\r\n\t\t\t\twarned = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_this.setTexture2D( texture, slot );\r\n\r\n\t\t};\r\n\r\n\t}() );\r\n\r\n\tthis.setTextureCube = ( function() {\r\n\r\n\t\tvar warned = false;\r\n\r\n\t\treturn function( texture, slot ) {\r\n\r\n\t\t\t// backwards compatibility: peel texture.texture\r\n\t\t\tif ( texture instanceof THREE.WebGLRenderTargetCube ) {\r\n\r\n\t\t\t\tif ( ! warned ) {\r\n\r\n\t\t\t\t\tconsole.warn( \"THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead.\" );\r\n\t\t\t\t\twarned = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\ttexture = texture.texture;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture\r\n\t\t\t// TODO: unify these code paths\r\n\t\t\tif ( texture instanceof THREE.CubeTexture ||\r\n\t\t\t\t ( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {\r\n\r\n\t\t\t\t// CompressedTexture can have Array in image :/\r\n\r\n\t\t\t\t// this function alone should take care of cube textures\r\n\t\t\t\tsetTextureCube( texture, slot );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// assumed: texture property of THREE.WebGLRenderTargetCube\r\n\r\n\t\t\t\tsetTextureCubeDynamic( texture, slot );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\t}() );\r\n\r\n\t// Render targets\r\n\r\n\t// Setup storage for target texture and bind it to correct framebuffer\r\n\tfunction setupFrameBufferTexture ( framebuffer, renderTarget, attachment, textureTarget ) {\r\n\r\n\t\tvar glFormat = paramThreeToGL( renderTarget.texture.format );\r\n\t\tvar glType = paramThreeToGL( renderTarget.texture.type );\r\n\t\tstate.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );\r\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );\r\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\r\n\r\n\t}\r\n\r\n\t// Setup storage for internal depth/stencil buffers and bind to correct framebuffer\r\n\tfunction setupRenderBufferStorage ( renderbuffer, renderTarget ) {\r\n\r\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );\r\n\r\n\t\tif ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );\r\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\r\n\t\t} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {\r\n\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );\r\n\t\t\t_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// FIXME: We don't support !depth !stencil\r\n\t\t\t_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );\r\n\r\n\t\t}\r\n\r\n\t\t_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );\r\n\r\n\t}\r\n\r\n\t// Setup resources for a Depth Texture for a FBO (needs an extension)\r\n\tfunction setupDepthTexture ( framebuffer, renderTarget ) {\r\n\r\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\t\tif ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');\r\n\r\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\r\n\t\tif ( !( renderTarget.depthTexture instanceof THREE.DepthTexture ) ) {\r\n\r\n\t\t\tthrow new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');\r\n\r\n\t\t}\r\n\r\n\t\t// upload an empty depth texture with framebuffer size\r\n\t\tif ( !properties.get( renderTarget.depthTexture ).__webglTexture ||\r\n\t\t\t\trenderTarget.depthTexture.image.width !== renderTarget.width ||\r\n\t\t\t\trenderTarget.depthTexture.image.height !== renderTarget.height ) {\r\n\t\t\trenderTarget.depthTexture.image.width = renderTarget.width;\r\n\t\t\trenderTarget.depthTexture.image.height = renderTarget.height;\r\n\t\t\trenderTarget.depthTexture.needsUpdate = true;\r\n\t\t}\r\n\r\n\t\t_this.setTexture2D( renderTarget.depthTexture, 0 );\r\n\r\n\t\tvar webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;\r\n\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );\r\n\r\n\t}\r\n\r\n\t// Setup GL resources for a non-texture depth buffer\r\n\tfunction setupDepthRenderbuffer( renderTarget ) {\r\n\r\n\t\tvar renderTargetProperties = properties.get( renderTarget );\r\n\r\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\r\n\t\tif ( renderTarget.depthTexture ) {\r\n\r\n\t\t\tif ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');\r\n\r\n\t\t\tsetupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif ( isCube ) {\r\n\r\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = [];\r\n\r\n\t\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );\r\n\t\t\t\t\trenderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();\r\n\t\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );\r\n\t\t\t\trenderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();\r\n\t\t\t\tsetupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );\r\n\r\n\t}\r\n\r\n\t// Set up GL resources for the render target\r\n\tfunction setupRenderTarget( renderTarget ) {\r\n\r\n\t\tvar renderTargetProperties = properties.get( renderTarget );\r\n\t\tvar textureProperties = properties.get( renderTarget.texture );\r\n\r\n\t\trenderTarget.addEventListener( 'dispose', onRenderTargetDispose );\r\n\r\n\t\ttextureProperties.__webglTexture = _gl.createTexture();\r\n\r\n\t\t_infoMemory.textures ++;\r\n\r\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\t\tvar isTargetPowerOfTwo = THREE.Math.isPowerOfTwo( renderTarget.width ) && THREE.Math.isPowerOfTwo( renderTarget.height );\r\n\r\n\t\t// Setup framebuffer\r\n\r\n\t\tif ( isCube ) {\r\n\r\n\t\t\trenderTargetProperties.__webglFramebuffer = [];\r\n\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\trenderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\trenderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();\r\n\r\n\t\t}\r\n\r\n\t\t// Setup color buffer\r\n\r\n\t\tif ( isCube ) {\r\n\r\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );\r\n\t\t\tsetTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );\r\n\r\n\t\t\tfor ( var i = 0; i < 6; i ++ ) {\r\n\r\n\t\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );\r\n\t\t\tstate.bindTexture( _gl.TEXTURE_CUBE_MAP, null );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );\r\n\t\t\tsetTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );\r\n\t\t\tsetupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );\r\n\r\n\t\t\tif ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );\r\n\t\t\tstate.bindTexture( _gl.TEXTURE_2D, null );\r\n\r\n\t\t}\r\n\r\n\t\t// Setup depth and stencil buffers\r\n\r\n\t\tif ( renderTarget.depthBuffer ) {\r\n\r\n\t\t\tsetupDepthRenderbuffer( renderTarget );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.getCurrentRenderTarget = function() {\r\n\r\n\t\treturn _currentRenderTarget;\r\n\r\n\t};\r\n\r\n\tthis.setRenderTarget = function ( renderTarget ) {\r\n\r\n\t\t_currentRenderTarget = renderTarget;\r\n\r\n\t\tif ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {\r\n\r\n\t\t\tsetupRenderTarget( renderTarget );\r\n\r\n\t\t}\r\n\r\n\t\tvar isCube = ( renderTarget instanceof THREE.WebGLRenderTargetCube );\r\n\t\tvar framebuffer;\r\n\r\n\t\tif ( renderTarget ) {\r\n\r\n\t\t\tvar renderTargetProperties = properties.get( renderTarget );\r\n\r\n\t\t\tif ( isCube ) {\r\n\r\n\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tframebuffer = renderTargetProperties.__webglFramebuffer;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t_currentScissor.copy( renderTarget.scissor );\r\n\t\t\t_currentScissorTest = renderTarget.scissorTest;\r\n\r\n\t\t\t_currentViewport.copy( renderTarget.viewport );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tframebuffer = null;\r\n\r\n\t\t\t_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );\r\n\t\t\t_currentScissorTest = _scissorTest;\r\n\r\n\t\t\t_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );\r\n\r\n\t\t}\r\n\r\n\t\tif ( _currentFramebuffer !== framebuffer ) {\r\n\r\n\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\t\t\t_currentFramebuffer = framebuffer;\r\n\r\n\t\t}\r\n\r\n\t\tstate.scissor( _currentScissor );\r\n\t\tstate.setScissorTest( _currentScissorTest );\r\n\r\n\t\tstate.viewport( _currentViewport );\r\n\r\n\t\tif ( isCube ) {\r\n\r\n\t\t\tvar textureProperties = properties.get( renderTarget.texture );\r\n\t\t\t_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {\r\n\r\n\t\tif ( renderTarget instanceof THREE.WebGLRenderTarget === false ) {\r\n\r\n\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar framebuffer = properties.get( renderTarget ).__webglFramebuffer;\r\n\r\n\t\tif ( framebuffer ) {\r\n\r\n\t\t\tvar restore = false;\r\n\r\n\t\t\tif ( framebuffer !== _currentFramebuffer ) {\r\n\r\n\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );\r\n\r\n\t\t\t\trestore = true;\r\n\r\n\t\t\t}\r\n\r\n\t\t\ttry {\r\n\r\n\t\t\t\tvar texture = renderTarget.texture;\r\n\r\n\t\t\t\tif ( texture.format !== THREE.RGBAFormat && paramThreeToGL( texture.format ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {\r\n\r\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( texture.type !== THREE.UnsignedByteType &&\r\n\t\t\t\t     paramThreeToGL( texture.type ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) &&\r\n\t\t\t\t     ! ( texture.type === THREE.FloatType && extensions.get( 'WEBGL_color_buffer_float' ) ) &&\r\n\t\t\t\t     ! ( texture.type === THREE.HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {\r\n\r\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );\r\n\t\t\t\t\treturn;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {\r\n\r\n\t\t\t\t\t// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)\r\n\r\n\t\t\t\t\tif ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {\r\n\r\n\t\t\t\t\t\t_gl.readPixels( x, y, width, height, paramThreeToGL( texture.format ), paramThreeToGL( texture.type ), buffer );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tconsole.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} finally {\r\n\r\n\t\t\t\tif ( restore ) {\r\n\r\n\t\t\t\t\t_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tfunction updateRenderTargetMipmap( renderTarget ) {\r\n\r\n\t\tvar target = renderTarget instanceof THREE.WebGLRenderTargetCube ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;\r\n\t\tvar texture = properties.get( renderTarget.texture ).__webglTexture;\r\n\r\n\t\tstate.bindTexture( target, texture );\r\n\t\t_gl.generateMipmap( target );\r\n\t\tstate.bindTexture( target, null );\r\n\r\n\t}\r\n\r\n\t// Fallback filters for non-power-of-2 textures\r\n\r\n\tfunction filterFallback ( f ) {\r\n\r\n\t\tif ( f === THREE.NearestFilter || f === THREE.NearestMipMapNearestFilter || f === THREE.NearestMipMapLinearFilter ) {\r\n\r\n\t\t\treturn _gl.NEAREST;\r\n\r\n\t\t}\r\n\r\n\t\treturn _gl.LINEAR;\r\n\r\n\t}\r\n\r\n\t// Map three.js constants to WebGL constants\r\n\r\n\tfunction paramThreeToGL ( p ) {\r\n\r\n\t\tvar extension;\r\n\r\n\t\tif ( p === THREE.RepeatWrapping ) return _gl.REPEAT;\r\n\t\tif ( p === THREE.ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;\r\n\t\tif ( p === THREE.MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;\r\n\r\n\t\tif ( p === THREE.NearestFilter ) return _gl.NEAREST;\r\n\t\tif ( p === THREE.NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;\r\n\t\tif ( p === THREE.NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;\r\n\r\n\t\tif ( p === THREE.LinearFilter ) return _gl.LINEAR;\r\n\t\tif ( p === THREE.LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;\r\n\t\tif ( p === THREE.LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;\r\n\r\n\t\tif ( p === THREE.UnsignedByteType ) return _gl.UNSIGNED_BYTE;\r\n\t\tif ( p === THREE.UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;\r\n\t\tif ( p === THREE.UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;\r\n\t\tif ( p === THREE.UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;\r\n\r\n\t\tif ( p === THREE.ByteType ) return _gl.BYTE;\r\n\t\tif ( p === THREE.ShortType ) return _gl.SHORT;\r\n\t\tif ( p === THREE.UnsignedShortType ) return _gl.UNSIGNED_SHORT;\r\n\t\tif ( p === THREE.IntType ) return _gl.INT;\r\n\t\tif ( p === THREE.UnsignedIntType ) return _gl.UNSIGNED_INT;\r\n\t\tif ( p === THREE.FloatType ) return _gl.FLOAT;\r\n\r\n\t\textension = extensions.get( 'OES_texture_half_float' );\r\n\r\n\t\tif ( extension !== null ) {\r\n\r\n\t\t\tif ( p === THREE.HalfFloatType ) return extension.HALF_FLOAT_OES;\r\n\r\n\t\t}\r\n\r\n\t\tif ( p === THREE.AlphaFormat ) return _gl.ALPHA;\r\n\t\tif ( p === THREE.RGBFormat ) return _gl.RGB;\r\n\t\tif ( p === THREE.RGBAFormat ) return _gl.RGBA;\r\n\t\tif ( p === THREE.LuminanceFormat ) return _gl.LUMINANCE;\r\n\t\tif ( p === THREE.LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;\r\n\t\tif ( p === THREE.DepthFormat ) return _gl.DEPTH_COMPONENT;\r\n\r\n\t\tif ( p === THREE.AddEquation ) return _gl.FUNC_ADD;\r\n\t\tif ( p === THREE.SubtractEquation ) return _gl.FUNC_SUBTRACT;\r\n\t\tif ( p === THREE.ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;\r\n\r\n\t\tif ( p === THREE.ZeroFactor ) return _gl.ZERO;\r\n\t\tif ( p === THREE.OneFactor ) return _gl.ONE;\r\n\t\tif ( p === THREE.SrcColorFactor ) return _gl.SRC_COLOR;\r\n\t\tif ( p === THREE.OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;\r\n\t\tif ( p === THREE.SrcAlphaFactor ) return _gl.SRC_ALPHA;\r\n\t\tif ( p === THREE.OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;\r\n\t\tif ( p === THREE.DstAlphaFactor ) return _gl.DST_ALPHA;\r\n\t\tif ( p === THREE.OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;\r\n\r\n\t\tif ( p === THREE.DstColorFactor ) return _gl.DST_COLOR;\r\n\t\tif ( p === THREE.OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;\r\n\t\tif ( p === THREE.SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;\r\n\r\n\t\textension = extensions.get( 'WEBGL_compressed_texture_s3tc' );\r\n\r\n\t\tif ( extension !== null ) {\r\n\r\n\t\t\tif ( p === THREE.RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;\r\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;\r\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;\r\n\t\t\tif ( p === THREE.RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;\r\n\r\n\t\t}\r\n\r\n\t\textension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );\r\n\r\n\t\tif ( extension !== null ) {\r\n\r\n\t\t\tif ( p === THREE.RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;\r\n\t\t\tif ( p === THREE.RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;\r\n\t\t\tif ( p === THREE.RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;\r\n\t\t\tif ( p === THREE.RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;\r\n\r\n\t\t}\r\n\r\n\t\textension = extensions.get( 'WEBGL_compressed_texture_etc1' );\r\n\r\n\t\tif ( extension !== null ) {\r\n\r\n\t\t\tif ( p === THREE.RGB_ETC1_Format ) return extension.COMPRESSED_RGB_ETC1_WEBGL;\r\n\r\n\t\t}\r\n\r\n\t\textension = extensions.get( 'EXT_blend_minmax' );\r\n\r\n\t\tif ( extension !== null ) {\r\n\r\n\t\t\tif ( p === THREE.MinEquation ) return extension.MIN_EXT;\r\n\t\t\tif ( p === THREE.MaxEquation ) return extension.MAX_EXT;\r\n\r\n\t\t}\r\n\r\n\t\treturn 0;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/renderers/WebGLRenderTarget.js\r\n\r\n/**\r\n * @author szimek / https://github.com/szimek/\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author Marius Kintel / https://github.com/kintel\r\n */\r\n\r\n/*\r\n In options, we can specify:\r\n * Texture parameters for an auto-generated target texture\r\n * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers\r\n*/\r\nTHREE.WebGLRenderTarget = function ( width, height, options ) {\r\n\r\n\tthis.uuid = THREE.Math.generateUUID();\r\n\r\n\tthis.width = width;\r\n\tthis.height = height;\r\n\r\n\tthis.scissor = new THREE.Vector4( 0, 0, width, height );\r\n\tthis.scissorTest = false;\r\n\r\n\tthis.viewport = new THREE.Vector4( 0, 0, width, height );\r\n\r\n\toptions = options || {};\r\n\r\n\tif ( options.minFilter === undefined ) options.minFilter = THREE.LinearFilter;\r\n\r\n\tthis.texture = new THREE.Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );\r\n\r\n\tthis.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;\r\n\tthis.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;\r\n\tthis.depthTexture = null;\r\n\r\n};\r\n\r\nObject.assign( THREE.WebGLRenderTarget.prototype, THREE.EventDispatcher.prototype, {\r\n\r\n\tsetSize: function ( width, height ) {\r\n\r\n\t\tif ( this.width !== width || this.height !== height ) {\r\n\r\n\t\t\tthis.width = width;\r\n\t\t\tthis.height = height;\r\n\r\n\t\t\tthis.dispose();\r\n\r\n\t\t}\r\n\r\n\t\tthis.viewport.set( 0, 0, width, height );\r\n\t\tthis.scissor.set( 0, 0, width, height );\r\n\r\n\t},\r\n\r\n\tclone: function () {\r\n\r\n\t\treturn new this.constructor().copy( this );\r\n\r\n\t},\r\n\r\n\tcopy: function ( source ) {\r\n\r\n\t\tthis.width = source.width;\r\n\t\tthis.height = source.height;\r\n\r\n\t\tthis.viewport.copy( source.viewport );\r\n\r\n\t\tthis.texture = source.texture.clone();\r\n\r\n\t\tthis.depthBuffer = source.depthBuffer;\r\n\t\tthis.stencilBuffer = source.stencilBuffer;\r\n\t\tthis.depthTexture = source.depthTexture;\r\n\r\n\t\treturn this;\r\n\r\n\t},\r\n\r\n\tdispose: function () {\r\n\r\n\t\tthis.dispatchEvent( { type: 'dispose' } );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/renderers/WebGLRenderTargetCube.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com\r\n */\r\n\r\nTHREE.WebGLRenderTargetCube = function ( width, height, options ) {\r\n\r\n\tTHREE.WebGLRenderTarget.call( this, width, height, options );\r\n\r\n\tthis.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5\r\n\tthis.activeMipMapLevel = 0;\r\n\r\n};\r\n\r\nTHREE.WebGLRenderTargetCube.prototype = Object.create( THREE.WebGLRenderTarget.prototype );\r\nTHREE.WebGLRenderTargetCube.prototype.constructor = THREE.WebGLRenderTargetCube;\r\n\r\n// File:src/renderers/webgl/WebGLBufferRenderer.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLBufferRenderer = function ( _gl, extensions, _infoRender ) {\r\n\r\n\tvar mode;\r\n\r\n\tfunction setMode( value ) {\r\n\r\n\t\tmode = value;\r\n\r\n\t}\r\n\r\n\tfunction render( start, count ) {\r\n\r\n\t\t_gl.drawArrays( mode, start, count );\r\n\r\n\t\t_infoRender.calls ++;\r\n\t\t_infoRender.vertices += count;\r\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\r\n\r\n\t}\r\n\r\n\tfunction renderInstances( geometry ) {\r\n\r\n\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\r\n\t\tif ( extension === null ) {\r\n\r\n\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tvar position = geometry.attributes.position;\r\n\r\n\t\tvar count = 0;\r\n\r\n\t\tif ( position instanceof THREE.InterleavedBufferAttribute ) {\r\n\r\n\t\t\tcount = position.data.count;\r\n\r\n\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tcount = position.count;\r\n\r\n\t\t\textension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );\r\n\r\n\t\t}\r\n\r\n\t\t_infoRender.calls ++;\r\n\t\t_infoRender.vertices += count * geometry.maxInstancedCount;\r\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;\r\n\r\n\t}\r\n\r\n\tthis.setMode = setMode;\r\n\tthis.render = render;\r\n\tthis.renderInstances = renderInstances;\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLClipping.js\r\n\r\nTHREE.WebGLClipping = function() {\r\n\r\n\tvar scope = this,\r\n\r\n\t\tglobalState = null,\r\n\t\tnumGlobalPlanes = 0,\r\n\t\tlocalClippingEnabled = false,\r\n\t\trenderingShadows = false,\r\n\r\n\t\tplane = new THREE.Plane(),\r\n\t\tviewNormalMatrix = new THREE.Matrix3(),\r\n\r\n\t\tuniform = { value: null, needsUpdate: false };\r\n\r\n\tthis.uniform = uniform;\r\n\tthis.numPlanes = 0;\r\n\r\n\tthis.init = function( planes, enableLocalClipping, camera ) {\r\n\r\n\t\tvar enabled =\r\n\t\t\tplanes.length !== 0 ||\r\n\t\t\tenableLocalClipping ||\r\n\t\t\t// enable state of previous frame - the clipping code has to\r\n\t\t\t// run another frame in order to reset the state:\r\n\t\t\tnumGlobalPlanes !== 0 ||\r\n\t\t\tlocalClippingEnabled;\r\n\r\n\t\tlocalClippingEnabled = enableLocalClipping;\r\n\r\n\t\tglobalState = projectPlanes( planes, camera, 0 );\r\n\t\tnumGlobalPlanes = planes.length;\r\n\r\n\t\treturn enabled;\r\n\r\n\t};\r\n\r\n\tthis.beginShadows = function() {\r\n\r\n\t\trenderingShadows = true;\r\n\t\tprojectPlanes( null );\r\n\r\n\t};\r\n\r\n\tthis.endShadows = function() {\r\n\r\n\t\trenderingShadows = false;\r\n\t\tresetGlobalState();\r\n\r\n\t};\r\n\r\n\tthis.setState = function( planes, clipShadows, camera, cache, fromCache ) {\r\n\r\n\t\tif ( ! localClippingEnabled ||\r\n\t\t\t\tplanes === null || planes.length === 0 ||\r\n\t\t\t\trenderingShadows && ! clipShadows ) {\r\n\t\t\t// there's no local clipping\r\n\r\n\t\t\tif ( renderingShadows ) {\r\n\t\t\t\t// there's no global clipping\r\n\r\n\t\t\t\tprojectPlanes( null );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tresetGlobalState();\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar nGlobal = renderingShadows ? 0 : numGlobalPlanes,\r\n\t\t\t\tlGlobal = nGlobal * 4,\r\n\r\n\t\t\t\tdstArray = cache.clippingState || null;\r\n\r\n\t\t\tuniform.value = dstArray; // ensure unique state\r\n\r\n\t\t\tdstArray = projectPlanes( planes, camera, lGlobal, fromCache );\r\n\r\n\t\t\tfor ( var i = 0; i !== lGlobal; ++ i ) {\r\n\r\n\t\t\t\tdstArray[ i ] = globalState[ i ];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcache.clippingState = dstArray;\r\n\t\t\tthis.numPlanes += nGlobal;\r\n\r\n\t\t}\r\n\r\n\r\n\t};\r\n\r\n\tfunction resetGlobalState() {\r\n\r\n\t\tif ( uniform.value !== globalState ) {\r\n\r\n\t\t\tuniform.value = globalState;\r\n\t\t\tuniform.needsUpdate = numGlobalPlanes > 0;\r\n\r\n\t\t}\r\n\r\n\t\tscope.numPlanes = numGlobalPlanes;\r\n\r\n\t}\r\n\r\n\tfunction projectPlanes( planes, camera, dstOffset, skipTransform ) {\r\n\r\n\t\tvar nPlanes = planes !== null ? planes.length : 0,\r\n\t\t\tdstArray = null;\r\n\r\n\t\tif ( nPlanes !== 0 ) {\r\n\r\n\t\t\tdstArray = uniform.value;\r\n\r\n\t\t\tif ( skipTransform !== true || dstArray === null ) {\r\n\r\n\t\t\t\tvar flatSize = dstOffset + nPlanes * 4,\r\n\t\t\t\t\tviewMatrix = camera.matrixWorldInverse;\r\n\r\n\t\t\t\tviewNormalMatrix.getNormalMatrix( viewMatrix );\r\n\r\n\t\t\t\tif ( dstArray === null || dstArray.length < flatSize ) {\r\n\r\n\t\t\t\t\tdstArray = new Float32Array( flatSize );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var i = 0, i4 = dstOffset;\r\n\t\t\t\t\t\t\t\t\ti !== nPlanes; ++ i, i4 += 4 ) {\r\n\r\n\t\t\t\t\tplane.copy( planes[ i ] ).\r\n\t\t\t\t\t\t\tapplyMatrix4( viewMatrix, viewNormalMatrix );\r\n\r\n\t\t\t\t\tplane.normal.toArray( dstArray, i4 );\r\n\t\t\t\t\tdstArray[ i4 + 3 ] = plane.constant;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tuniform.value = dstArray;\r\n\t\t\tuniform.needsUpdate = true;\r\n\r\n\t\t}\r\n\r\n\t\tscope.numPlanes = nPlanes;\r\n\t\treturn dstArray;\r\n\r\n\t}\r\n\r\n};\r\n\r\n\r\n// File:src/renderers/webgl/WebGLIndexedBufferRenderer.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLIndexedBufferRenderer = function ( _gl, extensions, _infoRender ) {\r\n\r\n\tvar mode;\r\n\r\n\tfunction setMode( value ) {\r\n\r\n\t\tmode = value;\r\n\r\n\t}\r\n\r\n\tvar type, size;\r\n\r\n\tfunction setIndex( index ) {\r\n\r\n\t\tif ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {\r\n\r\n\t\t\ttype = _gl.UNSIGNED_INT;\r\n\t\t\tsize = 4;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttype = _gl.UNSIGNED_SHORT;\r\n\t\t\tsize = 2;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction render( start, count ) {\r\n\r\n\t\t_gl.drawElements( mode, count, type, start * size );\r\n\r\n\t\t_infoRender.calls ++;\r\n\t\t_infoRender.vertices += count;\r\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += count / 3;\r\n\r\n\t}\r\n\r\n\tfunction renderInstances( geometry, start, count ) {\r\n\r\n\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\r\n\t\tif ( extension === null ) {\r\n\r\n\t\t\tconsole.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\textension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );\r\n\r\n\t\t_infoRender.calls ++;\r\n\t\t_infoRender.vertices += count * geometry.maxInstancedCount;\r\n\t\tif ( mode === _gl.TRIANGLES ) _infoRender.faces += geometry.maxInstancedCount * count / 3;\r\n\t}\r\n\r\n\tthis.setMode = setMode;\r\n\tthis.setIndex = setIndex;\r\n\tthis.render = render;\r\n\tthis.renderInstances = renderInstances;\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLExtensions.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLExtensions = function ( gl ) {\r\n\r\n\tvar extensions = {};\r\n\r\n\tthis.get = function ( name ) {\r\n\r\n\t\tif ( extensions[ name ] !== undefined ) {\r\n\r\n\t\t\treturn extensions[ name ];\r\n\r\n\t\t}\r\n\r\n\t\tvar extension;\r\n\r\n\t\tswitch ( name ) {\r\n\r\n\t\t\tcase 'WEBGL_depth_texture':\r\n\t\t\t\textension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'EXT_texture_filter_anisotropic':\r\n\t\t\t\textension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'WEBGL_compressed_texture_s3tc':\r\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'WEBGL_compressed_texture_pvrtc':\r\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'WEBGL_compressed_texture_etc1':\r\n\t\t\t\textension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\textension = gl.getExtension( name );\r\n\r\n\t\t}\r\n\r\n\t\tif ( extension === null ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );\r\n\r\n\t\t}\r\n\r\n\t\textensions[ name ] = extension;\r\n\r\n\t\treturn extension;\r\n\r\n\t};\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLCapabilities.js\r\n\r\nTHREE.WebGLCapabilities = function ( gl, extensions, parameters ) {\r\n\r\n\tfunction getMaxPrecision( precision ) {\r\n\r\n\t\tif ( precision === 'highp' ) {\r\n\r\n\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&\r\n\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {\r\n\r\n\t\t\t\treturn 'highp';\r\n\r\n\t\t\t}\r\n\r\n\t\t\tprecision = 'mediump';\r\n\r\n\t\t}\r\n\r\n\t\tif ( precision === 'mediump' ) {\r\n\r\n\t\t\tif ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&\r\n\t\t\t     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {\r\n\r\n\t\t\t\treturn 'mediump';\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn 'lowp';\r\n\r\n\t}\r\n\r\n\tthis.getMaxPrecision = getMaxPrecision;\r\n\r\n\tthis.precision = parameters.precision !== undefined ? parameters.precision : 'highp';\r\n\tthis.logarithmicDepthBuffer = parameters.logarithmicDepthBuffer !== undefined ? parameters.logarithmicDepthBuffer : false;\r\n\r\n\tthis.maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\r\n\tthis.maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );\r\n\tthis.maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );\r\n\tthis.maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );\r\n\r\n\tthis.maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\r\n\tthis.maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );\r\n\tthis.maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );\r\n\tthis.maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );\r\n\r\n\tthis.vertexTextures = this.maxVertexTextures > 0;\r\n\tthis.floatFragmentTextures = !! extensions.get( 'OES_texture_float' );\r\n\tthis.floatVertexTextures = this.vertexTextures && this.floatFragmentTextures;\r\n\r\n\tvar _maxPrecision = getMaxPrecision( this.precision );\r\n\r\n\tif ( _maxPrecision !== this.precision ) {\r\n\r\n\t\tconsole.warn( 'THREE.WebGLRenderer:', this.precision, 'not supported, using', _maxPrecision, 'instead.' );\r\n\t\tthis.precision = _maxPrecision;\r\n\r\n\t}\r\n\r\n\tif ( this.logarithmicDepthBuffer ) {\r\n\r\n\t\tthis.logarithmicDepthBuffer = !! extensions.get( 'EXT_frag_depth' );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLGeometries.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLGeometries = function ( gl, properties, info ) {\r\n\r\n\tvar geometries = {};\r\n\r\n\tfunction get( object ) {\r\n\r\n\t\tvar geometry = object.geometry;\r\n\r\n\t\tif ( geometries[ geometry.id ] !== undefined ) {\r\n\r\n\t\t\treturn geometries[ geometry.id ];\r\n\r\n\t\t}\r\n\r\n\t\tgeometry.addEventListener( 'dispose', onGeometryDispose );\r\n\r\n\t\tvar buffergeometry;\r\n\r\n\t\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\tbuffergeometry = geometry;\r\n\r\n\t\t} else if ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\tif ( geometry._bufferGeometry === undefined ) {\r\n\r\n\t\t\t\tgeometry._bufferGeometry = new THREE.BufferGeometry().setFromObject( object );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tbuffergeometry = geometry._bufferGeometry;\r\n\r\n\t\t}\r\n\r\n\t\tgeometries[ geometry.id ] = buffergeometry;\r\n\r\n\t\tinfo.memory.geometries ++;\r\n\r\n\t\treturn buffergeometry;\r\n\r\n\t}\r\n\r\n\tfunction onGeometryDispose( event ) {\r\n\r\n\t\tvar geometry = event.target;\r\n\t\tvar buffergeometry = geometries[ geometry.id ];\r\n\r\n\t\tif ( buffergeometry.index !== null ) {\r\n\r\n\t\t\tdeleteAttribute( buffergeometry.index );\r\n\r\n\t\t}\r\n\r\n\t\tdeleteAttributes( buffergeometry.attributes );\r\n\r\n\t\tgeometry.removeEventListener( 'dispose', onGeometryDispose );\r\n\r\n\t\tdelete geometries[ geometry.id ];\r\n\r\n\t\t// TODO\r\n\r\n\t\tvar property = properties.get( geometry );\r\n\r\n\t\tif ( property.wireframe ) {\r\n\r\n\t\t\tdeleteAttribute( property.wireframe );\r\n\r\n\t\t}\r\n\r\n\t\tproperties.delete( geometry );\r\n\r\n\t\tvar bufferproperty = properties.get( buffergeometry );\r\n\r\n\t\tif ( bufferproperty.wireframe ) {\r\n\r\n\t\t\tdeleteAttribute( bufferproperty.wireframe );\r\n\r\n\t\t}\r\n\r\n\t\tproperties.delete( buffergeometry );\r\n\r\n\t\t//\r\n\r\n\t\tinfo.memory.geometries --;\r\n\r\n\t}\r\n\r\n\tfunction getAttributeBuffer( attribute ) {\r\n\r\n\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\r\n\t\t\treturn properties.get( attribute.data ).__webglBuffer;\r\n\r\n\t\t}\r\n\r\n\t\treturn properties.get( attribute ).__webglBuffer;\r\n\r\n\t}\r\n\r\n\tfunction deleteAttribute( attribute ) {\r\n\r\n\t\tvar buffer = getAttributeBuffer( attribute );\r\n\r\n\t\tif ( buffer !== undefined ) {\r\n\r\n\t\t\tgl.deleteBuffer( buffer );\r\n\t\t\tremoveAttributeBuffer( attribute );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction deleteAttributes( attributes ) {\r\n\r\n\t\tfor ( var name in attributes ) {\r\n\r\n\t\t\tdeleteAttribute( attributes[ name ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction removeAttributeBuffer( attribute ) {\r\n\r\n\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\r\n\t\t\tproperties.delete( attribute.data );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tproperties.delete( attribute );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.get = get;\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLLights.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLLights = function () {\r\n\r\n\tvar lights = {};\r\n\r\n\tthis.get = function ( light ) {\r\n\r\n\t\tif ( lights[ light.id ] !== undefined ) {\r\n\r\n\t\t\treturn lights[ light.id ];\r\n\r\n\t\t}\r\n\r\n\t\tvar uniforms;\r\n\r\n\t\tswitch ( light.type ) {\r\n\r\n\t\t\tcase 'DirectionalLight':\r\n\t\t\t\tuniforms = {\r\n\t\t\t\t\tdirection: new THREE.Vector3(),\r\n\t\t\t\t\tcolor: new THREE.Color(),\r\n\r\n\t\t\t\t\tshadow: false,\r\n\t\t\t\t\tshadowBias: 0,\r\n\t\t\t\t\tshadowRadius: 1,\r\n\t\t\t\t\tshadowMapSize: new THREE.Vector2()\r\n\t\t\t\t};\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'SpotLight':\r\n\t\t\t\tuniforms = {\r\n\t\t\t\t\tposition: new THREE.Vector3(),\r\n\t\t\t\t\tdirection: new THREE.Vector3(),\r\n\t\t\t\t\tcolor: new THREE.Color(),\r\n\t\t\t\t\tdistance: 0,\r\n\t\t\t\t\tconeCos: 0,\r\n\t\t\t\t\tpenumbraCos: 0,\r\n\t\t\t\t\tdecay: 0,\r\n\r\n\t\t\t\t\tshadow: false,\r\n\t\t\t\t\tshadowBias: 0,\r\n\t\t\t\t\tshadowRadius: 1,\r\n\t\t\t\t\tshadowMapSize: new THREE.Vector2()\r\n\t\t\t\t};\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'PointLight':\r\n\t\t\t\tuniforms = {\r\n\t\t\t\t\tposition: new THREE.Vector3(),\r\n\t\t\t\t\tcolor: new THREE.Color(),\r\n\t\t\t\t\tdistance: 0,\r\n\t\t\t\t\tdecay: 0,\r\n\r\n\t\t\t\t\tshadow: false,\r\n\t\t\t\t\tshadowBias: 0,\r\n\t\t\t\t\tshadowRadius: 1,\r\n\t\t\t\t\tshadowMapSize: new THREE.Vector2()\r\n\t\t\t\t};\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'HemisphereLight':\r\n\t\t\t\tuniforms = {\r\n\t\t\t\t\tdirection: new THREE.Vector3(),\r\n\t\t\t\t\tskyColor: new THREE.Color(),\r\n\t\t\t\t\tgroundColor: new THREE.Color()\r\n\t\t\t\t};\r\n\t\t\t\tbreak;\r\n\r\n\t\t}\r\n\r\n\t\tlights[ light.id ] = uniforms;\r\n\r\n\t\treturn uniforms;\r\n\r\n\t};\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLObjects.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLObjects = function ( gl, properties, info ) {\r\n\r\n\tvar geometries = new THREE.WebGLGeometries( gl, properties, info );\r\n\r\n\t//\r\n\r\n\tfunction update( object ) {\r\n\r\n\t\t// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.\r\n\r\n\t\tvar geometry = geometries.get( object );\r\n\r\n\t\tif ( object.geometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\tgeometry.updateFromObject( object );\r\n\r\n\t\t}\r\n\r\n\t\tvar index = geometry.index;\r\n\t\tvar attributes = geometry.attributes;\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\tupdateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var name in attributes ) {\r\n\r\n\t\t\tupdateAttribute( attributes[ name ], gl.ARRAY_BUFFER );\r\n\r\n\t\t}\r\n\r\n\t\t// morph targets\r\n\r\n\t\tvar morphAttributes = geometry.morphAttributes;\r\n\r\n\t\tfor ( var name in morphAttributes ) {\r\n\r\n\t\t\tvar array = morphAttributes[ name ];\r\n\r\n\t\t\tfor ( var i = 0, l = array.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tupdateAttribute( array[ i ], gl.ARRAY_BUFFER );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn geometry;\r\n\r\n\t}\r\n\r\n\tfunction updateAttribute( attribute, bufferType ) {\r\n\r\n\t\tvar data = ( attribute instanceof THREE.InterleavedBufferAttribute ) ? attribute.data : attribute;\r\n\r\n\t\tvar attributeProperties = properties.get( data );\r\n\r\n\t\tif ( attributeProperties.__webglBuffer === undefined ) {\r\n\r\n\t\t\tcreateBuffer( attributeProperties, data, bufferType );\r\n\r\n\t\t} else if ( attributeProperties.version !== data.version ) {\r\n\r\n\t\t\tupdateBuffer( attributeProperties, data, bufferType );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction createBuffer( attributeProperties, data, bufferType ) {\r\n\r\n\t\tattributeProperties.__webglBuffer = gl.createBuffer();\r\n\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\r\n\r\n\t\tvar usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;\r\n\r\n\t\tgl.bufferData( bufferType, data.array, usage );\r\n\r\n\t\tattributeProperties.version = data.version;\r\n\r\n\t}\r\n\r\n\tfunction updateBuffer( attributeProperties, data, bufferType ) {\r\n\r\n\t\tgl.bindBuffer( bufferType, attributeProperties.__webglBuffer );\r\n\r\n\t\tif ( data.dynamic === false || data.updateRange.count === - 1 ) {\r\n\r\n\t\t\t// Not using update ranges\r\n\r\n\t\t\tgl.bufferSubData( bufferType, 0, data.array );\r\n\r\n\t\t} else if ( data.updateRange.count === 0 ) {\r\n\r\n\t\t\tconsole.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tgl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,\r\n\t\t\t\t\t\t\t  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );\r\n\r\n\t\t\tdata.updateRange.count = 0; // reset range\r\n\r\n\t\t}\r\n\r\n\t\tattributeProperties.version = data.version;\r\n\r\n\t}\r\n\r\n\tfunction getAttributeBuffer( attribute ) {\r\n\r\n\t\tif ( attribute instanceof THREE.InterleavedBufferAttribute ) {\r\n\r\n\t\t\treturn properties.get( attribute.data ).__webglBuffer;\r\n\r\n\t\t}\r\n\r\n\t\treturn properties.get( attribute ).__webglBuffer;\r\n\r\n\t}\r\n\r\n\tfunction getWireframeAttribute( geometry ) {\r\n\r\n\t\tvar property = properties.get( geometry );\r\n\r\n\t\tif ( property.wireframe !== undefined ) {\r\n\r\n\t\t\treturn property.wireframe;\r\n\r\n\t\t}\r\n\r\n\t\tvar indices = [];\r\n\r\n\t\tvar index = geometry.index;\r\n\t\tvar attributes = geometry.attributes;\r\n\t\tvar position = attributes.position;\r\n\r\n\t\t// console.time( 'wireframe' );\r\n\r\n\t\tif ( index !== null ) {\r\n\r\n\t\t\tvar edges = {};\r\n\t\t\tvar array = index.array;\r\n\r\n\t\t\tfor ( var i = 0, l = array.length; i < l; i += 3 ) {\r\n\r\n\t\t\t\tvar a = array[ i + 0 ];\r\n\t\t\t\tvar b = array[ i + 1 ];\r\n\t\t\t\tvar c = array[ i + 2 ];\r\n\r\n\t\t\t\tif ( checkEdge( edges, a, b ) ) indices.push( a, b );\r\n\t\t\t\tif ( checkEdge( edges, b, c ) ) indices.push( b, c );\r\n\t\t\t\tif ( checkEdge( edges, c, a ) ) indices.push( c, a );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tvar array = attributes.position.array;\r\n\r\n\t\t\tfor ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {\r\n\r\n\t\t\t\tvar a = i + 0;\r\n\t\t\t\tvar b = i + 1;\r\n\t\t\t\tvar c = i + 2;\r\n\r\n\t\t\t\tindices.push( a, b, b, c, c, a );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// console.timeEnd( 'wireframe' );\r\n\r\n\t\tvar TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;\r\n\t\tvar attribute = new THREE.BufferAttribute( new TypeArray( indices ), 1 );\r\n\r\n\t\tupdateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );\r\n\r\n\t\tproperty.wireframe = attribute;\r\n\r\n\t\treturn attribute;\r\n\r\n\t}\r\n\r\n\tfunction checkEdge( edges, a, b ) {\r\n\r\n\t\tif ( a > b ) {\r\n\r\n\t\t\tvar tmp = a;\r\n\t\t\ta = b;\r\n\t\t\tb = tmp;\r\n\r\n\t\t}\r\n\r\n\t\tvar list = edges[ a ];\r\n\r\n\t\tif ( list === undefined ) {\r\n\r\n\t\t\tedges[ a ] = [ b ];\r\n\t\t\treturn true;\r\n\r\n\t\t} else if ( list.indexOf( b ) === -1 ) {\r\n\r\n\t\t\tlist.push( b );\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\r\n\t}\r\n\r\n\tthis.getAttributeBuffer = getAttributeBuffer;\r\n\tthis.getWireframeAttribute = getWireframeAttribute;\r\n\r\n\tthis.update = update;\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLProgram.js\r\n\r\nTHREE.WebGLProgram = ( function () {\r\n\r\n\tvar programIdCount = 0;\r\n\r\n\tfunction getEncodingComponents( encoding ) {\r\n\r\n\t\tswitch ( encoding ) {\r\n\r\n\t\t\tcase THREE.LinearEncoding:\r\n\t\t\t\treturn [ 'Linear','( value )' ];\r\n\t\t\tcase THREE.sRGBEncoding:\r\n\t\t\t\treturn [ 'sRGB','( value )' ];\r\n\t\t\tcase THREE.RGBEEncoding:\r\n\t\t\t\treturn [ 'RGBE','( value )' ];\r\n\t\t\tcase THREE.RGBM7Encoding:\r\n\t\t\t\treturn [ 'RGBM','( value, 7.0 )' ];\r\n\t\t\tcase THREE.RGBM16Encoding:\r\n\t\t\t\treturn [ 'RGBM','( value, 16.0 )' ];\r\n\t\t\tcase THREE.RGBDEncoding:\r\n\t\t\t\treturn [ 'RGBD','( value, 256.0 )' ];\r\n\t\t\tcase THREE.GammaEncoding:\r\n\t\t\t\treturn [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error( 'unsupported encoding: ' + encoding );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction getTexelDecodingFunction( functionName, encoding ) {\r\n\r\n\t\tvar components = getEncodingComponents( encoding );\r\n\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return \" + components[ 0 ] + \"ToLinear\" + components[ 1 ] + \"; }\";\r\n\r\n\t}\r\n\r\n\tfunction getTexelEncodingFunction( functionName, encoding ) {\r\n\r\n\t\tvar components = getEncodingComponents( encoding );\r\n\t\treturn \"vec4 \" + functionName + \"( vec4 value ) { return LinearTo\" + components[ 0 ] + components[ 1 ] + \"; }\";\r\n\r\n\t}\r\n\r\n\tfunction getToneMappingFunction( functionName, toneMapping ) {\r\n\r\n\t\tvar toneMappingName;\r\n\r\n\t\tswitch ( toneMapping ) {\r\n\r\n\t\t\tcase THREE.LinearToneMapping:\r\n\t\t\t\ttoneMappingName = \"Linear\";\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase THREE.ReinhardToneMapping:\r\n\t\t\t\ttoneMappingName = \"Reinhard\";\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase THREE.Uncharted2ToneMapping:\r\n\t\t\t\ttoneMappingName = \"Uncharted2\";\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase THREE.CineonToneMapping:\r\n\t\t\t\ttoneMappingName = \"OptimizedCineon\";\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error( 'unsupported toneMapping: ' + toneMapping );\r\n\r\n\t\t}\r\n\r\n\t\treturn \"vec3 \" + functionName + \"( vec3 color ) { return \" + toneMappingName + \"ToneMapping( color ); }\";\r\n\r\n\t}\r\n\r\n\tfunction generateExtensions( extensions, parameters, rendererExtensions ) {\r\n\r\n\t\textensions = extensions || {};\r\n\r\n\t\tvar chunks = [\r\n\t\t\t( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',\r\n\t\t\t( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',\r\n\t\t\t( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',\r\n\t\t\t( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : '',\r\n\t\t];\r\n\r\n\t\treturn chunks.filter( filterEmptyLine ).join( '\\n' );\r\n\r\n\t}\r\n\r\n\tfunction generateDefines( defines ) {\r\n\r\n\t\tvar chunks = [];\r\n\r\n\t\tfor ( var name in defines ) {\r\n\r\n\t\t\tvar value = defines[ name ];\r\n\r\n\t\t\tif ( value === false ) continue;\r\n\r\n\t\t\tchunks.push( '#define ' + name + ' ' + value );\r\n\r\n\t\t}\r\n\r\n\t\treturn chunks.join( '\\n' );\r\n\r\n\t}\r\n\r\n\tfunction fetchAttributeLocations( gl, program, identifiers ) {\r\n\r\n\t\tvar attributes = {};\r\n\r\n\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );\r\n\r\n\t\tfor ( var i = 0; i < n; i ++ ) {\r\n\r\n\t\t\tvar info = gl.getActiveAttrib( program, i );\r\n\t\t\tvar name = info.name;\r\n\r\n\t\t\t// console.log(\"THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:\", name, i );\r\n\r\n\t\t\tattributes[ name ] = gl.getAttribLocation( program, name );\r\n\r\n\t\t}\r\n\r\n\t\treturn attributes;\r\n\r\n\t}\r\n\r\n\tfunction filterEmptyLine( string ) {\r\n\r\n\t\treturn string !== '';\r\n\r\n\t}\r\n\r\n\tfunction replaceLightNums( string, parameters ) {\r\n\r\n\t\treturn string\r\n\t\t\t.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )\r\n\t\t\t.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )\r\n\t\t\t.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )\r\n\t\t\t.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );\r\n\r\n\t}\r\n\r\n\tfunction parseIncludes( string ) {\r\n\r\n\t\tvar pattern = /#include +<([\\w\\d.]+)>/g;\r\n\r\n\t\tfunction replace( match, include ) {\r\n\r\n\t\t\tvar replace = THREE.ShaderChunk[ include ];\r\n\r\n\t\t\tif ( replace === undefined ) {\r\n\r\n\t\t\t\tthrow new Error( 'Can not resolve #include <' + include + '>' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn parseIncludes( replace );\r\n\r\n\t\t}\r\n\r\n\t\treturn string.replace( pattern, replace );\r\n\r\n\t}\r\n\r\n\tfunction unrollLoops( string ) {\r\n\r\n\t\tvar pattern = /for \\( int i \\= (\\d+)\\; i < (\\d+)\\; i \\+\\+ \\) \\{([\\s\\S]+?)(?=\\})\\}/g;\r\n\r\n\t\tfunction replace( match, start, end, snippet ) {\r\n\r\n\t\t\tvar unroll = '';\r\n\r\n\t\t\tfor ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {\r\n\r\n\t\t\t\tunroll += snippet.replace( /\\[ i \\]/g, '[ ' + i + ' ]' );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn unroll;\r\n\r\n\t\t}\r\n\r\n\t\treturn string.replace( pattern, replace );\r\n\r\n\t}\r\n\r\n\treturn function WebGLProgram( renderer, code, material, parameters ) {\r\n\r\n\t\tvar gl = renderer.context;\r\n\r\n\t\tvar extensions = material.extensions;\r\n\t\tvar defines = material.defines;\r\n\r\n\t\tvar vertexShader = material.__webglShader.vertexShader;\r\n\t\tvar fragmentShader = material.__webglShader.fragmentShader;\r\n\r\n\t\tvar shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';\r\n\r\n\t\tif ( parameters.shadowMapType === THREE.PCFShadowMap ) {\r\n\r\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';\r\n\r\n\t\t} else if ( parameters.shadowMapType === THREE.PCFSoftShadowMap ) {\r\n\r\n\t\t\tshadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';\r\n\r\n\t\t}\r\n\r\n\t\tvar envMapTypeDefine = 'ENVMAP_TYPE_CUBE';\r\n\t\tvar envMapModeDefine = 'ENVMAP_MODE_REFLECTION';\r\n\t\tvar envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\r\n\r\n\t\tif ( parameters.envMap ) {\r\n\r\n\t\t\tswitch ( material.envMap.mapping ) {\r\n\r\n\t\t\t\tcase THREE.CubeReflectionMapping:\r\n\t\t\t\tcase THREE.CubeRefractionMapping:\r\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.CubeUVReflectionMapping:\r\n\t\t\t\tcase THREE.CubeUVRefractionMapping:\r\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.EquirectangularReflectionMapping:\r\n\t\t\t\tcase THREE.EquirectangularRefractionMapping:\r\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.SphericalReflectionMapping:\r\n\t\t\t\t\tenvMapTypeDefine = 'ENVMAP_TYPE_SPHERE';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tswitch ( material.envMap.mapping ) {\r\n\r\n\t\t\t\tcase THREE.CubeRefractionMapping:\r\n\t\t\t\tcase THREE.EquirectangularRefractionMapping:\r\n\t\t\t\t\tenvMapModeDefine = 'ENVMAP_MODE_REFRACTION';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tswitch ( material.combine ) {\r\n\r\n\t\t\t\tcase THREE.MultiplyOperation:\r\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.MixOperation:\r\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_MIX';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\tcase THREE.AddOperation:\r\n\t\t\t\t\tenvMapBlendingDefine = 'ENVMAP_BLENDING_ADD';\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;\r\n\r\n\t\t// console.log( 'building new program ' );\r\n\r\n\t\t//\r\n\r\n\t\tvar customExtensions = generateExtensions( extensions, parameters, renderer.extensions );\r\n\r\n\t\tvar customDefines = generateDefines( defines );\r\n\r\n\t\t//\r\n\r\n\t\tvar program = gl.createProgram();\r\n\r\n\t\tvar prefixVertex, prefixFragment;\r\n\r\n\t\tif ( material instanceof THREE.RawShaderMaterial ) {\r\n\r\n\t\t\tprefixVertex = '';\r\n\t\t\tprefixFragment = '';\r\n\r\n\t\t} else {\r\n\r\n\t\t\tprefixVertex = [\r\n\r\n\t\t\t\t'precision ' + parameters.precision + ' float;',\r\n\t\t\t\t'precision ' + parameters.precision + ' int;',\r\n\r\n\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\r\n\r\n\t\t\t\tcustomDefines,\r\n\r\n\t\t\t\tparameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',\r\n\r\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\r\n\r\n\t\t\t\t'#define MAX_BONES ' + parameters.maxBones,\r\n\r\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\r\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\r\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\r\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\r\n\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\r\n\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\r\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\r\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\r\n\t\t\t\tparameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',\r\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\r\n\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\r\n\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\r\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\r\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\r\n\r\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\r\n\r\n\t\t\t\tparameters.skinning ? '#define USE_SKINNING' : '',\r\n\t\t\t\tparameters.useVertexTexture ? '#define BONE_TEXTURE' : '',\r\n\r\n\t\t\t\tparameters.morphTargets ? '#define USE_MORPHTARGETS' : '',\r\n\t\t\t\tparameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',\r\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\r\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\r\n\r\n\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\r\n\r\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\r\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\r\n\r\n\t\t\t\tparameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',\r\n\r\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\r\n\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\r\n\r\n\t\t\t\t'uniform mat4 modelMatrix;',\r\n\t\t\t\t'uniform mat4 modelViewMatrix;',\r\n\t\t\t\t'uniform mat4 projectionMatrix;',\r\n\t\t\t\t'uniform mat4 viewMatrix;',\r\n\t\t\t\t'uniform mat3 normalMatrix;',\r\n\t\t\t\t'uniform vec3 cameraPosition;',\r\n\r\n\t\t\t\t'attribute vec3 position;',\r\n\t\t\t\t'attribute vec3 normal;',\r\n\t\t\t\t'attribute vec2 uv;',\r\n\r\n\t\t\t\t'#ifdef USE_COLOR',\r\n\r\n\t\t\t\t'\tattribute vec3 color;',\r\n\r\n\t\t\t\t'#endif',\r\n\r\n\t\t\t\t'#ifdef USE_MORPHTARGETS',\r\n\r\n\t\t\t\t'\tattribute vec3 morphTarget0;',\r\n\t\t\t\t'\tattribute vec3 morphTarget1;',\r\n\t\t\t\t'\tattribute vec3 morphTarget2;',\r\n\t\t\t\t'\tattribute vec3 morphTarget3;',\r\n\r\n\t\t\t\t'\t#ifdef USE_MORPHNORMALS',\r\n\r\n\t\t\t\t'\t\tattribute vec3 morphNormal0;',\r\n\t\t\t\t'\t\tattribute vec3 morphNormal1;',\r\n\t\t\t\t'\t\tattribute vec3 morphNormal2;',\r\n\t\t\t\t'\t\tattribute vec3 morphNormal3;',\r\n\r\n\t\t\t\t'\t#else',\r\n\r\n\t\t\t\t'\t\tattribute vec3 morphTarget4;',\r\n\t\t\t\t'\t\tattribute vec3 morphTarget5;',\r\n\t\t\t\t'\t\tattribute vec3 morphTarget6;',\r\n\t\t\t\t'\t\tattribute vec3 morphTarget7;',\r\n\r\n\t\t\t\t'\t#endif',\r\n\r\n\t\t\t\t'#endif',\r\n\r\n\t\t\t\t'#ifdef USE_SKINNING',\r\n\r\n\t\t\t\t'\tattribute vec4 skinIndex;',\r\n\t\t\t\t'\tattribute vec4 skinWeight;',\r\n\r\n\t\t\t\t'#endif',\r\n\r\n\t\t\t\t'\\n'\r\n\r\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\r\n\r\n\t\t\tprefixFragment = [\r\n\r\n\t\t\t\tcustomExtensions,\r\n\r\n\t\t\t\t'precision ' + parameters.precision + ' float;',\r\n\t\t\t\t'precision ' + parameters.precision + ' int;',\r\n\r\n\t\t\t\t'#define SHADER_NAME ' + material.__webglShader.name,\r\n\r\n\t\t\t\tcustomDefines,\r\n\r\n\t\t\t\tparameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',\r\n\r\n\t\t\t\t'#define GAMMA_FACTOR ' + gammaFactorDefine,\r\n\r\n\t\t\t\t( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',\r\n\t\t\t\t( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',\r\n\r\n\t\t\t\tparameters.map ? '#define USE_MAP' : '',\r\n\t\t\t\tparameters.envMap ? '#define USE_ENVMAP' : '',\r\n\t\t\t\tparameters.envMap ? '#define ' + envMapTypeDefine : '',\r\n\t\t\t\tparameters.envMap ? '#define ' + envMapModeDefine : '',\r\n\t\t\t\tparameters.envMap ? '#define ' + envMapBlendingDefine : '',\r\n\t\t\t\tparameters.lightMap ? '#define USE_LIGHTMAP' : '',\r\n\t\t\t\tparameters.aoMap ? '#define USE_AOMAP' : '',\r\n\t\t\t\tparameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',\r\n\t\t\t\tparameters.bumpMap ? '#define USE_BUMPMAP' : '',\r\n\t\t\t\tparameters.normalMap ? '#define USE_NORMALMAP' : '',\r\n\t\t\t\tparameters.specularMap ? '#define USE_SPECULARMAP' : '',\r\n\t\t\t\tparameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',\r\n\t\t\t\tparameters.metalnessMap ? '#define USE_METALNESSMAP' : '',\r\n\t\t\t\tparameters.alphaMap ? '#define USE_ALPHAMAP' : '',\r\n\t\t\t\tparameters.vertexColors ? '#define USE_COLOR' : '',\r\n\r\n\t\t\t\tparameters.flatShading ? '#define FLAT_SHADED' : '',\r\n\r\n\t\t\t\tparameters.doubleSided ? '#define DOUBLE_SIDED' : '',\r\n\t\t\t\tparameters.flipSided ? '#define FLIP_SIDED' : '',\r\n\r\n\t\t\t\t'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,\r\n\r\n\t\t\t\tparameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',\r\n\t\t\t\tparameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',\r\n\r\n\t\t\t\tparameters.premultipliedAlpha ? \"#define PREMULTIPLIED_ALPHA\" : '',\r\n\r\n\t\t\t\tparameters.physicallyCorrectLights ? \"#define PHYSICALLY_CORRECT_LIGHTS\" : '',\r\n\r\n\t\t\t\tparameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',\r\n\t\t\t\tparameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',\r\n\r\n\t\t\t\tparameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',\r\n\r\n\t\t\t\t'uniform mat4 viewMatrix;',\r\n\t\t\t\t'uniform vec3 cameraPosition;',\r\n\r\n\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? \"#define TONE_MAPPING\" : '',\r\n\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? THREE.ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below\r\n\t\t\t\t( parameters.toneMapping !== THREE.NoToneMapping ) ? getToneMappingFunction( \"toneMapping\", parameters.toneMapping ) : '',\r\n\r\n\t\t\t\t( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? THREE.ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below\r\n\t\t\t\tparameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',\r\n\t\t\t\tparameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',\r\n\t\t\t\tparameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',\r\n\t\t\t\tparameters.outputEncoding ? getTexelEncodingFunction( \"linearToOutputTexel\", parameters.outputEncoding ) : '',\r\n\r\n\t\t\t\tparameters.depthPacking ? \"#define DEPTH_PACKING \" + material.depthPacking : '',\r\n\r\n\t\t\t\t'\\n'\r\n\r\n\t\t\t].filter( filterEmptyLine ).join( '\\n' );\r\n\r\n\t\t}\r\n\r\n\t\tvertexShader = parseIncludes( vertexShader, parameters );\r\n\t\tvertexShader = replaceLightNums( vertexShader, parameters );\r\n\r\n\t\tfragmentShader = parseIncludes( fragmentShader, parameters );\r\n\t\tfragmentShader = replaceLightNums( fragmentShader, parameters );\r\n\r\n\t\tif ( material instanceof THREE.ShaderMaterial === false ) {\r\n\r\n\t\t\tvertexShader = unrollLoops( vertexShader );\r\n\t\t\tfragmentShader = unrollLoops( fragmentShader );\r\n\r\n\t\t}\r\n\r\n\t\tvar vertexGlsl = prefixVertex + vertexShader;\r\n\t\tvar fragmentGlsl = prefixFragment + fragmentShader;\r\n\r\n\t\t// console.log( '*VERTEX*', vertexGlsl );\r\n\t\t// console.log( '*FRAGMENT*', fragmentGlsl );\r\n\r\n\t\tvar glVertexShader = THREE.WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );\r\n\t\tvar glFragmentShader = THREE.WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );\r\n\r\n\t\tgl.attachShader( program, glVertexShader );\r\n\t\tgl.attachShader( program, glFragmentShader );\r\n\r\n\t\t// Force a particular attribute to index 0.\r\n\r\n\t\tif ( material.index0AttributeName !== undefined ) {\r\n\r\n\t\t\tgl.bindAttribLocation( program, 0, material.index0AttributeName );\r\n\r\n\t\t} else if ( parameters.morphTargets === true ) {\r\n\r\n\t\t\t// programs with morphTargets displace position out of attribute 0\r\n\t\t\tgl.bindAttribLocation( program, 0, 'position' );\r\n\r\n\t\t}\r\n\r\n\t\tgl.linkProgram( program );\r\n\r\n\t\tvar programLog = gl.getProgramInfoLog( program );\r\n\t\tvar vertexLog = gl.getShaderInfoLog( glVertexShader );\r\n\t\tvar fragmentLog = gl.getShaderInfoLog( glFragmentShader );\r\n\r\n\t\tvar runnable = true;\r\n\t\tvar haveDiagnostics = true;\r\n\r\n\t\t// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );\r\n\t\t// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );\r\n\r\n\t\tif ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {\r\n\r\n\t\t\trunnable = false;\r\n\r\n\t\t\tconsole.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );\r\n\r\n\t\t} else if ( programLog !== '' ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );\r\n\r\n\t\t} else if ( vertexLog === '' || fragmentLog === '' ) {\r\n\r\n\t\t\thaveDiagnostics = false;\r\n\r\n\t\t}\r\n\r\n\t\tif ( haveDiagnostics ) {\r\n\r\n\t\t\tthis.diagnostics = {\r\n\r\n\t\t\t\trunnable: runnable,\r\n\t\t\t\tmaterial: material,\r\n\r\n\t\t\t\tprogramLog: programLog,\r\n\r\n\t\t\t\tvertexShader: {\r\n\r\n\t\t\t\t\tlog: vertexLog,\r\n\t\t\t\t\tprefix: prefixVertex\r\n\r\n\t\t\t\t},\r\n\r\n\t\t\t\tfragmentShader: {\r\n\r\n\t\t\t\t\tlog: fragmentLog,\r\n\t\t\t\t\tprefix: prefixFragment\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t};\r\n\r\n\t\t}\r\n\r\n\t\t// clean up\r\n\r\n\t\tgl.deleteShader( glVertexShader );\r\n\t\tgl.deleteShader( glFragmentShader );\r\n\r\n\t\t// set up caching for uniform locations\r\n\r\n\t\tvar cachedUniforms;\r\n\r\n\t\tthis.getUniforms = function() {\r\n\r\n\t\t\tif ( cachedUniforms === undefined ) {\r\n\r\n\t\t\t\tcachedUniforms =\r\n\t\t\t\t\t\tnew THREE.WebGLUniforms( gl, program, renderer );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn cachedUniforms;\r\n\r\n\t\t};\r\n\r\n\t\t// set up caching for attribute locations\r\n\r\n\t\tvar cachedAttributes;\r\n\r\n\t\tthis.getAttributes = function() {\r\n\r\n\t\t\tif ( cachedAttributes === undefined ) {\r\n\r\n\t\t\t\tcachedAttributes = fetchAttributeLocations( gl, program );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn cachedAttributes;\r\n\r\n\t\t};\r\n\r\n\t\t// free resource\r\n\r\n\t\tthis.destroy = function() {\r\n\r\n\t\t\tgl.deleteProgram( program );\r\n\t\t\tthis.program = undefined;\r\n\r\n\t\t};\r\n\r\n\t\t// DEPRECATED\r\n\r\n\t\tObject.defineProperties( this, {\r\n\r\n\t\t\tuniforms: {\r\n\t\t\t\tget: function() {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );\r\n\t\t\t\t\treturn this.getUniforms();\r\n\r\n\t\t\t\t}\r\n\t\t\t},\r\n\r\n\t\t\tattributes: {\r\n\t\t\t\tget: function() {\r\n\r\n\t\t\t\t\tconsole.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );\r\n\t\t\t\t\treturn this.getAttributes();\r\n\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t} );\r\n\r\n\r\n\t\t//\r\n\r\n\t\tthis.id = programIdCount ++;\r\n\t\tthis.code = code;\r\n\t\tthis.usedTimes = 1;\r\n\t\tthis.program = program;\r\n\t\tthis.vertexShader = glVertexShader;\r\n\t\tthis.fragmentShader = glFragmentShader;\r\n\r\n\t\treturn this;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n// File:src/renderers/webgl/WebGLPrograms.js\r\n\r\nTHREE.WebGLPrograms = function ( renderer, capabilities ) {\r\n\r\n\tvar programs = [];\r\n\r\n\tvar shaderIDs = {\r\n\t\tMeshDepthMaterial: 'depth',\r\n\t\tMeshNormalMaterial: 'normal',\r\n\t\tMeshBasicMaterial: 'basic',\r\n\t\tMeshLambertMaterial: 'lambert',\r\n\t\tMeshPhongMaterial: 'phong',\r\n\t\tMeshStandardMaterial: 'physical',\r\n\t\tMeshPhysicalMaterial: 'physical',\r\n\t\tLineBasicMaterial: 'basic',\r\n\t\tLineDashedMaterial: 'dashed',\r\n\t\tPointsMaterial: 'points'\r\n\t};\r\n\r\n\tvar parameterNames = [\r\n\t\t\"precision\", \"supportsVertexTextures\", \"map\", \"mapEncoding\", \"envMap\", \"envMapMode\", \"envMapEncoding\",\r\n\t\t\"lightMap\", \"aoMap\", \"emissiveMap\", \"emissiveMapEncoding\", \"bumpMap\", \"normalMap\", \"displacementMap\", \"specularMap\",\r\n\t\t\"roughnessMap\", \"metalnessMap\",\r\n\t\t\"alphaMap\", \"combine\", \"vertexColors\", \"fog\", \"useFog\", \"fogExp\",\r\n\t\t\"flatShading\", \"sizeAttenuation\", \"logarithmicDepthBuffer\", \"skinning\",\r\n\t\t\"maxBones\", \"useVertexTexture\", \"morphTargets\", \"morphNormals\",\r\n\t\t\"maxMorphTargets\", \"maxMorphNormals\", \"premultipliedAlpha\",\r\n\t\t\"numDirLights\", \"numPointLights\", \"numSpotLights\", \"numHemiLights\",\r\n\t\t\"shadowMapEnabled\", \"shadowMapType\", \"toneMapping\", 'physicallyCorrectLights',\r\n\t\t\"alphaTest\", \"doubleSided\", \"flipSided\", \"numClippingPlanes\", \"depthPacking\"\r\n\t];\r\n\r\n\r\n\tfunction allocateBones ( object ) {\r\n\r\n\t\tif ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {\r\n\r\n\t\t\treturn 1024;\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// default for when object is not specified\r\n\t\t\t// ( for example when prebuilding shader to be used with multiple objects )\r\n\t\t\t//\r\n\t\t\t//  - leave some extra space for other uniforms\r\n\t\t\t//  - limit here is ANGLE's 254 max uniform vectors\r\n\t\t\t//    (up to 54 should be safe)\r\n\r\n\t\t\tvar nVertexUniforms = capabilities.maxVertexUniforms;\r\n\t\t\tvar nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );\r\n\r\n\t\t\tvar maxBones = nVertexMatrices;\r\n\r\n\t\t\tif ( object !== undefined && object instanceof THREE.SkinnedMesh ) {\r\n\r\n\t\t\t\tmaxBones = Math.min( object.skeleton.bones.length, maxBones );\r\n\r\n\t\t\t\tif ( maxBones < object.skeleton.bones.length ) {\r\n\r\n\t\t\t\t\tconsole.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn maxBones;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction getTextureEncodingFromMap( map, gammaOverrideLinear ) {\r\n\r\n\t\tvar encoding;\r\n\r\n\t\tif ( ! map ) {\r\n\r\n\t\t\tencoding = THREE.LinearEncoding;\r\n\r\n\t\t} else if ( map instanceof THREE.Texture ) {\r\n\r\n\t\t\tencoding = map.encoding;\r\n\r\n\t\t} else if ( map instanceof THREE.WebGLRenderTarget ) {\r\n\r\n\t\t\tconsole.warn( \"THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead.\" );\r\n\t\t\tencoding = map.texture.encoding;\r\n\r\n\t\t}\r\n\r\n\t\t// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.\r\n\t\tif ( encoding === THREE.LinearEncoding && gammaOverrideLinear ) {\r\n\r\n\t\t\tencoding = THREE.GammaEncoding;\r\n\r\n\t\t}\r\n\r\n\t\treturn encoding;\r\n\r\n\t}\r\n\r\n\tthis.getParameters = function ( material, lights, fog, nClipPlanes, object ) {\r\n\r\n\t\tvar shaderID = shaderIDs[ material.type ];\r\n\r\n\t\t// heuristics to create shader parameters according to lights in the scene\r\n\t\t// (not to blow over maxLights budget)\r\n\r\n\t\tvar maxBones = allocateBones( object );\r\n\t\tvar precision = renderer.getPrecision();\r\n\r\n\t\tif ( material.precision !== null ) {\r\n\r\n\t\t\tprecision = capabilities.getMaxPrecision( material.precision );\r\n\r\n\t\t\tif ( precision !== material.precision ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar currentRenderTarget = renderer.getCurrentRenderTarget();\r\n\r\n\t\tvar parameters = {\r\n\r\n\t\t\tshaderID: shaderID,\r\n\r\n\t\t\tprecision: precision,\r\n\t\t\tsupportsVertexTextures: capabilities.vertexTextures,\r\n\t\t\toutputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),\r\n\t\t\tmap: !! material.map,\r\n\t\t\tmapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),\r\n\t\t\tenvMap: !! material.envMap,\r\n\t\t\tenvMapMode: material.envMap && material.envMap.mapping,\r\n\t\t\tenvMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),\r\n\t\t\tenvMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === THREE.CubeUVReflectionMapping ) || ( material.envMap.mapping === THREE.CubeUVRefractionMapping ) ),\r\n\t\t\tlightMap: !! material.lightMap,\r\n\t\t\taoMap: !! material.aoMap,\r\n\t\t\temissiveMap: !! material.emissiveMap,\r\n\t\t\temissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),\r\n\t\t\tbumpMap: !! material.bumpMap,\r\n\t\t\tnormalMap: !! material.normalMap,\r\n\t\t\tdisplacementMap: !! material.displacementMap,\r\n\t\t\troughnessMap: !! material.roughnessMap,\r\n\t\t\tmetalnessMap: !! material.metalnessMap,\r\n\t\t\tspecularMap: !! material.specularMap,\r\n\t\t\talphaMap: !! material.alphaMap,\r\n\r\n\t\t\tcombine: material.combine,\r\n\r\n\t\t\tvertexColors: material.vertexColors,\r\n\r\n\t\t\tfog: fog,\r\n\t\t\tuseFog: material.fog,\r\n\t\t\tfogExp: fog instanceof THREE.FogExp2,\r\n\r\n\t\t\tflatShading: material.shading === THREE.FlatShading,\r\n\r\n\t\t\tsizeAttenuation: material.sizeAttenuation,\r\n\t\t\tlogarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,\r\n\r\n\t\t\tskinning: material.skinning,\r\n\t\t\tmaxBones: maxBones,\r\n\t\t\tuseVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,\r\n\r\n\t\t\tmorphTargets: material.morphTargets,\r\n\t\t\tmorphNormals: material.morphNormals,\r\n\t\t\tmaxMorphTargets: renderer.maxMorphTargets,\r\n\t\t\tmaxMorphNormals: renderer.maxMorphNormals,\r\n\r\n\t\t\tnumDirLights: lights.directional.length,\r\n\t\t\tnumPointLights: lights.point.length,\r\n\t\t\tnumSpotLights: lights.spot.length,\r\n\t\t\tnumHemiLights: lights.hemi.length,\r\n\r\n\t\t\tnumClippingPlanes: nClipPlanes,\r\n\r\n\t\t\tshadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,\r\n\t\t\tshadowMapType: renderer.shadowMap.type,\r\n\r\n\t\t\ttoneMapping: renderer.toneMapping,\r\n\t\t\tphysicallyCorrectLights: renderer.physicallyCorrectLights,\r\n\r\n\t\t\tpremultipliedAlpha: material.premultipliedAlpha,\r\n\r\n\t\t\talphaTest: material.alphaTest,\r\n\t\t\tdoubleSided: material.side === THREE.DoubleSide,\r\n\t\t\tflipSided: material.side === THREE.BackSide,\r\n\r\n\t\t\tdepthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false\r\n\r\n\t\t};\r\n\r\n\t\treturn parameters;\r\n\r\n\t};\r\n\r\n\tthis.getProgramCode = function ( material, parameters ) {\r\n\r\n\t\tvar array = [];\r\n\r\n\t\tif ( parameters.shaderID ) {\r\n\r\n\t\t\tarray.push( parameters.shaderID );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tarray.push( material.fragmentShader );\r\n\t\t\tarray.push( material.vertexShader );\r\n\r\n\t\t}\r\n\r\n\t\tif ( material.defines !== undefined ) {\r\n\r\n\t\t\tfor ( var name in material.defines ) {\r\n\r\n\t\t\t\tarray.push( name );\r\n\t\t\t\tarray.push( material.defines[ name ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfor ( var i = 0; i < parameterNames.length; i ++ ) {\r\n\r\n\t\t\tarray.push( parameters[ parameterNames[ i ] ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn array.join();\r\n\r\n\t};\r\n\r\n\tthis.acquireProgram = function ( material, parameters, code ) {\r\n\r\n\t\tvar program;\r\n\r\n\t\t// Check if code has been already compiled\r\n\t\tfor ( var p = 0, pl = programs.length; p < pl; p ++ ) {\r\n\r\n\t\t\tvar programInfo = programs[ p ];\r\n\r\n\t\t\tif ( programInfo.code === code ) {\r\n\r\n\t\t\t\tprogram = programInfo;\r\n\t\t\t\t++ program.usedTimes;\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( program === undefined ) {\r\n\r\n\t\t\tprogram = new THREE.WebGLProgram( renderer, code, material, parameters );\r\n\t\t\tprograms.push( program );\r\n\r\n\t\t}\r\n\r\n\t\treturn program;\r\n\r\n\t};\r\n\r\n\tthis.releaseProgram = function( program ) {\r\n\r\n\t\tif ( -- program.usedTimes === 0 ) {\r\n\r\n\t\t\t// Remove from unordered set\r\n\t\t\tvar i = programs.indexOf( program );\r\n\t\t\tprograms[ i ] = programs[ programs.length - 1 ];\r\n\t\t\tprograms.pop();\r\n\r\n\t\t\t// Free WebGL resources\r\n\t\t\tprogram.destroy();\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// Exposed for resource monitoring & error feedback via renderer.info:\r\n\tthis.programs = programs;\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLProperties.js\r\n\r\n/**\r\n* @author fordacious / fordacious.github.io\r\n*/\r\n\r\nTHREE.WebGLProperties = function () {\r\n\r\n\tvar properties = {};\r\n\r\n\tthis.get = function ( object ) {\r\n\r\n\t\tvar uuid = object.uuid;\r\n\t\tvar map = properties[ uuid ];\r\n\r\n\t\tif ( map === undefined ) {\r\n\r\n\t\t\tmap = {};\r\n\t\t\tproperties[ uuid ] = map;\r\n\r\n\t\t}\r\n\r\n\t\treturn map;\r\n\r\n\t};\r\n\r\n\tthis.delete = function ( object ) {\r\n\r\n\t\tdelete properties[ object.uuid ];\r\n\r\n\t};\r\n\r\n\tthis.clear = function () {\r\n\r\n\t\tproperties = {};\r\n\r\n\t};\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLShader.js\r\n\r\nTHREE.WebGLShader = ( function () {\r\n\r\n\tfunction addLineNumbers( string ) {\r\n\r\n\t\tvar lines = string.split( '\\n' );\r\n\r\n\t\tfor ( var i = 0; i < lines.length; i ++ ) {\r\n\r\n\t\t\tlines[ i ] = ( i + 1 ) + ': ' + lines[ i ];\r\n\r\n\t\t}\r\n\r\n\t\treturn lines.join( '\\n' );\r\n\r\n\t}\r\n\r\n\treturn function WebGLShader( gl, type, string ) {\r\n\r\n\t\tvar shader = gl.createShader( type );\r\n\r\n\t\tgl.shaderSource( shader, string );\r\n\t\tgl.compileShader( shader );\r\n\r\n\t\tif ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {\r\n\r\n\t\t\tconsole.error( 'THREE.WebGLShader: Shader couldn\\'t compile.' );\r\n\r\n\t\t}\r\n\r\n\t\tif ( gl.getShaderInfoLog( shader ) !== '' ) {\r\n\r\n\t\t\tconsole.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );\r\n\r\n\t\t}\r\n\r\n\t\t// --enable-privileged-webgl-extension\r\n\t\t// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );\r\n\r\n\t\treturn shader;\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n// File:src/renderers/webgl/WebGLShadowMap.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.WebGLShadowMap = function ( _renderer, _lights, _objects ) {\r\n\r\n\tvar _gl = _renderer.context,\r\n\t_state = _renderer.state,\r\n\t_frustum = new THREE.Frustum(),\r\n\t_projScreenMatrix = new THREE.Matrix4(),\r\n\r\n\t_lightShadows = _lights.shadows,\r\n\r\n\t_shadowMapSize = new THREE.Vector2(),\r\n\r\n\t_lookTarget = new THREE.Vector3(),\r\n\t_lightPositionWorld = new THREE.Vector3(),\r\n\r\n\t_renderList = [],\r\n\r\n\t_MorphingFlag = 1,\r\n\t_SkinningFlag = 2,\r\n\r\n\t_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,\r\n\r\n\t_depthMaterials = new Array( _NumberOfMaterialVariants ),\r\n\t_distanceMaterials = new Array( _NumberOfMaterialVariants ),\r\n\r\n\t_materialCache = {};\r\n\r\n\tvar cubeDirections = [\r\n\t\tnew THREE.Vector3( 1, 0, 0 ), new THREE.Vector3( - 1, 0, 0 ), new THREE.Vector3( 0, 0, 1 ),\r\n\t\tnew THREE.Vector3( 0, 0, - 1 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, - 1, 0 )\r\n\t];\r\n\r\n\tvar cubeUps = [\r\n\t\tnew THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 1, 0 ),\r\n\t\tnew THREE.Vector3( 0, 1, 0 ), new THREE.Vector3( 0, 0, 1 ),\tnew THREE.Vector3( 0, 0, - 1 )\r\n\t];\r\n\r\n\tvar cube2DViewPorts = [\r\n\t\tnew THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4(),\r\n\t\tnew THREE.Vector4(), new THREE.Vector4(), new THREE.Vector4()\r\n\t];\r\n\r\n\t// init\r\n\r\n\tvar depthMaterialTemplate = new THREE.MeshDepthMaterial();\r\n\tdepthMaterialTemplate.depthPacking = THREE.RGBADepthPacking;\r\n\tdepthMaterialTemplate.clipping = true;\r\n\r\n\tvar distanceShader = THREE.ShaderLib[ \"distanceRGBA\" ];\r\n\tvar distanceUniforms = THREE.UniformsUtils.clone( distanceShader.uniforms );\r\n\r\n\tfor ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {\r\n\r\n\t\tvar useMorphing = ( i & _MorphingFlag ) !== 0;\r\n\t\tvar useSkinning = ( i & _SkinningFlag ) !== 0;\r\n\r\n\t\tvar depthMaterial = depthMaterialTemplate.clone();\r\n\t\tdepthMaterial.morphTargets = useMorphing;\r\n\t\tdepthMaterial.skinning = useSkinning;\r\n\r\n\t\t_depthMaterials[ i ] = depthMaterial;\r\n\r\n\t\tvar distanceMaterial = new THREE.ShaderMaterial( {\r\n\t\t\tdefines: {\r\n\t\t\t\t'USE_SHADOWMAP': ''\r\n\t\t\t},\r\n\t\t\tuniforms: distanceUniforms,\r\n\t\t\tvertexShader: distanceShader.vertexShader,\r\n\t\t\tfragmentShader: distanceShader.fragmentShader,\r\n\t\t\tmorphTargets: useMorphing,\r\n\t\t\tskinning: useSkinning,\r\n\t\t\tclipping: true\r\n\t\t} );\r\n\r\n\t\t_distanceMaterials[ i ] = distanceMaterial;\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tvar scope = this;\r\n\r\n\tthis.enabled = false;\r\n\r\n\tthis.autoUpdate = true;\r\n\tthis.needsUpdate = false;\r\n\r\n\tthis.type = THREE.PCFShadowMap;\r\n\r\n\tthis.renderReverseSided = true;\r\n\tthis.renderSingleSided = true;\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\tif ( scope.enabled === false ) return;\r\n\t\tif ( scope.autoUpdate === false && scope.needsUpdate === false ) return;\r\n\r\n\t\tif ( _lightShadows.length === 0 ) return;\r\n\r\n\t\t// Set GL state for depth map.\r\n\t\t_state.clearColor( 1, 1, 1, 1 );\r\n\t\t_state.disable( _gl.BLEND );\r\n\t\t_state.setDepthTest( true );\r\n\t\t_state.setScissorTest( false );\r\n\r\n\t\t// render depth map\r\n\r\n\t\tvar faceCount, isPointLight;\r\n\r\n\t\tfor ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {\r\n\r\n\t\t\tvar light = _lightShadows[ i ];\r\n\t\t\tvar shadow = light.shadow;\r\n\r\n\t\t\tif ( shadow === undefined ) {\r\n\r\n\t\t\t\tconsole.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );\r\n\t\t\t\tcontinue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar shadowCamera = shadow.camera;\r\n\r\n\t\t\t_shadowMapSize.copy( shadow.mapSize );\r\n\r\n\t\t\tif ( light instanceof THREE.PointLight ) {\r\n\r\n\t\t\t\tfaceCount = 6;\r\n\t\t\t\tisPointLight = true;\r\n\r\n\t\t\t\tvar vpWidth = _shadowMapSize.x;\r\n\t\t\t\tvar vpHeight = _shadowMapSize.y;\r\n\r\n\t\t\t\t// These viewports map a cube-map onto a 2D texture with the\r\n\t\t\t\t// following orientation:\r\n\t\t\t\t//\r\n\t\t\t\t//  xzXZ\r\n\t\t\t\t//   y Y\r\n\t\t\t\t//\r\n\t\t\t\t// X - Positive x direction\r\n\t\t\t\t// x - Negative x direction\r\n\t\t\t\t// Y - Positive y direction\r\n\t\t\t\t// y - Negative y direction\r\n\t\t\t\t// Z - Positive z direction\r\n\t\t\t\t// z - Negative z direction\r\n\r\n\t\t\t\t// positive X\r\n\t\t\t\tcube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );\r\n\t\t\t\t// negative X\r\n\t\t\t\tcube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );\r\n\t\t\t\t// positive Z\r\n\t\t\t\tcube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );\r\n\t\t\t\t// negative Z\r\n\t\t\t\tcube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );\r\n\t\t\t\t// positive Y\r\n\t\t\t\tcube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );\r\n\t\t\t\t// negative Y\r\n\t\t\t\tcube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );\r\n\r\n\t\t\t\t_shadowMapSize.x *= 4.0;\r\n\t\t\t\t_shadowMapSize.y *= 2.0;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfaceCount = 1;\r\n\t\t\t\tisPointLight = false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( shadow.map === null ) {\r\n\r\n\t\t\t\tvar pars = { minFilter: THREE.NearestFilter, magFilter: THREE.NearestFilter, format: THREE.RGBAFormat };\r\n\r\n\t\t\t\tshadow.map = new THREE.WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );\r\n\r\n\t\t\t\tshadowCamera.updateProjectionMatrix();\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( shadow instanceof THREE.SpotLightShadow ) {\r\n\r\n\t\t\t\tshadow.update( light );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar shadowMap = shadow.map;\r\n\t\t\tvar shadowMatrix = shadow.matrix;\r\n\r\n\t\t\t_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );\r\n\t\t\tshadowCamera.position.copy( _lightPositionWorld );\r\n\r\n\t\t\t_renderer.setRenderTarget( shadowMap );\r\n\t\t\t_renderer.clear();\r\n\r\n\t\t\t// render shadow map for each cube face (if omni-directional) or\r\n\t\t\t// run a single pass if not\r\n\r\n\t\t\tfor ( var face = 0; face < faceCount; face ++ ) {\r\n\r\n\t\t\t\tif ( isPointLight ) {\r\n\r\n\t\t\t\t\t_lookTarget.copy( shadowCamera.position );\r\n\t\t\t\t\t_lookTarget.add( cubeDirections[ face ] );\r\n\t\t\t\t\tshadowCamera.up.copy( cubeUps[ face ] );\r\n\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\r\n\r\n\t\t\t\t\tvar vpDimensions = cube2DViewPorts[ face ];\r\n\t\t\t\t\t_state.viewport( vpDimensions );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t_lookTarget.setFromMatrixPosition( light.target.matrixWorld );\r\n\t\t\t\t\tshadowCamera.lookAt( _lookTarget );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tshadowCamera.updateMatrixWorld();\r\n\t\t\t\tshadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );\r\n\r\n\t\t\t\t// compute shadow matrix\r\n\r\n\t\t\t\tshadowMatrix.set(\r\n\t\t\t\t\t0.5, 0.0, 0.0, 0.5,\r\n\t\t\t\t\t0.0, 0.5, 0.0, 0.5,\r\n\t\t\t\t\t0.0, 0.0, 0.5, 0.5,\r\n\t\t\t\t\t0.0, 0.0, 0.0, 1.0\r\n\t\t\t\t);\r\n\r\n\t\t\t\tshadowMatrix.multiply( shadowCamera.projectionMatrix );\r\n\t\t\t\tshadowMatrix.multiply( shadowCamera.matrixWorldInverse );\r\n\r\n\t\t\t\t// update camera matrices and frustum\r\n\r\n\t\t\t\t_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );\r\n\t\t\t\t_frustum.setFromMatrix( _projScreenMatrix );\r\n\r\n\t\t\t\t// set object matrices & frustum culling\r\n\r\n\t\t\t\t_renderList.length = 0;\r\n\r\n\t\t\t\tprojectObject( scene, camera, shadowCamera );\r\n\r\n\t\t\t\t// render shadow map\r\n\t\t\t\t// render regular objects\r\n\r\n\t\t\t\tfor ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tvar object = _renderList[ j ];\r\n\t\t\t\t\tvar geometry = _objects.update( object );\r\n\t\t\t\t\tvar material = object.material;\r\n\r\n\t\t\t\t\tif ( material instanceof THREE.MultiMaterial ) {\r\n\r\n\t\t\t\t\t\tvar groups = geometry.groups;\r\n\t\t\t\t\t\tvar materials = material.materials;\r\n\r\n\t\t\t\t\t\tfor ( var k = 0, kl = groups.length; k < kl; k ++ ) {\r\n\r\n\t\t\t\t\t\t\tvar group = groups[ k ];\r\n\t\t\t\t\t\t\tvar groupMaterial = materials[ group.materialIndex ];\r\n\r\n\t\t\t\t\t\t\tif ( groupMaterial.visible === true ) {\r\n\r\n\t\t\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );\r\n\t\t\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tvar depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );\r\n\t\t\t\t\t\t_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Restore GL state.\r\n\t\tvar clearColor = _renderer.getClearColor(),\r\n\t\tclearAlpha = _renderer.getClearAlpha();\r\n\t\t_renderer.setClearColor( clearColor, clearAlpha );\r\n\r\n\t\tscope.needsUpdate = false;\r\n\r\n\t};\r\n\r\n\tfunction getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {\r\n\r\n\t\tvar geometry = object.geometry;\r\n\r\n\t\tvar result = null;\r\n\r\n\t\tvar materialVariants = _depthMaterials;\r\n\t\tvar customMaterial = object.customDepthMaterial;\r\n\r\n\t\tif ( isPointLight ) {\r\n\r\n\t\t\tmaterialVariants = _distanceMaterials;\r\n\t\t\tcustomMaterial = object.customDistanceMaterial;\r\n\r\n\t\t}\r\n\r\n\t\tif ( ! customMaterial ) {\r\n\r\n\t\t\tvar useMorphing = geometry.morphTargets !== undefined &&\r\n\t\t\t\t\tgeometry.morphTargets.length > 0 && material.morphTargets;\r\n\r\n\t\t\tvar useSkinning = object instanceof THREE.SkinnedMesh && material.skinning;\r\n\r\n\t\t\tvar variantIndex = 0;\r\n\r\n\t\t\tif ( useMorphing ) variantIndex |= _MorphingFlag;\r\n\t\t\tif ( useSkinning ) variantIndex |= _SkinningFlag;\r\n\r\n\t\t\tresult = materialVariants[ variantIndex ];\r\n\r\n\t\t} else {\r\n\r\n\t\t\tresult = customMaterial;\r\n\r\n\t\t}\r\n\r\n\t\tif ( _renderer.localClippingEnabled &&\r\n\t\t\t material.clipShadows === true &&\r\n\t\t\t\tmaterial.clippingPlanes.length !== 0 ) {\r\n\r\n\t\t\t// in this case we need a unique material instance reflecting the\r\n\t\t\t// appropriate state\r\n\r\n\t\t\tvar keyA = result.uuid, keyB = material.uuid;\r\n\r\n\t\t\tvar materialsForVariant = _materialCache[ keyA ];\r\n\r\n\t\t\tif ( materialsForVariant === undefined ) {\r\n\r\n\t\t\t\tmaterialsForVariant = {};\r\n\t\t\t\t_materialCache[ keyA ] = materialsForVariant;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar cachedMaterial = materialsForVariant[ keyB ];\r\n\r\n\t\t\tif ( cachedMaterial === undefined ) {\r\n\r\n\t\t\t\tcachedMaterial = result.clone();\r\n\t\t\t\tmaterialsForVariant[ keyB ] = cachedMaterial;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tresult = cachedMaterial;\r\n\r\n\t\t}\r\n\r\n\t\tresult.visible = material.visible;\r\n\t\tresult.wireframe = material.wireframe;\r\n\r\n\t\tvar side = material.side;\r\n\r\n\t\tif ( scope.renderSingleSided && side == THREE.DoubleSide ) {\r\n\r\n\t\t\tside = THREE.FrontSide;\r\n\r\n\t\t}\r\n\r\n\t\tif ( scope.renderReverseSided ) {\r\n\r\n\t\t\tif ( side === THREE.FrontSide ) side = THREE.BackSide;\r\n\t\t\telse if ( side === THREE.BackSide ) side = THREE.FrontSide;\r\n\r\n\t\t}\r\n\r\n\t\tresult.side = side;\r\n\r\n\t\tresult.clipShadows = material.clipShadows;\r\n\t\tresult.clippingPlanes = material.clippingPlanes;\r\n\r\n\t\tresult.wireframeLinewidth = material.wireframeLinewidth;\r\n\t\tresult.linewidth = material.linewidth;\r\n\r\n\t\tif ( isPointLight && result.uniforms.lightPos !== undefined ) {\r\n\r\n\t\t\tresult.uniforms.lightPos.value.copy( lightPositionWorld );\r\n\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\tfunction projectObject( object, camera, shadowCamera ) {\r\n\r\n\t\tif ( object.visible === false ) return;\r\n\r\n\t\tif ( object.layers.test( camera.layers ) && ( object instanceof THREE.Mesh || object instanceof THREE.Line || object instanceof THREE.Points ) ) {\r\n\r\n\t\t\tif ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {\r\n\r\n\t\t\t\tvar material = object.material;\r\n\r\n\t\t\t\tif ( material.visible === true ) {\r\n\r\n\t\t\t\t\tobject.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );\r\n\t\t\t\t\t_renderList.push( object );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar children = object.children;\r\n\r\n\t\tfor ( var i = 0, l = children.length; i < l; i ++ ) {\r\n\r\n\t\t\tprojectObject( children[ i ], camera, shadowCamera );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLState.js\r\n\r\n/**\r\n* @author mrdoob / http://mrdoob.com/\r\n*/\r\n\r\nTHREE.WebGLState = function ( gl, extensions, paramThreeToGL ) {\r\n\r\n\tvar _this = this;\r\n\r\n\tthis.buffers = {\r\n\t\tcolor: new THREE.WebGLColorBuffer( gl, this ),\r\n\t\tdepth: new THREE.WebGLDepthBuffer( gl, this ),\r\n\t\tstencil: new THREE.WebGLStencilBuffer( gl, this )\r\n\t};\r\n\r\n\tvar maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );\r\n\tvar newAttributes = new Uint8Array( maxVertexAttributes );\r\n\tvar enabledAttributes = new Uint8Array( maxVertexAttributes );\r\n\tvar attributeDivisors = new Uint8Array( maxVertexAttributes );\r\n\r\n\tvar capabilities = {};\r\n\r\n\tvar compressedTextureFormats = null;\r\n\r\n\tvar currentBlending = null;\r\n\tvar currentBlendEquation = null;\r\n\tvar currentBlendSrc = null;\r\n\tvar currentBlendDst = null;\r\n\tvar currentBlendEquationAlpha = null;\r\n\tvar currentBlendSrcAlpha = null;\r\n\tvar currentBlendDstAlpha = null;\r\n\tvar currentPremultipledAlpha = false;\r\n\r\n\tvar currentFlipSided = null;\r\n\tvar currentCullFace = null;\r\n\r\n\tvar currentLineWidth = null;\r\n\r\n\tvar currentPolygonOffsetFactor = null;\r\n\tvar currentPolygonOffsetUnits = null;\r\n\r\n\tvar currentScissorTest = null;\r\n\r\n\tvar maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );\r\n\r\n\tvar currentTextureSlot = null;\r\n\tvar currentBoundTextures = {};\r\n\r\n\tvar currentScissor = new THREE.Vector4();\r\n\tvar currentViewport = new THREE.Vector4();\r\n\r\n\tfunction createTexture( type, target, count ) {\r\n\r\n\t\tvar data = new Uint8Array( 3 );\r\n\t\tvar texture = gl.createTexture();\r\n\r\n\t\tgl.bindTexture( type, texture );\r\n\t\tgl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\r\n\t\tgl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\r\n\r\n\t\tfor ( var i = 0; i < count; i ++ ) {\r\n\r\n\t\t\tgl.texImage2D( target + i, 0, gl.RGB, 1, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, data );\r\n\r\n\t\t}\r\n\r\n\t\treturn texture;\r\n\r\n\t}\r\n\r\n\tvar emptyTextures = {};\r\n\temptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );\r\n\temptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );\r\n\r\n\t//\r\n\r\n\tthis.init = function () {\r\n\r\n\t\tthis.clearColor( 0, 0, 0, 1 );\r\n\t\tthis.clearDepth( 1 );\r\n\t\tthis.clearStencil( 0 );\r\n\r\n\t\tthis.enable( gl.DEPTH_TEST );\r\n\t\tthis.setDepthFunc( THREE.LessEqualDepth );\r\n\r\n\t\tthis.setFlipSided( false );\r\n\t\tthis.setCullFace( THREE.CullFaceBack );\r\n\t\tthis.enable( gl.CULL_FACE );\r\n\r\n\t\tthis.enable( gl.BLEND );\r\n\t\tthis.setBlending( THREE.NormalBlending );\r\n\r\n\t};\r\n\r\n\tthis.initAttributes = function () {\r\n\r\n\t\tfor ( var i = 0, l = newAttributes.length; i < l; i ++ ) {\r\n\r\n\t\t\tnewAttributes[ i ] = 0;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.enableAttribute = function ( attribute ) {\r\n\r\n\t\tnewAttributes[ attribute ] = 1;\r\n\r\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\r\n\r\n\t\t\tgl.enableVertexAttribArray( attribute );\r\n\t\t\tenabledAttributes[ attribute ] = 1;\r\n\r\n\t\t}\r\n\r\n\t\tif ( attributeDivisors[ attribute ] !== 0 ) {\r\n\r\n\t\t\tvar extension = extensions.get( 'ANGLE_instanced_arrays' );\r\n\r\n\t\t\textension.vertexAttribDivisorANGLE( attribute, 0 );\r\n\t\t\tattributeDivisors[ attribute ] = 0;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.enableAttributeAndDivisor = function ( attribute, meshPerAttribute, extension ) {\r\n\r\n\t\tnewAttributes[ attribute ] = 1;\r\n\r\n\t\tif ( enabledAttributes[ attribute ] === 0 ) {\r\n\r\n\t\t\tgl.enableVertexAttribArray( attribute );\r\n\t\t\tenabledAttributes[ attribute ] = 1;\r\n\r\n\t\t}\r\n\r\n\t\tif ( attributeDivisors[ attribute ] !== meshPerAttribute ) {\r\n\r\n\t\t\textension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );\r\n\t\t\tattributeDivisors[ attribute ] = meshPerAttribute;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.disableUnusedAttributes = function () {\r\n\r\n\t\tfor ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {\r\n\r\n\t\t\tif ( enabledAttributes[ i ] !== newAttributes[ i ] ) {\r\n\r\n\t\t\t\tgl.disableVertexAttribArray( i );\r\n\t\t\t\tenabledAttributes[ i ] = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.enable = function ( id ) {\r\n\r\n\t\tif ( capabilities[ id ] !== true ) {\r\n\r\n\t\t\tgl.enable( id );\r\n\t\t\tcapabilities[ id ] = true;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.disable = function ( id ) {\r\n\r\n\t\tif ( capabilities[ id ] !== false ) {\r\n\r\n\t\t\tgl.disable( id );\r\n\t\t\tcapabilities[ id ] = false;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.getCompressedTextureFormats = function () {\r\n\r\n\t\tif ( compressedTextureFormats === null ) {\r\n\r\n\t\t\tcompressedTextureFormats = [];\r\n\r\n\t\t\tif ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||\r\n\t\t\t     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||\r\n\t\t\t     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {\r\n\r\n\t\t\t\tvar formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );\r\n\r\n\t\t\t\tfor ( var i = 0; i < formats.length; i ++ ) {\r\n\r\n\t\t\t\t\tcompressedTextureFormats.push( formats[ i ] );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn compressedTextureFormats;\r\n\r\n\t};\r\n\r\n\tthis.setBlending = function ( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {\r\n\r\n\t\tif ( blending !== THREE.NoBlending ) {\r\n\r\n\t\t\tthis.enable( gl.BLEND );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.disable( gl.BLEND );\r\n\t\t\tcurrentBlending = blending; // no blending, that is\r\n\t\t\treturn;\r\n\r\n\t\t}\r\n\r\n\t\tif ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {\r\n\r\n\t\t\tif ( blending === THREE.AdditiveBlending ) {\r\n\r\n\t\t\t\tif ( premultipliedAlpha ) {\r\n\r\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFunc( gl.SRC_ALPHA, gl.ONE );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( blending === THREE.SubtractiveBlending ) {\r\n\r\n\t\t\t\tif ( premultipliedAlpha ) {\r\n\r\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else if ( blending === THREE.MultiplyBlending ) {\r\n\r\n\t\t\t\tif ( premultipliedAlpha ) {\r\n\r\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tgl.blendEquation( gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFunc( gl.ZERO, gl.SRC_COLOR );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( premultipliedAlpha ) {\r\n\r\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tgl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );\r\n\t\t\t\t\tgl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcurrentBlending = blending;\r\n\t\t\tcurrentPremultipledAlpha = premultipliedAlpha;\r\n\r\n\t\t}\r\n\r\n\t\tif ( blending === THREE.CustomBlending ) {\r\n\r\n\t\t\tblendEquationAlpha = blendEquationAlpha || blendEquation;\r\n\t\t\tblendSrcAlpha = blendSrcAlpha || blendSrc;\r\n\t\t\tblendDstAlpha = blendDstAlpha || blendDst;\r\n\r\n\t\t\tif ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {\r\n\r\n\t\t\t\tgl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );\r\n\r\n\t\t\t\tcurrentBlendEquation = blendEquation;\r\n\t\t\t\tcurrentBlendEquationAlpha = blendEquationAlpha;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {\r\n\r\n\t\t\t\tgl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );\r\n\r\n\t\t\t\tcurrentBlendSrc = blendSrc;\r\n\t\t\t\tcurrentBlendDst = blendDst;\r\n\t\t\t\tcurrentBlendSrcAlpha = blendSrcAlpha;\r\n\t\t\t\tcurrentBlendDstAlpha = blendDstAlpha;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tcurrentBlendEquation = null;\r\n\t\t\tcurrentBlendSrc = null;\r\n\t\t\tcurrentBlendDst = null;\r\n\t\t\tcurrentBlendEquationAlpha = null;\r\n\t\t\tcurrentBlendSrcAlpha = null;\r\n\t\t\tcurrentBlendDstAlpha = null;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// TODO Deprecate\r\n\r\n\tthis.setColorWrite = function ( colorWrite ) {\r\n\r\n\t\tthis.buffers.color.setMask( colorWrite );\r\n\r\n\t};\r\n\r\n\tthis.setDepthTest = function ( depthTest ) {\r\n\r\n\t\tthis.buffers.depth.setTest( depthTest );\r\n\r\n\t};\r\n\r\n\tthis.setDepthWrite = function ( depthWrite ) {\r\n\r\n\t\tthis.buffers.depth.setMask( depthWrite );\r\n\r\n\t};\r\n\r\n\tthis.setDepthFunc = function ( depthFunc ) {\r\n\r\n\t\tthis.buffers.depth.setFunc( depthFunc );\r\n\r\n\t};\r\n\r\n\tthis.setStencilTest = function ( stencilTest ) {\r\n\r\n\t\tthis.buffers.stencil.setTest( stencilTest );\r\n\r\n\t};\r\n\r\n\tthis.setStencilWrite = function ( stencilWrite ) {\r\n\r\n\t\tthis.buffers.stencil.setMask( stencilWrite );\r\n\r\n\t};\r\n\r\n\tthis.setStencilFunc = function ( stencilFunc, stencilRef, stencilMask ) {\r\n\r\n\t\tthis.buffers.stencil.setFunc( stencilFunc, stencilRef, stencilMask );\r\n\r\n\t};\r\n\r\n\tthis.setStencilOp = function ( stencilFail, stencilZFail, stencilZPass ) {\r\n\r\n\t\tthis.buffers.stencil.setOp( stencilFail, stencilZFail, stencilZPass );\r\n\r\n\t};\r\n\r\n\t//\r\n\r\n\tthis.setFlipSided = function ( flipSided ) {\r\n\r\n\t\tif ( currentFlipSided !== flipSided ) {\r\n\r\n\t\t\tif ( flipSided ) {\r\n\r\n\t\t\t\tgl.frontFace( gl.CW );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tgl.frontFace( gl.CCW );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcurrentFlipSided = flipSided;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setCullFace = function ( cullFace ) {\r\n\r\n\t\tif ( cullFace !== THREE.CullFaceNone ) {\r\n\r\n\t\t\tthis.enable( gl.CULL_FACE );\r\n\r\n\t\t\tif ( cullFace !== currentCullFace ) {\r\n\r\n\t\t\t\tif ( cullFace === THREE.CullFaceBack ) {\r\n\r\n\t\t\t\t\tgl.cullFace( gl.BACK );\r\n\r\n\t\t\t\t} else if ( cullFace === THREE.CullFaceFront ) {\r\n\r\n\t\t\t\t\tgl.cullFace( gl.FRONT );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tgl.cullFace( gl.FRONT_AND_BACK );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.disable( gl.CULL_FACE );\r\n\r\n\t\t}\r\n\r\n\t\tcurrentCullFace = cullFace;\r\n\r\n\t};\r\n\r\n\tthis.setLineWidth = function ( width ) {\r\n\r\n\t\tif ( width !== currentLineWidth ) {\r\n\r\n\t\t\tgl.lineWidth( width );\r\n\r\n\t\t\tcurrentLineWidth = width;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setPolygonOffset = function ( polygonOffset, factor, units ) {\r\n\r\n\t\tif ( polygonOffset ) {\r\n\r\n\t\t\tthis.enable( gl.POLYGON_OFFSET_FILL );\r\n\r\n\t\t\tif ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {\r\n\r\n\t\t\t\tgl.polygonOffset( factor, units );\r\n\r\n\t\t\t\tcurrentPolygonOffsetFactor = factor;\r\n\t\t\t\tcurrentPolygonOffsetUnits = units;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.disable( gl.POLYGON_OFFSET_FILL );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.getScissorTest = function () {\r\n\r\n\t\treturn currentScissorTest;\r\n\r\n\t};\r\n\r\n\tthis.setScissorTest = function ( scissorTest ) {\r\n\r\n\t\tcurrentScissorTest = scissorTest;\r\n\r\n\t\tif ( scissorTest ) {\r\n\r\n\t\t\tthis.enable( gl.SCISSOR_TEST );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.disable( gl.SCISSOR_TEST );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// texture\r\n\r\n\tthis.activeTexture = function ( webglSlot ) {\r\n\r\n\t\tif ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;\r\n\r\n\t\tif ( currentTextureSlot !== webglSlot ) {\r\n\r\n\t\t\tgl.activeTexture( webglSlot );\r\n\t\t\tcurrentTextureSlot = webglSlot;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.bindTexture = function ( webglType, webglTexture ) {\r\n\r\n\t\tif ( currentTextureSlot === null ) {\r\n\r\n\t\t\t_this.activeTexture();\r\n\r\n\t\t}\r\n\r\n\t\tvar boundTexture = currentBoundTextures[ currentTextureSlot ];\r\n\r\n\t\tif ( boundTexture === undefined ) {\r\n\r\n\t\t\tboundTexture = { type: undefined, texture: undefined };\r\n\t\t\tcurrentBoundTextures[ currentTextureSlot ] = boundTexture;\r\n\r\n\t\t}\r\n\r\n\t\tif ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {\r\n\r\n\t\t\tgl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );\r\n\r\n\t\t\tboundTexture.type = webglType;\r\n\t\t\tboundTexture.texture = webglTexture;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.compressedTexImage2D = function () {\r\n\r\n\t\ttry {\r\n\r\n\t\t\tgl.compressedTexImage2D.apply( gl, arguments );\r\n\r\n\t\t} catch ( error ) {\r\n\r\n\t\t\tconsole.error( error );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.texImage2D = function () {\r\n\r\n\t\ttry {\r\n\r\n\t\t\tgl.texImage2D.apply( gl, arguments );\r\n\r\n\t\t} catch ( error ) {\r\n\r\n\t\t\tconsole.error( error );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// TODO Deprecate\r\n\r\n\tthis.clearColor = function ( r, g, b, a ) {\r\n\r\n\t\tthis.buffers.color.setClear( r, g, b, a );\r\n\r\n\t};\r\n\r\n\tthis.clearDepth = function ( depth ) {\r\n\r\n\t\tthis.buffers.depth.setClear( depth );\r\n\r\n\t};\r\n\r\n\tthis.clearStencil = function ( stencil ) {\r\n\r\n\t\tthis.buffers.stencil.setClear( stencil );\r\n\r\n\t};\r\n\r\n\t//\r\n\r\n\tthis.scissor = function ( scissor ) {\r\n\r\n\t\tif ( currentScissor.equals( scissor ) === false ) {\r\n\r\n\t\t\tgl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );\r\n\t\t\tcurrentScissor.copy( scissor );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.viewport = function ( viewport ) {\r\n\r\n\t\tif ( currentViewport.equals( viewport ) === false ) {\r\n\r\n\t\t\tgl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );\r\n\t\t\tcurrentViewport.copy( viewport );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t//\r\n\r\n\tthis.reset = function () {\r\n\r\n\t\tfor ( var i = 0; i < enabledAttributes.length; i ++ ) {\r\n\r\n\t\t\tif ( enabledAttributes[ i ] === 1 ) {\r\n\r\n\t\t\t\tgl.disableVertexAttribArray( i );\r\n\t\t\t\tenabledAttributes[ i ] = 0;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tcapabilities = {};\r\n\r\n\t\tcompressedTextureFormats = null;\r\n\r\n\t\tcurrentTextureSlot = null;\r\n\t\tcurrentBoundTextures = {};\r\n\r\n\t\tcurrentBlending = null;\r\n\r\n\t\tcurrentFlipSided = null;\r\n\t\tcurrentCullFace = null;\r\n\r\n\t\tthis.buffers.color.reset();\r\n\t\tthis.buffers.depth.reset();\r\n\t\tthis.buffers.stencil.reset();\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.WebGLColorBuffer = function ( gl, state ) {\r\n\r\n\tvar locked = false;\r\n\r\n\tvar color = new THREE.Vector4();\r\n\tvar currentColorMask = null;\r\n\tvar currentColorClear = new THREE.Vector4();\r\n\r\n\tthis.setMask = function ( colorMask ) {\r\n\r\n\t\tif ( currentColorMask !== colorMask && ! locked ) {\r\n\r\n\t\t\tgl.colorMask( colorMask, colorMask, colorMask, colorMask );\r\n\t\t\tcurrentColorMask = colorMask;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setLocked = function ( lock ) {\r\n\r\n\t\tlocked = lock;\r\n\r\n\t};\r\n\r\n\tthis.setClear = function ( r, g, b, a ) {\r\n\r\n\t\tcolor.set( r, g, b, a );\r\n\r\n\t\tif ( currentColorClear.equals( color ) === false ) {\r\n\r\n\t\t\tgl.clearColor( r, g, b, a );\r\n\t\t\tcurrentColorClear.copy( color );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.reset = function () {\r\n\r\n\t\tlocked = false;\r\n\r\n\t\tcurrentColorMask = null;\r\n\t\tcurrentColorClear = new THREE.Vector4();\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.WebGLDepthBuffer = function( gl, state ) {\r\n\r\n\tvar locked = false;\r\n\r\n\tvar currentDepthMask = null;\r\n\tvar currentDepthFunc = null;\r\n\tvar currentDepthClear = null;\r\n\r\n\tthis.setTest = function ( depthTest ) {\r\n\r\n\t\tif ( depthTest ) {\r\n\r\n\t\t\tstate.enable( gl.DEPTH_TEST );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tstate.disable( gl.DEPTH_TEST );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setMask = function( depthMask ){\r\n\r\n\t\tif ( currentDepthMask !== depthMask && ! locked ) {\r\n\r\n\t\t\tgl.depthMask( depthMask );\r\n\t\t\tcurrentDepthMask = depthMask;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setFunc = function ( depthFunc ) {\r\n\r\n\t\tif ( currentDepthFunc !== depthFunc ) {\r\n\r\n\t\t\tif ( depthFunc ) {\r\n\r\n\t\t\t\tswitch ( depthFunc ) {\r\n\r\n\t\t\t\t\tcase THREE.NeverDepth:\r\n\r\n\t\t\t\t\t\tgl.depthFunc( gl.NEVER );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase THREE.AlwaysDepth:\r\n\r\n\t\t\t\t\t\tgl.depthFunc( gl.ALWAYS );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase THREE.LessDepth:\r\n\r\n\t\t\t\t\t\tgl.depthFunc( gl.LESS );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase THREE.LessEqualDepth:\r\n\r\n\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase THREE.EqualDepth:\r\n\r\n\t\t\t\t\t\tgl.depthFunc( gl.EQUAL );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase THREE.GreaterEqualDepth:\r\n\r\n\t\t\t\t\t\tgl.depthFunc( gl.GEQUAL );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase THREE.GreaterDepth:\r\n\r\n\t\t\t\t\t\tgl.depthFunc( gl.GREATER );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tcase THREE.NotEqualDepth:\r\n\r\n\t\t\t\t\t\tgl.depthFunc( gl.NOTEQUAL );\r\n\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\tdefault:\r\n\r\n\t\t\t\t\t\tgl.depthFunc( gl.LEQUAL );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tgl.depthFunc( gl.LEQUAL );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tcurrentDepthFunc = depthFunc;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setLocked = function ( lock ) {\r\n\r\n\t\tlocked = lock;\r\n\r\n\t};\r\n\r\n\tthis.setClear = function ( depth ) {\r\n\r\n\t\tif ( currentDepthClear !== depth ) {\r\n\r\n\t\t\tgl.clearDepth( depth );\r\n\t\t\tcurrentDepthClear = depth;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.reset = function () {\r\n\r\n\t\tlocked = false;\r\n\r\n\t\tcurrentDepthMask = null;\r\n\t\tcurrentDepthFunc = null;\r\n\t\tcurrentDepthClear = null;\r\n\r\n\t};\r\n\r\n};\r\n\r\nTHREE.WebGLStencilBuffer = function ( gl, state ) {\r\n\r\n\tvar locked = false;\r\n\r\n\tvar currentStencilMask = null;\r\n\tvar currentStencilFunc = null;\r\n\tvar currentStencilRef = null;\r\n\tvar currentStencilFuncMask = null;\r\n\tvar currentStencilFail  = null;\r\n\tvar currentStencilZFail = null;\r\n\tvar currentStencilZPass = null;\r\n\tvar currentStencilClear = null;\r\n\r\n\tthis.setTest = function ( stencilTest ) {\r\n\r\n\t\tif ( stencilTest ) {\r\n\r\n\t\t\tstate.enable( gl.STENCIL_TEST );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tstate.disable( gl.STENCIL_TEST );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setMask = function ( stencilMask ) {\r\n\r\n\t\tif ( currentStencilMask !== stencilMask && ! locked ) {\r\n\r\n\t\t\tgl.stencilMask( stencilMask );\r\n\t\t\tcurrentStencilMask = stencilMask;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setFunc = function ( stencilFunc, stencilRef, stencilMask ) {\r\n\r\n\t\tif ( currentStencilFunc !== stencilFunc ||\r\n\t\t     currentStencilRef \t!== stencilRef \t||\r\n\t\t     currentStencilFuncMask !== stencilMask ) {\r\n\r\n\t\t\tgl.stencilFunc( stencilFunc,  stencilRef, stencilMask );\r\n\r\n\t\t\tcurrentStencilFunc = stencilFunc;\r\n\t\t\tcurrentStencilRef  = stencilRef;\r\n\t\t\tcurrentStencilFuncMask = stencilMask;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setOp\t = function ( stencilFail, stencilZFail, stencilZPass ) {\r\n\r\n\t\tif ( currentStencilFail\t !== stencilFail \t||\r\n\t\t     currentStencilZFail !== stencilZFail ||\r\n\t\t     currentStencilZPass !== stencilZPass ) {\r\n\r\n\t\t\tgl.stencilOp( stencilFail,  stencilZFail, stencilZPass );\r\n\r\n\t\t\tcurrentStencilFail  = stencilFail;\r\n\t\t\tcurrentStencilZFail = stencilZFail;\r\n\t\t\tcurrentStencilZPass = stencilZPass;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.setLocked = function ( lock ) {\r\n\r\n\t\tlocked = lock;\r\n\r\n\t};\r\n\r\n\tthis.setClear = function ( stencil ) {\r\n\r\n\t\tif ( currentStencilClear !== stencil ) {\r\n\r\n\t\t\tgl.clearStencil( stencil );\r\n\t\t\tcurrentStencilClear = stencil;\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tthis.reset = function () {\r\n\r\n\t\tlocked = false;\r\n\r\n\t\tcurrentStencilMask = null;\r\n\t\tcurrentStencilFunc = null;\r\n\t\tcurrentStencilRef = null;\r\n\t\tcurrentStencilFuncMask = null;\r\n\t\tcurrentStencilFail = null;\r\n\t\tcurrentStencilZFail = null;\r\n\t\tcurrentStencilZPass = null;\r\n\t\tcurrentStencilClear = null;\r\n\r\n\t};\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/WebGLUniforms.js\r\n\r\n/**\r\n *\r\n * Uniforms of a program.\r\n * Those form a tree structure with a special top-level container for the root,\r\n * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.\r\n *\r\n *\r\n * Properties of inner nodes including the top-level container:\r\n *\r\n * .seq - array of nested uniforms\r\n * .map - nested uniforms by name\r\n *\r\n *\r\n * Methods of all nodes except the top-level container:\r\n *\r\n * .setValue( gl, value, [renderer] )\r\n *\r\n * \t\tuploads a uniform value(s)\r\n *  \tthe 'renderer' parameter is needed for sampler uniforms\r\n *\r\n *\r\n * Static methods of the top-level container (renderer factorizations):\r\n *\r\n * .upload( gl, seq, values, renderer )\r\n *\r\n * \t\tsets uniforms in 'seq' to 'values[id].value'\r\n *\r\n * .seqWithValue( seq, values ) : filteredSeq\r\n *\r\n * \t\tfilters 'seq' entries with corresponding entry in values\r\n *\r\n * .splitDynamic( seq, values ) : filteredSeq\r\n *\r\n * \t\tfilters 'seq' entries with dynamic entry and removes them from 'seq'\r\n *\r\n *\r\n * Methods of the top-level container (renderer factorizations):\r\n *\r\n * .setValue( gl, name, value )\r\n *\r\n * \t\tsets uniform with  name 'name' to 'value'\r\n *\r\n * .set( gl, obj, prop )\r\n *\r\n * \t\tsets uniform from object and property with same name than uniform\r\n *\r\n * .setOptional( gl, obj, prop )\r\n *\r\n * \t\tlike .set for an optional property of the object\r\n *\r\n *\r\n * @author tschw\r\n *\r\n */\r\n\r\nTHREE.WebGLUniforms = ( function() { // scope\r\n\r\n\t// --- Base for inner nodes (including the root) ---\r\n\r\n\tvar UniformContainer = function() {\r\n\r\n\t\t\tthis.seq = [];\r\n\t\t\tthis.map = {};\r\n\r\n\t\t},\r\n\r\n\t// --- Utilities ---\r\n\r\n\t// Array Caches (provide typed arrays for temporary by size)\r\n\r\n\t\tarrayCacheF32 = [],\r\n\t\tarrayCacheI32 = [],\r\n\r\n\t\tuncacheTemporaryArrays = function() {\r\n\r\n\t\t\tarrayCacheF32.length = 0;\r\n\t\t\tarrayCacheI32.length = 0;\r\n\r\n\t\t},\r\n\r\n\t// Flattening for arrays of vectors and matrices\r\n\r\n\t\tflatten = function( array, nBlocks, blockSize ) {\r\n\r\n\t\t\tvar firstElem = array[ 0 ];\r\n\r\n\t\t\tif ( firstElem <= 0 || firstElem > 0 ) return array;\r\n\t\t\t// unoptimized: ! isNaN( firstElem )\r\n\t\t\t// see http://jacksondunstan.com/articles/983\r\n\r\n\t\t\tvar n = nBlocks * blockSize,\r\n\t\t\t\tr = arrayCacheF32[ n ];\r\n\r\n\t\t\tif ( r === undefined ) {\r\n\r\n\t\t\t\tr = new Float32Array( n );\r\n\t\t\t\tarrayCacheF32[ n ] = r;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( nBlocks !== 0 ) {\r\n\r\n\t\t\t\tfirstElem.toArray( r, 0 );\r\n\r\n\t\t\t\tfor ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {\r\n\r\n\t\t\t\t\toffset += blockSize;\r\n\t\t\t\t\tarray[ i ].toArray( r, offset );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn r;\r\n\r\n\t\t},\r\n\r\n\t// Texture unit allocation\r\n\r\n\t\tallocTexUnits = function( renderer, n ) {\r\n\r\n\t\t\tvar r = arrayCacheI32[ n ];\r\n\r\n\t\t\tif ( r === undefined ) {\r\n\r\n\t\t\t\tr = new Int32Array( n );\r\n\t\t\t\tarrayCacheI32[ n ] = r;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var i = 0; i !== n; ++ i )\r\n\t\t\t\tr[ i ] = renderer.allocTextureUnit();\r\n\r\n\t\t\treturn r;\r\n\r\n\t\t},\r\n\r\n\t// --- Setters ---\r\n\r\n\t// Note: Defining these methods externally, because they come in a bunch\r\n\t// and this way their names minify.\r\n\r\n\t\t// Single scalar\r\n\r\n\t\tsetValue1f = function( gl, v ) { gl.uniform1f( this.addr, v ); },\r\n\t\tsetValue1i = function( gl, v ) { gl.uniform1i( this.addr, v ); },\r\n\r\n\t\t// Single float vector (from flat array or THREE.VectorN)\r\n\r\n\t\tsetValue2fv = function( gl, v ) {\r\n\r\n\t\t\tif ( v.x === undefined ) gl.uniform2fv( this.addr, v );\r\n\t\t\telse gl.uniform2f( this.addr, v.x, v.y );\r\n\r\n\t\t},\r\n\r\n\t\tsetValue3fv = function( gl, v ) {\r\n\r\n\t\t\tif ( v.x !== undefined )\r\n\t\t\t\tgl.uniform3f( this.addr, v.x, v.y, v.z );\r\n\t\t\telse if ( v.r !== undefined )\r\n\t\t\t\tgl.uniform3f( this.addr, v.r, v.g, v.b );\r\n\t\t\telse\r\n\t\t\t\tgl.uniform3fv( this.addr, v );\r\n\r\n\t\t},\r\n\r\n\t\tsetValue4fv = function( gl, v ) {\r\n\r\n\t\t\tif ( v.x === undefined ) gl.uniform4fv( this.addr, v );\r\n\t\t\telse gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );\r\n\r\n\t\t},\r\n\r\n\t\t// Single matrix (from flat array or MatrixN)\r\n\r\n\t\tsetValue2fm = function( gl, v ) {\r\n\r\n\t\t\tgl.uniformMatrix2fv( this.addr, false, v.elements || v );\r\n\r\n\t\t},\r\n\r\n\t\tsetValue3fm = function( gl, v ) {\r\n\r\n\t\t\tgl.uniformMatrix3fv( this.addr, false, v.elements || v );\r\n\r\n\t\t},\r\n\r\n\t\tsetValue4fm = function( gl, v ) {\r\n\r\n\t\t\tgl.uniformMatrix4fv( this.addr, false, v.elements || v );\r\n\r\n\t\t},\r\n\r\n\t\t// Single texture (2D / Cube)\r\n\r\n\t\tsetValueT1 = function( gl, v, renderer ) {\r\n\r\n\t\t\tvar unit = renderer.allocTextureUnit();\r\n\t\t\tgl.uniform1i( this.addr, unit );\r\n\t\t\tif ( v ) renderer.setTexture2D( v, unit );\r\n\r\n\t\t},\r\n\r\n\t\tsetValueT6 = function( gl, v, renderer ) {\r\n\r\n\t\t\tvar unit = renderer.allocTextureUnit();\r\n\t\t\tgl.uniform1i( this.addr, unit );\r\n\t\t\tif ( v ) renderer.setTextureCube( v, unit );\r\n\r\n\t\t},\r\n\r\n\t\t// Integer / Boolean vectors or arrays thereof (always flat arrays)\r\n\r\n\t\tsetValue2iv = function( gl, v ) { gl.uniform2iv( this.addr, v ); },\r\n\t\tsetValue3iv = function( gl, v ) { gl.uniform3iv( this.addr, v ); },\r\n\t\tsetValue4iv = function( gl, v ) { gl.uniform4iv( this.addr, v ); },\r\n\r\n\t\t// Helper to pick the right setter for the singular case\r\n\r\n\t\tgetSingularSetter = function( type ) {\r\n\r\n\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\tcase 0x1406: return setValue1f; // FLOAT\r\n\t\t\t\tcase 0x8b50: return setValue2fv; // _VEC2\r\n\t\t\t\tcase 0x8b51: return setValue3fv; // _VEC3\r\n\t\t\t\tcase 0x8b52: return setValue4fv; // _VEC4\r\n\r\n\t\t\t\tcase 0x8b5a: return setValue2fm; // _MAT2\r\n\t\t\t\tcase 0x8b5b: return setValue3fm; // _MAT3\r\n\t\t\t\tcase 0x8b5c: return setValue4fm; // _MAT4\r\n\r\n\t\t\t\tcase 0x8b5e: return setValueT1; // SAMPLER_2D\r\n\t\t\t\tcase 0x8b60: return setValueT6; // SAMPLER_CUBE\r\n\r\n\t\t\t\tcase 0x1404: case 0x8b56: return setValue1i; // INT, BOOL\r\n\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\r\n\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\r\n\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\t// Array of scalars\r\n\r\n\t\tsetValue1fv = function( gl, v ) { gl.uniform1fv( this.addr, v ); },\r\n\t\tsetValue1iv = function( gl, v ) { gl.uniform1iv( this.addr, v ); },\r\n\r\n\t\t// Array of vectors (flat or from THREE classes)\r\n\r\n\t\tsetValueV2a = function( gl, v ) {\r\n\r\n\t\t\tgl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );\r\n\r\n\t\t},\r\n\r\n\t\tsetValueV3a = function( gl, v ) {\r\n\r\n\t\t\tgl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );\r\n\r\n\t\t},\r\n\r\n\t\tsetValueV4a = function( gl, v ) {\r\n\r\n\t\t\tgl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );\r\n\r\n\t\t},\r\n\r\n\t\t// Array of matrices (flat or from THREE clases)\r\n\r\n\t\tsetValueM2a = function( gl, v ) {\r\n\r\n\t\t\tgl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );\r\n\r\n\t\t},\r\n\r\n\t\tsetValueM3a = function( gl, v ) {\r\n\r\n\t\t\tgl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );\r\n\r\n\t\t},\r\n\r\n\t\tsetValueM4a = function( gl, v ) {\r\n\r\n\t\t\tgl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );\r\n\r\n\t\t},\r\n\r\n\t\t// Array of textures (2D / Cube)\r\n\r\n\t\tsetValueT1a = function( gl, v, renderer ) {\r\n\r\n\t\t\tvar n = v.length,\r\n\t\t\t\tunits = allocTexUnits( renderer, n );\r\n\r\n\t\t\tgl.uniform1iv( this.addr, units );\r\n\r\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\r\n\r\n\t\t\t\tvar tex = v[ i ];\r\n\t\t\t\tif ( tex ) renderer.setTexture2D( tex, units[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t\tsetValueT6a = function( gl, v, renderer ) {\r\n\r\n\t\t\tvar n = v.length,\r\n\t\t\t\tunits = allocTexUnits( renderer, n );\r\n\r\n\t\t\tgl.uniform1iv( this.addr, units );\r\n\r\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\r\n\r\n\t\t\t\tvar tex = v[ i ];\r\n\t\t\t\tif ( tex ) renderer.setTextureCube( tex, units[ i ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\r\n\t\t// Helper to pick the right setter for a pure (bottom-level) array\r\n\r\n\t\tgetPureArraySetter = function( type ) {\r\n\r\n\t\t\tswitch ( type ) {\r\n\r\n\t\t\t\tcase 0x1406: return setValue1fv; // FLOAT\r\n\t\t\t\tcase 0x8b50: return setValueV2a; // _VEC2\r\n\t\t\t\tcase 0x8b51: return setValueV3a; // _VEC3\r\n\t\t\t\tcase 0x8b52: return setValueV4a; // _VEC4\r\n\r\n\t\t\t\tcase 0x8b5a: return setValueM2a; // _MAT2\r\n\t\t\t\tcase 0x8b5b: return setValueM3a; // _MAT3\r\n\t\t\t\tcase 0x8b5c: return setValueM4a; // _MAT4\r\n\r\n\t\t\t\tcase 0x8b5e: return setValueT1a; // SAMPLER_2D\r\n\t\t\t\tcase 0x8b60: return setValueT6a; // SAMPLER_CUBE\r\n\r\n\t\t\t\tcase 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL\r\n\t\t\t\tcase 0x8b53: case 0x8b57: return setValue2iv; // _VEC2\r\n\t\t\t\tcase 0x8b54: case 0x8b58: return setValue3iv; // _VEC3\r\n\t\t\t\tcase 0x8b55: case 0x8b59: return setValue4iv; // _VEC4\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t// --- Uniform Classes ---\r\n\r\n\t\tSingleUniform = function SingleUniform( id, activeInfo, addr ) {\r\n\r\n\t\t\tthis.id = id;\r\n\t\t\tthis.addr = addr;\r\n\t\t\tthis.setValue = getSingularSetter( activeInfo.type );\r\n\r\n\t\t\t// this.path = activeInfo.name; // DEBUG\r\n\r\n\t\t},\r\n\r\n\t\tPureArrayUniform = function( id, activeInfo, addr ) {\r\n\r\n\t\t\tthis.id = id;\r\n\t\t\tthis.addr = addr;\r\n\t\t\tthis.size = activeInfo.size;\r\n\t\t\tthis.setValue = getPureArraySetter( activeInfo.type );\r\n\r\n\t\t\t// this.path = activeInfo.name; // DEBUG\r\n\r\n\t\t},\r\n\r\n\t\tStructuredUniform = function( id ) {\r\n\r\n\t\t\tthis.id = id;\r\n\r\n\t\t\tUniformContainer.call( this ); // mix-in\r\n\r\n\t\t};\r\n\r\n\tStructuredUniform.prototype.setValue = function( gl, value ) {\r\n\r\n\t\t// Note: Don't need an extra 'renderer' parameter, since samplers\r\n\t\t// are not allowed in structured uniforms.\r\n\r\n\t\tvar seq = this.seq;\r\n\r\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar u = seq[ i ];\r\n\t\t\tu.setValue( gl, value[ u.id ] );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\t// --- Top-level ---\r\n\r\n\t// Parser - builds up the property tree from the path strings\r\n\r\n\tvar RePathPart = /([\\w\\d_]+)(\\])?(\\[|\\.)?/g,\r\n\t\t// extracts\r\n\t\t// \t- the identifier (member name or array index)\r\n\t\t//  - followed by an optional right bracket (found when array index)\r\n\t\t//  - followed by an optional left bracket or dot (type of subscript)\r\n\t\t//\r\n\t\t// Note: These portions can be read in a non-overlapping fashion and\r\n\t\t// allow straightforward parsing of the hierarchy that WebGL encodes\r\n\t\t// in the uniform names.\r\n\r\n\t\taddUniform = function( container, uniformObject ) {\r\n\r\n\t\t\tcontainer.seq.push( uniformObject );\r\n\t\t\tcontainer.map[ uniformObject.id ] = uniformObject;\r\n\r\n\t\t},\r\n\r\n\t\tparseUniform = function( activeInfo, addr, container ) {\r\n\r\n\t\t\tvar path = activeInfo.name,\r\n\t\t\t\tpathLength = path.length;\r\n\r\n\t\t\t// reset RegExp object, because of the early exit of a previous run\r\n\t\t\tRePathPart.lastIndex = 0;\r\n\r\n\t\t\tfor (; ;) {\r\n\r\n\t\t\t\tvar match = RePathPart.exec( path ),\r\n\t\t\t\t\tmatchEnd = RePathPart.lastIndex,\r\n\r\n\t\t\t\t\tid = match[ 1 ],\r\n\t\t\t\t\tidIsIndex = match[ 2 ] === ']',\r\n\t\t\t\t\tsubscript = match[ 3 ];\r\n\r\n\t\t\t\tif ( idIsIndex ) id = id | 0; // convert to integer\r\n\r\n\t\t\t\tif ( subscript === undefined ||\r\n\t\t\t\t\t\tsubscript === '[' && matchEnd + 2 === pathLength ) {\r\n\t\t\t\t\t// bare name or \"pure\" bottom-level array \"[0]\" suffix\r\n\r\n\t\t\t\t\taddUniform( container, subscript === undefined ?\r\n\t\t\t\t\t\t\tnew SingleUniform( id, activeInfo, addr ) :\r\n\t\t\t\t\t\t\tnew PureArrayUniform( id, activeInfo, addr ) );\r\n\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// step into inner node / create it in case it doesn't exist\r\n\r\n\t\t\t\t\tvar map = container.map,\r\n\t\t\t\t\t\tnext = map[ id ];\r\n\r\n\t\t\t\t\tif ( next === undefined ) {\r\n\r\n\t\t\t\t\t\tnext = new StructuredUniform( id );\r\n\t\t\t\t\t\taddUniform( container, next );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tcontainer = next;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t},\r\n\r\n\t// Root Container\r\n\r\n\t\tWebGLUniforms = function WebGLUniforms( gl, program, renderer ) {\r\n\r\n\t\t\tUniformContainer.call( this );\r\n\r\n\t\t\tthis.renderer = renderer;\r\n\r\n\t\t\tvar n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );\r\n\r\n\t\t\tfor ( var i = 0; i !== n; ++ i ) {\r\n\r\n\t\t\t\tvar info = gl.getActiveUniform( program, i ),\r\n\t\t\t\t\tpath = info.name,\r\n\t\t\t\t\taddr = gl.getUniformLocation( program, path );\r\n\r\n\t\t\t\tparseUniform( info, addr, this );\r\n\r\n\t\t\t}\r\n\r\n\t\t};\r\n\r\n\r\n\tWebGLUniforms.prototype.setValue = function( gl, name, value ) {\r\n\r\n\t\tvar u = this.map[ name ];\r\n\r\n\t\tif ( u !== undefined ) u.setValue( gl, value, this.renderer );\r\n\r\n\t};\r\n\r\n\tWebGLUniforms.prototype.set = function( gl, object, name ) {\r\n\r\n\t\tvar u = this.map[ name ];\r\n\r\n\t\tif ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );\r\n\r\n\t};\r\n\r\n\tWebGLUniforms.prototype.setOptional = function( gl, object, name ) {\r\n\r\n\t\tvar v = object[ name ];\r\n\r\n\t\tif ( v !== undefined ) this.setValue( gl, name, v );\r\n\r\n\t};\r\n\r\n\r\n\t// Static interface\r\n\r\n\tWebGLUniforms.upload = function( gl, seq, values, renderer ) {\r\n\r\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar u = seq[ i ],\r\n\t\t\t\tv = values[ u.id ];\r\n\r\n\t\t\tif ( v.needsUpdate !== false ) {\r\n\t\t\t\t// note: always updating when .needsUpdate is undefined\r\n\r\n\t\t\t\tu.setValue( gl, v.value, renderer );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\tWebGLUniforms.seqWithValue = function( seq, values ) {\r\n\r\n\t\tvar r = [];\r\n\r\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar u = seq[ i ];\r\n\t\t\tif ( u.id in values ) r.push( u );\r\n\r\n\t\t}\r\n\r\n\t\treturn r;\r\n\r\n\t};\r\n\r\n\tWebGLUniforms.splitDynamic = function( seq, values ) {\r\n\r\n\t\tvar r = null,\r\n\t\t\tn = seq.length,\r\n\t\t\tw = 0;\r\n\r\n\t\tfor ( var i = 0; i !== n; ++ i ) {\r\n\r\n\t\t\tvar u = seq[ i ],\r\n\t\t\t\tv = values[ u.id ];\r\n\r\n\t\t\tif ( v && v.dynamic === true ) {\r\n\r\n\t\t\t\tif ( r === null ) r = [];\r\n\t\t\t\tr.push( u );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// in-place compact 'seq', removing the matches\r\n\t\t\t\tif ( w < i ) seq[ w ] = u;\r\n\t\t\t\t++ w;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tif ( w < n ) seq.length = w;\r\n\r\n\t\treturn r;\r\n\r\n\t};\r\n\r\n\tWebGLUniforms.evalDynamic = function( seq, values, object, camera ) {\r\n\r\n\t\tfor ( var i = 0, n = seq.length; i !== n; ++ i ) {\r\n\r\n\t\t\tvar v = values[ seq[ i ].id ],\r\n\t\t\t\tf = v.onUpdateCallback;\r\n\r\n\t\t\tif ( f !== undefined ) f.call( v, object, camera );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n\treturn WebGLUniforms;\r\n\r\n} )();\r\n\r\n\r\n// File:src/renderers/webgl/plugins/LensFlarePlugin.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.LensFlarePlugin = function ( renderer, flares ) {\r\n\r\n\tvar gl = renderer.context;\r\n\tvar state = renderer.state;\r\n\r\n\tvar vertexBuffer, elementBuffer;\r\n\tvar shader, program, attributes, uniforms;\r\n\r\n\tvar tempTexture, occlusionTexture;\r\n\r\n\tfunction init() {\r\n\r\n\t\tvar vertices = new Float32Array( [\r\n\t\t\t- 1, - 1,  0, 0,\r\n\t\t\t 1, - 1,  1, 0,\r\n\t\t\t 1,  1,  1, 1,\r\n\t\t\t- 1,  1,  0, 1\r\n\t\t] );\r\n\r\n\t\tvar faces = new Uint16Array( [\r\n\t\t\t0, 1, 2,\r\n\t\t\t0, 2, 3\r\n\t\t] );\r\n\r\n\t\t// buffers\r\n\r\n\t\tvertexBuffer     = gl.createBuffer();\r\n\t\telementBuffer    = gl.createBuffer();\r\n\r\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\r\n\r\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\r\n\r\n\t\t// textures\r\n\r\n\t\ttempTexture      = gl.createTexture();\r\n\t\tocclusionTexture = gl.createTexture();\r\n\r\n\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\r\n\r\n\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\r\n\t\tgl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );\r\n\t\tgl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );\r\n\r\n\t\tshader = {\r\n\r\n\t\t\tvertexShader: [\r\n\r\n\t\t\t\t\"uniform lowp int renderType;\",\r\n\r\n\t\t\t\t\"uniform vec3 screenPosition;\",\r\n\t\t\t\t\"uniform vec2 scale;\",\r\n\t\t\t\t\"uniform float rotation;\",\r\n\r\n\t\t\t\t\"uniform sampler2D occlusionMap;\",\r\n\r\n\t\t\t\t\"attribute vec2 position;\",\r\n\t\t\t\t\"attribute vec2 uv;\",\r\n\r\n\t\t\t\t\"varying vec2 vUV;\",\r\n\t\t\t\t\"varying float vVisibility;\",\r\n\r\n\t\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\t\"vUV = uv;\",\r\n\r\n\t\t\t\t\t\"vec2 pos = position;\",\r\n\r\n\t\t\t\t\t\"if ( renderType == 2 ) {\",\r\n\r\n\t\t\t\t\t\t\"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );\",\r\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );\",\r\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );\",\r\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );\",\r\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );\",\r\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );\",\r\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );\",\r\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );\",\r\n\t\t\t\t\t\t\"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );\",\r\n\r\n\t\t\t\t\t\t\"vVisibility =        visibility.r / 9.0;\",\r\n\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.g / 9.0;\",\r\n\t\t\t\t\t\t\"vVisibility *=       visibility.b / 9.0;\",\r\n\t\t\t\t\t\t\"vVisibility *= 1.0 - visibility.a / 9.0;\",\r\n\r\n\t\t\t\t\t\t\"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;\",\r\n\t\t\t\t\t\t\"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\t\"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );\",\r\n\r\n\t\t\t\t\"}\"\r\n\r\n\t\t\t].join( \"\\n\" ),\r\n\r\n\t\t\tfragmentShader: [\r\n\r\n\t\t\t\t\"uniform lowp int renderType;\",\r\n\r\n\t\t\t\t\"uniform sampler2D map;\",\r\n\t\t\t\t\"uniform float opacity;\",\r\n\t\t\t\t\"uniform vec3 color;\",\r\n\r\n\t\t\t\t\"varying vec2 vUV;\",\r\n\t\t\t\t\"varying float vVisibility;\",\r\n\r\n\t\t\t\t\"void main() {\",\r\n\r\n\t\t\t\t\t// pink square\r\n\r\n\t\t\t\t\t\"if ( renderType == 0 ) {\",\r\n\r\n\t\t\t\t\t\t\"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );\",\r\n\r\n\t\t\t\t\t// restore\r\n\r\n\t\t\t\t\t\"} else if ( renderType == 1 ) {\",\r\n\r\n\t\t\t\t\t\t\"gl_FragColor = texture2D( map, vUV );\",\r\n\r\n\t\t\t\t\t// flare\r\n\r\n\t\t\t\t\t\"} else {\",\r\n\r\n\t\t\t\t\t\t\"vec4 texture = texture2D( map, vUV );\",\r\n\t\t\t\t\t\t\"texture.a *= opacity * vVisibility;\",\r\n\t\t\t\t\t\t\"gl_FragColor = texture;\",\r\n\t\t\t\t\t\t\"gl_FragColor.rgb *= color;\",\r\n\r\n\t\t\t\t\t\"}\",\r\n\r\n\t\t\t\t\"}\"\r\n\r\n\t\t\t].join( \"\\n\" )\r\n\r\n\t\t};\r\n\r\n\t\tprogram = createProgram( shader );\r\n\r\n\t\tattributes = {\r\n\t\t\tvertex: gl.getAttribLocation ( program, \"position\" ),\r\n\t\t\tuv:     gl.getAttribLocation ( program, \"uv\" )\r\n\t\t};\r\n\r\n\t\tuniforms = {\r\n\t\t\trenderType:     gl.getUniformLocation( program, \"renderType\" ),\r\n\t\t\tmap:            gl.getUniformLocation( program, \"map\" ),\r\n\t\t\tocclusionMap:   gl.getUniformLocation( program, \"occlusionMap\" ),\r\n\t\t\topacity:        gl.getUniformLocation( program, \"opacity\" ),\r\n\t\t\tcolor:          gl.getUniformLocation( program, \"color\" ),\r\n\t\t\tscale:          gl.getUniformLocation( program, \"scale\" ),\r\n\t\t\trotation:       gl.getUniformLocation( program, \"rotation\" ),\r\n\t\t\tscreenPosition: gl.getUniformLocation( program, \"screenPosition\" )\r\n\t\t};\r\n\r\n\t}\r\n\r\n\t/*\r\n\t * Render lens flares\r\n\t * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,\r\n\t *         reads these back and calculates occlusion.\r\n\t */\r\n\r\n\tthis.render = function ( scene, camera, viewport ) {\r\n\r\n\t\tif ( flares.length === 0 ) return;\r\n\r\n\t\tvar tempPosition = new THREE.Vector3();\r\n\r\n\t\tvar invAspect = viewport.w / viewport.z,\r\n\t\t\thalfViewportWidth = viewport.z * 0.5,\r\n\t\t\thalfViewportHeight = viewport.w * 0.5;\r\n\r\n\t\tvar size = 16 / viewport.w,\r\n\t\t\tscale = new THREE.Vector2( size * invAspect, size );\r\n\r\n\t\tvar screenPosition = new THREE.Vector3( 1, 1, 0 ),\r\n\t\t\tscreenPositionPixels = new THREE.Vector2( 1, 1 );\r\n\r\n\t\tvar validArea = new THREE.Box2();\r\n\r\n\t\tvalidArea.min.set( 0, 0 );\r\n\t\tvalidArea.max.set( viewport.z - 16, viewport.w - 16 );\r\n\r\n\t\tif ( program === undefined ) {\r\n\r\n\t\t\tinit();\r\n\r\n\t\t}\r\n\r\n\t\tgl.useProgram( program );\r\n\r\n\t\tstate.initAttributes();\r\n\t\tstate.enableAttribute( attributes.vertex );\r\n\t\tstate.enableAttribute( attributes.uv );\r\n\t\tstate.disableUnusedAttributes();\r\n\r\n\t\t// loop through all lens flares to update their occlusion and positions\r\n\t\t// setup gl and common used attribs/uniforms\r\n\r\n\t\tgl.uniform1i( uniforms.occlusionMap, 0 );\r\n\t\tgl.uniform1i( uniforms.map, 1 );\r\n\r\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\tgl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );\r\n\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\r\n\r\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\r\n\t\tstate.disable( gl.CULL_FACE );\r\n\t\tstate.setDepthWrite( false );\r\n\r\n\t\tfor ( var i = 0, l = flares.length; i < l; i ++ ) {\r\n\r\n\t\t\tsize = 16 / viewport.w;\r\n\t\t\tscale.set( size * invAspect, size );\r\n\r\n\t\t\t// calc object screen position\r\n\r\n\t\t\tvar flare = flares[ i ];\r\n\r\n\t\t\ttempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );\r\n\r\n\t\t\ttempPosition.applyMatrix4( camera.matrixWorldInverse );\r\n\t\t\ttempPosition.applyProjection( camera.projectionMatrix );\r\n\r\n\t\t\t// setup arrays for gl programs\r\n\r\n\t\t\tscreenPosition.copy( tempPosition );\r\n\r\n\t\t\t// horizontal and vertical coordinate of the lower left corner of the pixels to copy\r\n\r\n\t\t\tscreenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;\r\n\t\t\tscreenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;\r\n\r\n\t\t\t// screen cull\r\n\r\n\t\t\tif ( validArea.containsPoint( screenPositionPixels ) === true ) {\r\n\r\n\t\t\t\t// save current RGB to temp texture\r\n\r\n\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\r\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, null );\r\n\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\r\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\r\n\r\n\r\n\t\t\t\t// render pink quad\r\n\r\n\t\t\t\tgl.uniform1i( uniforms.renderType, 0 );\r\n\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n\r\n\t\t\t\tstate.disable( gl.BLEND );\r\n\t\t\t\tstate.enable( gl.DEPTH_TEST );\r\n\r\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n\r\n\t\t\t\t// copy result to occlusionMap\r\n\r\n\t\t\t\tstate.activeTexture( gl.TEXTURE0 );\r\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, occlusionTexture );\r\n\t\t\t\tgl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );\r\n\r\n\r\n\t\t\t\t// restore graphics\r\n\r\n\t\t\t\tgl.uniform1i( uniforms.renderType, 1 );\r\n\t\t\t\tstate.disable( gl.DEPTH_TEST );\r\n\r\n\t\t\t\tstate.activeTexture( gl.TEXTURE1 );\r\n\t\t\t\tstate.bindTexture( gl.TEXTURE_2D, tempTexture );\r\n\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n\r\n\t\t\t\t// update object positions\r\n\r\n\t\t\t\tflare.positionScreen.copy( screenPosition );\r\n\r\n\t\t\t\tif ( flare.customUpdateCallback ) {\r\n\r\n\t\t\t\t\tflare.customUpdateCallback( flare );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tflare.updateLensFlares();\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// render flares\r\n\r\n\t\t\t\tgl.uniform1i( uniforms.renderType, 2 );\r\n\t\t\t\tstate.enable( gl.BLEND );\r\n\r\n\t\t\t\tfor ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tvar sprite = flare.lensFlares[ j ];\r\n\r\n\t\t\t\t\tif ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {\r\n\r\n\t\t\t\t\t\tscreenPosition.x = sprite.x;\r\n\t\t\t\t\t\tscreenPosition.y = sprite.y;\r\n\t\t\t\t\t\tscreenPosition.z = sprite.z;\r\n\r\n\t\t\t\t\t\tsize = sprite.size * sprite.scale / viewport.w;\r\n\r\n\t\t\t\t\t\tscale.x = size * invAspect;\r\n\t\t\t\t\t\tscale.y = size;\r\n\r\n\t\t\t\t\t\tgl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );\r\n\t\t\t\t\t\tgl.uniform2f( uniforms.scale, scale.x, scale.y );\r\n\t\t\t\t\t\tgl.uniform1f( uniforms.rotation, sprite.rotation );\r\n\r\n\t\t\t\t\t\tgl.uniform1f( uniforms.opacity, sprite.opacity );\r\n\t\t\t\t\t\tgl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );\r\n\r\n\t\t\t\t\t\tstate.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );\r\n\t\t\t\t\t\trenderer.setTexture2D( sprite.texture, 1 );\r\n\r\n\t\t\t\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// restore gl\r\n\r\n\t\tstate.enable( gl.CULL_FACE );\r\n\t\tstate.enable( gl.DEPTH_TEST );\r\n\t\tstate.setDepthWrite( true );\r\n\r\n\t\trenderer.resetGLState();\r\n\r\n\t};\r\n\r\n\tfunction createProgram ( shader ) {\r\n\r\n\t\tvar program = gl.createProgram();\r\n\r\n\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\r\n\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\r\n\r\n\t\tvar prefix = \"precision \" + renderer.getPrecision() + \" float;\\n\";\r\n\r\n\t\tgl.shaderSource( fragmentShader, prefix + shader.fragmentShader );\r\n\t\tgl.shaderSource( vertexShader, prefix + shader.vertexShader );\r\n\r\n\t\tgl.compileShader( fragmentShader );\r\n\t\tgl.compileShader( vertexShader );\r\n\r\n\t\tgl.attachShader( program, fragmentShader );\r\n\t\tgl.attachShader( program, vertexShader );\r\n\r\n\t\tgl.linkProgram( program );\r\n\r\n\t\treturn program;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/renderers/webgl/plugins/SpritePlugin.js\r\n\r\n/**\r\n * @author mikael emtinger / http://gomo.se/\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SpritePlugin = function ( renderer, sprites ) {\r\n\r\n\tvar gl = renderer.context;\r\n\tvar state = renderer.state;\r\n\r\n\tvar vertexBuffer, elementBuffer;\r\n\tvar program, attributes, uniforms;\r\n\r\n\tvar texture;\r\n\r\n\t// decompose matrixWorld\r\n\r\n\tvar spritePosition = new THREE.Vector3();\r\n\tvar spriteRotation = new THREE.Quaternion();\r\n\tvar spriteScale = new THREE.Vector3();\r\n\r\n\tfunction init() {\r\n\r\n\t\tvar vertices = new Float32Array( [\r\n\t\t\t- 0.5, - 0.5,  0, 0,\r\n\t\t\t  0.5, - 0.5,  1, 0,\r\n\t\t\t  0.5,   0.5,  1, 1,\r\n\t\t\t- 0.5,   0.5,  0, 1\r\n\t\t] );\r\n\r\n\t\tvar faces = new Uint16Array( [\r\n\t\t\t0, 1, 2,\r\n\t\t\t0, 2, 3\r\n\t\t] );\r\n\r\n\t\tvertexBuffer  = gl.createBuffer();\r\n\t\telementBuffer = gl.createBuffer();\r\n\r\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\tgl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );\r\n\r\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\t\tgl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );\r\n\r\n\t\tprogram = createProgram();\r\n\r\n\t\tattributes = {\r\n\t\t\tposition:\t\t\tgl.getAttribLocation ( program, 'position' ),\r\n\t\t\tuv:\t\t\t\t\tgl.getAttribLocation ( program, 'uv' )\r\n\t\t};\r\n\r\n\t\tuniforms = {\r\n\t\t\tuvOffset:\t\t\tgl.getUniformLocation( program, 'uvOffset' ),\r\n\t\t\tuvScale:\t\t\tgl.getUniformLocation( program, 'uvScale' ),\r\n\r\n\t\t\trotation:\t\t\tgl.getUniformLocation( program, 'rotation' ),\r\n\t\t\tscale:\t\t\t\tgl.getUniformLocation( program, 'scale' ),\r\n\r\n\t\t\tcolor:\t\t\t\tgl.getUniformLocation( program, 'color' ),\r\n\t\t\tmap:\t\t\t\tgl.getUniformLocation( program, 'map' ),\r\n\t\t\topacity:\t\t\tgl.getUniformLocation( program, 'opacity' ),\r\n\r\n\t\t\tmodelViewMatrix: \tgl.getUniformLocation( program, 'modelViewMatrix' ),\r\n\t\t\tprojectionMatrix:\tgl.getUniformLocation( program, 'projectionMatrix' ),\r\n\r\n\t\t\tfogType:\t\t\tgl.getUniformLocation( program, 'fogType' ),\r\n\t\t\tfogDensity:\t\t\tgl.getUniformLocation( program, 'fogDensity' ),\r\n\t\t\tfogNear:\t\t\tgl.getUniformLocation( program, 'fogNear' ),\r\n\t\t\tfogFar:\t\t\t\tgl.getUniformLocation( program, 'fogFar' ),\r\n\t\t\tfogColor:\t\t\tgl.getUniformLocation( program, 'fogColor' ),\r\n\r\n\t\t\talphaTest:\t\t\tgl.getUniformLocation( program, 'alphaTest' )\r\n\t\t};\r\n\r\n\t\tvar canvas = document.createElement( 'canvas' );\r\n\t\tcanvas.width = 8;\r\n\t\tcanvas.height = 8;\r\n\r\n\t\tvar context = canvas.getContext( '2d' );\r\n\t\tcontext.fillStyle = 'white';\r\n\t\tcontext.fillRect( 0, 0, 8, 8 );\r\n\r\n\t\ttexture = new THREE.Texture( canvas );\r\n\t\ttexture.needsUpdate = true;\r\n\r\n\t}\r\n\r\n\tthis.render = function ( scene, camera ) {\r\n\r\n\t\tif ( sprites.length === 0 ) return;\r\n\r\n\t\t// setup gl\r\n\r\n\t\tif ( program === undefined ) {\r\n\r\n\t\t\tinit();\r\n\r\n\t\t}\r\n\r\n\t\tgl.useProgram( program );\r\n\r\n\t\tstate.initAttributes();\r\n\t\tstate.enableAttribute( attributes.position );\r\n\t\tstate.enableAttribute( attributes.uv );\r\n\t\tstate.disableUnusedAttributes();\r\n\r\n\t\tstate.disable( gl.CULL_FACE );\r\n\t\tstate.enable( gl.BLEND );\r\n\r\n\t\tgl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );\r\n\t\tgl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );\r\n\t\tgl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );\r\n\r\n\t\tgl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );\r\n\r\n\t\tgl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );\r\n\r\n\t\tstate.activeTexture( gl.TEXTURE0 );\r\n\t\tgl.uniform1i( uniforms.map, 0 );\r\n\r\n\t\tvar oldFogType = 0;\r\n\t\tvar sceneFogType = 0;\r\n\t\tvar fog = scene.fog;\r\n\r\n\t\tif ( fog ) {\r\n\r\n\t\t\tgl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );\r\n\r\n\t\t\tif ( fog instanceof THREE.Fog ) {\r\n\r\n\t\t\t\tgl.uniform1f( uniforms.fogNear, fog.near );\r\n\t\t\t\tgl.uniform1f( uniforms.fogFar, fog.far );\r\n\r\n\t\t\t\tgl.uniform1i( uniforms.fogType, 1 );\r\n\t\t\t\toldFogType = 1;\r\n\t\t\t\tsceneFogType = 1;\r\n\r\n\t\t\t} else if ( fog instanceof THREE.FogExp2 ) {\r\n\r\n\t\t\t\tgl.uniform1f( uniforms.fogDensity, fog.density );\r\n\r\n\t\t\t\tgl.uniform1i( uniforms.fogType, 2 );\r\n\t\t\t\toldFogType = 2;\r\n\t\t\t\tsceneFogType = 2;\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tgl.uniform1i( uniforms.fogType, 0 );\r\n\t\t\toldFogType = 0;\r\n\t\t\tsceneFogType = 0;\r\n\r\n\t\t}\r\n\r\n\r\n\t\t// update positions and sort\r\n\r\n\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar sprite = sprites[ i ];\r\n\r\n\t\t\tsprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );\r\n\t\t\tsprite.z = - sprite.modelViewMatrix.elements[ 14 ];\r\n\r\n\t\t}\r\n\r\n\t\tsprites.sort( painterSortStable );\r\n\r\n\t\t// render all sprites\r\n\r\n\t\tvar scale = [];\r\n\r\n\t\tfor ( var i = 0, l = sprites.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar sprite = sprites[ i ];\r\n\t\t\tvar material = sprite.material;\r\n\r\n\t\t\tgl.uniform1f( uniforms.alphaTest, material.alphaTest );\r\n\t\t\tgl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );\r\n\r\n\t\t\tsprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );\r\n\r\n\t\t\tscale[ 0 ] = spriteScale.x;\r\n\t\t\tscale[ 1 ] = spriteScale.y;\r\n\r\n\t\t\tvar fogType = 0;\r\n\r\n\t\t\tif ( scene.fog && material.fog ) {\r\n\r\n\t\t\t\tfogType = sceneFogType;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( oldFogType !== fogType ) {\r\n\r\n\t\t\t\tgl.uniform1i( uniforms.fogType, fogType );\r\n\t\t\t\toldFogType = fogType;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( material.map !== null ) {\r\n\r\n\t\t\t\tgl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );\r\n\t\t\t\tgl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tgl.uniform2f( uniforms.uvOffset, 0, 0 );\r\n\t\t\t\tgl.uniform2f( uniforms.uvScale, 1, 1 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgl.uniform1f( uniforms.opacity, material.opacity );\r\n\t\t\tgl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );\r\n\r\n\t\t\tgl.uniform1f( uniforms.rotation, material.rotation );\r\n\t\t\tgl.uniform2fv( uniforms.scale, scale );\r\n\r\n\t\t\tstate.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );\r\n\t\t\tstate.setDepthTest( material.depthTest );\r\n\t\t\tstate.setDepthWrite( material.depthWrite );\r\n\r\n\t\t\tif ( material.map ) {\r\n\r\n\t\t\t\trenderer.setTexture2D( material.map, 0 );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\trenderer.setTexture2D( texture, 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tgl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );\r\n\r\n\t\t}\r\n\r\n\t\t// restore gl\r\n\r\n\t\tstate.enable( gl.CULL_FACE );\r\n\r\n\t\trenderer.resetGLState();\r\n\r\n\t};\r\n\r\n\tfunction createProgram () {\r\n\r\n\t\tvar program = gl.createProgram();\r\n\r\n\t\tvar vertexShader = gl.createShader( gl.VERTEX_SHADER );\r\n\t\tvar fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );\r\n\r\n\t\tgl.shaderSource( vertexShader, [\r\n\r\n\t\t\t'precision ' + renderer.getPrecision() + ' float;',\r\n\r\n\t\t\t'uniform mat4 modelViewMatrix;',\r\n\t\t\t'uniform mat4 projectionMatrix;',\r\n\t\t\t'uniform float rotation;',\r\n\t\t\t'uniform vec2 scale;',\r\n\t\t\t'uniform vec2 uvOffset;',\r\n\t\t\t'uniform vec2 uvScale;',\r\n\r\n\t\t\t'attribute vec2 position;',\r\n\t\t\t'attribute vec2 uv;',\r\n\r\n\t\t\t'varying vec2 vUV;',\r\n\r\n\t\t\t'void main() {',\r\n\r\n\t\t\t\t'vUV = uvOffset + uv * uvScale;',\r\n\r\n\t\t\t\t'vec2 alignedPosition = position * scale;',\r\n\r\n\t\t\t\t'vec2 rotatedPosition;',\r\n\t\t\t\t'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',\r\n\t\t\t\t'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',\r\n\r\n\t\t\t\t'vec4 finalPosition;',\r\n\r\n\t\t\t\t'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',\r\n\t\t\t\t'finalPosition.xy += rotatedPosition;',\r\n\t\t\t\t'finalPosition = projectionMatrix * finalPosition;',\r\n\r\n\t\t\t\t'gl_Position = finalPosition;',\r\n\r\n\t\t\t'}'\r\n\r\n\t\t].join( '\\n' ) );\r\n\r\n\t\tgl.shaderSource( fragmentShader, [\r\n\r\n\t\t\t'precision ' + renderer.getPrecision() + ' float;',\r\n\r\n\t\t\t'uniform vec3 color;',\r\n\t\t\t'uniform sampler2D map;',\r\n\t\t\t'uniform float opacity;',\r\n\r\n\t\t\t'uniform int fogType;',\r\n\t\t\t'uniform vec3 fogColor;',\r\n\t\t\t'uniform float fogDensity;',\r\n\t\t\t'uniform float fogNear;',\r\n\t\t\t'uniform float fogFar;',\r\n\t\t\t'uniform float alphaTest;',\r\n\r\n\t\t\t'varying vec2 vUV;',\r\n\r\n\t\t\t'void main() {',\r\n\r\n\t\t\t\t'vec4 texture = texture2D( map, vUV );',\r\n\r\n\t\t\t\t'if ( texture.a < alphaTest ) discard;',\r\n\r\n\t\t\t\t'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',\r\n\r\n\t\t\t\t'if ( fogType > 0 ) {',\r\n\r\n\t\t\t\t\t'float depth = gl_FragCoord.z / gl_FragCoord.w;',\r\n\t\t\t\t\t'float fogFactor = 0.0;',\r\n\r\n\t\t\t\t\t'if ( fogType == 1 ) {',\r\n\r\n\t\t\t\t\t\t'fogFactor = smoothstep( fogNear, fogFar, depth );',\r\n\r\n\t\t\t\t\t'} else {',\r\n\r\n\t\t\t\t\t\t'const float LOG2 = 1.442695;',\r\n\t\t\t\t\t\t'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',\r\n\t\t\t\t\t\t'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',\r\n\r\n\t\t\t\t\t'}',\r\n\r\n\t\t\t\t\t'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',\r\n\r\n\t\t\t\t'}',\r\n\r\n\t\t\t'}'\r\n\r\n\t\t].join( '\\n' ) );\r\n\r\n\t\tgl.compileShader( vertexShader );\r\n\t\tgl.compileShader( fragmentShader );\r\n\r\n\t\tgl.attachShader( program, vertexShader );\r\n\t\tgl.attachShader( program, fragmentShader );\r\n\r\n\t\tgl.linkProgram( program );\r\n\r\n\t\treturn program;\r\n\r\n\t}\r\n\r\n\tfunction painterSortStable ( a, b ) {\r\n\t\t\r\n\t\tif ( a.renderOrder !== b.renderOrder ) {\r\n\r\n\t\t\treturn a.renderOrder - b.renderOrder;\r\n\r\n\t\t} else if ( a.z !== b.z ) {\r\n\r\n\t\t\treturn b.z - a.z;\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn b.id - a.id;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/Three.Legacy.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nObject.assign( THREE, {\r\n\tFace4: function ( a, b, c, d, normal, color, materialIndex ) {\r\n\t\tconsole.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );\r\n\t\treturn new THREE.Face3( a, b, c, normal, color, materialIndex );\r\n\t},\r\n\tLineStrip: 0,\r\n\tLinePieces: 1,\r\n\tMeshFaceMaterial: THREE.MultiMaterial,\r\n\tPointCloud: function ( geometry, material ) {\r\n\t\tconsole.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );\r\n\t\treturn new THREE.Points( geometry, material );\r\n\t},\r\n\tParticle: THREE.Sprite,\r\n\tParticleSystem: function ( geometry, material ) {\r\n\t\tconsole.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );\r\n\t\treturn new THREE.Points( geometry, material );\r\n\t},\r\n\tPointCloudMaterial: function ( parameters ) {\r\n\t\tconsole.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );\r\n\t\treturn new THREE.PointsMaterial( parameters );\r\n\t},\r\n\tParticleBasicMaterial: function ( parameters ) {\r\n\t\tconsole.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );\r\n\t\treturn new THREE.PointsMaterial( parameters );\r\n\t},\r\n\tParticleSystemMaterial: function ( parameters ) {\r\n\t\tconsole.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );\r\n\t\treturn new THREE.PointsMaterial( parameters );\r\n\t},\r\n\tVertex: function ( x, y, z ) {\r\n\t\tconsole.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );\r\n\t\treturn new THREE.Vector3( x, y, z );\r\n\t}\r\n} );\r\n\r\n//\r\n\r\nObject.assign( THREE.Box2.prototype, {\r\n\tempty: function () {\r\n\t\tconsole.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );\r\n\t\treturn this.isEmpty();\r\n\t},\r\n\tisIntersectionBox: function ( box ) {\r\n\t\tconsole.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );\r\n\t\treturn this.intersectsBox( box );\r\n\t}\r\n} );\r\n\r\nObject.assign( THREE.Box3.prototype, {\r\n\tempty: function () {\r\n\t\tconsole.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );\r\n\t\treturn this.isEmpty();\r\n\t},\r\n\tisIntersectionBox: function ( box ) {\r\n\t\tconsole.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );\r\n\t\treturn this.intersectsBox( box );\r\n\t},\r\n\tisIntersectionSphere: function ( sphere ) {\r\n\t\tconsole.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\r\n\t\treturn this.intersectsSphere( sphere );\r\n\t}\r\n} );\r\n\r\nObject.assign( THREE.Matrix3.prototype, {\r\n\tmultiplyVector3: function ( vector ) {\r\n\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );\r\n\t\treturn vector.applyMatrix3( this );\r\n\t},\r\n\tmultiplyVector3Array: function ( a ) {\r\n\t\tconsole.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\r\n\t\treturn this.applyToVector3Array( a );\r\n\t}\r\n} );\r\n\r\nObject.assign( THREE.Matrix4.prototype, {\r\n\textractPosition: function ( m ) {\r\n\t\tconsole.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );\r\n\t\treturn this.copyPosition( m );\r\n\t},\r\n\tsetRotationFromQuaternion: function ( q ) {\r\n\t\tconsole.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );\r\n\t\treturn this.makeRotationFromQuaternion( q );\r\n\t},\r\n\tmultiplyVector3: function ( vector ) {\r\n\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );\r\n\t\treturn vector.applyProjection( this );\r\n\t},\r\n\tmultiplyVector4: function ( vector ) {\r\n\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\r\n\t\treturn vector.applyMatrix4( this );\r\n\t},\r\n\tmultiplyVector3Array: function ( a ) {\r\n\t\tconsole.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );\r\n\t\treturn this.applyToVector3Array( a );\r\n\t},\r\n\trotateAxis: function ( v ) {\r\n\t\tconsole.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );\r\n\t\tv.transformDirection( this );\r\n\t},\r\n\tcrossVector: function ( vector ) {\r\n\t\tconsole.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );\r\n\t\treturn vector.applyMatrix4( this );\r\n\t},\r\n\ttranslate: function ( v ) {\r\n\t\tconsole.error( 'THREE.Matrix4: .translate() has been removed.' );\r\n\t},\r\n\trotateX: function ( angle ) {\r\n\t\tconsole.error( 'THREE.Matrix4: .rotateX() has been removed.' );\r\n\t},\r\n\trotateY: function ( angle ) {\r\n\t\tconsole.error( 'THREE.Matrix4: .rotateY() has been removed.' );\r\n\t},\r\n\trotateZ: function ( angle ) {\r\n\t\tconsole.error( 'THREE.Matrix4: .rotateZ() has been removed.' );\r\n\t},\r\n\trotateByAxis: function ( axis, angle ) {\r\n\t\tconsole.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );\r\n\t}\r\n} );\r\n\r\nObject.assign( THREE.Plane.prototype, {\r\n\tisIntersectionLine: function ( line ) {\r\n\t\tconsole.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );\r\n\t\treturn this.intersectsLine( line );\r\n\t}\r\n} );\r\n\r\nObject.assign( THREE.Quaternion.prototype, {\r\n\tmultiplyVector3: function ( vector ) {\r\n\t\tconsole.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );\r\n\t\treturn vector.applyQuaternion( this );\r\n\t}\r\n} );\r\n\r\nObject.assign( THREE.Ray.prototype, {\r\n\tisIntersectionBox: function ( box ) {\r\n\t\tconsole.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );\r\n\t\treturn this.intersectsBox( box );\r\n\t},\r\n\tisIntersectionPlane: function ( plane ) {\r\n\t\tconsole.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );\r\n\t\treturn this.intersectsPlane( plane );\r\n\t},\r\n\tisIntersectionSphere: function ( sphere ) {\r\n\t\tconsole.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );\r\n\t\treturn this.intersectsSphere( sphere );\r\n\t}\r\n} );\r\n\r\nObject.assign( THREE.Vector3.prototype, {\r\n\tsetEulerFromRotationMatrix: function () {\r\n\t\tconsole.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );\r\n\t},\r\n\tsetEulerFromQuaternion: function () {\r\n\t\tconsole.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );\r\n\t},\r\n\tgetPositionFromMatrix: function ( m ) {\r\n\t\tconsole.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );\r\n\t\treturn this.setFromMatrixPosition( m );\r\n\t},\r\n\tgetScaleFromMatrix: function ( m ) {\r\n\t\tconsole.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );\r\n\t\treturn this.setFromMatrixScale( m );\r\n\t},\r\n\tgetColumnFromMatrix: function ( index, matrix ) {\r\n\t\tconsole.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );\r\n\t\treturn this.setFromMatrixColumn( matrix, index );\r\n\t}\r\n} );\r\n\r\n//\r\n\r\nObject.assign( THREE.Object3D.prototype, {\r\n\tgetChildByName: function ( name ) {\r\n\t\tconsole.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );\r\n\t\treturn this.getObjectByName( name );\r\n\t},\r\n\trenderDepth: function ( value ) {\r\n\t\tconsole.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );\r\n\t},\r\n\ttranslate: function ( distance, axis ) {\r\n\t\tconsole.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );\r\n\t\treturn this.translateOnAxis( axis, distance );\r\n\t}\r\n} );\r\n\r\nObject.defineProperties( THREE.Object3D.prototype, {\r\n\teulerOrder: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\r\n\t\t\treturn this.rotation.order;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );\r\n\t\t\tthis.rotation.order = value;\r\n\t\t}\r\n\t},\r\n\tuseQuaternion: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );\r\n\t\t}\r\n\t}\r\n} );\r\n\r\nObject.defineProperties( THREE.LOD.prototype, {\r\n\tobjects: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.LOD: .objects has been renamed to .levels.' );\r\n\t\t\treturn this.levels;\r\n\t\t}\r\n\t}\r\n} );\r\n\r\n//\r\n\r\nTHREE.PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {\r\n\r\n\tconsole.warn( \"THREE.PerspectiveCamera.setLens is deprecated. \" +\r\n\t\t\t\"Use .setFocalLength and .filmGauge for a photographic setup.\" );\r\n\r\n\tif ( filmGauge !== undefined ) this.filmGauge = filmGauge;\r\n\tthis.setFocalLength( focalLength );\r\n\r\n};\r\n\r\n//\r\n\r\nObject.defineProperties( THREE.Light.prototype, {\r\n\tonlyShadow: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .onlyShadow has been removed.' );\r\n\t\t}\r\n\t},\r\n\tshadowCameraFov: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );\r\n\t\t\tthis.shadow.camera.fov = value;\r\n\t\t}\r\n\t},\r\n\tshadowCameraLeft: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );\r\n\t\t\tthis.shadow.camera.left = value;\r\n\t\t}\r\n\t},\r\n\tshadowCameraRight: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );\r\n\t\t\tthis.shadow.camera.right = value;\r\n\t\t}\r\n\t},\r\n\tshadowCameraTop: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );\r\n\t\t\tthis.shadow.camera.top = value;\r\n\t\t}\r\n\t},\r\n\tshadowCameraBottom: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );\r\n\t\t\tthis.shadow.camera.bottom = value;\r\n\t\t}\r\n\t},\r\n\tshadowCameraNear: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );\r\n\t\t\tthis.shadow.camera.near = value;\r\n\t\t}\r\n\t},\r\n\tshadowCameraFar: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );\r\n\t\t\tthis.shadow.camera.far = value;\r\n\t\t}\r\n\t},\r\n\tshadowCameraVisible: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );\r\n\t\t}\r\n\t},\r\n\tshadowBias: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );\r\n\t\t\tthis.shadow.bias = value;\r\n\t\t}\r\n\t},\r\n\tshadowDarkness: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowDarkness has been removed.' );\r\n\t\t}\r\n\t},\r\n\tshadowMapWidth: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );\r\n\t\t\tthis.shadow.mapSize.width = value;\r\n\t\t}\r\n\t},\r\n\tshadowMapHeight: {\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );\r\n\t\t\tthis.shadow.mapSize.height = value;\r\n\t\t}\r\n\t}\r\n} );\r\n\r\n//\r\n\r\nObject.defineProperties( THREE.BufferAttribute.prototype, {\r\n\tlength: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.BufferAttribute: .length has been deprecated. Please use .count.' );\r\n\t\t\treturn this.array.length;\r\n\t\t}\r\n\t}\r\n} );\r\n\r\nObject.assign( THREE.BufferGeometry.prototype, {\r\n\taddIndex: function ( index ) {\r\n\t\tconsole.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );\r\n\t\tthis.setIndex( index );\r\n\t},\r\n\taddDrawCall: function ( start, count, indexOffset ) {\r\n\t\tif ( indexOffset !== undefined ) {\r\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );\r\n\t\t}\r\n\t\tconsole.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );\r\n\t\tthis.addGroup( start, count );\r\n\t},\r\n\tclearDrawCalls: function () {\r\n\t\tconsole.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );\r\n\t\tthis.clearGroups();\r\n\t},\r\n\tcomputeTangents: function () {\r\n\t\tconsole.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );\r\n\t},\r\n\tcomputeOffsets: function () {\r\n\t\tconsole.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );\r\n\t}\r\n} );\r\n\r\nObject.defineProperties( THREE.BufferGeometry.prototype, {\r\n\tdrawcalls: {\r\n\t\tget: function () {\r\n\t\t\tconsole.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );\r\n\t\t\treturn this.groups;\r\n\t\t}\r\n\t},\r\n\toffsets: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );\r\n\t\t\treturn this.groups;\r\n\t\t}\r\n\t}\r\n} );\r\n\r\n//\r\n\r\nObject.defineProperties( THREE.Material.prototype, {\r\n\twrapAround: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );\r\n\t\t}\r\n\t},\r\n\twrapRGB: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );\r\n\t\t\treturn new THREE.Color();\r\n\t\t}\r\n\t}\r\n} );\r\n\r\nObject.defineProperties( THREE.MeshPhongMaterial.prototype, {\r\n\tmetal: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );\r\n\t\t\treturn false;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );\r\n\t\t}\r\n\t}\r\n} );\r\n\r\nObject.defineProperties( THREE.ShaderMaterial.prototype, {\r\n\tderivatives: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\r\n\t\t\treturn this.extensions.derivatives;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );\r\n\t\t\tthis.extensions.derivatives = value;\r\n\t\t}\r\n\t}\r\n} );\r\n\r\n//\r\n\r\nTHREE.EventDispatcher.prototype = Object.assign( Object.create( {\r\n\r\n\t// Note: Extra base ensures these properties are not 'assign'ed.\r\n\r\n\tconstructor: THREE.EventDispatcher,\r\n\r\n\tapply: function ( target ) {\r\n\r\n\t\tconsole.warn( \"THREE.EventDispatcher: .apply is deprecated, \" +\r\n\t\t\t\t\"just inherit or Object.assign the prototype to mix-in.\" );\r\n\r\n\t\tObject.assign( target, this );\r\n\r\n\t}\r\n\r\n} ), THREE.EventDispatcher.prototype );\r\n\r\n//\r\n\r\nObject.assign( THREE.WebGLRenderer.prototype, {\r\n\tsupportsFloatTextures: function () {\r\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \\'OES_texture_float\\' ).' );\r\n\t\treturn this.extensions.get( 'OES_texture_float' );\r\n\t},\r\n\tsupportsHalfFloatTextures: function () {\r\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \\'OES_texture_half_float\\' ).' );\r\n\t\treturn this.extensions.get( 'OES_texture_half_float' );\r\n\t},\r\n\tsupportsStandardDerivatives: function () {\r\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \\'OES_standard_derivatives\\' ).' );\r\n\t\treturn this.extensions.get( 'OES_standard_derivatives' );\r\n\t},\r\n\tsupportsCompressedTextureS3TC: function () {\r\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \\'WEBGL_compressed_texture_s3tc\\' ).' );\r\n\t\treturn this.extensions.get( 'WEBGL_compressed_texture_s3tc' );\r\n\t},\r\n\tsupportsCompressedTexturePVRTC: function () {\r\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \\'WEBGL_compressed_texture_pvrtc\\' ).' );\r\n\t\treturn this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );\r\n\t},\r\n\tsupportsBlendMinMax: function () {\r\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \\'EXT_blend_minmax\\' ).' );\r\n\t\treturn this.extensions.get( 'EXT_blend_minmax' );\r\n\t},\r\n\tsupportsVertexTextures: function () {\r\n\t\treturn this.capabilities.vertexTextures;\r\n\t},\r\n\tsupportsInstancedArrays: function () {\r\n\t\tconsole.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \\'ANGLE_instanced_arrays\\' ).' );\r\n\t\treturn this.extensions.get( 'ANGLE_instanced_arrays' );\r\n\t},\r\n\tenableScissorTest: function ( boolean ) {\r\n\t\tconsole.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );\r\n\t\tthis.setScissorTest( boolean );\r\n\t},\r\n\tinitMaterial: function () {\r\n\t\tconsole.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );\r\n\t},\r\n\taddPrePlugin: function () {\r\n\t\tconsole.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );\r\n\t},\r\n\taddPostPlugin: function () {\r\n\t\tconsole.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );\r\n\t},\r\n\tupdateShadowMap: function () {\r\n\t\tconsole.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );\r\n\t}\r\n} );\r\n\r\nObject.defineProperties( THREE.WebGLRenderer.prototype, {\r\n\tshadowMapEnabled: {\r\n\t\tget: function () {\r\n\t\t\treturn this.shadowMap.enabled;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );\r\n\t\t\tthis.shadowMap.enabled = value;\r\n\t\t}\r\n\t},\r\n\tshadowMapType: {\r\n\t\tget: function () {\r\n\t\t\treturn this.shadowMap.type;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );\r\n\t\t\tthis.shadowMap.type = value;\r\n\t\t}\r\n\t},\r\n\tshadowMapCullFace: {\r\n\t\tget: function () {\r\n\t\t\treturn this.shadowMap.cullFace;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );\r\n\t\t\tthis.shadowMap.cullFace = value;\r\n\t\t}\r\n\t}\r\n} );\r\n\r\nObject.defineProperties( THREE.WebGLShadowMap.prototype, {\r\n\tcullFace: {\r\n\t\tget: function () {\r\n\t\t\treturn this.renderReverseSided ? THREE.CullFaceFront : THREE.CullFaceBack;\r\n\t\t},\r\n\t\tset: function ( cullFace ) {\r\n\t\t\tvar value = ( cullFace !== THREE.CullFaceBack );\r\n\t\t\tconsole.warn( \"WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to \" + value + \".\" );\r\n\t\t\tthis.renderReverseSided = value;\r\n\t\t}\r\n\t}\r\n} );\r\n\r\n//\r\n\r\nObject.defineProperties( THREE.WebGLRenderTarget.prototype, {\r\n\twrapS: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\r\n\t\t\treturn this.texture.wrapS;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );\r\n\t\t\tthis.texture.wrapS = value;\r\n\t\t}\r\n\t},\r\n\twrapT: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\r\n\t\t\treturn this.texture.wrapT;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );\r\n\t\t\tthis.texture.wrapT = value;\r\n\t\t}\r\n\t},\r\n\tmagFilter: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\r\n\t\t\treturn this.texture.magFilter;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );\r\n\t\t\tthis.texture.magFilter = value;\r\n\t\t}\r\n\t},\r\n\tminFilter: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\r\n\t\t\treturn this.texture.minFilter;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );\r\n\t\t\tthis.texture.minFilter = value;\r\n\t\t}\r\n\t},\r\n\tanisotropy: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\r\n\t\t\treturn this.texture.anisotropy;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );\r\n\t\t\tthis.texture.anisotropy = value;\r\n\t\t}\r\n\t},\r\n\toffset: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\r\n\t\t\treturn this.texture.offset;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );\r\n\t\t\tthis.texture.offset = value;\r\n\t\t}\r\n\t},\r\n\trepeat: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\r\n\t\t\treturn this.texture.repeat;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );\r\n\t\t\tthis.texture.repeat = value;\r\n\t\t}\r\n\t},\r\n\tformat: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\r\n\t\t\treturn this.texture.format;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );\r\n\t\t\tthis.texture.format = value;\r\n\t\t}\r\n\t},\r\n\ttype: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\r\n\t\t\treturn this.texture.type;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );\r\n\t\t\tthis.texture.type = value;\r\n\t\t}\r\n\t},\r\n\tgenerateMipmaps: {\r\n\t\tget: function () {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\r\n\t\t\treturn this.texture.generateMipmaps;\r\n\t\t},\r\n\t\tset: function ( value ) {\r\n\t\t\tconsole.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );\r\n\t\t\tthis.texture.generateMipmaps = value;\r\n\t\t}\r\n\t}\r\n} );\r\n\r\n//\r\n\r\nObject.assign( THREE.Audio.prototype, {\r\n\tload: function ( file ) {\r\n\t\tconsole.warn( 'THREE.Audio: .load has been deprecated. Please use THREE.AudioLoader.' );\r\n\t\tvar scope = this;\r\n\t\tvar audioLoader = new THREE.AudioLoader();\r\n\t\taudioLoader.load( file, function ( buffer ) {\r\n\t\t\tscope.setBuffer( buffer );\r\n\t\t} );\r\n\t\treturn this;\r\n\t}\r\n} );\r\n\r\nObject.assign( THREE.AudioAnalyser.prototype, {\r\n\tgetData: function ( file ) {\r\n\t\tconsole.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );\r\n\t\treturn this.getFrequencyData();\r\n\t}\r\n} );\r\n\r\n//\r\n\r\nTHREE.GeometryUtils = {\r\n\r\n\tmerge: function ( geometry1, geometry2, materialIndexOffset ) {\r\n\r\n\t\tconsole.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );\r\n\r\n\t\tvar matrix;\r\n\r\n\t\tif ( geometry2 instanceof THREE.Mesh ) {\r\n\r\n\t\t\tgeometry2.matrixAutoUpdate && geometry2.updateMatrix();\r\n\r\n\t\t\tmatrix = geometry2.matrix;\r\n\t\t\tgeometry2 = geometry2.geometry;\r\n\r\n\t\t}\r\n\r\n\t\tgeometry1.merge( geometry2, matrix, materialIndexOffset );\r\n\r\n\t},\r\n\r\n\tcenter: function ( geometry ) {\r\n\r\n\t\tconsole.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );\r\n\t\treturn geometry.center();\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.ImageUtils = {\r\n\r\n\tcrossOrigin: undefined,\r\n\r\n\tloadTexture: function ( url, mapping, onLoad, onError ) {\r\n\r\n\t\tconsole.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );\r\n\r\n\t\tvar loader = new THREE.TextureLoader();\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\r\n\t\tvar texture = loader.load( url, onLoad, undefined, onError );\r\n\r\n\t\tif ( mapping ) texture.mapping = mapping;\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tloadTextureCube: function ( urls, mapping, onLoad, onError ) {\r\n\r\n\t\tconsole.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );\r\n\r\n\t\tvar loader = new THREE.CubeTextureLoader();\r\n\t\tloader.setCrossOrigin( this.crossOrigin );\r\n\r\n\t\tvar texture = loader.load( urls, onLoad, undefined, onError );\r\n\r\n\t\tif ( mapping ) texture.mapping = mapping;\r\n\r\n\t\treturn texture;\r\n\r\n\t},\r\n\r\n\tloadCompressedTexture: function () {\r\n\r\n\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );\r\n\r\n\t},\r\n\r\n\tloadCompressedTextureCube: function () {\r\n\r\n\t\tconsole.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );\r\n\r\n\t}\r\n\r\n};\r\n\r\n//\r\n\r\nTHREE.Projector = function () {\r\n\r\n\tconsole.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );\r\n\r\n\tthis.projectVector = function ( vector, camera ) {\r\n\r\n\t\tconsole.warn( 'THREE.Projector: .projectVector() is now vector.project().' );\r\n\t\tvector.project( camera );\r\n\r\n\t};\r\n\r\n\tthis.unprojectVector = function ( vector, camera ) {\r\n\r\n\t\tconsole.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );\r\n\t\tvector.unproject( camera );\r\n\r\n\t};\r\n\r\n\tthis.pickingRay = function ( vector, camera ) {\r\n\r\n\t\tconsole.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );\r\n\r\n\t};\r\n\r\n};\r\n\r\n//\r\n\r\nTHREE.CanvasRenderer = function () {\r\n\r\n\tconsole.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );\r\n\r\n\tthis.domElement = document.createElement( 'canvas' );\r\n\tthis.clear = function () {};\r\n\tthis.render = function () {};\r\n\tthis.setClearColor = function () {};\r\n\tthis.setSize = function () {};\r\n\r\n};\r\n\r\n// File:src/extras/CurveUtils.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\nTHREE.CurveUtils = {\r\n\r\n\ttangentQuadraticBezier: function ( t, p0, p1, p2 ) {\r\n\r\n\t\treturn 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );\r\n\r\n\t},\r\n\r\n\t// Puay Bing, thanks for helping with this derivative!\r\n\r\n\ttangentCubicBezier: function ( t, p0, p1, p2, p3 ) {\r\n\r\n\t\treturn - 3 * p0 * ( 1 - t ) * ( 1 - t )  +\r\n\t\t\t3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +\r\n\t\t\t6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +\r\n\t\t\t3 * t * t * p3;\r\n\r\n\t},\r\n\r\n\ttangentSpline: function ( t, p0, p1, p2, p3 ) {\r\n\r\n\t\t// To check if my formulas are correct\r\n\r\n\t\tvar h00 = 6 * t * t - 6 * t; \t// derived from 2t^3 − 3t^2 + 1\r\n\t\tvar h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t\r\n\t\tvar h01 = - 6 * t * t + 6 * t; \t// − 2t3 + 3t2\r\n\t\tvar h11 = 3 * t * t - 2 * t;\t// t3 − t2\r\n\r\n\t\treturn h00 + h10 + h01 + h11;\r\n\r\n\t},\r\n\r\n\t// Catmull-Rom\r\n\r\n\tinterpolate: function( p0, p1, p2, p3, t ) {\r\n\r\n\t\tvar v0 = ( p2 - p0 ) * 0.5;\r\n\t\tvar v1 = ( p3 - p1 ) * 0.5;\r\n\t\tvar t2 = t * t;\r\n\t\tvar t3 = t * t2;\r\n\t\treturn ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/extras/SceneUtils.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.SceneUtils = {\r\n\r\n\tcreateMultiMaterialObject: function ( geometry, materials ) {\r\n\r\n\t\tvar group = new THREE.Group();\r\n\r\n\t\tfor ( var i = 0, l = materials.length; i < l; i ++ ) {\r\n\r\n\t\t\tgroup.add( new THREE.Mesh( geometry, materials[ i ] ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn group;\r\n\r\n\t},\r\n\r\n\tdetach: function ( child, parent, scene ) {\r\n\r\n\t\tchild.applyMatrix( parent.matrixWorld );\r\n\t\tparent.remove( child );\r\n\t\tscene.add( child );\r\n\r\n\t},\r\n\r\n\tattach: function ( child, scene, parent ) {\r\n\r\n\t\tvar matrixWorldInverse = new THREE.Matrix4();\r\n\t\tmatrixWorldInverse.getInverse( parent.matrixWorld );\r\n\t\tchild.applyMatrix( matrixWorldInverse );\r\n\r\n\t\tscene.remove( child );\r\n\t\tparent.add( child );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/extras/ShapeUtils.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n */\r\n\r\nTHREE.ShapeUtils = {\r\n\r\n\t// calculate area of the contour polygon\r\n\r\n\tarea: function ( contour ) {\r\n\r\n\t\tvar n = contour.length;\r\n\t\tvar a = 0.0;\r\n\r\n\t\tfor ( var p = n - 1, q = 0; q < n; p = q ++ ) {\r\n\r\n\t\t\ta += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;\r\n\r\n\t\t}\r\n\r\n\t\treturn a * 0.5;\r\n\r\n\t},\r\n\r\n\ttriangulate: ( function () {\r\n\r\n\t\t/**\r\n\t\t * This code is a quick port of code written in C++ which was submitted to\r\n\t\t * flipcode.com by John W. Ratcliff  // July 22, 2000\r\n\t\t * See original code and more information here:\r\n\t\t * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml\r\n\t\t *\r\n\t\t * ported to actionscript by Zevan Rosser\r\n\t\t * www.actionsnippet.com\r\n\t\t *\r\n\t\t * ported to javascript by Joshua Koo\r\n\t\t * http://www.lab4games.net/zz85/blog\r\n\t\t *\r\n\t\t */\r\n\r\n\t\tfunction snip( contour, u, v, w, n, verts ) {\r\n\r\n\t\t\tvar p;\r\n\t\t\tvar ax, ay, bx, by;\r\n\t\t\tvar cx, cy, px, py;\r\n\r\n\t\t\tax = contour[ verts[ u ] ].x;\r\n\t\t\tay = contour[ verts[ u ] ].y;\r\n\r\n\t\t\tbx = contour[ verts[ v ] ].x;\r\n\t\t\tby = contour[ verts[ v ] ].y;\r\n\r\n\t\t\tcx = contour[ verts[ w ] ].x;\r\n\t\t\tcy = contour[ verts[ w ] ].y;\r\n\r\n\t\t\tif ( Number.EPSILON > ( ( ( bx - ax ) * ( cy - ay ) ) - ( ( by - ay ) * ( cx - ax ) ) ) ) return false;\r\n\r\n\t\t\tvar aX, aY, bX, bY, cX, cY;\r\n\t\t\tvar apx, apy, bpx, bpy, cpx, cpy;\r\n\t\t\tvar cCROSSap, bCROSScp, aCROSSbp;\r\n\r\n\t\t\taX = cx - bx;  aY = cy - by;\r\n\t\t\tbX = ax - cx;  bY = ay - cy;\r\n\t\t\tcX = bx - ax;  cY = by - ay;\r\n\r\n\t\t\tfor ( p = 0; p < n; p ++ ) {\r\n\r\n\t\t\t\tpx = contour[ verts[ p ] ].x;\r\n\t\t\t\tpy = contour[ verts[ p ] ].y;\r\n\r\n\t\t\t\tif ( ( ( px === ax ) && ( py === ay ) ) ||\r\n\t\t\t\t\t ( ( px === bx ) && ( py === by ) ) ||\r\n\t\t\t\t\t ( ( px === cx ) && ( py === cy ) ) )\tcontinue;\r\n\r\n\t\t\t\tapx = px - ax;  apy = py - ay;\r\n\t\t\t\tbpx = px - bx;  bpy = py - by;\r\n\t\t\t\tcpx = px - cx;  cpy = py - cy;\r\n\r\n\t\t\t\t// see if p is inside triangle abc\r\n\r\n\t\t\t\taCROSSbp = aX * bpy - aY * bpx;\r\n\t\t\t\tcCROSSap = cX * apy - cY * apx;\r\n\t\t\t\tbCROSScp = bX * cpy - bY * cpx;\r\n\r\n\t\t\t\tif ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\r\n\t\t}\r\n\r\n\t\t// takes in an contour array and returns\r\n\r\n\t\treturn function ( contour, indices ) {\r\n\r\n\t\t\tvar n = contour.length;\r\n\r\n\t\t\tif ( n < 3 ) return null;\r\n\r\n\t\t\tvar result = [],\r\n\t\t\t\tverts = [],\r\n\t\t\t\tvertIndices = [];\r\n\r\n\t\t\t/* we want a counter-clockwise polygon in verts */\r\n\r\n\t\t\tvar u, v, w;\r\n\r\n\t\t\tif ( THREE.ShapeUtils.area( contour ) > 0.0 ) {\r\n\r\n\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = v;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tfor ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar nv = n;\r\n\r\n\t\t\t/*  remove nv - 2 vertices, creating 1 triangle every time */\r\n\r\n\t\t\tvar count = 2 * nv;   /* error detection */\r\n\r\n\t\t\tfor ( v = nv - 1; nv > 2; ) {\r\n\r\n\t\t\t\t/* if we loop, it is probably a non-simple polygon */\r\n\r\n\t\t\t\tif ( ( count -- ) <= 0 ) {\r\n\r\n\t\t\t\t\t//** Triangulate: ERROR - probable bad polygon!\r\n\r\n\t\t\t\t\t//throw ( \"Warning, unable to triangulate polygon!\" );\r\n\t\t\t\t\t//return null;\r\n\t\t\t\t\t// Sometimes warning is fine, especially polygons are triangulated in reverse.\r\n\t\t\t\t\tconsole.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );\r\n\r\n\t\t\t\t\tif ( indices ) return vertIndices;\r\n\t\t\t\t\treturn result;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t/* three consecutive vertices in current polygon, <u,v,w> */\r\n\r\n\t\t\t\tu = v; \t \tif ( nv <= u ) u = 0;     /* previous */\r\n\t\t\t\tv = u + 1;  if ( nv <= v ) v = 0;     /* new v    */\r\n\t\t\t\tw = v + 1;  if ( nv <= w ) w = 0;     /* next     */\r\n\r\n\t\t\t\tif ( snip( contour, u, v, w, nv, verts ) ) {\r\n\r\n\t\t\t\t\tvar a, b, c, s, t;\r\n\r\n\t\t\t\t\t/* true names of the vertices */\r\n\r\n\t\t\t\t\ta = verts[ u ];\r\n\t\t\t\t\tb = verts[ v ];\r\n\t\t\t\t\tc = verts[ w ];\r\n\r\n\t\t\t\t\t/* output Triangle */\r\n\r\n\t\t\t\t\tresult.push( [ contour[ a ],\r\n\t\t\t\t\t\tcontour[ b ],\r\n\t\t\t\t\t\tcontour[ c ] ] );\r\n\r\n\r\n\t\t\t\t\tvertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );\r\n\r\n\t\t\t\t\t/* remove v from the remaining polygon */\r\n\r\n\t\t\t\t\tfor ( s = v, t = v + 1; t < nv; s ++, t ++ ) {\r\n\r\n\t\t\t\t\t\tverts[ s ] = verts[ t ];\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tnv --;\r\n\r\n\t\t\t\t\t/* reset error detection counter */\r\n\r\n\t\t\t\t\tcount = 2 * nv;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( indices ) return vertIndices;\r\n\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t} )(),\r\n\r\n\ttriangulateShape: function ( contour, holes ) {\r\n\r\n\t\tfunction point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {\r\n\r\n\t\t\t// inOtherPt needs to be collinear to the inSegment\r\n\t\t\tif ( inSegPt1.x !== inSegPt2.x ) {\r\n\r\n\t\t\t\tif ( inSegPt1.x < inSegPt2.x ) {\r\n\r\n\t\t\t\t\treturn\t( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\treturn\t( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( inSegPt1.y < inSegPt2.y ) {\r\n\r\n\t\t\t\t\treturn\t( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\treturn\t( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {\r\n\r\n\t\t\tvar seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;\r\n\t\t\tvar seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;\r\n\r\n\t\t\tvar seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;\r\n\t\t\tvar seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;\r\n\r\n\t\t\tvar limit\t\t= seg1dy * seg2dx - seg1dx * seg2dy;\r\n\t\t\tvar perpSeg1\t= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;\r\n\r\n\t\t\tif ( Math.abs( limit ) > Number.EPSILON ) {\r\n\r\n\t\t\t\t// not parallel\r\n\r\n\t\t\t\tvar perpSeg2;\r\n\t\t\t\tif ( limit > 0 ) {\r\n\r\n\t\t\t\t\tif ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) \t\treturn [];\r\n\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\r\n\t\t\t\t\tif ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) \t\treturn [];\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) \t\treturn [];\r\n\t\t\t\t\tperpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;\r\n\t\t\t\t\tif ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) \t\treturn [];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// i.e. to reduce rounding errors\r\n\t\t\t\t// intersection at endpoint of segment#1?\r\n\t\t\t\tif ( perpSeg2 === 0 ) {\r\n\r\n\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\r\n\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\r\n\t\t\t\t\treturn [ inSeg1Pt1 ];\r\n\r\n\t\t\t\t}\r\n\t\t\t\tif ( perpSeg2 === limit ) {\r\n\r\n\t\t\t\t\tif ( ( inExcludeAdjacentSegs ) &&\r\n\t\t\t\t\t\t ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )\t\treturn [];\r\n\t\t\t\t\treturn [ inSeg1Pt2 ];\r\n\r\n\t\t\t\t}\r\n\t\t\t\t// intersection at endpoint of segment#2?\r\n\t\t\t\tif ( perpSeg1 === 0 )\t\treturn [ inSeg2Pt1 ];\r\n\t\t\t\tif ( perpSeg1 === limit )\treturn [ inSeg2Pt2 ];\r\n\r\n\t\t\t\t// return real intersection point\r\n\t\t\t\tvar factorSeg1 = perpSeg2 / limit;\r\n\t\t\t\treturn\t[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,\r\n\t\t\t\t\t\t\ty: inSeg1Pt1.y + factorSeg1 * seg1dy } ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// parallel or collinear\r\n\t\t\t\tif ( ( perpSeg1 !== 0 ) ||\r\n\t\t\t\t\t ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) \t\t\treturn [];\r\n\r\n\t\t\t\t// they are collinear or degenerate\r\n\t\t\t\tvar seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );\t// segment1 is just a point?\r\n\t\t\t\tvar seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );\t// segment2 is just a point?\r\n\t\t\t\t// both segments are points\r\n\t\t\t\tif ( seg1Pt && seg2Pt ) {\r\n\r\n\t\t\t\t\tif ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||\r\n\t\t\t\t\t\t ( inSeg1Pt1.y !== inSeg2Pt1.y ) )\t\treturn [];\t// they are distinct  points\r\n\t\t\t\t\treturn [ inSeg1Pt1 ];                 \t\t\t\t\t\t// they are the same point\r\n\r\n\t\t\t\t}\r\n\t\t\t\t// segment#1  is a single point\r\n\t\t\t\tif ( seg1Pt ) {\r\n\r\n\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )\t\treturn [];\t\t// but not in segment#2\r\n\t\t\t\t\treturn [ inSeg1Pt1 ];\r\n\r\n\t\t\t\t}\r\n\t\t\t\t// segment#2  is a single point\r\n\t\t\t\tif ( seg2Pt ) {\r\n\r\n\t\t\t\t\tif ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )\t\treturn [];\t\t// but not in segment#1\r\n\t\t\t\t\treturn [ inSeg2Pt1 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// they are collinear segments, which might overlap\r\n\t\t\t\tvar seg1min, seg1max, seg1minVal, seg1maxVal;\r\n\t\t\t\tvar seg2min, seg2max, seg2minVal, seg2maxVal;\r\n\t\t\t\tif ( seg1dx !== 0 ) {\r\n\r\n\t\t\t\t\t// the segments are NOT on a vertical line\r\n\t\t\t\t\tif ( inSeg1Pt1.x < inSeg1Pt2.x ) {\r\n\r\n\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;\r\n\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;\r\n\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( inSeg2Pt1.x < inSeg2Pt2.x ) {\r\n\r\n\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;\r\n\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;\r\n\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// the segments are on a vertical line\r\n\t\t\t\t\tif ( inSeg1Pt1.y < inSeg1Pt2.y ) {\r\n\r\n\t\t\t\t\t\tseg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;\r\n\t\t\t\t\t\tseg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tseg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;\r\n\t\t\t\t\t\tseg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( inSeg2Pt1.y < inSeg2Pt2.y ) {\r\n\r\n\t\t\t\t\t\tseg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;\r\n\t\t\t\t\t\tseg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tseg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;\r\n\t\t\t\t\t\tseg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t\tif ( seg1minVal <= seg2minVal ) {\r\n\r\n\t\t\t\t\tif ( seg1maxVal <  seg2minVal )\treturn [];\r\n\t\t\t\t\tif ( seg1maxVal === seg2minVal )\t{\r\n\r\n\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\r\n\t\t\t\t\t\treturn [ seg2min ];\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg2min, seg1max ];\r\n\t\t\t\t\treturn\t[ seg2min, seg2max ];\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( seg1minVal >  seg2maxVal )\treturn [];\r\n\t\t\t\t\tif ( seg1minVal === seg2maxVal )\t{\r\n\r\n\t\t\t\t\t\tif ( inExcludeAdjacentSegs )\t\treturn [];\r\n\t\t\t\t\t\treturn [ seg1min ];\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( seg1maxVal <= seg2maxVal )\treturn [ seg1min, seg1max ];\r\n\t\t\t\t\treturn\t[ seg1min, seg2max ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tfunction isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {\r\n\r\n\t\t\t// The order of legs is important\r\n\r\n\t\t\t// translation of all points, so that Vertex is at (0,0)\r\n\t\t\tvar legFromPtX\t= inLegFromPt.x - inVertex.x,  legFromPtY\t= inLegFromPt.y - inVertex.y;\r\n\t\t\tvar legToPtX\t= inLegToPt.x\t- inVertex.x,  legToPtY\t\t= inLegToPt.y\t- inVertex.y;\r\n\t\t\tvar otherPtX\t= inOtherPt.x\t- inVertex.x,  otherPtY\t\t= inOtherPt.y\t- inVertex.y;\r\n\r\n\t\t\t// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.\r\n\t\t\tvar from2toAngle\t= legFromPtX * legToPtY - legFromPtY * legToPtX;\r\n\t\t\tvar from2otherAngle\t= legFromPtX * otherPtY - legFromPtY * otherPtX;\r\n\r\n\t\t\tif ( Math.abs( from2toAngle ) > Number.EPSILON ) {\r\n\r\n\t\t\t\t// angle != 180 deg.\r\n\r\n\t\t\t\tvar other2toAngle\t\t= otherPtX * legToPtY - otherPtY * legToPtX;\r\n\t\t\t\t// console.log( \"from2to: \" + from2toAngle + \", from2other: \" + from2otherAngle + \", other2to: \" + other2toAngle );\r\n\r\n\t\t\t\tif ( from2toAngle > 0 ) {\r\n\r\n\t\t\t\t\t// main angle < 180 deg.\r\n\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// main angle > 180 deg.\r\n\t\t\t\t\treturn\t( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// angle == 180 deg.\r\n\t\t\t\t// console.log( \"from2to: 180 deg., from2other: \" + from2otherAngle  );\r\n\t\t\t\treturn\t( from2otherAngle > 0 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\tfunction removeHoles( contour, holes ) {\r\n\r\n\t\t\tvar shape = contour.concat(); // work on this shape\r\n\t\t\tvar hole;\r\n\r\n\t\t\tfunction isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {\r\n\r\n\t\t\t\t// Check if hole point lies within angle around shape point\r\n\t\t\t\tvar lastShapeIdx = shape.length - 1;\r\n\r\n\t\t\t\tvar prevShapeIdx = inShapeIdx - 1;\r\n\t\t\t\tif ( prevShapeIdx < 0 )\t\t\tprevShapeIdx = lastShapeIdx;\r\n\r\n\t\t\t\tvar nextShapeIdx = inShapeIdx + 1;\r\n\t\t\t\tif ( nextShapeIdx > lastShapeIdx )\tnextShapeIdx = 0;\r\n\r\n\t\t\t\tvar insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );\r\n\t\t\t\tif ( ! insideAngle ) {\r\n\r\n\t\t\t\t\t// console.log( \"Vertex (Shape): \" + inShapeIdx + \", Point: \" + hole[inHoleIdx].x + \"/\" + hole[inHoleIdx].y );\r\n\t\t\t\t\treturn\tfalse;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Check if shape point lies within angle around hole point\r\n\t\t\t\tvar lastHoleIdx = hole.length - 1;\r\n\r\n\t\t\t\tvar prevHoleIdx = inHoleIdx - 1;\r\n\t\t\t\tif ( prevHoleIdx < 0 )\t\t\tprevHoleIdx = lastHoleIdx;\r\n\r\n\t\t\t\tvar nextHoleIdx = inHoleIdx + 1;\r\n\t\t\t\tif ( nextHoleIdx > lastHoleIdx )\tnextHoleIdx = 0;\r\n\r\n\t\t\t\tinsideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );\r\n\t\t\t\tif ( ! insideAngle ) {\r\n\r\n\t\t\t\t\t// console.log( \"Vertex (Hole): \" + inHoleIdx + \", Point: \" + shape[inShapeIdx].x + \"/\" + shape[inShapeIdx].y );\r\n\t\t\t\t\treturn\tfalse;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn\ttrue;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfunction intersectsShapeEdge( inShapePt, inHolePt ) {\r\n\r\n\t\t\t\t// checks for intersections with shape edges\r\n\t\t\t\tvar sIdx, nextIdx, intersection;\r\n\t\t\t\tfor ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {\r\n\r\n\t\t\t\t\tnextIdx = sIdx + 1; nextIdx %= shape.length;\r\n\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );\r\n\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn\tfalse;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar indepHoles = [];\r\n\r\n\t\t\tfunction intersectsHoleEdge( inShapePt, inHolePt ) {\r\n\r\n\t\t\t\t// checks for intersections with hole edges\r\n\t\t\t\tvar ihIdx, chkHole,\r\n\t\t\t\t\thIdx, nextIdx, intersection;\r\n\t\t\t\tfor ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {\r\n\r\n\t\t\t\t\tchkHole = holes[ indepHoles[ ihIdx ]];\r\n\t\t\t\t\tfor ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {\r\n\r\n\t\t\t\t\t\tnextIdx = hIdx + 1; nextIdx %= chkHole.length;\r\n\t\t\t\t\t\tintersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );\r\n\t\t\t\t\t\tif ( intersection.length > 0 )\t\treturn\ttrue;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\t\t\t\treturn\tfalse;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar holeIndex, shapeIndex,\r\n\t\t\t\tshapePt, holePt,\r\n\t\t\t\tholeIdx, cutKey, failedCuts = [],\r\n\t\t\t\ttmpShape1, tmpShape2,\r\n\t\t\t\ttmpHole1, tmpHole2;\r\n\r\n\t\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\t\tindepHoles.push( h );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar minShapeIndex = 0;\r\n\t\t\tvar counter = indepHoles.length * 2;\r\n\t\t\twhile ( indepHoles.length > 0 ) {\r\n\r\n\t\t\t\tcounter --;\r\n\t\t\t\tif ( counter < 0 ) {\r\n\r\n\t\t\t\t\tconsole.log( \"Infinite Loop! Holes left:\" + indepHoles.length + \", Probably Hole outside Shape!\" );\r\n\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// search for shape-vertex and hole-vertex,\r\n\t\t\t\t// which can be connected without intersections\r\n\t\t\t\tfor ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {\r\n\r\n\t\t\t\t\tshapePt = shape[ shapeIndex ];\r\n\t\t\t\t\tholeIndex\t= - 1;\r\n\r\n\t\t\t\t\t// search for hole which can be reached without intersections\r\n\t\t\t\t\tfor ( var h = 0; h < indepHoles.length; h ++ ) {\r\n\r\n\t\t\t\t\t\tholeIdx = indepHoles[ h ];\r\n\r\n\t\t\t\t\t\t// prevent multiple checks\r\n\t\t\t\t\t\tcutKey = shapePt.x + \":\" + shapePt.y + \":\" + holeIdx;\r\n\t\t\t\t\t\tif ( failedCuts[ cutKey ] !== undefined )\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\thole = holes[ holeIdx ];\r\n\t\t\t\t\t\tfor ( var h2 = 0; h2 < hole.length; h2 ++ ) {\r\n\r\n\t\t\t\t\t\t\tholePt = hole[ h2 ];\r\n\t\t\t\t\t\t\tif ( ! isCutLineInsideAngles( shapeIndex, h2 ) )\t\tcontinue;\r\n\t\t\t\t\t\t\tif ( intersectsShapeEdge( shapePt, holePt ) )\t\tcontinue;\r\n\t\t\t\t\t\t\tif ( intersectsHoleEdge( shapePt, holePt ) )\t\tcontinue;\r\n\r\n\t\t\t\t\t\t\tholeIndex = h2;\r\n\t\t\t\t\t\t\tindepHoles.splice( h, 1 );\r\n\r\n\t\t\t\t\t\t\ttmpShape1 = shape.slice( 0, shapeIndex + 1 );\r\n\t\t\t\t\t\t\ttmpShape2 = shape.slice( shapeIndex );\r\n\t\t\t\t\t\t\ttmpHole1 = hole.slice( holeIndex );\r\n\t\t\t\t\t\t\ttmpHole2 = hole.slice( 0, holeIndex + 1 );\r\n\r\n\t\t\t\t\t\t\tshape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );\r\n\r\n\t\t\t\t\t\t\tminShapeIndex = shapeIndex;\r\n\r\n\t\t\t\t\t\t\t// Debug only, to show the selected cuts\r\n\t\t\t\t\t\t\t// glob_CutLines.push( [ shapePt, holePt ] );\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\r\n\r\n\t\t\t\t\t\tfailedCuts[ cutKey ] = true;\t\t\t// remember failure\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( holeIndex >= 0 )\tbreak;\t\t// hole-vertex found\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn shape; \t\t\t/* shape with no holes */\r\n\r\n\t\t}\r\n\r\n\r\n\t\tvar i, il, f, face,\r\n\t\t\tkey, index,\r\n\t\t\tallPointsMap = {};\r\n\r\n\t\t// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.\r\n\r\n\t\tvar allpoints = contour.concat();\r\n\r\n\t\tfor ( var h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tArray.prototype.push.apply( allpoints, holes[ h ] );\r\n\r\n\t\t}\r\n\r\n\t\t//console.log( \"allpoints\",allpoints, allpoints.length );\r\n\r\n\t\t// prepare all points map\r\n\r\n\t\tfor ( i = 0, il = allpoints.length; i < il; i ++ ) {\r\n\r\n\t\t\tkey = allpoints[ i ].x + \":\" + allpoints[ i ].y;\r\n\r\n\t\t\tif ( allPointsMap[ key ] !== undefined ) {\r\n\r\n\t\t\t\tconsole.warn( \"THREE.Shape: Duplicate point\", key );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tallPointsMap[ key ] = i;\r\n\r\n\t\t}\r\n\r\n\t\t// remove holes by cutting paths to holes and adding them to the shape\r\n\t\tvar shapeWithoutHoles = removeHoles( contour, holes );\r\n\r\n\t\tvar triangles = THREE.ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape\r\n\t\t//console.log( \"triangles\",triangles, triangles.length );\r\n\r\n\t\t// check all face vertices against all points map\r\n\r\n\t\tfor ( i = 0, il = triangles.length; i < il; i ++ ) {\r\n\r\n\t\t\tface = triangles[ i ];\r\n\r\n\t\t\tfor ( f = 0; f < 3; f ++ ) {\r\n\r\n\t\t\t\tkey = face[ f ].x + \":\" + face[ f ].y;\r\n\r\n\t\t\t\tindex = allPointsMap[ key ];\r\n\r\n\t\t\t\tif ( index !== undefined ) {\r\n\r\n\t\t\t\t\tface[ f ] = index;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn triangles.concat();\r\n\r\n\t},\r\n\r\n\tisClockWise: function ( pts ) {\r\n\r\n\t\treturn THREE.ShapeUtils.area( pts ) < 0;\r\n\r\n\t},\r\n\r\n\t// Bezier Curves formulas obtained from\r\n\t// http://en.wikipedia.org/wiki/B%C3%A9zier_curve\r\n\r\n\t// Quad Bezier Functions\r\n\r\n\tb2: ( function () {\r\n\r\n\t\tfunction b2p0( t, p ) {\r\n\r\n\t\t\tvar k = 1 - t;\r\n\t\t\treturn k * k * p;\r\n\r\n\t\t}\r\n\r\n\t\tfunction b2p1( t, p ) {\r\n\r\n\t\t\treturn 2 * ( 1 - t ) * t * p;\r\n\r\n\t\t}\r\n\r\n\t\tfunction b2p2( t, p ) {\r\n\r\n\t\t\treturn t * t * p;\r\n\r\n\t\t}\r\n\r\n\t\treturn function ( t, p0, p1, p2 ) {\r\n\r\n\t\t\treturn b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );\r\n\r\n\t\t};\r\n\r\n\t} )(),\r\n\r\n\t// Cubic Bezier Functions\r\n\r\n\tb3: ( function () {\r\n\r\n\t\tfunction b3p0( t, p ) {\r\n\r\n\t\t\tvar k = 1 - t;\r\n\t\t\treturn k * k * k * p;\r\n\r\n\t\t}\r\n\r\n\t\tfunction b3p1( t, p ) {\r\n\r\n\t\t\tvar k = 1 - t;\r\n\t\t\treturn 3 * k * k * t * p;\r\n\r\n\t\t}\r\n\r\n\t\tfunction b3p2( t, p ) {\r\n\r\n\t\t\tvar k = 1 - t;\r\n\t\t\treturn 3 * k * t * t * p;\r\n\r\n\t\t}\r\n\r\n\t\tfunction b3p3( t, p ) {\r\n\r\n\t\t\treturn t * t * t * p;\r\n\r\n\t\t}\r\n\r\n\t\treturn function ( t, p0, p1, p2, p3 ) {\r\n\r\n\t\t\treturn b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );\r\n\r\n\t\t};\r\n\r\n\t} )()\r\n\r\n};\r\n\r\n// File:src/extras/core/Curve.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Extensible curve object\r\n *\r\n * Some common of Curve methods\r\n * .getPoint(t), getTangent(t)\r\n * .getPointAt(u), getTagentAt(u)\r\n * .getPoints(), .getSpacedPoints()\r\n * .getLength()\r\n * .updateArcLengths()\r\n *\r\n * This following classes subclasses THREE.Curve:\r\n *\r\n * -- 2d classes --\r\n * THREE.LineCurve\r\n * THREE.QuadraticBezierCurve\r\n * THREE.CubicBezierCurve\r\n * THREE.SplineCurve\r\n * THREE.ArcCurve\r\n * THREE.EllipseCurve\r\n *\r\n * -- 3d classes --\r\n * THREE.LineCurve3\r\n * THREE.QuadraticBezierCurve3\r\n * THREE.CubicBezierCurve3\r\n * THREE.SplineCurve3\r\n *\r\n * A series of curves can be represented as a THREE.CurvePath\r\n *\r\n **/\r\n\r\n/**************************************************************\r\n *\tAbstract Curve base class\r\n **************************************************************/\r\n\r\nTHREE.Curve = function () {\r\n\r\n};\r\n\r\nTHREE.Curve.prototype = {\r\n\r\n\tconstructor: THREE.Curve,\r\n\r\n\t// Virtual base class method to overwrite and implement in subclasses\r\n\t//\t- t [0 .. 1]\r\n\r\n\tgetPoint: function ( t ) {\r\n\r\n\t\tconsole.warn( \"THREE.Curve: Warning, getPoint() not implemented!\" );\r\n\t\treturn null;\r\n\r\n\t},\r\n\r\n\t// Get point at relative position in curve according to arc length\r\n\t// - u [0 .. 1]\r\n\r\n\tgetPointAt: function ( u ) {\r\n\r\n\t\tvar t = this.getUtoTmapping( u );\r\n\t\treturn this.getPoint( t );\r\n\r\n\t},\r\n\r\n\t// Get sequence of points using getPoint( t )\r\n\r\n\tgetPoints: function ( divisions ) {\r\n\r\n\t\tif ( ! divisions ) divisions = 5;\r\n\r\n\t\tvar d, pts = [];\r\n\r\n\t\tfor ( d = 0; d <= divisions; d ++ ) {\r\n\r\n\t\t\tpts.push( this.getPoint( d / divisions ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn pts;\r\n\r\n\t},\r\n\r\n\t// Get sequence of points using getPointAt( u )\r\n\r\n\tgetSpacedPoints: function ( divisions ) {\r\n\r\n\t\tif ( ! divisions ) divisions = 5;\r\n\r\n\t\tvar d, pts = [];\r\n\r\n\t\tfor ( d = 0; d <= divisions; d ++ ) {\r\n\r\n\t\t\tpts.push( this.getPointAt( d / divisions ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn pts;\r\n\r\n\t},\r\n\r\n\t// Get total curve arc length\r\n\r\n\tgetLength: function () {\r\n\r\n\t\tvar lengths = this.getLengths();\r\n\t\treturn lengths[ lengths.length - 1 ];\r\n\r\n\t},\r\n\r\n\t// Get list of cumulative segment lengths\r\n\r\n\tgetLengths: function ( divisions ) {\r\n\r\n\t\tif ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;\r\n\r\n\t\tif ( this.cacheArcLengths\r\n\t\t\t&& ( this.cacheArcLengths.length === divisions + 1 )\r\n\t\t\t&& ! this.needsUpdate ) {\r\n\r\n\t\t\t//console.log( \"cached\", this.cacheArcLengths );\r\n\t\t\treturn this.cacheArcLengths;\r\n\r\n\t\t}\r\n\r\n\t\tthis.needsUpdate = false;\r\n\r\n\t\tvar cache = [];\r\n\t\tvar current, last = this.getPoint( 0 );\r\n\t\tvar p, sum = 0;\r\n\r\n\t\tcache.push( 0 );\r\n\r\n\t\tfor ( p = 1; p <= divisions; p ++ ) {\r\n\r\n\t\t\tcurrent = this.getPoint ( p / divisions );\r\n\t\t\tsum += current.distanceTo( last );\r\n\t\t\tcache.push( sum );\r\n\t\t\tlast = current;\r\n\r\n\t\t}\r\n\r\n\t\tthis.cacheArcLengths = cache;\r\n\r\n\t\treturn cache; // { sums: cache, sum:sum }; Sum is in the last element.\r\n\r\n\t},\r\n\r\n\tupdateArcLengths: function() {\r\n\r\n\t\tthis.needsUpdate = true;\r\n\t\tthis.getLengths();\r\n\r\n\t},\r\n\r\n\t// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\r\n\r\n\tgetUtoTmapping: function ( u, distance ) {\r\n\r\n\t\tvar arcLengths = this.getLengths();\r\n\r\n\t\tvar i = 0, il = arcLengths.length;\r\n\r\n\t\tvar targetArcLength; // The targeted u distance value to get\r\n\r\n\t\tif ( distance ) {\r\n\r\n\t\t\ttargetArcLength = distance;\r\n\r\n\t\t} else {\r\n\r\n\t\t\ttargetArcLength = u * arcLengths[ il - 1 ];\r\n\r\n\t\t}\r\n\r\n\t\t//var time = Date.now();\r\n\r\n\t\t// binary search for the index with largest value smaller than target u distance\r\n\r\n\t\tvar low = 0, high = il - 1, comparison;\r\n\r\n\t\twhile ( low <= high ) {\r\n\r\n\t\t\ti = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\r\n\r\n\t\t\tcomparison = arcLengths[ i ] - targetArcLength;\r\n\r\n\t\t\tif ( comparison < 0 ) {\r\n\r\n\t\t\t\tlow = i + 1;\r\n\r\n\t\t\t} else if ( comparison > 0 ) {\r\n\r\n\t\t\t\thigh = i - 1;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\thigh = i;\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t\t// DONE\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\ti = high;\r\n\r\n\t\t//console.log('b' , i, low, high, Date.now()- time);\r\n\r\n\t\tif ( arcLengths[ i ] === targetArcLength ) {\r\n\r\n\t\t\tvar t = i / ( il - 1 );\r\n\t\t\treturn t;\r\n\r\n\t\t}\r\n\r\n\t\t// we could get finer grain at lengths, or use simple interpolation between two points\r\n\r\n\t\tvar lengthBefore = arcLengths[ i ];\r\n\t\tvar lengthAfter = arcLengths[ i + 1 ];\r\n\r\n\t\tvar segmentLength = lengthAfter - lengthBefore;\r\n\r\n\t\t// determine where we are between the 'before' and 'after' points\r\n\r\n\t\tvar segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;\r\n\r\n\t\t// add that fractional amount to t\r\n\r\n\t\tvar t = ( i + segmentFraction ) / ( il - 1 );\r\n\r\n\t\treturn t;\r\n\r\n\t},\r\n\r\n\t// Returns a unit vector tangent at t\r\n\t// In case any sub curve does not implement its tangent derivation,\r\n\t// 2 points a small delta apart will be used to find its gradient\r\n\t// which seems to give a reasonable approximation\r\n\r\n\tgetTangent: function( t ) {\r\n\r\n\t\tvar delta = 0.0001;\r\n\t\tvar t1 = t - delta;\r\n\t\tvar t2 = t + delta;\r\n\r\n\t\t// Capping in case of danger\r\n\r\n\t\tif ( t1 < 0 ) t1 = 0;\r\n\t\tif ( t2 > 1 ) t2 = 1;\r\n\r\n\t\tvar pt1 = this.getPoint( t1 );\r\n\t\tvar pt2 = this.getPoint( t2 );\r\n\r\n\t\tvar vec = pt2.clone().sub( pt1 );\r\n\t\treturn vec.normalize();\r\n\r\n\t},\r\n\r\n\tgetTangentAt: function ( u ) {\r\n\r\n\t\tvar t = this.getUtoTmapping( u );\r\n\t\treturn this.getTangent( t );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// TODO: Transformation for Curves?\r\n\r\n/**************************************************************\r\n *\t3D Curves\r\n **************************************************************/\r\n\r\n// A Factory method for creating new curve subclasses\r\n\r\nTHREE.Curve.create = function ( constructor, getPointFunc ) {\r\n\r\n\tconstructor.prototype = Object.create( THREE.Curve.prototype );\r\n\tconstructor.prototype.constructor = constructor;\r\n\tconstructor.prototype.getPoint = getPointFunc;\r\n\r\n\treturn constructor;\r\n\r\n};\r\n\r\n// File:src/extras/core/CurvePath.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n **/\r\n\r\n/**************************************************************\r\n *\tCurved Path - a curve path is simply a array of connected\r\n *  curves, but retains the api of a curve\r\n **************************************************************/\r\n\r\nTHREE.CurvePath = function () {\r\n\r\n\tthis.curves = [];\r\n\r\n\tthis.autoClose = false; // Automatically closes the path\r\n\r\n};\r\n\r\nTHREE.CurvePath.prototype = Object.assign( Object.create( THREE.Curve.prototype ), {\r\n\r\n\tconstructor: THREE.CurvePath,\r\n\r\n\tadd: function ( curve ) {\r\n\r\n\t\tthis.curves.push( curve );\r\n\r\n\t},\r\n\r\n\tclosePath: function () {\r\n\r\n\t\t// TODO Test\r\n\t\t// and verify for vector3 (needs to implement equals)\r\n\t\t// Add a line curve if start and end of lines are not connected\r\n\t\tvar startPoint = this.curves[ 0 ].getPoint( 0 );\r\n\t\tvar endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );\r\n\r\n\t\tif ( ! startPoint.equals( endPoint ) ) {\r\n\r\n\t\t\tthis.curves.push( new THREE.LineCurve( endPoint, startPoint ) );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\t// To get accurate point with reference to\r\n\t// entire path distance at time t,\r\n\t// following has to be done:\r\n\r\n\t// 1. Length of each sub path have to be known\r\n\t// 2. Locate and identify type of curve\r\n\t// 3. Get t for the curve\r\n\t// 4. Return curve.getPointAt(t')\r\n\r\n\tgetPoint: function ( t ) {\r\n\r\n\t\tvar d = t * this.getLength();\r\n\t\tvar curveLengths = this.getCurveLengths();\r\n\t\tvar i = 0;\r\n\r\n\t\t// To think about boundaries points.\r\n\r\n\t\twhile ( i < curveLengths.length ) {\r\n\r\n\t\t\tif ( curveLengths[ i ] >= d ) {\r\n\r\n\t\t\t\tvar diff = curveLengths[ i ] - d;\r\n\t\t\t\tvar curve = this.curves[ i ];\r\n\r\n\t\t\t\tvar u = 1 - diff / curve.getLength();\r\n\r\n\t\t\t\treturn curve.getPointAt( u );\r\n\r\n\t\t\t}\r\n\r\n\t\t\ti ++;\r\n\r\n\t\t}\r\n\r\n\t\treturn null;\r\n\r\n\t\t// loop where sum != 0, sum > d , sum+1 <d\r\n\r\n\t},\r\n\r\n\t// We cannot use the default THREE.Curve getPoint() with getLength() because in\r\n\t// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath\r\n\t// getPoint() depends on getLength\r\n\r\n\tgetLength: function () {\r\n\r\n\t\tvar lens = this.getCurveLengths();\r\n\t\treturn lens[ lens.length - 1 ];\r\n\r\n\t},\r\n\r\n\t// Compute lengths and cache them\r\n\t// We cannot overwrite getLengths() because UtoT mapping uses it.\r\n\r\n\tgetCurveLengths: function () {\r\n\r\n\t\t// We use cache values if curves and cache array are same length\r\n\r\n\t\tif ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {\r\n\r\n\t\t\treturn this.cacheLengths;\r\n\r\n\t\t}\r\n\r\n\t\t// Get length of sub-curve\r\n\t\t// Push sums into cached array\r\n\r\n\t\tvar lengths = [], sums = 0;\r\n\r\n\t\tfor ( var i = 0, l = this.curves.length; i < l; i ++ ) {\r\n\r\n\t\t\tsums += this.curves[ i ].getLength();\r\n\t\t\tlengths.push( sums );\r\n\r\n\t\t}\r\n\r\n\t\tthis.cacheLengths = lengths;\r\n\r\n\t\treturn lengths;\r\n\r\n\t},\r\n\r\n\t/**************************************************************\r\n\t *\tCreate Geometries Helpers\r\n\t **************************************************************/\r\n\r\n\t/// Generate geometry from path points (for Line or Points objects)\r\n\r\n\tcreatePointsGeometry: function ( divisions ) {\r\n\r\n\t\tvar pts = this.getPoints( divisions );\r\n\t\treturn this.createGeometry( pts );\r\n\r\n\t},\r\n\r\n\t// Generate geometry from equidistant sampling along the path\r\n\r\n\tcreateSpacedPointsGeometry: function ( divisions ) {\r\n\r\n\t\tvar pts = this.getSpacedPoints( divisions );\r\n\t\treturn this.createGeometry( pts );\r\n\r\n\t},\r\n\r\n\tcreateGeometry: function ( points ) {\r\n\r\n\t\tvar geometry = new THREE.Geometry();\r\n\r\n\t\tfor ( var i = 0, l = points.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar point = points[ i ];\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3( point.x, point.y, point.z || 0 ) );\r\n\r\n\t\t}\r\n\r\n\t\treturn geometry;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/extras/core/Font.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.Font = function ( data ) {\r\n\r\n\tthis.data = data;\r\n\r\n};\r\n\r\nObject.assign( THREE.Font.prototype, {\r\n\r\n\tgenerateShapes: function ( text, size, divisions ) {\r\n\r\n\t\tfunction createPaths( text ) {\r\n\r\n\t\t\tvar chars = String( text ).split( '' );\r\n\t\t\tvar scale = size / data.resolution;\r\n\t\t\tvar offset = 0;\r\n\r\n\t\t\tvar paths = [];\r\n\r\n\t\t\tfor ( var i = 0; i < chars.length; i ++ ) {\r\n\r\n\t\t\t\tvar ret = createPath( chars[ i ], scale, offset );\r\n\t\t\t\toffset += ret.offset;\r\n\r\n\t\t\t\tpaths.push( ret.path );\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn paths;\r\n\r\n\t\t}\r\n\r\n\t\tfunction createPath( c, scale, offset ) {\r\n\r\n\t\t\tvar glyph = data.glyphs[ c ] || data.glyphs[ '?' ];\r\n\r\n\t\t\tif ( ! glyph ) return;\r\n\r\n\t\t\tvar path = new THREE.Path();\r\n\r\n\t\t\tvar pts = [], b2 = THREE.ShapeUtils.b2, b3 = THREE.ShapeUtils.b3;\r\n\t\t\tvar x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;\r\n\r\n\t\t\tif ( glyph.o ) {\r\n\r\n\t\t\t\tvar outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );\r\n\r\n\t\t\t\tfor ( var i = 0, l = outline.length; i < l; ) {\r\n\r\n\t\t\t\t\tvar action = outline[ i ++ ];\r\n\r\n\t\t\t\t\tswitch ( action ) {\r\n\r\n\t\t\t\t\t\tcase 'm': // moveTo\r\n\r\n\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\r\n\r\n\t\t\t\t\t\t\tpath.moveTo( x, y );\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'l': // lineTo\r\n\r\n\t\t\t\t\t\t\tx = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\ty = outline[ i ++ ] * scale;\r\n\r\n\t\t\t\t\t\t\tpath.lineTo( x, y );\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'q': // quadraticCurveTo\r\n\r\n\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\r\n\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\r\n\r\n\t\t\t\t\t\t\tpath.quadraticCurveTo( cpx1, cpy1, cpx, cpy );\r\n\r\n\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\r\n\r\n\t\t\t\t\t\t\tif ( laste ) {\r\n\r\n\t\t\t\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\r\n\t\t\t\t\t\t\t\t\tb2( t, cpx0, cpx1, cpx );\r\n\t\t\t\t\t\t\t\t\tb2( t, cpy0, cpy1, cpy );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t\tcase 'b': // bezierCurveTo\r\n\r\n\t\t\t\t\t\t\tcpx  = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\tcpy  = outline[ i ++ ] * scale;\r\n\t\t\t\t\t\t\tcpx1 = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\tcpy1 = outline[ i ++ ] * scale;\r\n\t\t\t\t\t\t\tcpx2 = outline[ i ++ ] * scale + offset;\r\n\t\t\t\t\t\t\tcpy2 = outline[ i ++ ] * scale;\r\n\r\n\t\t\t\t\t\t\tpath.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );\r\n\r\n\t\t\t\t\t\t\tlaste = pts[ pts.length - 1 ];\r\n\r\n\t\t\t\t\t\t\tif ( laste ) {\r\n\r\n\t\t\t\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t\t\t\t\t\tfor ( var i2 = 1; i2 <= divisions; i2 ++ ) {\r\n\r\n\t\t\t\t\t\t\t\t\tvar t = i2 / divisions;\r\n\t\t\t\t\t\t\t\t\tb3( t, cpx0, cpx1, cpx2, cpx );\r\n\t\t\t\t\t\t\t\t\tb3( t, cpy0, cpy1, cpy2, cpy );\r\n\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tbreak;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn { offset: glyph.ha * scale, path: path };\r\n\r\n\t\t}\r\n\r\n\t\t//\r\n\r\n\t\tif ( size === undefined ) size = 100;\r\n\t\tif ( divisions === undefined ) divisions = 4;\r\n\r\n\t\tvar data = this.data;\r\n\r\n\t\tvar paths = createPaths( text );\r\n\t\tvar shapes = [];\r\n\r\n\t\tfor ( var p = 0, pl = paths.length; p < pl; p ++ ) {\r\n\r\n\t\t\tArray.prototype.push.apply( shapes, paths[ p ].toShapes() );\r\n\r\n\t\t}\r\n\r\n\t\treturn shapes;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/extras/core/Path.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Creates free form 2d path using series of points, lines or curves.\r\n *\r\n **/\r\n\r\nTHREE.Path = function ( points ) {\r\n\r\n\tTHREE.CurvePath.call( this );\r\n\r\n\tthis.actions = [];\r\n\r\n\tif ( points ) {\r\n\r\n\t\tthis.fromPoints( points );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.Path.prototype = Object.assign( Object.create( THREE.CurvePath.prototype ), {\r\n\r\n\tconstructor: THREE.Path,\r\n\r\n\t// TODO Clean up PATH API\r\n\r\n\t// Create path using straight lines to connect all points\r\n\t// - vectors: array of Vector2\r\n\r\n\tfromPoints: function ( vectors ) {\r\n\r\n\t\tthis.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );\r\n\r\n\t\tfor ( var i = 1, l = vectors.length; i < l; i ++ ) {\r\n\r\n\t\t\tthis.lineTo( vectors[ i ].x, vectors[ i ].y );\r\n\r\n\t\t}\r\n\r\n\t},\r\n\r\n\tmoveTo: function ( x, y ) {\r\n\r\n\t\tthis.actions.push( { action: 'moveTo', args: [ x, y ] } );\r\n\r\n\t},\r\n\r\n\tlineTo: function ( x, y ) {\r\n\r\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\t\tvar curve = new THREE.LineCurve( new THREE.Vector2( x0, y0 ), new THREE.Vector2( x, y ) );\r\n\t\tthis.curves.push( curve );\r\n\r\n\t\tthis.actions.push( { action: 'lineTo', args: [ x, y ] } );\r\n\r\n\t},\r\n\r\n\tquadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {\r\n\r\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\t\tvar curve = new THREE.QuadraticBezierCurve(\r\n\t\t\tnew THREE.Vector2( x0, y0 ),\r\n\t\t\tnew THREE.Vector2( aCPx, aCPy ),\r\n\t\t\tnew THREE.Vector2( aX, aY )\r\n\t\t);\r\n\r\n\t\tthis.curves.push( curve );\r\n\r\n\t\tthis.actions.push( { action: 'quadraticCurveTo', args: [ aCPx, aCPy, aX, aY ] } );\r\n\r\n\t},\r\n\r\n\tbezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {\r\n\r\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\t\tvar curve = new THREE.CubicBezierCurve(\r\n\t\t\tnew THREE.Vector2( x0, y0 ),\r\n\t\t\tnew THREE.Vector2( aCP1x, aCP1y ),\r\n\t\t\tnew THREE.Vector2( aCP2x, aCP2y ),\r\n\t\t\tnew THREE.Vector2( aX, aY )\r\n\t\t);\r\n\r\n\t\tthis.curves.push( curve );\r\n\r\n\t\tthis.actions.push( { action: 'bezierCurveTo', args: [ aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ] } );\r\n\r\n\t},\r\n\r\n\tsplineThru: function ( pts /*Array of Vector*/ ) {\r\n\r\n\t\tvar args = Array.prototype.slice.call( arguments );\r\n\r\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\r\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\t\tvar npts = [ new THREE.Vector2( x0, y0 ) ];\r\n\t\tArray.prototype.push.apply( npts, pts );\r\n\r\n\t\tvar curve = new THREE.SplineCurve( npts );\r\n\t\tthis.curves.push( curve );\r\n\r\n\t\tthis.actions.push( { action: 'splineThru', args: args } );\r\n\r\n\t},\r\n\r\n\tarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\t\tthis.absarc( aX + x0, aY + y0, aRadius,\r\n\t\t\taStartAngle, aEndAngle, aClockwise );\r\n\r\n\t},\r\n\r\n\tabsarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\t\tthis.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\r\n\r\n\t},\r\n\r\n\tellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\r\n\t\tvar lastargs = this.actions[ this.actions.length - 1 ].args;\r\n\t\tvar x0 = lastargs[ lastargs.length - 2 ];\r\n\t\tvar y0 = lastargs[ lastargs.length - 1 ];\r\n\r\n\t\tthis.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\r\n\r\n\t},\r\n\r\n\tabsellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\r\n\t\tvar args = [\r\n\t\t\taX, aY,\r\n\t\t\txRadius, yRadius,\r\n\t\t\taStartAngle, aEndAngle,\r\n\t\t\taClockwise,\r\n\t\t\taRotation || 0 // aRotation is optional.\r\n\t\t];\r\n\r\n\t\tvar curve = new THREE.EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );\r\n\t\tthis.curves.push( curve );\r\n\r\n\t\tvar lastPoint = curve.getPoint( 1 );\r\n\t\targs.push( lastPoint.x );\r\n\t\targs.push( lastPoint.y );\r\n\r\n\t\tthis.actions.push( { action: 'ellipse', args: args } );\r\n\r\n\t},\r\n\r\n\tgetSpacedPoints: function ( divisions ) {\r\n\r\n\t\tif ( ! divisions ) divisions = 40;\r\n\r\n\t\tvar points = [];\r\n\r\n\t\tfor ( var i = 0; i < divisions; i ++ ) {\r\n\r\n\t\t\tpoints.push( this.getPoint( i / divisions ) );\r\n\r\n\t\t\t//if ( !this.getPoint( i / divisions ) ) throw \"DIE\";\r\n\r\n\t\t}\r\n\r\n\t\tif ( this.autoClose ) {\r\n\r\n\t\t\tpoints.push( points[ 0 ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn points;\r\n\r\n\t},\r\n\r\n\tgetPoints: function ( divisions ) {\r\n\r\n\t\tdivisions = divisions || 12;\r\n\r\n\t\tvar b2 = THREE.ShapeUtils.b2;\r\n\t\tvar b3 = THREE.ShapeUtils.b3;\r\n\r\n\t\tvar points = [];\r\n\r\n\t\tvar cpx, cpy, cpx2, cpy2, cpx1, cpy1, cpx0, cpy0,\r\n\t\t\tlaste, tx, ty;\r\n\r\n\t\tfor ( var i = 0, l = this.actions.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar item = this.actions[ i ];\r\n\r\n\t\t\tvar action = item.action;\r\n\t\t\tvar args = item.args;\r\n\r\n\t\t\tswitch ( action ) {\r\n\r\n\t\t\tcase 'moveTo':\r\n\r\n\t\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'lineTo':\r\n\r\n\t\t\t\tpoints.push( new THREE.Vector2( args[ 0 ], args[ 1 ] ) );\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'quadraticCurveTo':\r\n\r\n\t\t\t\tcpx  = args[ 2 ];\r\n\t\t\t\tcpy  = args[ 3 ];\r\n\r\n\t\t\t\tcpx1 = args[ 0 ];\r\n\t\t\t\tcpy1 = args[ 1 ];\r\n\r\n\t\t\t\tif ( points.length > 0 ) {\r\n\r\n\t\t\t\t\tlaste = points[ points.length - 1 ];\r\n\r\n\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\r\n\t\t\t\t\tcpx0 = laste[ laste.length - 2 ];\r\n\t\t\t\t\tcpy0 = laste[ laste.length - 1 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var j = 1; j <= divisions; j ++ ) {\r\n\r\n\t\t\t\t\tvar t = j / divisions;\r\n\r\n\t\t\t\t\ttx = b2( t, cpx0, cpx1, cpx );\r\n\t\t\t\t\tty = b2( t, cpy0, cpy1, cpy );\r\n\r\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'bezierCurveTo':\r\n\r\n\t\t\t\tcpx  = args[ 4 ];\r\n\t\t\t\tcpy  = args[ 5 ];\r\n\r\n\t\t\t\tcpx1 = args[ 0 ];\r\n\t\t\t\tcpy1 = args[ 1 ];\r\n\r\n\t\t\t\tcpx2 = args[ 2 ];\r\n\t\t\t\tcpy2 = args[ 3 ];\r\n\r\n\t\t\t\tif ( points.length > 0 ) {\r\n\r\n\t\t\t\t\tlaste = points[ points.length - 1 ];\r\n\r\n\t\t\t\t\tcpx0 = laste.x;\r\n\t\t\t\t\tcpy0 = laste.y;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\r\n\t\t\t\t\tcpx0 = laste[ laste.length - 2 ];\r\n\t\t\t\t\tcpy0 = laste[ laste.length - 1 ];\r\n\r\n\t\t\t\t}\r\n\r\n\r\n\t\t\t\tfor ( var j = 1; j <= divisions; j ++ ) {\r\n\r\n\t\t\t\t\tvar t = j / divisions;\r\n\r\n\t\t\t\t\ttx = b3( t, cpx0, cpx1, cpx2, cpx );\r\n\t\t\t\t\tty = b3( t, cpy0, cpy1, cpy2, cpy );\r\n\r\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'splineThru':\r\n\r\n\t\t\t\tlaste = this.actions[ i - 1 ].args;\r\n\r\n\t\t\t\tvar last = new THREE.Vector2( laste[ laste.length - 2 ], laste[ laste.length - 1 ] );\r\n\t\t\t\tvar spts = [ last ];\r\n\r\n\t\t\t\tvar n = divisions * args[ 0 ].length;\r\n\r\n\t\t\t\tspts = spts.concat( args[ 0 ] );\r\n\r\n\t\t\t\tvar spline = new THREE.SplineCurve( spts );\r\n\r\n\t\t\t\tfor ( var j = 1; j <= n; j ++ ) {\r\n\r\n\t\t\t\t\tpoints.push( spline.getPointAt( j / n ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'arc':\r\n\r\n\t\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\r\n\t\t\t\t\taRadius = args[ 2 ],\r\n\t\t\t\t\taStartAngle = args[ 3 ], aEndAngle = args[ 4 ],\r\n\t\t\t\t\taClockwise = !! args[ 5 ];\r\n\r\n\t\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\r\n\t\t\t\tvar angle;\r\n\t\t\t\tvar tdivisions = divisions * 2;\r\n\r\n\t\t\t\tfor ( var j = 1; j <= tdivisions; j ++ ) {\r\n\r\n\t\t\t\t\tvar t = j / tdivisions;\r\n\r\n\t\t\t\t\tif ( ! aClockwise ) {\r\n\r\n\t\t\t\t\t\tt = 1 - t;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tangle = aStartAngle + t * deltaAngle;\r\n\r\n\t\t\t\t\ttx = aX + aRadius * Math.cos( angle );\r\n\t\t\t\t\tty = aY + aRadius * Math.sin( angle );\r\n\r\n\t\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\r\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//console.log(points);\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\tcase 'ellipse':\r\n\r\n\t\t\t\tvar aX = args[ 0 ], aY = args[ 1 ],\r\n\t\t\t\t\txRadius = args[ 2 ],\r\n\t\t\t\t\tyRadius = args[ 3 ],\r\n\t\t\t\t\taStartAngle = args[ 4 ], aEndAngle = args[ 5 ],\r\n\t\t\t\t\taClockwise = !! args[ 6 ],\r\n\t\t\t\t\taRotation = args[ 7 ];\r\n\r\n\r\n\t\t\t\tvar deltaAngle = aEndAngle - aStartAngle;\r\n\t\t\t\tvar angle;\r\n\t\t\t\tvar tdivisions = divisions * 2;\r\n\r\n\t\t\t\tvar cos, sin;\r\n\t\t\t\tif ( aRotation !== 0 ) {\r\n\r\n\t\t\t\t\tcos = Math.cos( aRotation );\r\n\t\t\t\t\tsin = Math.sin( aRotation );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor ( var j = 1; j <= tdivisions; j ++ ) {\r\n\r\n\t\t\t\t\tvar t = j / tdivisions;\r\n\r\n\t\t\t\t\tif ( ! aClockwise ) {\r\n\r\n\t\t\t\t\t\tt = 1 - t;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tangle = aStartAngle + t * deltaAngle;\r\n\r\n\t\t\t\t\ttx = aX + xRadius * Math.cos( angle );\r\n\t\t\t\t\tty = aY + yRadius * Math.sin( angle );\r\n\r\n\t\t\t\t\tif ( aRotation !== 0 ) {\r\n\r\n\t\t\t\t\t\tvar x = tx, y = ty;\r\n\r\n\t\t\t\t\t\t// Rotate the point about the center of the ellipse.\r\n\t\t\t\t\t\ttx = ( x - aX ) * cos - ( y - aY ) * sin + aX;\r\n\t\t\t\t\t\tty = ( x - aX ) * sin + ( y - aY ) * cos + aY;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t//console.log('t', t, 'angle', angle, 'tx', tx, 'ty', ty);\r\n\r\n\t\t\t\t\tpoints.push( new THREE.Vector2( tx, ty ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//console.log(points);\r\n\r\n\t\t\t\tbreak;\r\n\r\n\t\t\t} // end switch\r\n\r\n\t\t}\r\n\r\n\r\n\r\n\t\t// Normalize to remove the closing point by default.\r\n\t\tvar lastPoint = points[ points.length - 1 ];\r\n\t\tif ( Math.abs( lastPoint.x - points[ 0 ].x ) < Number.EPSILON &&\r\n\t\t\t\t Math.abs( lastPoint.y - points[ 0 ].y ) < Number.EPSILON )\r\n\t\t\tpoints.splice( points.length - 1, 1 );\r\n\r\n\t\tif ( this.autoClose ) {\r\n\r\n\t\t\tpoints.push( points[ 0 ] );\r\n\r\n\t\t}\r\n\r\n\t\treturn points;\r\n\r\n\t},\r\n\r\n\ttoShapes: function ( isCCW, noHoles ) {\r\n\r\n\t\tfunction extractSubpaths( inActions ) {\r\n\r\n\t\t\tvar subPaths = [], lastPath = new THREE.Path();\r\n\r\n\t\t\tfor ( var i = 0, l = inActions.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar item = inActions[ i ];\r\n\r\n\t\t\t\tvar args = item.args;\r\n\t\t\t\tvar action = item.action;\r\n\r\n\t\t\t\tif ( action === 'moveTo' ) {\r\n\r\n\t\t\t\t\tif ( lastPath.actions.length !== 0 ) {\r\n\r\n\t\t\t\t\t\tsubPaths.push( lastPath );\r\n\t\t\t\t\t\tlastPath = new THREE.Path();\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlastPath[ action ].apply( lastPath, args );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( lastPath.actions.length !== 0 ) {\r\n\r\n\t\t\t\tsubPaths.push( lastPath );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// console.log(subPaths);\r\n\r\n\t\t\treturn\tsubPaths;\r\n\r\n\t\t}\r\n\r\n\t\tfunction toShapesNoHoles( inSubpaths ) {\r\n\r\n\t\t\tvar shapes = [];\r\n\r\n\t\t\tfor ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar tmpPath = inSubpaths[ i ];\r\n\r\n\t\t\t\tvar tmpShape = new THREE.Shape();\r\n\t\t\t\ttmpShape.actions = tmpPath.actions;\r\n\t\t\t\ttmpShape.curves = tmpPath.curves;\r\n\r\n\t\t\t\tshapes.push( tmpShape );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t//console.log(\"shape\", shapes);\r\n\r\n\t\t\treturn shapes;\r\n\r\n\t\t}\r\n\r\n\t\tfunction isPointInsidePolygon( inPt, inPolygon ) {\r\n\r\n\t\t\tvar polyLen = inPolygon.length;\r\n\r\n\t\t\t// inPt on polygon contour => immediate success    or\r\n\t\t\t// toggling of inside/outside at every single! intersection point of an edge\r\n\t\t\t//  with the horizontal line through inPt, left of inPt\r\n\t\t\t//  not counting lowerY endpoints of edges and whole edges on that line\r\n\t\t\tvar inside = false;\r\n\t\t\tfor ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {\r\n\r\n\t\t\t\tvar edgeLowPt  = inPolygon[ p ];\r\n\t\t\t\tvar edgeHighPt = inPolygon[ q ];\r\n\r\n\t\t\t\tvar edgeDx = edgeHighPt.x - edgeLowPt.x;\r\n\t\t\t\tvar edgeDy = edgeHighPt.y - edgeLowPt.y;\r\n\r\n\t\t\t\tif ( Math.abs( edgeDy ) > Number.EPSILON ) {\r\n\r\n\t\t\t\t\t// not parallel\r\n\t\t\t\t\tif ( edgeDy < 0 ) {\r\n\r\n\t\t\t\t\t\tedgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;\r\n\t\t\t\t\t\tedgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) \t\tcontinue;\r\n\r\n\t\t\t\t\tif ( inPt.y === edgeLowPt.y ) {\r\n\r\n\t\t\t\t\t\tif ( inPt.x === edgeLowPt.x )\t\treturn\ttrue;\t\t// inPt is on contour ?\r\n\t\t\t\t\t\t// continue;\t\t\t\t// no intersection or edgeLowPt => doesn't count !!!\r\n\r\n\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\tvar perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );\r\n\t\t\t\t\t\tif ( perpEdge === 0 )\t\t\t\treturn\ttrue;\t\t// inPt is on contour ?\r\n\t\t\t\t\t\tif ( perpEdge < 0 ) \t\t\t\tcontinue;\r\n\t\t\t\t\t\tinside = ! inside;\t\t// true intersection left of inPt\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\t// parallel or collinear\r\n\t\t\t\t\tif ( inPt.y !== edgeLowPt.y ) \t\tcontinue;\t\t\t// parallel\r\n\t\t\t\t\t// edge lies on the same horizontal line as inPt\r\n\t\t\t\t\tif ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||\r\n\t\t\t\t\t\t ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )\t\treturn\ttrue;\t// inPt: Point on contour !\r\n\t\t\t\t\t// continue;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\treturn\tinside;\r\n\r\n\t\t}\r\n\r\n\t\tvar isClockWise = THREE.ShapeUtils.isClockWise;\r\n\r\n\t\tvar subPaths = extractSubpaths( this.actions );\r\n\t\tif ( subPaths.length === 0 ) return [];\r\n\r\n\t\tif ( noHoles === true )\treturn\ttoShapesNoHoles( subPaths );\r\n\r\n\r\n\t\tvar solid, tmpPath, tmpShape, shapes = [];\r\n\r\n\t\tif ( subPaths.length === 1 ) {\r\n\r\n\t\t\ttmpPath = subPaths[ 0 ];\r\n\t\t\ttmpShape = new THREE.Shape();\r\n\t\t\ttmpShape.actions = tmpPath.actions;\r\n\t\t\ttmpShape.curves = tmpPath.curves;\r\n\t\t\tshapes.push( tmpShape );\r\n\t\t\treturn shapes;\r\n\r\n\t\t}\r\n\r\n\t\tvar holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );\r\n\t\tholesFirst = isCCW ? ! holesFirst : holesFirst;\r\n\r\n\t\t// console.log(\"Holes first\", holesFirst);\r\n\r\n\t\tvar betterShapeHoles = [];\r\n\t\tvar newShapes = [];\r\n\t\tvar newShapeHoles = [];\r\n\t\tvar mainIdx = 0;\r\n\t\tvar tmpPoints;\r\n\r\n\t\tnewShapes[ mainIdx ] = undefined;\r\n\t\tnewShapeHoles[ mainIdx ] = [];\r\n\r\n\t\tfor ( var i = 0, l = subPaths.length; i < l; i ++ ) {\r\n\r\n\t\t\ttmpPath = subPaths[ i ];\r\n\t\t\ttmpPoints = tmpPath.getPoints();\r\n\t\t\tsolid = isClockWise( tmpPoints );\r\n\t\t\tsolid = isCCW ? ! solid : solid;\r\n\r\n\t\t\tif ( solid ) {\r\n\r\n\t\t\t\tif ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )\tmainIdx ++;\r\n\r\n\t\t\t\tnewShapes[ mainIdx ] = { s: new THREE.Shape(), p: tmpPoints };\r\n\t\t\t\tnewShapes[ mainIdx ].s.actions = tmpPath.actions;\r\n\t\t\t\tnewShapes[ mainIdx ].s.curves = tmpPath.curves;\r\n\r\n\t\t\t\tif ( holesFirst )\tmainIdx ++;\r\n\t\t\t\tnewShapeHoles[ mainIdx ] = [];\r\n\r\n\t\t\t\t//console.log('cw', i);\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tnewShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );\r\n\r\n\t\t\t\t//console.log('ccw', i);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// only Holes? -> probably all Shapes with wrong orientation\r\n\t\tif ( ! newShapes[ 0 ] )\treturn\ttoShapesNoHoles( subPaths );\r\n\r\n\r\n\t\tif ( newShapes.length > 1 ) {\r\n\r\n\t\t\tvar ambiguous = false;\r\n\t\t\tvar toChange = [];\r\n\r\n\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\r\n\r\n\t\t\t\tbetterShapeHoles[ sIdx ] = [];\r\n\r\n\t\t\t}\r\n\r\n\t\t\tfor ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {\r\n\r\n\t\t\t\tvar sho = newShapeHoles[ sIdx ];\r\n\r\n\t\t\t\tfor ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {\r\n\r\n\t\t\t\t\tvar ho = sho[ hIdx ];\r\n\t\t\t\t\tvar hole_unassigned = true;\r\n\r\n\t\t\t\t\tfor ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {\r\n\r\n\t\t\t\t\t\tif ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {\r\n\r\n\t\t\t\t\t\t\tif ( sIdx !== s2Idx )\ttoChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );\r\n\t\t\t\t\t\t\tif ( hole_unassigned ) {\r\n\r\n\t\t\t\t\t\t\t\thole_unassigned = false;\r\n\t\t\t\t\t\t\t\tbetterShapeHoles[ s2Idx ].push( ho );\r\n\r\n\t\t\t\t\t\t\t} else {\r\n\r\n\t\t\t\t\t\t\t\tambiguous = true;\r\n\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif ( hole_unassigned ) {\r\n\r\n\t\t\t\t\t\tbetterShapeHoles[ sIdx ].push( ho );\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t\t// console.log(\"ambiguous: \", ambiguous);\r\n\t\t\tif ( toChange.length > 0 ) {\r\n\r\n\t\t\t\t// console.log(\"to change: \", toChange);\r\n\t\t\t\tif ( ! ambiguous )\tnewShapeHoles = betterShapeHoles;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar tmpHoles;\r\n\r\n\t\tfor ( var i = 0, il = newShapes.length; i < il; i ++ ) {\r\n\r\n\t\t\ttmpShape = newShapes[ i ].s;\r\n\t\t\tshapes.push( tmpShape );\r\n\t\t\ttmpHoles = newShapeHoles[ i ];\r\n\r\n\t\t\tfor ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\ttmpShape.holes.push( tmpHoles[ j ].h );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t//console.log(\"shape\", shapes);\r\n\r\n\t\treturn shapes;\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/extras/core/Shape.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * Defines a 2d shape plane using paths.\r\n **/\r\n\r\n// STEP 1 Create a path.\r\n// STEP 2 Turn path into shape.\r\n// STEP 3 ExtrudeGeometry takes in Shape/Shapes\r\n// STEP 3a - Extract points from each shape, turn to vertices\r\n// STEP 3b - Triangulate each shape, add faces.\r\n\r\nTHREE.Shape = function () {\r\n\r\n\tTHREE.Path.apply( this, arguments );\r\n\r\n\tthis.holes = [];\r\n\r\n};\r\n\r\nTHREE.Shape.prototype = Object.assign( Object.create( THREE.Path.prototype ), {\r\n\r\n\tconstructor: THREE.Shape,\r\n\r\n\t// Convenience method to return ExtrudeGeometry\r\n\r\n\textrude: function ( options ) {\r\n\r\n\t\treturn new THREE.ExtrudeGeometry( this, options );\r\n\r\n\t},\r\n\r\n\t// Convenience method to return ShapeGeometry\r\n\r\n\tmakeGeometry: function ( options ) {\r\n\r\n\t\treturn new THREE.ShapeGeometry( this, options );\r\n\r\n\t},\r\n\r\n\tgetPointsHoles: function ( divisions ) {\r\n\r\n\t\tvar holesPts = [];\r\n\r\n\t\tfor ( var i = 0, l = this.holes.length; i < l; i ++ ) {\r\n\r\n\t\t\tholesPts[ i ] = this.holes[ i ].getPoints( divisions );\r\n\r\n\t\t}\r\n\r\n\t\treturn holesPts;\r\n\r\n\t},\r\n\r\n\t// Get points of shape and holes (keypoints based on segments parameter)\r\n\r\n\textractAllPoints: function ( divisions ) {\r\n\r\n\t\treturn {\r\n\r\n\t\t\tshape: this.getPoints( divisions ),\r\n\t\t\tholes: this.getPointsHoles( divisions )\r\n\r\n\t\t};\r\n\r\n\t},\r\n\r\n\textractPoints: function ( divisions ) {\r\n\r\n\t\treturn this.extractAllPoints( divisions );\r\n\r\n\t}\r\n\r\n} );\r\n\r\n// File:src/extras/curves/LineCurve.js\r\n\r\n/**************************************************************\r\n *\tLine\r\n **************************************************************/\r\n\r\nTHREE.LineCurve = function ( v1, v2 ) {\r\n\r\n\tthis.v1 = v1;\r\n\tthis.v2 = v2;\r\n\r\n};\r\n\r\nTHREE.LineCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.LineCurve.prototype.constructor = THREE.LineCurve;\r\n\r\nTHREE.LineCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar point = this.v2.clone().sub( this.v1 );\r\n\tpoint.multiplyScalar( t ).add( this.v1 );\r\n\r\n\treturn point;\r\n\r\n};\r\n\r\n// Line curve is linear, so we can overwrite default getPointAt\r\n\r\nTHREE.LineCurve.prototype.getPointAt = function ( u ) {\r\n\r\n\treturn this.getPoint( u );\r\n\r\n};\r\n\r\nTHREE.LineCurve.prototype.getTangent = function( t ) {\r\n\r\n\tvar tangent = this.v2.clone().sub( this.v1 );\r\n\r\n\treturn tangent.normalize();\r\n\r\n};\r\n\r\n// File:src/extras/curves/QuadraticBezierCurve.js\r\n\r\n/**************************************************************\r\n *\tQuadratic Bezier curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.QuadraticBezierCurve = function ( v0, v1, v2 ) {\r\n\r\n\tthis.v0 = v0;\r\n\tthis.v1 = v1;\r\n\tthis.v2 = v2;\r\n\r\n};\r\n\r\nTHREE.QuadraticBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.QuadraticBezierCurve.prototype.constructor = THREE.QuadraticBezierCurve;\r\n\r\n\r\nTHREE.QuadraticBezierCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar b2 = THREE.ShapeUtils.b2;\r\n\r\n\treturn new THREE.Vector2(\r\n\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\r\n\t\tb2( t, this.v0.y, this.v1.y, this.v2.y )\r\n\t);\r\n\r\n};\r\n\r\n\r\nTHREE.QuadraticBezierCurve.prototype.getTangent = function( t ) {\r\n\r\n\tvar tangentQuadraticBezier = THREE.CurveUtils.tangentQuadraticBezier;\r\n\r\n\treturn new THREE.Vector2(\r\n\t\ttangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),\r\n\t\ttangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )\r\n\t).normalize();\r\n\r\n};\r\n\r\n// File:src/extras/curves/CubicBezierCurve.js\r\n\r\n/**************************************************************\r\n *\tCubic Bezier curve\r\n **************************************************************/\r\n\r\nTHREE.CubicBezierCurve = function ( v0, v1, v2, v3 ) {\r\n\r\n\tthis.v0 = v0;\r\n\tthis.v1 = v1;\r\n\tthis.v2 = v2;\r\n\tthis.v3 = v3;\r\n\r\n};\r\n\r\nTHREE.CubicBezierCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.CubicBezierCurve.prototype.constructor = THREE.CubicBezierCurve;\r\n\r\nTHREE.CubicBezierCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar b3 = THREE.ShapeUtils.b3;\r\n\r\n\treturn new THREE.Vector2( \r\n\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\r\n\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\r\n\t);\r\n\r\n};\r\n\r\nTHREE.CubicBezierCurve.prototype.getTangent = function( t ) {\r\n\r\n\tvar tangentCubicBezier = THREE.CurveUtils.tangentCubicBezier;\r\n\r\n\treturn new THREE.Vector2( \r\n\t\ttangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\r\n\t\ttangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )\r\n\t).normalize();\r\n\r\n};\r\n\r\n// File:src/extras/curves/SplineCurve.js\r\n\r\n/**************************************************************\r\n *\tSpline curve\r\n **************************************************************/\r\n\r\nTHREE.SplineCurve = function ( points /* array of Vector2 */ ) {\r\n\r\n\tthis.points = ( points == undefined ) ? [] : points;\r\n\r\n};\r\n\r\nTHREE.SplineCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.SplineCurve.prototype.constructor = THREE.SplineCurve;\r\n\r\nTHREE.SplineCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar points = this.points;\r\n\tvar point = ( points.length - 1 ) * t;\r\n\r\n\tvar intPoint = Math.floor( point );\r\n\tvar weight = point - intPoint;\r\n\r\n\tvar point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];\r\n\tvar point1 = points[ intPoint ];\r\n\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\r\n\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\r\n\r\n\tvar interpolate = THREE.CurveUtils.interpolate;\r\n\r\n\treturn new THREE.Vector2(\r\n\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\r\n\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight )\r\n\t);\r\n\r\n};\r\n\r\n// File:src/extras/curves/EllipseCurve.js\r\n\r\n/**************************************************************\r\n *\tEllipse curve\r\n **************************************************************/\r\n\r\nTHREE.EllipseCurve = function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {\r\n\r\n\tthis.aX = aX;\r\n\tthis.aY = aY;\r\n\r\n\tthis.xRadius = xRadius;\r\n\tthis.yRadius = yRadius;\r\n\r\n\tthis.aStartAngle = aStartAngle;\r\n\tthis.aEndAngle = aEndAngle;\r\n\r\n\tthis.aClockwise = aClockwise;\r\n\t\r\n\tthis.aRotation = aRotation || 0;\r\n\r\n};\r\n\r\nTHREE.EllipseCurve.prototype = Object.create( THREE.Curve.prototype );\r\nTHREE.EllipseCurve.prototype.constructor = THREE.EllipseCurve;\r\n\r\nTHREE.EllipseCurve.prototype.getPoint = function ( t ) {\r\n\r\n\tvar deltaAngle = this.aEndAngle - this.aStartAngle;\r\n\r\n\tif ( deltaAngle < 0 ) deltaAngle += Math.PI * 2;\r\n\tif ( deltaAngle > Math.PI * 2 ) deltaAngle -= Math.PI * 2;\r\n\r\n\tvar angle;\r\n\r\n\tif ( this.aClockwise === true ) {\r\n\r\n\t\tangle = this.aEndAngle + ( 1 - t ) * ( Math.PI * 2 - deltaAngle );\r\n\r\n\t} else {\r\n\r\n\t\tangle = this.aStartAngle + t * deltaAngle;\r\n\r\n\t}\r\n\t\r\n\tvar x = this.aX + this.xRadius * Math.cos( angle );\r\n\tvar y = this.aY + this.yRadius * Math.sin( angle );\r\n\r\n\tif ( this.aRotation !== 0 ) {\r\n\r\n\t\tvar cos = Math.cos( this.aRotation );\r\n\t\tvar sin = Math.sin( this.aRotation );\r\n\r\n\t\tvar tx = x, ty = y;\r\n\r\n\t\t// Rotate the point about the center of the ellipse.\r\n\t\tx = ( tx - this.aX ) * cos - ( ty - this.aY ) * sin + this.aX;\r\n\t\ty = ( tx - this.aX ) * sin + ( ty - this.aY ) * cos + this.aY;\r\n\r\n\t}\r\n\r\n\treturn new THREE.Vector2( x, y );\r\n\r\n};\r\n\r\n// File:src/extras/curves/ArcCurve.js\r\n\r\n/**************************************************************\r\n *\tArc curve\r\n **************************************************************/\r\n\r\nTHREE.ArcCurve = function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {\r\n\r\n\tTHREE.EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );\r\n\r\n};\r\n\r\nTHREE.ArcCurve.prototype = Object.create( THREE.EllipseCurve.prototype );\r\nTHREE.ArcCurve.prototype.constructor = THREE.ArcCurve;\r\n\r\n// File:src/extras/curves/LineCurve3.js\r\n\r\n/**************************************************************\r\n *\tLine3D\r\n **************************************************************/\r\n\r\nTHREE.LineCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( v1, v2 ) {\r\n\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar vector = new THREE.Vector3();\r\n\r\n\t\tvector.subVectors( this.v2, this.v1 ); // diff\r\n\t\tvector.multiplyScalar( t );\r\n\t\tvector.add( this.v1 );\r\n\r\n\t\treturn vector;\r\n\r\n\t}\r\n\r\n);\r\n\r\n// File:src/extras/curves/QuadraticBezierCurve3.js\r\n\r\n/**************************************************************\r\n *\tQuadratic Bezier 3D curve\r\n **************************************************************/\r\n\r\nTHREE.QuadraticBezierCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( v0, v1, v2 ) {\r\n\r\n\t\tthis.v0 = v0;\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar b2 = THREE.ShapeUtils.b2;\t\t\r\n\r\n\t\treturn new THREE.Vector3(\r\n\t\t\tb2( t, this.v0.x, this.v1.x, this.v2.x ),\r\n\t\t\tb2( t, this.v0.y, this.v1.y, this.v2.y ),\r\n\t\t\tb2( t, this.v0.z, this.v1.z, this.v2.z )\r\n\t\t);\r\n\r\n\t}\r\n\r\n);\r\n\r\n// File:src/extras/curves/CubicBezierCurve3.js\r\n\r\n/**************************************************************\r\n *\tCubic Bezier 3D curve\r\n **************************************************************/\r\n\r\nTHREE.CubicBezierCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( v0, v1, v2, v3 ) {\r\n\r\n\t\tthis.v0 = v0;\r\n\t\tthis.v1 = v1;\r\n\t\tthis.v2 = v2;\r\n\t\tthis.v3 = v3;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar b3 = THREE.ShapeUtils.b3;\r\n\r\n\t\treturn new THREE.Vector3(\r\n\t\t\tb3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),\r\n\t\t\tb3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),\r\n\t\t\tb3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )\r\n\t\t);\r\n\r\n\t}\r\n\r\n);\r\n\r\n// File:src/extras/curves/SplineCurve3.js\r\n\r\n/**************************************************************\r\n *\tSpline 3D curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.SplineCurve3 = THREE.Curve.create(\r\n\r\n\tfunction ( points /* array of Vector3 */ ) {\r\n\r\n\t\tconsole.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );\r\n\t\tthis.points = ( points == undefined ) ? [] : points;\r\n\r\n\t},\r\n\r\n\tfunction ( t ) {\r\n\r\n\t\tvar points = this.points;\r\n\t\tvar point = ( points.length - 1 ) * t;\r\n\r\n\t\tvar intPoint = Math.floor( point );\r\n\t\tvar weight = point - intPoint;\r\n\r\n\t\tvar point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];\r\n\t\tvar point1 = points[ intPoint ];\r\n\t\tvar point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];\r\n\t\tvar point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];\r\n\r\n\t\tvar interpolate = THREE.CurveUtils.interpolate;\r\n\r\n\t\treturn new THREE.Vector3(\r\n\t\t\tinterpolate( point0.x, point1.x, point2.x, point3.x, weight ),\r\n\t\t\tinterpolate( point0.y, point1.y, point2.y, point3.y, weight ),\r\n\t\t\tinterpolate( point0.z, point1.z, point2.z, point3.z, weight )\r\n\t\t);\r\n\r\n\t}\r\n\r\n);\r\n\r\n// File:src/extras/curves/CatmullRomCurve3.js\r\n\r\n/**\r\n * @author zz85 https://github.com/zz85\r\n *\r\n * Centripetal CatmullRom Curve - which is useful for avoiding\r\n * cusps and self-intersections in non-uniform catmull rom curves.\r\n * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf\r\n *\r\n * curve.type accepts centripetal(default), chordal and catmullrom\r\n * curve.tension is used for catmullrom which defaults to 0.5\r\n */\r\n\r\nTHREE.CatmullRomCurve3 = ( function() {\r\n\r\n\tvar\r\n\t\ttmp = new THREE.Vector3(),\r\n\t\tpx = new CubicPoly(),\r\n\t\tpy = new CubicPoly(),\r\n\t\tpz = new CubicPoly();\r\n\r\n\t/*\r\n\tBased on an optimized c++ solution in\r\n\t - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/\r\n\t - http://ideone.com/NoEbVM\r\n\r\n\tThis CubicPoly class could be used for reusing some variables and calculations,\r\n\tbut for three.js curve use, it could be possible inlined and flatten into a single function call\r\n\twhich can be placed in CurveUtils.\r\n\t*/\r\n\r\n\tfunction CubicPoly() {\r\n\r\n\t}\r\n\r\n\t/*\r\n\t * Compute coefficients for a cubic polynomial\r\n\t *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3\r\n\t * such that\r\n\t *   p(0) = x0, p(1) = x1\r\n\t *  and\r\n\t *   p'(0) = t0, p'(1) = t1.\r\n\t */\r\n\tCubicPoly.prototype.init = function( x0, x1, t0, t1 ) {\r\n\r\n\t\tthis.c0 = x0;\r\n\t\tthis.c1 = t0;\r\n\t\tthis.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;\r\n\t\tthis.c3 = 2 * x0 - 2 * x1 + t0 + t1;\r\n\r\n\t};\r\n\r\n\tCubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {\r\n\r\n\t\t// compute tangents when parameterized in [t1,t2]\r\n\t\tvar t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;\r\n\t\tvar t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;\r\n\r\n\t\t// rescale tangents for parametrization in [0,1]\r\n\t\tt1 *= dt1;\r\n\t\tt2 *= dt1;\r\n\r\n\t\t// initCubicPoly\r\n\t\tthis.init( x1, x2, t1, t2 );\r\n\r\n\t};\r\n\r\n\t// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4\r\n\tCubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {\r\n\r\n\t\tthis.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );\r\n\r\n\t};\r\n\r\n\tCubicPoly.prototype.calc = function( t ) {\r\n\r\n\t\tvar t2 = t * t;\r\n\t\tvar t3 = t2 * t;\r\n\t\treturn this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;\r\n\r\n\t};\r\n\r\n\t// Subclass Three.js curve\r\n\treturn THREE.Curve.create(\r\n\r\n\t\tfunction ( p /* array of Vector3 */ ) {\r\n\r\n\t\t\tthis.points = p || [];\r\n\t\t\tthis.closed = false;\r\n\r\n\t\t},\r\n\r\n\t\tfunction ( t ) {\r\n\r\n\t\t\tvar points = this.points,\r\n\t\t\t\tpoint, intPoint, weight, l;\r\n\r\n\t\t\tl = points.length;\r\n\r\n\t\t\tif ( l < 2 ) console.log( 'duh, you need at least 2 points' );\r\n\r\n\t\t\tpoint = ( l - ( this.closed ? 0 : 1 ) ) * t;\r\n\t\t\tintPoint = Math.floor( point );\r\n\t\t\tweight = point - intPoint;\r\n\r\n\t\t\tif ( this.closed ) {\r\n\r\n\t\t\t\tintPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;\r\n\r\n\t\t\t} else if ( weight === 0 && intPoint === l - 1 ) {\r\n\r\n\t\t\t\tintPoint = l - 2;\r\n\t\t\t\tweight = 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar p0, p1, p2, p3; // 4 points\r\n\r\n\t\t\tif ( this.closed || intPoint > 0 ) {\r\n\r\n\t\t\t\tp0 = points[ ( intPoint - 1 ) % l ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// extrapolate first point\r\n\t\t\t\ttmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );\r\n\t\t\t\tp0 = tmp;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tp1 = points[ intPoint % l ];\r\n\t\t\tp2 = points[ ( intPoint + 1 ) % l ];\r\n\r\n\t\t\tif ( this.closed || intPoint + 2 < l ) {\r\n\r\n\t\t\t\tp3 = points[ ( intPoint + 2 ) % l ];\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// extrapolate last point\r\n\t\t\t\ttmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );\r\n\t\t\t\tp3 = tmp;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {\r\n\r\n\t\t\t\t// init Centripetal / Chordal Catmull-Rom\r\n\t\t\t\tvar pow = this.type === 'chordal' ? 0.5 : 0.25;\r\n\t\t\t\tvar dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );\r\n\t\t\t\tvar dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );\r\n\t\t\t\tvar dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );\r\n\r\n\t\t\t\t// safety check for repeated points\r\n\t\t\t\tif ( dt1 < 1e-4 ) dt1 = 1.0;\r\n\t\t\t\tif ( dt0 < 1e-4 ) dt0 = dt1;\r\n\t\t\t\tif ( dt2 < 1e-4 ) dt2 = dt1;\r\n\r\n\t\t\t\tpx.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );\r\n\t\t\t\tpy.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );\r\n\t\t\t\tpz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );\r\n\r\n\t\t\t} else if ( this.type === 'catmullrom' ) {\r\n\r\n\t\t\t\tvar tension = this.tension !== undefined ? this.tension : 0.5;\r\n\t\t\t\tpx.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );\r\n\t\t\t\tpy.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );\r\n\t\t\t\tpz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar v = new THREE.Vector3(\r\n\t\t\t\tpx.calc( weight ),\r\n\t\t\t\tpy.calc( weight ),\r\n\t\t\t\tpz.calc( weight )\r\n\t\t\t);\r\n\r\n\t\t\treturn v;\r\n\r\n\t\t}\r\n\r\n\t);\r\n\r\n} )();\r\n\r\n// File:src/extras/curves/ClosedSplineCurve3.js\r\n\r\n/**************************************************************\r\n *\tClosed Spline 3D curve\r\n **************************************************************/\r\n\r\n\r\nTHREE.ClosedSplineCurve3 = function ( points ) {\r\n\r\n\tconsole.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Please use THREE.CatmullRomCurve3.' );\r\n\r\n\tTHREE.CatmullRomCurve3.call( this, points );\r\n\tthis.type = 'catmullrom';\r\n\tthis.closed = true;\r\n\r\n};\r\n\r\nTHREE.ClosedSplineCurve3.prototype = Object.create( THREE.CatmullRomCurve3.prototype );\r\n\r\n// File:src/extras/geometries/BoxGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as\r\n */\r\n\r\nTHREE.BoxGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'BoxGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\twidth: width,\r\n\t\theight: height,\r\n\t\tdepth: depth,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\tdepthSegments: depthSegments\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new THREE.BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );\r\n\tthis.mergeVertices();\r\n\r\n};\r\n\r\nTHREE.BoxGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.BoxGeometry.prototype.constructor = THREE.BoxGeometry;\r\n\r\nTHREE.CubeGeometry = THREE.BoxGeometry;\r\n\r\n// File:src/extras/geometries/BoxBufferGeometry.js\r\n\r\n/**\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\n\r\nTHREE.BoxBufferGeometry = function ( width, height, depth, widthSegments, heightSegments, depthSegments ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'BoxBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\twidth: width,\r\n\t\theight: height,\r\n\t\tdepth: depth,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\tdepthSegments: depthSegments\r\n\t};\r\n\r\n\tvar scope = this;\r\n\r\n\t// segments\r\n\twidthSegments = Math.floor( widthSegments ) || 1;\r\n\theightSegments = Math.floor( heightSegments ) || 1;\r\n\tdepthSegments = Math.floor( depthSegments ) || 1;\r\n\r\n\t// these are used to calculate buffer length\r\n\tvar vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );\r\n\tvar indexCount = calculateIndexCount( widthSegments, heightSegments, depthSegments );\r\n\r\n\t// buffers\r\n\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\r\n\tvar vertices = new Float32Array( vertexCount * 3 );\r\n\tvar normals = new Float32Array( vertexCount * 3 );\r\n\tvar uvs = new Float32Array( vertexCount * 2 );\r\n\r\n\t// offset variables\r\n\tvar vertexBufferOffset = 0;\r\n\tvar uvBufferOffset = 0;\r\n\tvar indexBufferOffset = 0;\r\n\tvar numberOfVertices = 0;\r\n\r\n\t// group variables\r\n\tvar groupStart = 0;\r\n\r\n\t// build each side of the box geometry\r\n\tbuildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px\r\n\tbuildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx\r\n\tbuildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py\r\n\tbuildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny\r\n\tbuildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz\r\n\tbuildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz\r\n\r\n\t// build geometry\r\n\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\r\n\t// helper functions\r\n\r\n\tfunction calculateVertexCount ( w, h, d ) {\r\n\r\n\t\tvar vertices = 0;\r\n\r\n\t\t// calculate the amount of vertices for each side (plane)\r\n\t\tvertices += (w + 1) * (h + 1) * 2; // xy\r\n\t\tvertices += (w + 1) * (d + 1) * 2; // xz\r\n\t\tvertices += (d + 1) * (h + 1) * 2; // zy\r\n\r\n\t\treturn vertices;\r\n\r\n\t}\r\n\r\n\tfunction calculateIndexCount ( w, h, d ) {\r\n\r\n\t\tvar index = 0;\r\n\r\n\t\t// calculate the amount of squares for each side\r\n\t\tindex += w * h * 2; // xy\r\n\t\tindex += w * d * 2; // xz\r\n\t\tindex += d * h * 2; // zy\r\n\r\n\t\treturn index * 6; // two triangles per square => six vertices per square\r\n\r\n\t}\r\n\r\n\tfunction buildPlane ( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {\r\n\r\n\t\tvar segmentWidth\t= width / gridX;\r\n\t\tvar segmentHeight = height / gridY;\r\n\r\n\t\tvar widthHalf = width / 2;\r\n\t\tvar heightHalf = height / 2;\r\n\t\tvar depthHalf = depth / 2;\r\n\r\n\t\tvar gridX1 = gridX + 1;\r\n\t\tvar gridY1 = gridY + 1;\r\n\r\n\t\tvar vertexCounter = 0;\r\n\t\tvar groupCount = 0;\r\n\r\n\t\tvar vector = new THREE.Vector3();\r\n\r\n\t\t// generate vertices, normals and uvs\r\n\r\n\t\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\r\n\r\n\t\t\tvar y = iy * segmentHeight - heightHalf;\r\n\r\n\t\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\r\n\r\n\t\t\t\tvar x = ix * segmentWidth - widthHalf;\r\n\r\n\t\t\t\t// set values to correct vector component\r\n\t\t\t\tvector[ u ] = x * udir;\r\n\t\t\t\tvector[ v ] = y * vdir;\r\n\t\t\t\tvector[ w ] = depthHalf;\r\n\r\n\t\t\t\t// now apply vector to vertex buffer\r\n\t\t\t\tvertices[ vertexBufferOffset ] = vector.x;\r\n\t\t\t\tvertices[ vertexBufferOffset + 1 ] = vector.y;\r\n\t\t\t\tvertices[ vertexBufferOffset + 2 ] = vector.z;\r\n\r\n\t\t\t\t// set values to correct vector component\r\n\t\t\t\tvector[ u ] = 0;\r\n\t\t\t\tvector[ v ] = 0;\r\n\t\t\t\tvector[ w ] = depth > 0 ? 1 : - 1;\r\n\r\n\t\t\t\t// now apply vector to normal buffer\r\n\t\t\t\tnormals[ vertexBufferOffset ] = vector.x;\r\n\t\t\t\tnormals[ vertexBufferOffset + 1 ] = vector.y;\r\n\t\t\t\tnormals[ vertexBufferOffset + 2 ] = vector.z;\r\n\r\n\t\t\t\t// uvs\r\n\t\t\t\tuvs[ uvBufferOffset ] = ix / gridX;\r\n\t\t\t\tuvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );\r\n\r\n\t\t\t\t// update offsets and counters\r\n\t\t\t\tvertexBufferOffset += 3;\r\n\t\t\t\tuvBufferOffset += 2;\r\n\t\t\t\tvertexCounter += 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// 1. you need three indices to draw a single face\r\n\t\t// 2. a single segment consists of two faces\r\n\t\t// 3. so we need to generate six (2*3) indices per segment\r\n\r\n\t\tfor ( iy = 0; iy < gridY; iy ++ ) {\r\n\r\n\t\t\tfor ( ix = 0; ix < gridX; ix ++ ) {\r\n\r\n\t\t\t\t// indices\r\n\t\t\t\tvar a = numberOfVertices + ix + gridX1 * iy;\r\n\t\t\t\tvar b = numberOfVertices + ix + gridX1 * ( iy + 1 );\r\n\t\t\t\tvar c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n\t\t\t\tvar d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;\r\n\r\n\t\t\t\t// face one\r\n\t\t\t\tindices[ indexBufferOffset ] = a;\r\n\t\t\t\tindices[ indexBufferOffset + 1 ] = b;\r\n\t\t\t\tindices[ indexBufferOffset + 2 ] = d;\r\n\r\n\t\t\t\t// face two\r\n\t\t\t\tindices[ indexBufferOffset + 3 ] = b;\r\n\t\t\t\tindices[ indexBufferOffset + 4 ] = c;\r\n\t\t\t\tindices[ indexBufferOffset + 5 ] = d;\r\n\r\n\t\t\t\t// update offsets and counters\r\n\t\t\t\tindexBufferOffset += 6;\r\n\t\t\t\tgroupCount += 6;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// add a group to the geometry. this will ensure multi material support\r\n\t\tscope.addGroup( groupStart, groupCount, materialIndex );\r\n\r\n\t\t// calculate new start value for groups\r\n\t\tgroupStart += groupCount;\r\n\r\n\t\t// update total number of vertices\r\n\t\tnumberOfVertices += vertexCounter;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.BoxBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.BoxBufferGeometry.prototype.constructor = THREE.BoxBufferGeometry;\r\n\r\n// File:src/extras/geometries/CircleGeometry.js\r\n\r\n/**\r\n * @author hughes\r\n */\r\n\r\nTHREE.CircleGeometry = function ( radius, segments, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'CircleGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tsegments: segments,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new THREE.CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );\r\n\r\n};\r\n\r\nTHREE.CircleGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.CircleGeometry.prototype.constructor = THREE.CircleGeometry;\r\n\r\n// File:src/extras/geometries/CircleBufferGeometry.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n */\r\n\r\nTHREE.CircleBufferGeometry = function ( radius, segments, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'CircleBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tsegments: segments,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tradius = radius || 50;\r\n\tsegments = segments !== undefined ? Math.max( 3, segments ) : 8;\r\n\r\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\r\n\tvar vertices = segments + 2;\r\n\r\n\tvar positions = new Float32Array( vertices * 3 );\r\n\tvar normals = new Float32Array( vertices * 3 );\r\n\tvar uvs = new Float32Array( vertices * 2 );\r\n\r\n\t// center data is already zero, but need to set a few extras\r\n\tnormals[ 2 ] = 1.0;\r\n\tuvs[ 0 ] = 0.5;\r\n\tuvs[ 1 ] = 0.5;\r\n\r\n\tfor ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {\r\n\r\n\t\tvar segment = thetaStart + s / segments * thetaLength;\r\n\r\n\t\tpositions[ i ] = radius * Math.cos( segment );\r\n\t\tpositions[ i + 1 ] = radius * Math.sin( segment );\r\n\r\n\t\tnormals[ i + 2 ] = 1; // normal z\r\n\r\n\t\tuvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;\r\n\t\tuvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;\r\n\r\n\t}\r\n\r\n\tvar indices = [];\r\n\r\n\tfor ( var i = 1; i <= segments; i ++ ) {\r\n\r\n\t\tindices.push( i, i + 1, 0 );\r\n\r\n\t}\r\n\r\n\tthis.setIndex( new THREE.BufferAttribute( new Uint16Array( indices ), 1 ) );\r\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\r\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\r\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.CircleBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.CircleBufferGeometry.prototype.constructor = THREE.CircleBufferGeometry;\r\n\r\n// File:src/extras/geometries/CylinderBufferGeometry.js\r\n\r\n/**\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\n\r\nTHREE.CylinderBufferGeometry = function( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'CylinderBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradiusTop: radiusTop,\r\n\t\tradiusBottom: radiusBottom,\r\n\t\theight: height,\r\n\t\tradialSegments: radialSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\topenEnded: openEnded,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tvar scope = this;\r\n\r\n\tradiusTop = radiusTop !== undefined ? radiusTop : 20;\r\n\tradiusBottom = radiusBottom !== undefined ? radiusBottom : 20;\r\n\theight = height !== undefined ? height : 100;\r\n\r\n\tradialSegments = Math.floor( radialSegments ) || 8;\r\n\theightSegments = Math.floor( heightSegments ) || 1;\r\n\r\n\topenEnded = openEnded !== undefined ? openEnded : false;\r\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0.0;\r\n\tthetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;\r\n\r\n\t// used to calculate buffer length\r\n\r\n\tvar nbCap = 0;\r\n\r\n\tif ( openEnded === false ) {\r\n\r\n\t\tif ( radiusTop > 0 ) nbCap ++;\r\n\t\tif ( radiusBottom > 0 ) nbCap ++;\r\n\r\n\t}\r\n\r\n\tvar vertexCount = calculateVertexCount();\r\n\tvar indexCount = calculateIndexCount();\r\n\r\n\t// buffers\r\n\r\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );\r\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\r\n\t// helper variables\r\n\r\n\tvar index = 0,\r\n\t    indexOffset = 0,\r\n\t    indexArray = [],\r\n\t    halfHeight = height / 2;\r\n\r\n\t// group variables\r\n\tvar groupStart = 0;\r\n\r\n\t// generate geometry\r\n\r\n\tgenerateTorso();\r\n\r\n\tif ( openEnded === false ) {\r\n\r\n\t\tif ( radiusTop > 0 ) generateCap( true );\r\n\t\tif ( radiusBottom > 0 ) generateCap( false );\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\r\n\tthis.setIndex( indices );\r\n\tthis.addAttribute( 'position', vertices );\r\n\tthis.addAttribute( 'normal', normals );\r\n\tthis.addAttribute( 'uv', uvs );\r\n\r\n\t// helper functions\r\n\r\n\tfunction calculateVertexCount() {\r\n\r\n\t\tvar count = ( radialSegments + 1 ) * ( heightSegments + 1 );\r\n\r\n\t\tif ( openEnded === false ) {\r\n\r\n\t\t\tcount += ( ( radialSegments + 1 ) * nbCap ) + ( radialSegments * nbCap );\r\n\r\n\t\t}\r\n\r\n\t\treturn count;\r\n\r\n\t}\r\n\r\n\tfunction calculateIndexCount() {\r\n\r\n\t\tvar count = radialSegments * heightSegments * 2 * 3;\r\n\r\n\t\tif ( openEnded === false ) {\r\n\r\n\t\t\tcount += radialSegments * nbCap * 3;\r\n\r\n\t\t}\r\n\r\n\t\treturn count;\r\n\r\n\t}\r\n\r\n\tfunction generateTorso() {\r\n\r\n\t\tvar x, y;\r\n\t\tvar normal = new THREE.Vector3();\r\n\t\tvar vertex = new THREE.Vector3();\r\n\r\n\t\tvar groupCount = 0;\r\n\r\n\t\t// this will be used to calculate the normal\r\n\t\tvar tanTheta = ( radiusBottom - radiusTop ) / height;\r\n\r\n\t\t// generate vertices, normals and uvs\r\n\r\n\t\tfor ( y = 0; y <= heightSegments; y ++ ) {\r\n\r\n\t\t\tvar indexRow = [];\r\n\r\n\t\t\tvar v = y / heightSegments;\r\n\r\n\t\t\t// calculate the radius of the current row\r\n\t\t\tvar radius = v * ( radiusBottom - radiusTop ) + radiusTop;\r\n\r\n\t\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\r\n\r\n\t\t\t\tvar u = x / radialSegments;\r\n\r\n\t\t\t\t// vertex\r\n\t\t\t\tvertex.x = radius * Math.sin( u * thetaLength + thetaStart );\r\n\t\t\t\tvertex.y = - v * height + halfHeight;\r\n\t\t\t\tvertex.z = radius * Math.cos( u * thetaLength + thetaStart );\r\n\t\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t\t// normal\r\n\t\t\t\tnormal.copy( vertex );\r\n\r\n\t\t\t\t// handle special case if radiusTop/radiusBottom is zero\r\n\r\n\t\t\t\tif ( ( radiusTop === 0 && y === 0 ) || ( radiusBottom === 0 && y === heightSegments ) ) {\r\n\r\n\t\t\t\t\tnormal.x = Math.sin( u * thetaLength + thetaStart );\r\n\t\t\t\t\tnormal.z = Math.cos( u * thetaLength + thetaStart );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tnormal.setY( Math.sqrt( normal.x * normal.x + normal.z * normal.z ) * tanTheta ).normalize();\r\n\t\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\r\n\r\n\t\t\t\t// uv\r\n\t\t\t\tuvs.setXY( index, u, 1 - v );\r\n\r\n\t\t\t\t// save index of vertex in respective row\r\n\t\t\t\tindexRow.push( index );\r\n\r\n\t\t\t\t// increase index\r\n\t\t\t\tindex ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// now save vertices of the row in our index array\r\n\t\t\tindexArray.push( indexRow );\r\n\r\n\t\t}\r\n\r\n\t\t// generate indices\r\n\r\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\r\n\r\n\t\t\tfor ( y = 0; y < heightSegments; y ++ ) {\r\n\r\n\t\t\t\t// we use the index array to access the correct indices\r\n\t\t\t\tvar i1 = indexArray[ y ][ x ];\r\n\t\t\t\tvar i2 = indexArray[ y + 1 ][ x ];\r\n\t\t\t\tvar i3 = indexArray[ y + 1 ][ x + 1 ];\r\n\t\t\t\tvar i4 = indexArray[ y ][ x + 1 ];\r\n\r\n\t\t\t\t// face one\r\n\t\t\t\tindices.setX( indexOffset, i1 ); indexOffset ++;\r\n\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\r\n\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\r\n\r\n\t\t\t\t// face two\r\n\t\t\t\tindices.setX( indexOffset, i2 ); indexOffset ++;\r\n\t\t\t\tindices.setX( indexOffset, i3 ); indexOffset ++;\r\n\t\t\t\tindices.setX( indexOffset, i4 ); indexOffset ++;\r\n\r\n\t\t\t\t// update counters\r\n\t\t\t\tgroupCount += 6;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// add a group to the geometry. this will ensure multi material support\r\n\t\tscope.addGroup( groupStart, groupCount, 0 );\r\n\r\n\t\t// calculate new start value for groups\r\n\t\tgroupStart += groupCount;\r\n\r\n\t}\r\n\r\n\tfunction generateCap( top ) {\r\n\r\n\t\tvar x, centerIndexStart, centerIndexEnd;\r\n\r\n\t\tvar uv = new THREE.Vector2();\r\n\t\tvar vertex = new THREE.Vector3();\r\n\r\n\t\tvar groupCount = 0;\r\n\r\n\t\tvar radius = ( top === true ) ? radiusTop : radiusBottom;\r\n\t\tvar sign = ( top === true ) ? 1 : - 1;\r\n\r\n\t\t// save the index of the first center vertex\r\n\t\tcenterIndexStart = index;\r\n\r\n\t\t// first we generate the center vertex data of the cap.\r\n\t\t// because the geometry needs one set of uvs per face,\r\n\t\t// we must generate a center vertex per face/segment\r\n\r\n\t\tfor ( x = 1; x <= radialSegments; x ++ ) {\r\n\r\n\t\t\t// vertex\r\n\t\t\tvertices.setXYZ( index, 0, halfHeight * sign, 0 );\r\n\r\n\t\t\t// normal\r\n\t\t\tnormals.setXYZ( index, 0, sign, 0 );\r\n\r\n\t\t\t// uv\r\n\t\t\tuv.x = 0.5;\r\n\t\t\tuv.y = 0.5;\r\n\r\n\t\t\tuvs.setXY( index, uv.x, uv.y );\r\n\r\n\t\t\t// increase index\r\n\t\t\tindex ++;\r\n\r\n\t\t}\r\n\r\n\t\t// save the index of the last center vertex\r\n\t\tcenterIndexEnd = index;\r\n\r\n\t\t// now we generate the surrounding vertices, normals and uvs\r\n\r\n\t\tfor ( x = 0; x <= radialSegments; x ++ ) {\r\n\r\n\t\t\tvar u = x / radialSegments;\r\n\t\t\tvar theta = u * thetaLength + thetaStart;\r\n\r\n\t\t\tvar cosTheta = Math.cos( theta );\r\n\t\t\tvar sinTheta = Math.sin( theta );\r\n\r\n\t\t\t// vertex\r\n\t\t\tvertex.x = radius * sinTheta;\r\n\t\t\tvertex.y = halfHeight * sign;\r\n\t\t\tvertex.z = radius * cosTheta;\r\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t// normal\r\n\t\t\tnormals.setXYZ( index, 0, sign, 0 );\r\n\r\n\t\t\t// uv\r\n\t\t\tuv.x = ( cosTheta * 0.5 ) + 0.5;\r\n\t\t\tuv.y = ( sinTheta * 0.5 * sign ) + 0.5;\r\n\t\t\tuvs.setXY( index, uv.x, uv.y );\r\n\r\n\t\t\t// increase index\r\n\t\t\tindex ++;\r\n\r\n\t\t}\r\n\r\n\t\t// generate indices\r\n\r\n\t\tfor ( x = 0; x < radialSegments; x ++ ) {\r\n\r\n\t\t\tvar c = centerIndexStart + x;\r\n\t\t\tvar i = centerIndexEnd + x;\r\n\r\n\t\t\tif ( top === true ) {\r\n\r\n\t\t\t\t// face top\r\n\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\r\n\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\r\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// face bottom\r\n\t\t\t\tindices.setX( indexOffset, i + 1 ); indexOffset ++;\r\n\t\t\t\tindices.setX( indexOffset, i ); indexOffset ++;\r\n\t\t\t\tindices.setX( indexOffset, c ); indexOffset ++;\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// update counters\r\n\t\t\tgroupCount += 3;\r\n\r\n\t\t}\r\n\r\n\t\t// add a group to the geometry. this will ensure multi material support\r\n\t\tscope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );\r\n\r\n\t\t// calculate new start value for groups\r\n\t\tgroupStart += groupCount;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.CylinderBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.CylinderBufferGeometry.prototype.constructor = THREE.CylinderBufferGeometry;\r\n\r\n// File:src/extras/geometries/CylinderGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.CylinderGeometry = function ( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'CylinderGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradiusTop: radiusTop,\r\n\t\tradiusBottom: radiusBottom,\r\n\t\theight: height,\r\n\t\tradialSegments: radialSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\topenEnded: openEnded,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new THREE.CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );\r\n\tthis.mergeVertices();\r\n\r\n};\r\n\r\nTHREE.CylinderGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.CylinderGeometry.prototype.constructor = THREE.CylinderGeometry;\r\n\r\n// File:src/extras/geometries/ConeBufferGeometry.js\r\n\r\n/*\r\n * @author: abelnation / http://github.com/abelnation\r\n */\r\n\r\nTHREE.ConeBufferGeometry = function (\r\n\tradius, height,\r\n\tradialSegments, heightSegments,\r\n\topenEnded, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.CylinderBufferGeometry.call( this,\r\n\t\t0, radius, height,\r\n\t\tradialSegments, heightSegments,\r\n\t\topenEnded, thetaStart, thetaLength );\r\n\r\n\tthis.type = 'ConeBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\theight: height,\r\n\t\tradialSegments: radialSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n};\r\n\r\nTHREE.ConeBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.ConeBufferGeometry.prototype.constructor = THREE.ConeBufferGeometry;\r\n\r\n// File:src/extras/geometries/ConeGeometry.js\r\n\r\n/**\r\n * @author abelnation / http://github.com/abelnation\r\n */\r\n\r\nTHREE.ConeGeometry = function (\r\n\tradius, height,\r\n\tradialSegments, heightSegments,\r\n\topenEnded, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.CylinderGeometry.call( this,\r\n\t\t0, radius, height,\r\n\t\tradialSegments, heightSegments,\r\n\t\topenEnded, thetaStart, thetaLength );\r\n\r\n\tthis.type = 'ConeGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\theight: height,\r\n\t\tradialSegments: radialSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\topenEnded: openEnded,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n};\r\n\r\nTHREE.ConeGeometry.prototype = Object.create( THREE.CylinderGeometry.prototype );\r\nTHREE.ConeGeometry.prototype.constructor = THREE.ConeGeometry;\r\n\r\n// File:src/extras/geometries/EdgesGeometry.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.EdgesGeometry = function ( geometry, thresholdAngle ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;\r\n\r\n\tvar thresholdDot = Math.cos( THREE.Math.DEG2RAD * thresholdAngle );\r\n\r\n\tvar edge = [ 0, 0 ], hash = {};\r\n\r\n\tfunction sortFunction( a, b ) {\r\n\r\n\t\treturn a - b;\r\n\r\n\t}\r\n\r\n\tvar keys = [ 'a', 'b', 'c' ];\r\n\r\n\tvar geometry2;\r\n\r\n\tif ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\tgeometry2 = new THREE.Geometry();\r\n\t\tgeometry2.fromBufferGeometry( geometry );\r\n\r\n\t} else {\r\n\r\n\t\tgeometry2 = geometry.clone();\r\n\r\n\t}\r\n\r\n\tgeometry2.mergeVertices();\r\n\tgeometry2.computeFaceNormals();\r\n\r\n\tvar vertices = geometry2.vertices;\r\n\tvar faces = geometry2.faces;\r\n\r\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\tvar face = faces[ i ];\r\n\r\n\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\tedge[ 0 ] = face[ keys[ j ] ];\r\n\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\r\n\t\t\tedge.sort( sortFunction );\r\n\r\n\t\t\tvar key = edge.toString();\r\n\r\n\t\t\tif ( hash[ key ] === undefined ) {\r\n\r\n\t\t\t\thash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\thash[ key ].face2 = i;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar coords = [];\r\n\r\n\tfor ( var key in hash ) {\r\n\r\n\t\tvar h = hash[ key ];\r\n\r\n\t\tif ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {\r\n\r\n\t\t\tvar vertex = vertices[ h.vert1 ];\r\n\t\t\tcoords.push( vertex.x );\r\n\t\t\tcoords.push( vertex.y );\r\n\t\t\tcoords.push( vertex.z );\r\n\r\n\t\t\tvertex = vertices[ h.vert2 ];\r\n\t\t\tcoords.push( vertex.x );\r\n\t\t\tcoords.push( vertex.y );\r\n\t\t\tcoords.push( vertex.z );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( new Float32Array( coords ), 3 ) );\r\n\r\n};\r\n\r\nTHREE.EdgesGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.EdgesGeometry.prototype.constructor = THREE.EdgesGeometry;\r\n\r\n// File:src/extras/geometries/ExtrudeGeometry.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n *\r\n * Creates extruded geometry from a path shape.\r\n *\r\n * parameters = {\r\n *\r\n *  curveSegments: <int>, // number of points on the curves\r\n *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too\r\n *  amount: <int>, // Depth to extrude the shape\r\n *\r\n *  bevelEnabled: <bool>, // turn on bevel\r\n *  bevelThickness: <float>, // how deep into the original shape bevel goes\r\n *  bevelSize: <float>, // how far from shape outline is bevel\r\n *  bevelSegments: <int>, // number of bevel layers\r\n *\r\n *  extrudePath: <THREE.CurvePath> // 3d spline path to extrude shape along. (creates Frames if .frames aren't defined)\r\n *  frames: <THREE.TubeGeometry.FrenetFrames> // containing arrays of tangents, normals, binormals\r\n *\r\n *  uvGenerator: <Object> // object that provides UV generator functions\r\n *\r\n * }\r\n **/\r\n\r\nTHREE.ExtrudeGeometry = function ( shapes, options ) {\r\n\r\n\tif ( typeof( shapes ) === \"undefined\" ) {\r\n\r\n\t\tshapes = [];\r\n\t\treturn;\r\n\r\n\t}\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'ExtrudeGeometry';\r\n\r\n\tshapes = Array.isArray( shapes ) ? shapes : [ shapes ];\r\n\r\n\tthis.addShapeList( shapes, options );\r\n\r\n\tthis.computeFaceNormals();\r\n\r\n\t// can't really use automatic vertex normals\r\n\t// as then front and back sides get smoothed too\r\n\t// should do separate smoothing just for sides\r\n\r\n\t//this.computeVertexNormals();\r\n\r\n\t//console.log( \"took\", ( Date.now() - startTime ) );\r\n\r\n};\r\n\r\nTHREE.ExtrudeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.ExtrudeGeometry.prototype.constructor = THREE.ExtrudeGeometry;\r\n\r\nTHREE.ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\r\n\tvar sl = shapes.length;\r\n\r\n\tfor ( var s = 0; s < sl; s ++ ) {\r\n\r\n\t\tvar shape = shapes[ s ];\r\n\t\tthis.addShape( shape, options );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.ExtrudeGeometry.prototype.addShape = function ( shape, options ) {\r\n\r\n\tvar amount = options.amount !== undefined ? options.amount : 100;\r\n\r\n\tvar bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10\r\n\tvar bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8\r\n\tvar bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;\r\n\r\n\tvar bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false\r\n\r\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\r\n\tvar steps = options.steps !== undefined ? options.steps : 1;\r\n\r\n\tvar extrudePath = options.extrudePath;\r\n\tvar extrudePts, extrudeByPath = false;\r\n\r\n\t// Use default WorldUVGenerator if no UV generators are specified.\r\n\tvar uvgen = options.UVGenerator !== undefined ? options.UVGenerator : THREE.ExtrudeGeometry.WorldUVGenerator;\r\n\r\n\tvar splineTube, binormal, normal, position2;\r\n\tif ( extrudePath ) {\r\n\r\n\t\textrudePts = extrudePath.getSpacedPoints( steps );\r\n\r\n\t\textrudeByPath = true;\r\n\t\tbevelEnabled = false; // bevels not supported for path extrusion\r\n\r\n\t\t// SETUP TNB variables\r\n\r\n\t\t// Reuse TNB from TubeGeomtry for now.\r\n\t\t// TODO1 - have a .isClosed in spline?\r\n\r\n\t\tsplineTube = options.frames !== undefined ? options.frames : new THREE.TubeGeometry.FrenetFrames( extrudePath, steps, false );\r\n\r\n\t\t// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);\r\n\r\n\t\tbinormal = new THREE.Vector3();\r\n\t\tnormal = new THREE.Vector3();\r\n\t\tposition2 = new THREE.Vector3();\r\n\r\n\t}\r\n\r\n\t// Safeguards if bevels are not enabled\r\n\r\n\tif ( ! bevelEnabled ) {\r\n\r\n\t\tbevelSegments = 0;\r\n\t\tbevelThickness = 0;\r\n\t\tbevelSize = 0;\r\n\r\n\t}\r\n\r\n\t// Variables initialization\r\n\r\n\tvar ahole, h, hl; // looping of holes\r\n\tvar scope = this;\r\n\r\n\tvar shapesOffset = this.vertices.length;\r\n\r\n\tvar shapePoints = shape.extractPoints( curveSegments );\r\n\r\n\tvar vertices = shapePoints.shape;\r\n\tvar holes = shapePoints.holes;\r\n\r\n\tvar reverse = ! THREE.ShapeUtils.isClockWise( vertices );\r\n\r\n\tif ( reverse ) {\r\n\r\n\t\tvertices = vertices.reverse();\r\n\r\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe ...\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\r\n\t\t\tif ( THREE.ShapeUtils.isClockWise( ahole ) ) {\r\n\r\n\t\t\t\tholes[ h ] = ahole.reverse();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!\r\n\r\n\t}\r\n\r\n\r\n\tvar faces = THREE.ShapeUtils.triangulateShape( vertices, holes );\r\n\r\n\t/* Vertices */\r\n\r\n\tvar contour = vertices; // vertices has all points but contour has only points of circumference\r\n\r\n\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\tahole = holes[ h ];\r\n\r\n\t\tvertices = vertices.concat( ahole );\r\n\r\n\t}\r\n\r\n\r\n\tfunction scalePt2 ( pt, vec, size ) {\r\n\r\n\t\tif ( ! vec ) console.error( \"THREE.ExtrudeGeometry: vec does not exist\" );\r\n\r\n\t\treturn vec.clone().multiplyScalar( size ).add( pt );\r\n\r\n\t}\r\n\r\n\tvar b, bs, t, z,\r\n\t\tvert, vlen = vertices.length,\r\n\t\tface, flen = faces.length;\r\n\r\n\r\n\t// Find directions for point movement\r\n\r\n\r\n\tfunction getBevelVec( inPt, inPrev, inNext ) {\r\n\r\n\t\t// computes for inPt the corresponding point inPt' on a new contour\r\n\t\t//   shifted by 1 unit (length of normalized vector) to the left\r\n\t\t// if we walk along contour clockwise, this new contour is outside the old one\r\n\t\t//\r\n\t\t// inPt' is the intersection of the two lines parallel to the two\r\n\t\t//  adjacent edges of inPt at a distance of 1 unit on the left side.\r\n\r\n\t\tvar v_trans_x, v_trans_y, shrink_by = 1;\t\t// resulting translation vector for inPt\r\n\r\n\t\t// good reading for geometry algorithms (here: line-line intersection)\r\n\t\t// http://geomalgorithms.com/a05-_intersect-1.html\r\n\r\n\t\tvar v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;\r\n\t\tvar v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;\r\n\r\n\t\tvar v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );\r\n\r\n\t\t// check for collinear edges\r\n\t\tvar collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\r\n\t\tif ( Math.abs( collinear0 ) > Number.EPSILON ) {\r\n\r\n\t\t\t// not collinear\r\n\r\n\t\t\t// length of vectors for normalizing\r\n\r\n\t\t\tvar v_prev_len = Math.sqrt( v_prev_lensq );\r\n\t\t\tvar v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );\r\n\r\n\t\t\t// shift adjacent points by unit vectors to the left\r\n\r\n\t\t\tvar ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );\r\n\t\t\tvar ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );\r\n\r\n\t\t\tvar ptNextShift_x = ( inNext.x - v_next_y / v_next_len );\r\n\t\t\tvar ptNextShift_y = ( inNext.y + v_next_x / v_next_len );\r\n\r\n\t\t\t// scaling factor for v_prev to intersection point\r\n\r\n\t\t\tvar sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -\r\n\t\t\t\t\t\t( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /\r\n\t\t\t\t\t  ( v_prev_x * v_next_y - v_prev_y * v_next_x );\r\n\r\n\t\t\t// vector from inPt to intersection point\r\n\r\n\t\t\tv_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );\r\n\t\t\tv_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );\r\n\r\n\t\t\t// Don't normalize!, otherwise sharp corners become ugly\r\n\t\t\t//  but prevent crazy spikes\r\n\t\t\tvar v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );\r\n\t\t\tif ( v_trans_lensq <= 2 ) {\r\n\r\n\t\t\t\treturn\tnew THREE.Vector2( v_trans_x, v_trans_y );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tshrink_by = Math.sqrt( v_trans_lensq / 2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// handle special case of collinear edges\r\n\r\n\t\t\tvar direction_eq = false;\t\t// assumes: opposite\r\n\t\t\tif ( v_prev_x > Number.EPSILON ) {\r\n\r\n\t\t\t\tif ( v_next_x > Number.EPSILON ) {\r\n\r\n\t\t\t\t\tdirection_eq = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\tif ( v_prev_x < - Number.EPSILON ) {\r\n\r\n\t\t\t\t\tif ( v_next_x < - Number.EPSILON ) {\r\n\r\n\t\t\t\t\t\tdirection_eq = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tif ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {\r\n\r\n\t\t\t\t\t\tdirection_eq = true;\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tif ( direction_eq ) {\r\n\r\n\t\t\t\t// console.log(\"Warning: lines are a straight sequence\");\r\n\t\t\t\tv_trans_x = - v_prev_y;\r\n\t\t\t\tv_trans_y =  v_prev_x;\r\n\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// console.log(\"Warning: lines are a straight spike\");\r\n\t\t\t\tv_trans_x = v_prev_x;\r\n\t\t\t\tv_trans_y = v_prev_y;\r\n\t\t\t\tshrink_by = Math.sqrt( v_prev_lensq / 2 );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn\tnew THREE.Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );\r\n\r\n\t}\r\n\r\n\r\n\tvar contourMovements = [];\r\n\r\n\tfor ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\r\n\t\tif ( j === il ) j = 0;\r\n\t\tif ( k === il ) k = 0;\r\n\r\n\t\t//  (j)---(i)---(k)\r\n\t\t// console.log('i,j,k', i, j , k)\r\n\r\n\t\tcontourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );\r\n\r\n\t}\r\n\r\n\tvar holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();\r\n\r\n\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\tahole = holes[ h ];\r\n\r\n\t\toneHoleMovements = [];\r\n\r\n\t\tfor ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {\r\n\r\n\t\t\tif ( j === il ) j = 0;\r\n\t\t\tif ( k === il ) k = 0;\r\n\r\n\t\t\t//  (j)---(i)---(k)\r\n\t\t\toneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );\r\n\r\n\t\t}\r\n\r\n\t\tholesMovements.push( oneHoleMovements );\r\n\t\tverticesMovements = verticesMovements.concat( oneHoleMovements );\r\n\r\n\t}\r\n\r\n\r\n\t// Loop bevelSegments, 1 for the front, 1 for the back\r\n\r\n\tfor ( b = 0; b < bevelSegments; b ++ ) {\r\n\r\n\t\t//for ( b = bevelSegments; b > 0; b -- ) {\r\n\r\n\t\tt = b / bevelSegments;\r\n\t\tz = bevelThickness * ( 1 - t );\r\n\r\n\t\t//z = bevelThickness * t;\r\n\t\tbs = bevelSize * ( Math.sin ( t * Math.PI / 2 ) ); // curved\r\n\t\t//bs = bevelSize * t; // linear\r\n\r\n\t\t// contract shape\r\n\r\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\r\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\r\n\t\t\tv( vert.x, vert.y,  - z );\r\n\r\n\t\t}\r\n\r\n\t\t// expand holes\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\t\t\toneHoleMovements = holesMovements[ h ];\r\n\r\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\r\n\t\t\t\tv( vert.x, vert.y,  - z );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tbs = bevelSize;\r\n\r\n\t// Back facing vertices\r\n\r\n\tfor ( i = 0; i < vlen; i ++ ) {\r\n\r\n\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\r\n\t\tif ( ! extrudeByPath ) {\r\n\r\n\t\t\tv( vert.x, vert.y, 0 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );\r\n\r\n\t\t\tnormal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );\r\n\t\t\tbinormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );\r\n\r\n\t\t\tposition2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );\r\n\r\n\t\t\tv( position2.x, position2.y, position2.z );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Add stepped vertices...\r\n\t// Including front facing vertices\r\n\r\n\tvar s;\r\n\r\n\tfor ( s = 1; s <= steps; s ++ ) {\r\n\r\n\t\tfor ( i = 0; i < vlen; i ++ ) {\r\n\r\n\t\t\tvert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];\r\n\r\n\t\t\tif ( ! extrudeByPath ) {\r\n\r\n\t\t\t\tv( vert.x, vert.y, amount / steps * s );\r\n\r\n\t\t\t} else {\r\n\r\n\t\t\t\t// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );\r\n\r\n\t\t\t\tnormal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );\r\n\t\t\t\tbinormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );\r\n\r\n\t\t\t\tposition2.copy( extrudePts[ s ] ).add( normal ).add( binormal );\r\n\r\n\t\t\t\tv( position2.x, position2.y, position2.z );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t// Add bevel segments planes\r\n\r\n\t//for ( b = 1; b <= bevelSegments; b ++ ) {\r\n\tfor ( b = bevelSegments - 1; b >= 0; b -- ) {\r\n\r\n\t\tt = b / bevelSegments;\r\n\t\tz = bevelThickness * ( 1 - t );\r\n\t\t//bs = bevelSize * ( 1-Math.sin ( ( 1 - t ) * Math.PI/2 ) );\r\n\t\tbs = bevelSize * Math.sin ( t * Math.PI / 2 );\r\n\r\n\t\t// contract shape\r\n\r\n\t\tfor ( i = 0, il = contour.length; i < il; i ++ ) {\r\n\r\n\t\t\tvert = scalePt2( contour[ i ], contourMovements[ i ], bs );\r\n\t\t\tv( vert.x, vert.y,  amount + z );\r\n\r\n\t\t}\r\n\r\n\t\t// expand holes\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\t\t\toneHoleMovements = holesMovements[ h ];\r\n\r\n\t\t\tfor ( i = 0, il = ahole.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tvert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );\r\n\r\n\t\t\t\tif ( ! extrudeByPath ) {\r\n\r\n\t\t\t\t\tv( vert.x, vert.y,  amount + z );\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tv( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/* Faces */\r\n\r\n\t// Top and bottom faces\r\n\r\n\tbuildLidFaces();\r\n\r\n\t// Sides faces\r\n\r\n\tbuildSideFaces();\r\n\r\n\r\n\t/////  Internal functions\r\n\r\n\tfunction buildLidFaces() {\r\n\r\n\t\tif ( bevelEnabled ) {\r\n\r\n\t\t\tvar layer = 0; // steps + 1\r\n\t\t\tvar offset = vlen * layer;\r\n\r\n\t\t\t// Bottom faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );\r\n\r\n\t\t\t}\r\n\r\n\t\t\tlayer = steps + bevelSegments * 2;\r\n\t\t\toffset = vlen * layer;\r\n\r\n\t\t\t// Top faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// Bottom faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 2 ], face[ 1 ], face[ 0 ] );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// Top faces\r\n\r\n\t\t\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\t\t\tface = faces[ i ];\r\n\t\t\t\tf3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// Create faces for the z-sides of the shape\r\n\r\n\tfunction buildSideFaces() {\r\n\r\n\t\tvar layeroffset = 0;\r\n\t\tsidewalls( contour, layeroffset );\r\n\t\tlayeroffset += contour.length;\r\n\r\n\t\tfor ( h = 0, hl = holes.length; h < hl; h ++ ) {\r\n\r\n\t\t\tahole = holes[ h ];\r\n\t\t\tsidewalls( ahole, layeroffset );\r\n\r\n\t\t\t//, true\r\n\t\t\tlayeroffset += ahole.length;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfunction sidewalls( contour, layeroffset ) {\r\n\r\n\t\tvar j, k;\r\n\t\ti = contour.length;\r\n\r\n\t\twhile ( -- i >= 0 ) {\r\n\r\n\t\t\tj = i;\r\n\t\t\tk = i - 1;\r\n\t\t\tif ( k < 0 ) k = contour.length - 1;\r\n\r\n\t\t\t//console.log('b', i,j, i-1, k,vertices.length);\r\n\r\n\t\t\tvar s = 0, sl = steps  + bevelSegments * 2;\r\n\r\n\t\t\tfor ( s = 0; s < sl; s ++ ) {\r\n\r\n\t\t\t\tvar slen1 = vlen * s;\r\n\t\t\t\tvar slen2 = vlen * ( s + 1 );\r\n\r\n\t\t\t\tvar a = layeroffset + j + slen1,\r\n\t\t\t\t\tb = layeroffset + k + slen1,\r\n\t\t\t\t\tc = layeroffset + k + slen2,\r\n\t\t\t\t\td = layeroffset + j + slen2;\r\n\r\n\t\t\t\tf4( a, b, c, d, contour, s, sl, j, k );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\tfunction v( x, y, z ) {\r\n\r\n\t\tscope.vertices.push( new THREE.Vector3( x, y, z ) );\r\n\r\n\t}\r\n\r\n\tfunction f3( a, b, c ) {\r\n\r\n\t\ta += shapesOffset;\r\n\t\tb += shapesOffset;\r\n\t\tc += shapesOffset;\r\n\r\n\t\tscope.faces.push( new THREE.Face3( a, b, c, null, null, 0 ) );\r\n\r\n\t\tvar uvs = uvgen.generateTopUV( scope, a, b, c );\r\n\r\n\t\tscope.faceVertexUvs[ 0 ].push( uvs );\r\n\r\n\t}\r\n\r\n\tfunction f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {\r\n\r\n\t\ta += shapesOffset;\r\n\t\tb += shapesOffset;\r\n\t\tc += shapesOffset;\r\n\t\td += shapesOffset;\r\n\r\n\t\tscope.faces.push( new THREE.Face3( a, b, d, null, null, 1 ) );\r\n\t\tscope.faces.push( new THREE.Face3( b, c, d, null, null, 1 ) );\r\n\r\n\t\tvar uvs = uvgen.generateSideWallUV( scope, a, b, c, d );\r\n\r\n\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );\r\n\t\tscope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.ExtrudeGeometry.WorldUVGenerator = {\r\n\r\n\tgenerateTopUV: function ( geometry, indexA, indexB, indexC ) {\r\n\r\n\t\tvar vertices = geometry.vertices;\r\n\r\n\t\tvar a = vertices[ indexA ];\r\n\t\tvar b = vertices[ indexB ];\r\n\t\tvar c = vertices[ indexC ];\r\n\r\n\t\treturn [\r\n\t\t\tnew THREE.Vector2( a.x, a.y ),\r\n\t\t\tnew THREE.Vector2( b.x, b.y ),\r\n\t\t\tnew THREE.Vector2( c.x, c.y )\r\n\t\t];\r\n\r\n\t},\r\n\r\n\tgenerateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {\r\n\r\n\t\tvar vertices = geometry.vertices;\r\n\r\n\t\tvar a = vertices[ indexA ];\r\n\t\tvar b = vertices[ indexB ];\r\n\t\tvar c = vertices[ indexC ];\r\n\t\tvar d = vertices[ indexD ];\r\n\r\n\t\tif ( Math.abs( a.y - b.y ) < 0.01 ) {\r\n\r\n\t\t\treturn [\r\n\t\t\t\tnew THREE.Vector2( a.x, 1 - a.z ),\r\n\t\t\t\tnew THREE.Vector2( b.x, 1 - b.z ),\r\n\t\t\t\tnew THREE.Vector2( c.x, 1 - c.z ),\r\n\t\t\t\tnew THREE.Vector2( d.x, 1 - d.z )\r\n\t\t\t];\r\n\r\n\t\t} else {\r\n\r\n\t\t\treturn [\r\n\t\t\t\tnew THREE.Vector2( a.y, 1 - a.z ),\r\n\t\t\t\tnew THREE.Vector2( b.y, 1 - b.z ),\r\n\t\t\t\tnew THREE.Vector2( c.y, 1 - c.z ),\r\n\t\t\t\tnew THREE.Vector2( d.y, 1 - d.z )\r\n\t\t\t];\r\n\r\n\t\t}\r\n\r\n\t}\r\n};\r\n\r\n// File:src/extras/geometries/ShapeGeometry.js\r\n\r\n/**\r\n * @author jonobr1 / http://jonobr1.com\r\n *\r\n * Creates a one-sided polygonal geometry from a path shape. Similar to\r\n * ExtrudeGeometry.\r\n *\r\n * parameters = {\r\n *\r\n *\tcurveSegments: <int>, // number of points on the curves. NOT USED AT THE MOMENT.\r\n *\r\n *\tmaterial: <int> // material index for front and back faces\r\n *\tuvGenerator: <Object> // object that provides UV generator functions\r\n *\r\n * }\r\n **/\r\n\r\nTHREE.ShapeGeometry = function ( shapes, options ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'ShapeGeometry';\r\n\r\n\tif ( Array.isArray( shapes ) === false ) shapes = [ shapes ];\r\n\r\n\tthis.addShapeList( shapes, options );\r\n\r\n\tthis.computeFaceNormals();\r\n\r\n};\r\n\r\nTHREE.ShapeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.ShapeGeometry.prototype.constructor = THREE.ShapeGeometry;\r\n\r\n/**\r\n * Add an array of shapes to THREE.ShapeGeometry.\r\n */\r\nTHREE.ShapeGeometry.prototype.addShapeList = function ( shapes, options ) {\r\n\r\n\tfor ( var i = 0, l = shapes.length; i < l; i ++ ) {\r\n\r\n\t\tthis.addShape( shapes[ i ], options );\r\n\r\n\t}\r\n\r\n\treturn this;\r\n\r\n};\r\n\r\n/**\r\n * Adds a shape to THREE.ShapeGeometry, based on THREE.ExtrudeGeometry.\r\n */\r\nTHREE.ShapeGeometry.prototype.addShape = function ( shape, options ) {\r\n\r\n\tif ( options === undefined ) options = {};\r\n\tvar curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;\r\n\r\n\tvar material = options.material;\r\n\tvar uvgen = options.UVGenerator === undefined ? THREE.ExtrudeGeometry.WorldUVGenerator : options.UVGenerator;\r\n\r\n\t//\r\n\r\n\tvar i, l, hole;\r\n\r\n\tvar shapesOffset = this.vertices.length;\r\n\tvar shapePoints = shape.extractPoints( curveSegments );\r\n\r\n\tvar vertices = shapePoints.shape;\r\n\tvar holes = shapePoints.holes;\r\n\r\n\tvar reverse = ! THREE.ShapeUtils.isClockWise( vertices );\r\n\r\n\tif ( reverse ) {\r\n\r\n\t\tvertices = vertices.reverse();\r\n\r\n\t\t// Maybe we should also check if holes are in the opposite direction, just to be safe...\r\n\r\n\t\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\r\n\r\n\t\t\thole = holes[ i ];\r\n\r\n\t\t\tif ( THREE.ShapeUtils.isClockWise( hole ) ) {\r\n\r\n\t\t\t\tholes[ i ] = hole.reverse();\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treverse = false;\r\n\r\n\t}\r\n\r\n\tvar faces = THREE.ShapeUtils.triangulateShape( vertices, holes );\r\n\r\n\t// Vertices\r\n\r\n\tfor ( i = 0, l = holes.length; i < l; i ++ ) {\r\n\r\n\t\thole = holes[ i ];\r\n\t\tvertices = vertices.concat( hole );\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tvar vert, vlen = vertices.length;\r\n\tvar face, flen = faces.length;\r\n\r\n\tfor ( i = 0; i < vlen; i ++ ) {\r\n\r\n\t\tvert = vertices[ i ];\r\n\r\n\t\tthis.vertices.push( new THREE.Vector3( vert.x, vert.y, 0 ) );\r\n\r\n\t}\r\n\r\n\tfor ( i = 0; i < flen; i ++ ) {\r\n\r\n\t\tface = faces[ i ];\r\n\r\n\t\tvar a = face[ 0 ] + shapesOffset;\r\n\t\tvar b = face[ 1 ] + shapesOffset;\r\n\t\tvar c = face[ 2 ] + shapesOffset;\r\n\r\n\t\tthis.faces.push( new THREE.Face3( a, b, c, null, null, material ) );\r\n\t\tthis.faceVertexUvs[ 0 ].push( uvgen.generateTopUV( this, a, b, c ) );\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/extras/geometries/LatheBufferGeometry.js\r\n\r\n/**\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\n\r\n // points - to create a closed torus, one must use a set of points\r\n //    like so: [ a, b, c, d, a ], see first is the same as last.\r\n // segments - the number of circumference segments to create\r\n // phiStart - the starting radian\r\n // phiLength - the radian (0 to 2PI) range of the lathed section\r\n //    2PI is a closed lathe, less than 2PI is a portion.\r\n\r\nTHREE.LatheBufferGeometry = function ( points, segments, phiStart, phiLength ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'LatheBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tpoints: points,\r\n\t\tsegments: segments,\r\n\t\tphiStart: phiStart,\r\n\t\tphiLength: phiLength\r\n\t};\r\n\r\n\tsegments = Math.floor( segments ) || 12;\r\n\tphiStart = phiStart || 0;\r\n\tphiLength = phiLength || Math.PI * 2;\r\n\r\n\t// clamp phiLength so it's in range of [ 0, 2PI ]\r\n\tphiLength = THREE.Math.clamp( phiLength, 0, Math.PI * 2 );\r\n\r\n\t// these are used to calculate buffer length\r\n\tvar vertexCount = ( segments + 1 ) * points.length;\r\n\tvar indexCount = segments * points.length * 2 * 3;\r\n\r\n\t// buffers\r\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\r\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\r\n\t// helper variables\r\n\tvar index = 0, indexOffset = 0, base;\r\n\tvar inversePointLength = 1.0 / ( points.length - 1 );\r\n\tvar inverseSegments = 1.0 / segments;\r\n\tvar vertex = new THREE.Vector3();\r\n\tvar uv = new THREE.Vector2();\r\n\tvar i, j;\r\n\r\n\t// generate vertices and uvs\r\n\r\n\tfor ( i = 0; i <= segments; i ++ ) {\r\n\r\n\t\tvar phi = phiStart + i * inverseSegments * phiLength;\r\n\r\n\t\tvar sin = Math.sin( phi );\r\n\t\tvar cos = Math.cos( phi );\r\n\r\n\t\tfor ( j = 0; j <= ( points.length - 1 ); j ++ ) {\r\n\r\n\t\t\t// vertex\r\n\t\t\tvertex.x = points[ j ].x * sin;\r\n\t\t\tvertex.y = points[ j ].y;\r\n\t\t\tvertex.z = points[ j ].x * cos;\r\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t// uv\r\n\t\t\tuv.x = i / segments;\r\n\t\t\tuv.y = j / ( points.length - 1 );\r\n\t\t\tuvs.setXY( index, uv.x, uv.y );\r\n\r\n\t\t\t// increase index\r\n\t\t\tindex ++;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// generate indices\r\n\r\n\tfor ( i = 0; i < segments; i ++ ) {\r\n\r\n\t\tfor ( j = 0; j < ( points.length - 1 ); j ++ ) {\r\n\r\n\t\t\tbase = j + i * points.length;\r\n\r\n\t\t\t// indices\r\n\t\t\tvar a = base;\r\n\t\t\tvar b = base + points.length;\r\n\t\t\tvar c = base + points.length + 1;\r\n\t\t\tvar d = base + 1;\r\n\r\n\t\t\t// face one\r\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\r\n\r\n\t\t\t// face two\r\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\r\n\tthis.setIndex( indices );\r\n\tthis.addAttribute( 'position', vertices );\r\n\tthis.addAttribute( 'uv', uvs );\r\n\r\n\t// generate normals\r\n\r\n\tthis.computeVertexNormals();\r\n\r\n\t// if the geometry is closed, we need to average the normals along the seam.\r\n\t// because the corresponding vertices are identical (but still have different UVs).\r\n\r\n\tif( phiLength === Math.PI * 2 ) {\r\n\r\n\t\tvar normals = this.attributes.normal.array;\r\n\t\tvar n1 = new THREE.Vector3();\r\n\t\tvar n2 = new THREE.Vector3();\r\n\t\tvar n = new THREE.Vector3();\r\n\r\n\t\t// this is the buffer offset for the last line of vertices\r\n\t\tbase = segments * points.length * 3;\r\n\r\n\t\tfor( i = 0, j = 0; i < points.length; i ++, j += 3 ) {\r\n\r\n\t\t\t// select the normal of the vertex in the first line\r\n\t\t\tn1.x = normals[ j + 0 ];\r\n\t\t\tn1.y = normals[ j + 1 ];\r\n\t\t\tn1.z = normals[ j + 2 ];\r\n\r\n\t\t\t// select the normal of the vertex in the last line\r\n\t\t\tn2.x = normals[ base + j + 0 ];\r\n\t\t\tn2.y = normals[ base + j + 1 ];\r\n\t\t\tn2.z = normals[ base + j + 2 ];\r\n\r\n\t\t\t// average normals\r\n\t\t\tn.addVectors( n1, n2 ).normalize();\r\n\r\n\t\t\t// assign the new values to both normals\r\n\t\t\tnormals[ j + 0 ] = normals[ base + j + 0 ] = n.x;\r\n\t\t\tnormals[ j + 1 ] = normals[ base + j + 1 ] = n.y;\r\n\t\t\tnormals[ j + 2 ] = normals[ base + j + 2 ] = n.z;\r\n\r\n\t\t} // next row\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.LatheBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.LatheBufferGeometry.prototype.constructor = THREE.LatheBufferGeometry;\r\n\r\n// File:src/extras/geometries/LatheGeometry.js\r\n\r\n/**\r\n * @author astrodud / http://astrodud.isgreat.org/\r\n * @author zz85 / https://github.com/zz85\r\n * @author bhouston / http://clara.io\r\n */\r\n\r\n// points - to create a closed torus, one must use a set of points\r\n//    like so: [ a, b, c, d, a ], see first is the same as last.\r\n// segments - the number of circumference segments to create\r\n// phiStart - the starting radian\r\n// phiLength - the radian (0 to 2PI) range of the lathed section\r\n//    2PI is a closed lathe, less than 2PI is a portion.\r\n\r\nTHREE.LatheGeometry = function ( points, segments, phiStart, phiLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'LatheGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tpoints: points,\r\n\t\tsegments: segments,\r\n\t\tphiStart: phiStart,\r\n\t\tphiLength: phiLength\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new THREE.LatheBufferGeometry( points, segments, phiStart, phiLength ) );\r\n\tthis.mergeVertices();\r\n\r\n};\r\n\r\nTHREE.LatheGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.LatheGeometry.prototype.constructor = THREE.LatheGeometry;\r\n\r\n// File:src/extras/geometries/PlaneGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n */\r\n\r\nTHREE.PlaneGeometry = function ( width, height, widthSegments, heightSegments ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'PlaneGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\twidth: width,\r\n\t\theight: height,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new THREE.PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );\r\n\r\n};\r\n\r\nTHREE.PlaneGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.PlaneGeometry.prototype.constructor = THREE.PlaneGeometry;\r\n\r\n// File:src/extras/geometries/PlaneBufferGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as\r\n */\r\n\r\nTHREE.PlaneBufferGeometry = function ( width, height, widthSegments, heightSegments ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'PlaneBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\twidth: width,\r\n\t\theight: height,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments\r\n\t};\r\n\r\n\tvar width_half = width / 2;\r\n\tvar height_half = height / 2;\r\n\r\n\tvar gridX = Math.floor( widthSegments ) || 1;\r\n\tvar gridY = Math.floor( heightSegments ) || 1;\r\n\r\n\tvar gridX1 = gridX + 1;\r\n\tvar gridY1 = gridY + 1;\r\n\r\n\tvar segment_width = width / gridX;\r\n\tvar segment_height = height / gridY;\r\n\r\n\tvar vertices = new Float32Array( gridX1 * gridY1 * 3 );\r\n\tvar normals = new Float32Array( gridX1 * gridY1 * 3 );\r\n\tvar uvs = new Float32Array( gridX1 * gridY1 * 2 );\r\n\r\n\tvar offset = 0;\r\n\tvar offset2 = 0;\r\n\r\n\tfor ( var iy = 0; iy < gridY1; iy ++ ) {\r\n\r\n\t\tvar y = iy * segment_height - height_half;\r\n\r\n\t\tfor ( var ix = 0; ix < gridX1; ix ++ ) {\r\n\r\n\t\t\tvar x = ix * segment_width - width_half;\r\n\r\n\t\t\tvertices[ offset ] = x;\r\n\t\t\tvertices[ offset + 1 ] = - y;\r\n\r\n\t\t\tnormals[ offset + 2 ] = 1;\r\n\r\n\t\t\tuvs[ offset2 ] = ix / gridX;\r\n\t\t\tuvs[ offset2 + 1 ] = 1 - ( iy / gridY );\r\n\r\n\t\t\toffset += 3;\r\n\t\t\toffset2 += 2;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\toffset = 0;\r\n\r\n\tvar indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );\r\n\r\n\tfor ( var iy = 0; iy < gridY; iy ++ ) {\r\n\r\n\t\tfor ( var ix = 0; ix < gridX; ix ++ ) {\r\n\r\n\t\t\tvar a = ix + gridX1 * iy;\r\n\t\t\tvar b = ix + gridX1 * ( iy + 1 );\r\n\t\t\tvar c = ( ix + 1 ) + gridX1 * ( iy + 1 );\r\n\t\t\tvar d = ( ix + 1 ) + gridX1 * iy;\r\n\r\n\t\t\tindices[ offset ] = a;\r\n\t\t\tindices[ offset + 1 ] = b;\r\n\t\t\tindices[ offset + 2 ] = d;\r\n\r\n\t\t\tindices[ offset + 3 ] = b;\r\n\t\t\tindices[ offset + 4 ] = c;\r\n\t\t\tindices[ offset + 5 ] = d;\r\n\r\n\t\t\toffset += 6;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\r\n};\r\n\r\nTHREE.PlaneBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.PlaneBufferGeometry.prototype.constructor = THREE.PlaneBufferGeometry;\r\n\r\n// File:src/extras/geometries/RingBufferGeometry.js\r\n\r\n/**\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\n\r\nTHREE.RingBufferGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'RingBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tinnerRadius: innerRadius,\r\n\t\touterRadius: outerRadius,\r\n\t\tthetaSegments: thetaSegments,\r\n\t\tphiSegments: phiSegments,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tinnerRadius = innerRadius || 20;\r\n\touterRadius = outerRadius || 50;\r\n\r\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;\r\n\r\n\tthetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;\r\n\tphiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;\r\n\r\n\t// these are used to calculate buffer length\r\n\tvar vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );\r\n\tvar indexCount = thetaSegments * phiSegments * 2 * 3;\r\n\r\n\t// buffers\r\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\r\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\r\n\t// some helper variables\r\n\tvar index = 0, indexOffset = 0, segment;\r\n\tvar radius = innerRadius;\r\n\tvar radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );\r\n\tvar vertex = new THREE.Vector3();\r\n\tvar uv = new THREE.Vector2();\r\n\tvar j, i;\r\n\r\n\t// generate vertices, normals and uvs\r\n\r\n\t// values are generate from the inside of the ring to the outside\r\n\r\n\tfor ( j = 0; j <= phiSegments; j ++ ) {\r\n\r\n\t\tfor ( i = 0; i <= thetaSegments; i ++ ) {\r\n\r\n\t\t\tsegment = thetaStart + i / thetaSegments * thetaLength;\r\n\r\n\t\t\t// vertex\r\n\t\t\tvertex.x = radius * Math.cos( segment );\r\n\t\t\tvertex.y = radius * Math.sin( segment );\r\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t// normal\r\n\t\t\tnormals.setXYZ( index, 0, 0, 1 );\r\n\r\n\t\t\t// uv\r\n\t\t\tuv.x = ( vertex.x / outerRadius + 1 ) / 2;\r\n\t\t\tuv.y = ( vertex.y / outerRadius + 1 ) / 2;\r\n\t\t\tuvs.setXY( index, uv.x, uv.y );\r\n\r\n\t\t\t// increase index\r\n\t\t\tindex++;\r\n\r\n\t\t}\r\n\r\n\t\t// increase the radius for next row of vertices\r\n\t\tradius += radiusStep;\r\n\r\n\t}\r\n\r\n\t// generate indices\r\n\r\n\tfor ( j = 0; j < phiSegments; j ++ ) {\r\n\r\n\t\tvar thetaSegmentLevel = j * ( thetaSegments + 1 );\r\n\r\n\t\tfor ( i = 0; i < thetaSegments; i ++ ) {\r\n\r\n\t\t\tsegment = i + thetaSegmentLevel;\r\n\r\n\t\t\t// indices\r\n\t\t\tvar a = segment;\r\n\t\t\tvar b = segment + thetaSegments + 1;\r\n\t\t\tvar c = segment + thetaSegments + 2;\r\n\t\t\tvar d = segment + 1;\r\n\r\n\t\t\t// face one\r\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\r\n\r\n\t\t\t// face two\r\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\r\n\tthis.setIndex( indices );\r\n\tthis.addAttribute( 'position', vertices );\r\n\tthis.addAttribute( 'normal', normals );\r\n\tthis.addAttribute( 'uv', uvs );\r\n\r\n};\r\n\r\nTHREE.RingBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.RingBufferGeometry.prototype.constructor = THREE.RingBufferGeometry;\r\n\r\n// File:src/extras/geometries/RingGeometry.js\r\n\r\n/**\r\n * @author Kaleb Murphy\r\n */\r\n\r\nTHREE.RingGeometry = function ( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'RingGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tinnerRadius: innerRadius,\r\n\t\touterRadius: outerRadius,\r\n\t\tthetaSegments: thetaSegments,\r\n\t\tphiSegments: phiSegments,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new THREE.RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );\r\n\r\n};\r\n\r\nTHREE.RingGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.RingGeometry.prototype.constructor = THREE.RingGeometry;\r\n\r\n// File:src/extras/geometries/SphereGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.SphereGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'SphereGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\tphiStart: phiStart,\r\n\t\tphiLength: phiLength,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new THREE.SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );\r\n\r\n};\r\n\r\nTHREE.SphereGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.SphereGeometry.prototype.constructor = THREE.SphereGeometry;\r\n\r\n// File:src/extras/geometries/SphereBufferGeometry.js\r\n\r\n/**\r\n * @author benaadams / https://twitter.com/ben_a_adams\r\n * based on THREE.SphereGeometry\r\n */\r\n\r\nTHREE.SphereBufferGeometry = function ( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'SphereBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\twidthSegments: widthSegments,\r\n\t\theightSegments: heightSegments,\r\n\t\tphiStart: phiStart,\r\n\t\tphiLength: phiLength,\r\n\t\tthetaStart: thetaStart,\r\n\t\tthetaLength: thetaLength\r\n\t};\r\n\r\n\tradius = radius || 50;\r\n\r\n\twidthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );\r\n\theightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );\r\n\r\n\tphiStart = phiStart !== undefined ? phiStart : 0;\r\n\tphiLength = phiLength !== undefined ? phiLength : Math.PI * 2;\r\n\r\n\tthetaStart = thetaStart !== undefined ? thetaStart : 0;\r\n\tthetaLength = thetaLength !== undefined ? thetaLength : Math.PI;\r\n\r\n\tvar thetaEnd = thetaStart + thetaLength;\r\n\r\n\tvar vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );\r\n\r\n\tvar positions = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\r\n\tvar index = 0, vertices = [], normal = new THREE.Vector3();\r\n\r\n\tfor ( var y = 0; y <= heightSegments; y ++ ) {\r\n\r\n\t\tvar verticesRow = [];\r\n\r\n\t\tvar v = y / heightSegments;\r\n\r\n\t\tfor ( var x = 0; x <= widthSegments; x ++ ) {\r\n\r\n\t\t\tvar u = x / widthSegments;\r\n\r\n\t\t\tvar px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\t\t\tvar py = radius * Math.cos( thetaStart + v * thetaLength );\r\n\t\t\tvar pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );\r\n\r\n\t\t\tnormal.set( px, py, pz ).normalize();\r\n\r\n\t\t\tpositions.setXYZ( index, px, py, pz );\r\n\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\r\n\t\t\tuvs.setXY( index, u, 1 - v );\r\n\r\n\t\t\tverticesRow.push( index );\r\n\r\n\t\t\tindex ++;\r\n\r\n\t\t}\r\n\r\n\t\tvertices.push( verticesRow );\r\n\r\n\t}\r\n\r\n\tvar indices = [];\r\n\r\n\tfor ( var y = 0; y < heightSegments; y ++ ) {\r\n\r\n\t\tfor ( var x = 0; x < widthSegments; x ++ ) {\r\n\r\n\t\t\tvar v1 = vertices[ y ][ x + 1 ];\r\n\t\t\tvar v2 = vertices[ y ][ x ];\r\n\t\t\tvar v3 = vertices[ y + 1 ][ x ];\r\n\t\t\tvar v4 = vertices[ y + 1 ][ x + 1 ];\r\n\r\n\t\t\tif ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );\r\n\t\t\tif ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.setIndex( new ( positions.count > 65535 ? THREE.Uint32Attribute : THREE.Uint16Attribute )( indices, 1 ) );\r\n\tthis.addAttribute( 'position', positions );\r\n\tthis.addAttribute( 'normal', normals );\r\n\tthis.addAttribute( 'uv', uvs );\r\n\r\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n};\r\n\r\nTHREE.SphereBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.SphereBufferGeometry.prototype.constructor = THREE.SphereBufferGeometry;\r\n\r\n// File:src/extras/geometries/TextGeometry.js\r\n\r\n/**\r\n * @author zz85 / http://www.lab4games.net/zz85/blog\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n * Text = 3D Text\r\n *\r\n * parameters = {\r\n *  font: <THREE.Font>, // font\r\n *\r\n *  size: <float>, // size of the text\r\n *  height: <float>, // thickness to extrude text\r\n *  curveSegments: <int>, // number of points on the curves\r\n *\r\n *  bevelEnabled: <bool>, // turn on bevel\r\n *  bevelThickness: <float>, // how deep into text bevel goes\r\n *  bevelSize: <float> // how far from text outline is bevel\r\n * }\r\n */\r\n\r\nTHREE.TextGeometry = function ( text, parameters ) {\r\n\r\n\tparameters = parameters || {};\r\n\r\n\tvar font = parameters.font;\r\n\r\n\tif ( font instanceof THREE.Font === false ) {\r\n\r\n\t\tconsole.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );\r\n\t\treturn new THREE.Geometry();\r\n\r\n\t}\r\n\r\n\tvar shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );\r\n\r\n\t// translate parameters to ExtrudeGeometry API\r\n\r\n\tparameters.amount = parameters.height !== undefined ? parameters.height : 50;\r\n\r\n\t// defaults\r\n\r\n\tif ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;\r\n\tif ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;\r\n\tif ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;\r\n\r\n\tTHREE.ExtrudeGeometry.call( this, shapes, parameters );\r\n\r\n\tthis.type = 'TextGeometry';\r\n\r\n};\r\n\r\nTHREE.TextGeometry.prototype = Object.create( THREE.ExtrudeGeometry.prototype );\r\nTHREE.TextGeometry.prototype.constructor = THREE.TextGeometry;\r\n\r\n// File:src/extras/geometries/TorusBufferGeometry.js\r\n\r\n/**\r\n * @author Mugen87 / https://github.com/Mugen87\r\n */\r\n\r\nTHREE.TorusBufferGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'TorusBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\ttube: tube,\r\n\t\tradialSegments: radialSegments,\r\n\t\ttubularSegments: tubularSegments,\r\n\t\tarc: arc\r\n\t};\r\n\r\n\tradius = radius || 100;\r\n\ttube = tube || 40;\r\n\tradialSegments = Math.floor( radialSegments ) || 8;\r\n\ttubularSegments = Math.floor( tubularSegments ) || 6;\r\n\tarc = arc || Math.PI * 2;\r\n\r\n\t// used to calculate buffer length\r\n\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\r\n\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\r\n\r\n\t// buffers\r\n\tvar indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );\r\n\tvar vertices = new Float32Array( vertexCount * 3 );\r\n\tvar normals = new Float32Array( vertexCount * 3 );\r\n\tvar uvs = new Float32Array( vertexCount * 2 );\r\n\r\n\t// offset variables\r\n\tvar vertexBufferOffset = 0;\r\n\tvar uvBufferOffset = 0;\r\n\tvar indexBufferOffset = 0;\r\n\r\n\t// helper variables\r\n\tvar center = new THREE.Vector3();\r\n\tvar vertex = new THREE.Vector3();\r\n\tvar normal = new THREE.Vector3();\r\n\r\n\tvar j, i;\r\n\r\n\t// generate vertices, normals and uvs\r\n\r\n\tfor ( j = 0; j <= radialSegments; j ++ ) {\r\n\r\n\t\tfor ( i = 0; i <= tubularSegments; i ++ ) {\r\n\r\n\t\t\tvar u = i / tubularSegments * arc;\r\n\t\t\tvar v = j / radialSegments * Math.PI * 2;\r\n\r\n\t\t\t// vertex\r\n\t\t\tvertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );\r\n\t\t\tvertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );\r\n\t\t\tvertex.z = tube * Math.sin( v );\r\n\r\n\t\t\tvertices[ vertexBufferOffset ] = vertex.x;\r\n\t\t\tvertices[ vertexBufferOffset + 1 ] = vertex.y;\r\n\t\t\tvertices[ vertexBufferOffset + 2 ] = vertex.z;\r\n\r\n\t\t\t// this vector is used to calculate the normal\r\n\t\t\tcenter.x = radius * Math.cos( u );\r\n\t\t\tcenter.y = radius * Math.sin( u );\r\n\r\n\t\t\t// normal\r\n\t\t\tnormal.subVectors( vertex, center ).normalize();\r\n\r\n\t\t\tnormals[ vertexBufferOffset ] = normal.x;\r\n\t\t\tnormals[ vertexBufferOffset + 1 ] = normal.y;\r\n\t\t\tnormals[ vertexBufferOffset + 2 ] = normal.z;\r\n\r\n\t\t\t// uv\r\n\t\t\tuvs[ uvBufferOffset ] = i / tubularSegments;\r\n\t\t\tuvs[ uvBufferOffset + 1 ] = j / radialSegments;\r\n\r\n\t\t\t// update offsets\r\n\t\t\tvertexBufferOffset += 3;\r\n\t\t\tuvBufferOffset += 2;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// generate indices\r\n\r\n\tfor ( j = 1; j <= radialSegments; j ++ ) {\r\n\r\n\t\tfor ( i = 1; i <= tubularSegments; i ++ ) {\r\n\r\n\t\t\t// indices\r\n\t\t\tvar a = ( tubularSegments + 1 ) * j + i - 1;\r\n\t\t\tvar b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;\r\n\t\t\tvar c = ( tubularSegments + 1 ) * ( j - 1 ) + i;\r\n\t\t\tvar d = ( tubularSegments + 1 ) * j + i;\r\n\r\n\t\t\t// face one\r\n\t\t\tindices[ indexBufferOffset ] = a;\r\n\t\t\tindices[ indexBufferOffset + 1 ] = b;\r\n\t\t\tindices[ indexBufferOffset + 2 ] = d;\r\n\r\n\t\t\t// face two\r\n\t\t\tindices[ indexBufferOffset + 3 ] = b;\r\n\t\t\tindices[ indexBufferOffset + 4 ] = c;\r\n\t\t\tindices[ indexBufferOffset + 5 ] = d;\r\n\r\n\t\t\t// update offset\r\n\t\t\tindexBufferOffset += 6;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\tthis.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n\tthis.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\tthis.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3 ) );\r\n\tthis.addAttribute( 'uv', new THREE.BufferAttribute( uvs, 2 ) );\r\n\r\n};\r\n\r\nTHREE.TorusBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.TorusBufferGeometry.prototype.constructor = THREE.TorusBufferGeometry;\r\n\r\n// File:src/extras/geometries/TorusGeometry.js\r\n\r\n/**\r\n * @author oosmoxiecode\r\n * @author mrdoob / http://mrdoob.com/\r\n * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888\r\n */\r\n\r\nTHREE.TorusGeometry = function ( radius, tube, radialSegments, tubularSegments, arc ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'TorusGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\ttube: tube,\r\n\t\tradialSegments: radialSegments,\r\n\t\ttubularSegments: tubularSegments,\r\n\t\tarc: arc\r\n\t};\r\n\r\n\tthis.fromBufferGeometry( new THREE.TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );\r\n\r\n};\r\n\r\nTHREE.TorusGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.TorusGeometry.prototype.constructor = THREE.TorusGeometry;\r\n\r\n// File:src/extras/geometries/TorusKnotBufferGeometry.js\r\n\r\n/**\r\n * @author Mugen87 / https://github.com/Mugen87\r\n *\r\n * see: http://www.blackpawn.com/texts/pqtorus/\r\n */\r\nTHREE.TorusKnotBufferGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tthis.type = 'TorusKnotBufferGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\ttube: tube,\r\n\t\ttubularSegments: tubularSegments,\r\n\t\tradialSegments: radialSegments,\r\n\t\tp: p,\r\n\t\tq: q\r\n\t};\r\n\r\n\tradius = radius || 100;\r\n\ttube = tube || 40;\r\n\ttubularSegments = Math.floor( tubularSegments ) || 64;\r\n\tradialSegments = Math.floor( radialSegments ) || 8;\r\n\tp = p || 2;\r\n\tq = q || 3;\r\n\r\n\t// used to calculate buffer length\r\n\tvar vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );\r\n\tvar indexCount = radialSegments * tubularSegments * 2 * 3;\r\n\r\n\t// buffers\r\n\tvar indices = new THREE.BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );\r\n\tvar vertices = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\tvar normals = new THREE.BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );\r\n\tvar uvs = new THREE.BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );\r\n\r\n\t// helper variables\r\n\tvar i, j, index = 0, indexOffset = 0;\r\n\r\n\tvar vertex = new THREE.Vector3();\r\n\tvar normal = new THREE.Vector3();\r\n\tvar uv = new THREE.Vector2();\r\n\r\n\tvar P1 = new THREE.Vector3();\r\n\tvar P2 = new THREE.Vector3();\r\n\r\n\tvar B = new THREE.Vector3();\r\n\tvar T = new THREE.Vector3();\r\n\tvar N = new THREE.Vector3();\r\n\r\n\t// generate vertices, normals and uvs\r\n\r\n\tfor ( i = 0; i <= tubularSegments; ++ i ) {\r\n\r\n\t\t// the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\r\n\r\n\t\tvar u = i / tubularSegments * p * Math.PI * 2;\r\n\r\n\t\t// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\r\n\t\t// these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\r\n\r\n\t\tcalculatePositionOnCurve( u, p, q, radius, P1 );\r\n\t\tcalculatePositionOnCurve( u + 0.01, p, q, radius, P2 );\r\n\r\n\t\t// calculate orthonormal basis\r\n\r\n\t\tT.subVectors( P2, P1 );\r\n\t\tN.addVectors( P2, P1 );\r\n\t\tB.crossVectors( T, N );\r\n\t\tN.crossVectors( B, T );\r\n\r\n\t\t// normalize B, N. T can be ignored, we don't use it\r\n\r\n\t\tB.normalize();\r\n\t\tN.normalize();\r\n\r\n\t\tfor ( j = 0; j <= radialSegments; ++ j ) {\r\n\r\n\t\t\t// now calculate the vertices. they are nothing more than an extrusion of the torus curve.\r\n\t\t\t// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.\r\n\r\n\t\t\tvar v = j / radialSegments * Math.PI * 2;\r\n\t\t\tvar cx = - tube * Math.cos( v );\r\n\t\t\tvar cy = tube * Math.sin( v );\r\n\r\n\t\t\t// now calculate the final vertex position.\r\n\t\t\t// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve\r\n\r\n\t\t\tvertex.x = P1.x + ( cx * N.x + cy * B.x );\r\n\t\t\tvertex.y = P1.y + ( cx * N.y + cy * B.y );\r\n\t\t\tvertex.z = P1.z + ( cx * N.z + cy * B.z );\r\n\r\n\t\t\t// vertex\r\n\t\t\tvertices.setXYZ( index, vertex.x, vertex.y, vertex.z );\r\n\r\n\t\t\t// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)\r\n\t\t\tnormal.subVectors( vertex, P1 ).normalize();\r\n\t\t\tnormals.setXYZ( index, normal.x, normal.y, normal.z );\r\n\r\n\t\t\t// uv\r\n\t\t\tuv.x = i / tubularSegments;\r\n\t\t\tuv.y = j / radialSegments;\r\n\t\t\tuvs.setXY( index, uv.x, uv.y );\r\n\r\n\t\t\t// increase index\r\n\t\t\tindex ++;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// generate indices\r\n\r\n\tfor ( j = 1; j <= tubularSegments; j ++ ) {\r\n\r\n\t\tfor ( i = 1; i <= radialSegments; i ++ ) {\r\n\r\n\t\t\t// indices\r\n\t\t\tvar a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );\r\n\t\t\tvar b = ( radialSegments + 1 ) * j + ( i - 1 );\r\n\t\t\tvar c = ( radialSegments + 1 ) * j + i;\r\n\t\t\tvar d = ( radialSegments + 1 ) * ( j - 1 ) + i;\r\n\r\n\t\t\t// face one\r\n\t\t\tindices.setX( indexOffset, a ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\r\n\r\n\t\t\t// face two\r\n\t\t\tindices.setX( indexOffset, b ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, c ); indexOffset++;\r\n\t\t\tindices.setX( indexOffset, d ); indexOffset++;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// build geometry\r\n\r\n\tthis.setIndex( indices );\r\n\tthis.addAttribute( 'position', vertices );\r\n\tthis.addAttribute( 'normal', normals );\r\n\tthis.addAttribute( 'uv', uvs );\r\n\r\n\t// this function calculates the current position on the torus curve\r\n\r\n\tfunction calculatePositionOnCurve( u, p, q, radius, position ) {\r\n\r\n\t\tvar cu = Math.cos( u );\r\n\t\tvar su = Math.sin( u );\r\n\t\tvar quOverP = q / p * u;\r\n\t\tvar cs = Math.cos( quOverP );\r\n\r\n\t\tposition.x = radius * ( 2 + cs ) * 0.5 * cu;\r\n\t\tposition.y = radius * ( 2 + cs ) * su * 0.5;\r\n\t\tposition.z = radius * Math.sin( quOverP ) * 0.5;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.TorusKnotBufferGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.TorusKnotBufferGeometry.prototype.constructor = THREE.TorusKnotBufferGeometry;\r\n\r\n// File:src/extras/geometries/TorusKnotGeometry.js\r\n\r\n/**\r\n * @author oosmoxiecode\r\n */\r\n\r\nTHREE.TorusKnotGeometry = function ( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'TorusKnotGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\ttube: tube,\r\n\t\ttubularSegments: tubularSegments,\r\n\t\tradialSegments: radialSegments,\r\n\t\tp: p,\r\n\t\tq: q\r\n\t};\r\n\r\n\tif( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );\r\n\r\n\tthis.fromBufferGeometry( new THREE.TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );\r\n\tthis.mergeVertices();\r\n\r\n};\r\n\r\nTHREE.TorusKnotGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.TorusKnotGeometry.prototype.constructor = THREE.TorusKnotGeometry;\r\n\r\n// File:src/extras/geometries/TubeGeometry.js\r\n\r\n/**\r\n * @author WestLangley / https://github.com/WestLangley\r\n * @author zz85 / https://github.com/zz85\r\n * @author miningold / https://github.com/miningold\r\n * @author jonobr1 / https://github.com/jonobr1\r\n *\r\n * Modified from the TorusKnotGeometry by @oosmoxiecode\r\n *\r\n * Creates a tube which extrudes along a 3d spline\r\n *\r\n * Uses parallel transport frames as described in\r\n * http://www.cs.indiana.edu/pub/techreports/TR425.pdf\r\n */\r\n\r\nTHREE.TubeGeometry = function ( path, segments, radius, radialSegments, closed, taper ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'TubeGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tpath: path,\r\n\t\tsegments: segments,\r\n\t\tradius: radius,\r\n\t\tradialSegments: radialSegments,\r\n\t\tclosed: closed,\r\n\t\ttaper: taper\r\n\t};\r\n\r\n\tsegments = segments || 64;\r\n\tradius = radius || 1;\r\n\tradialSegments = radialSegments || 8;\r\n\tclosed = closed || false;\r\n\ttaper = taper || THREE.TubeGeometry.NoTaper;\r\n\r\n\tvar grid = [];\r\n\r\n\tvar scope = this,\r\n\r\n\t\ttangent,\r\n\t\tnormal,\r\n\t\tbinormal,\r\n\r\n\t\tnumpoints = segments + 1,\r\n\r\n\t\tu, v, r,\r\n\r\n\t\tcx, cy,\r\n\t\tpos, pos2 = new THREE.Vector3(),\r\n\t\ti, j,\r\n\t\tip, jp,\r\n\t\ta, b, c, d,\r\n\t\tuva, uvb, uvc, uvd;\r\n\r\n\tvar frames = new THREE.TubeGeometry.FrenetFrames( path, segments, closed ),\r\n\t\ttangents = frames.tangents,\r\n\t\tnormals = frames.normals,\r\n\t\tbinormals = frames.binormals;\r\n\r\n\t// proxy internals\r\n\tthis.tangents = tangents;\r\n\tthis.normals = normals;\r\n\tthis.binormals = binormals;\r\n\r\n\tfunction vert( x, y, z ) {\r\n\r\n\t\treturn scope.vertices.push( new THREE.Vector3( x, y, z ) ) - 1;\r\n\r\n\t}\r\n\r\n\t// construct the grid\r\n\r\n\tfor ( i = 0; i < numpoints; i ++ ) {\r\n\r\n\t\tgrid[ i ] = [];\r\n\r\n\t\tu = i / ( numpoints - 1 );\r\n\r\n\t\tpos = path.getPointAt( u );\r\n\r\n\t\ttangent = tangents[ i ];\r\n\t\tnormal = normals[ i ];\r\n\t\tbinormal = binormals[ i ];\r\n\r\n\t\tr = radius * taper( u );\r\n\r\n\t\tfor ( j = 0; j < radialSegments; j ++ ) {\r\n\r\n\t\t\tv = j / radialSegments * 2 * Math.PI;\r\n\r\n\t\t\tcx = - r * Math.cos( v ); // TODO: Hack: Negating it so it faces outside.\r\n\t\t\tcy = r * Math.sin( v );\r\n\r\n\t\t\tpos2.copy( pos );\r\n\t\t\tpos2.x += cx * normal.x + cy * binormal.x;\r\n\t\t\tpos2.y += cx * normal.y + cy * binormal.y;\r\n\t\t\tpos2.z += cx * normal.z + cy * binormal.z;\r\n\r\n\t\t\tgrid[ i ][ j ] = vert( pos2.x, pos2.y, pos2.z );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t// construct the mesh\r\n\r\n\tfor ( i = 0; i < segments; i ++ ) {\r\n\r\n\t\tfor ( j = 0; j < radialSegments; j ++ ) {\r\n\r\n\t\t\tip = ( closed ) ? ( i + 1 ) % segments : i + 1;\r\n\t\t\tjp = ( j + 1 ) % radialSegments;\r\n\r\n\t\t\ta = grid[ i ][ j ];\t\t// *** NOT NECESSARILY PLANAR ! ***\r\n\t\t\tb = grid[ ip ][ j ];\r\n\t\t\tc = grid[ ip ][ jp ];\r\n\t\t\td = grid[ i ][ jp ];\r\n\r\n\t\t\tuva = new THREE.Vector2( i / segments, j / radialSegments );\r\n\t\t\tuvb = new THREE.Vector2( ( i + 1 ) / segments, j / radialSegments );\r\n\t\t\tuvc = new THREE.Vector2( ( i + 1 ) / segments, ( j + 1 ) / radialSegments );\r\n\t\t\tuvd = new THREE.Vector2( i / segments, ( j + 1 ) / radialSegments );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( a, b, d ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uva, uvb, uvd ] );\r\n\r\n\t\t\tthis.faces.push( new THREE.Face3( b, c, d ) );\r\n\t\t\tthis.faceVertexUvs[ 0 ].push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tthis.computeFaceNormals();\r\n\tthis.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.TubeGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.TubeGeometry.prototype.constructor = THREE.TubeGeometry;\r\n\r\nTHREE.TubeGeometry.NoTaper = function ( u ) {\r\n\r\n\treturn 1;\r\n\r\n};\r\n\r\nTHREE.TubeGeometry.SinusoidalTaper = function ( u ) {\r\n\r\n\treturn Math.sin( Math.PI * u );\r\n\r\n};\r\n\r\n// For computing of Frenet frames, exposing the tangents, normals and binormals the spline\r\nTHREE.TubeGeometry.FrenetFrames = function ( path, segments, closed ) {\r\n\r\n\tvar\tnormal = new THREE.Vector3(),\r\n\r\n\t\ttangents = [],\r\n\t\tnormals = [],\r\n\t\tbinormals = [],\r\n\r\n\t\tvec = new THREE.Vector3(),\r\n\t\tmat = new THREE.Matrix4(),\r\n\r\n\t\tnumpoints = segments + 1,\r\n\t\ttheta,\r\n\t\tsmallest,\r\n\r\n\t\ttx, ty, tz,\r\n\t\ti, u;\r\n\r\n\r\n\t// expose internals\r\n\tthis.tangents = tangents;\r\n\tthis.normals = normals;\r\n\tthis.binormals = binormals;\r\n\r\n\t// compute the tangent vectors for each segment on the path\r\n\r\n\tfor ( i = 0; i < numpoints; i ++ ) {\r\n\r\n\t\tu = i / ( numpoints - 1 );\r\n\r\n\t\ttangents[ i ] = path.getTangentAt( u );\r\n\t\ttangents[ i ].normalize();\r\n\r\n\t}\r\n\r\n\tinitialNormal3();\r\n\r\n\t/*\r\n\tfunction initialNormal1(lastBinormal) {\r\n\t\t// fixed start binormal. Has dangers of 0 vectors\r\n\t\tnormals[ 0 ] = new THREE.Vector3();\r\n\t\tbinormals[ 0 ] = new THREE.Vector3();\r\n\t\tif (lastBinormal===undefined) lastBinormal = new THREE.Vector3( 0, 0, 1 );\r\n\t\tnormals[ 0 ].crossVectors( lastBinormal, tangents[ 0 ] ).normalize();\r\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n\t}\r\n\r\n\tfunction initialNormal2() {\r\n\r\n\t\t// This uses the Frenet-Serret formula for deriving binormal\r\n\t\tvar t2 = path.getTangentAt( epsilon );\r\n\r\n\t\tnormals[ 0 ] = new THREE.Vector3().subVectors( t2, tangents[ 0 ] ).normalize();\r\n\t\tbinormals[ 0 ] = new THREE.Vector3().crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\r\n\t\tnormals[ 0 ].crossVectors( binormals[ 0 ], tangents[ 0 ] ).normalize(); // last binormal x tangent\r\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] ).normalize();\r\n\r\n\t}\r\n\t*/\r\n\r\n\tfunction initialNormal3() {\r\n\r\n\t\t// select an initial normal vector perpendicular to the first tangent vector,\r\n\t\t// and in the direction of the smallest tangent xyz component\r\n\r\n\t\tnormals[ 0 ] = new THREE.Vector3();\r\n\t\tbinormals[ 0 ] = new THREE.Vector3();\r\n\t\tsmallest = Number.MAX_VALUE;\r\n\t\ttx = Math.abs( tangents[ 0 ].x );\r\n\t\tty = Math.abs( tangents[ 0 ].y );\r\n\t\ttz = Math.abs( tangents[ 0 ].z );\r\n\r\n\t\tif ( tx <= smallest ) {\r\n\r\n\t\t\tsmallest = tx;\r\n\t\t\tnormal.set( 1, 0, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( ty <= smallest ) {\r\n\r\n\t\t\tsmallest = ty;\r\n\t\t\tnormal.set( 0, 1, 0 );\r\n\r\n\t\t}\r\n\r\n\t\tif ( tz <= smallest ) {\r\n\r\n\t\t\tnormal.set( 0, 0, 1 );\r\n\r\n\t\t}\r\n\r\n\t\tvec.crossVectors( tangents[ 0 ], normal ).normalize();\r\n\r\n\t\tnormals[ 0 ].crossVectors( tangents[ 0 ], vec );\r\n\t\tbinormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );\r\n\r\n\t}\r\n\r\n\r\n\t// compute the slowly-varying normal and binormal vectors for each segment on the path\r\n\r\n\tfor ( i = 1; i < numpoints; i ++ ) {\r\n\r\n\t\tnormals[ i ] = normals[ i - 1 ].clone();\r\n\r\n\t\tbinormals[ i ] = binormals[ i - 1 ].clone();\r\n\r\n\t\tvec.crossVectors( tangents[ i - 1 ], tangents[ i ] );\r\n\r\n\t\tif ( vec.length() > Number.EPSILON ) {\r\n\r\n\t\t\tvec.normalize();\r\n\r\n\t\t\ttheta = Math.acos( THREE.Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors\r\n\r\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );\r\n\r\n\t\t}\r\n\r\n\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\r\n\t}\r\n\r\n\r\n\t// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\r\n\r\n\tif ( closed ) {\r\n\r\n\t\ttheta = Math.acos( THREE.Math.clamp( normals[ 0 ].dot( normals[ numpoints - 1 ] ), - 1, 1 ) );\r\n\t\ttheta /= ( numpoints - 1 );\r\n\r\n\t\tif ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ numpoints - 1 ] ) ) > 0 ) {\r\n\r\n\t\t\ttheta = - theta;\r\n\r\n\t\t}\r\n\r\n\t\tfor ( i = 1; i < numpoints; i ++ ) {\r\n\r\n\t\t\t// twist a little...\r\n\t\t\tnormals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );\r\n\t\t\tbinormals[ i ].crossVectors( tangents[ i ], normals[ i ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n// File:src/extras/geometries/PolyhedronGeometry.js\r\n\r\n/**\r\n * @author clockworkgeek / https://github.com/clockworkgeek\r\n * @author timothypratley / https://github.com/timothypratley\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.PolyhedronGeometry = function ( vertices, indices, radius, detail ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'PolyhedronGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tvertices: vertices,\r\n\t\tindices: indices,\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n\tradius = radius || 1;\r\n\tdetail = detail || 0;\r\n\r\n\tvar that = this;\r\n\r\n\tfor ( var i = 0, l = vertices.length; i < l; i += 3 ) {\r\n\r\n\t\tprepare( new THREE.Vector3( vertices[ i ], vertices[ i + 1 ], vertices[ i + 2 ] ) );\r\n\r\n\t}\r\n\r\n\tvar p = this.vertices;\r\n\r\n\tvar faces = [];\r\n\r\n\tfor ( var i = 0, j = 0, l = indices.length; i < l; i += 3, j ++ ) {\r\n\r\n\t\tvar v1 = p[ indices[ i ] ];\r\n\t\tvar v2 = p[ indices[ i + 1 ] ];\r\n\t\tvar v3 = p[ indices[ i + 2 ] ];\r\n\r\n\t\tfaces[ j ] = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, j );\r\n\r\n\t}\r\n\r\n\tvar centroid = new THREE.Vector3();\r\n\r\n\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\tsubdivide( faces[ i ], detail );\r\n\r\n\t}\r\n\r\n\r\n\t// Handle case when face straddles the seam\r\n\r\n\tfor ( var i = 0, l = this.faceVertexUvs[ 0 ].length; i < l; i ++ ) {\r\n\r\n\t\tvar uvs = this.faceVertexUvs[ 0 ][ i ];\r\n\r\n\t\tvar x0 = uvs[ 0 ].x;\r\n\t\tvar x1 = uvs[ 1 ].x;\r\n\t\tvar x2 = uvs[ 2 ].x;\r\n\r\n\t\tvar max = Math.max( x0, x1, x2 );\r\n\t\tvar min = Math.min( x0, x1, x2 );\r\n\r\n\t\tif ( max > 0.9 && min < 0.1 ) {\r\n\r\n\t\t\t// 0.9 is somewhat arbitrary\r\n\r\n\t\t\tif ( x0 < 0.2 ) uvs[ 0 ].x += 1;\r\n\t\t\tif ( x1 < 0.2 ) uvs[ 1 ].x += 1;\r\n\t\t\tif ( x2 < 0.2 ) uvs[ 2 ].x += 1;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t// Apply radius\r\n\r\n\tfor ( var i = 0, l = this.vertices.length; i < l; i ++ ) {\r\n\r\n\t\tthis.vertices[ i ].multiplyScalar( radius );\r\n\r\n\t}\r\n\r\n\r\n\t// Merge vertices\r\n\r\n\tthis.mergeVertices();\r\n\r\n\tthis.computeFaceNormals();\r\n\r\n\tthis.boundingSphere = new THREE.Sphere( new THREE.Vector3(), radius );\r\n\r\n\r\n\t// Project vector onto sphere's surface\r\n\r\n\tfunction prepare( vector ) {\r\n\r\n\t\tvar vertex = vector.normalize().clone();\r\n\t\tvertex.index = that.vertices.push( vertex ) - 1;\r\n\r\n\t\t// Texture coords are equivalent to map coords, calculate angle and convert to fraction of a circle.\r\n\r\n\t\tvar u = azimuth( vector ) / 2 / Math.PI + 0.5;\r\n\t\tvar v = inclination( vector ) / Math.PI + 0.5;\r\n\t\tvertex.uv = new THREE.Vector2( u, 1 - v );\r\n\r\n\t\treturn vertex;\r\n\r\n\t}\r\n\r\n\r\n\t// Approximate a curved face with recursively sub-divided triangles.\r\n\r\n\tfunction make( v1, v2, v3, materialIndex ) {\r\n\r\n\t\tvar face = new THREE.Face3( v1.index, v2.index, v3.index, [ v1.clone(), v2.clone(), v3.clone() ], undefined, materialIndex );\r\n\t\tthat.faces.push( face );\r\n\r\n\t\tcentroid.copy( v1 ).add( v2 ).add( v3 ).divideScalar( 3 );\r\n\r\n\t\tvar azi = azimuth( centroid );\r\n\r\n\t\tthat.faceVertexUvs[ 0 ].push( [\r\n\t\t\tcorrectUV( v1.uv, v1, azi ),\r\n\t\t\tcorrectUV( v2.uv, v2, azi ),\r\n\t\t\tcorrectUV( v3.uv, v3, azi )\r\n\t\t] );\r\n\r\n\t}\r\n\r\n\r\n\t// Analytically subdivide a face to the required detail level.\r\n\r\n\tfunction subdivide( face, detail ) {\r\n\r\n\t\tvar cols = Math.pow( 2, detail );\r\n\t\tvar a = prepare( that.vertices[ face.a ] );\r\n\t\tvar b = prepare( that.vertices[ face.b ] );\r\n\t\tvar c = prepare( that.vertices[ face.c ] );\r\n\t\tvar v = [];\r\n\r\n\t\tvar materialIndex = face.materialIndex;\r\n\r\n\t\t// Construct all of the vertices for this subdivision.\r\n\r\n\t\tfor ( var i = 0 ; i <= cols; i ++ ) {\r\n\r\n\t\t\tv[ i ] = [];\r\n\r\n\t\t\tvar aj = prepare( a.clone().lerp( c, i / cols ) );\r\n\t\t\tvar bj = prepare( b.clone().lerp( c, i / cols ) );\r\n\t\t\tvar rows = cols - i;\r\n\r\n\t\t\tfor ( var j = 0; j <= rows; j ++ ) {\r\n\r\n\t\t\t\tif ( j === 0 && i === cols ) {\r\n\r\n\t\t\t\t\tv[ i ][ j ] = aj;\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tv[ i ][ j ] = prepare( aj.clone().lerp( bj, j / rows ) );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\t// Construct all of the faces.\r\n\r\n\t\tfor ( var i = 0; i < cols ; i ++ ) {\r\n\r\n\t\t\tfor ( var j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {\r\n\r\n\t\t\t\tvar k = Math.floor( j / 2 );\r\n\r\n\t\t\t\tif ( j % 2 === 0 ) {\r\n\r\n\t\t\t\t\tmake(\r\n\t\t\t\t\t\tv[ i ][ k + 1 ],\r\n\t\t\t\t\t\tv[ i + 1 ][ k ],\r\n\t\t\t\t\t\tv[ i ][ k ],\r\n\t\t\t\t\t\tmaterialIndex\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t} else {\r\n\r\n\t\t\t\t\tmake(\r\n\t\t\t\t\t\tv[ i ][ k + 1 ],\r\n\t\t\t\t\t\tv[ i + 1 ][ k + 1 ],\r\n\t\t\t\t\t\tv[ i + 1 ][ k ],\r\n\t\t\t\t\t\tmaterialIndex\r\n\t\t\t\t\t);\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\r\n\t// Angle around the Y axis, counter-clockwise when looking from above.\r\n\r\n\tfunction azimuth( vector ) {\r\n\r\n\t\treturn Math.atan2( vector.z, - vector.x );\r\n\r\n\t}\r\n\r\n\r\n\t// Angle above the XZ plane.\r\n\r\n\tfunction inclination( vector ) {\r\n\r\n\t\treturn Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );\r\n\r\n\t}\r\n\r\n\r\n\t// Texture fixing helper. Spheres have some odd behaviours.\r\n\r\n\tfunction correctUV( uv, vector, azimuth ) {\r\n\r\n\t\tif ( ( azimuth < 0 ) && ( uv.x === 1 ) ) uv = new THREE.Vector2( uv.x - 1, uv.y );\r\n\t\tif ( ( vector.x === 0 ) && ( vector.z === 0 ) ) uv = new THREE.Vector2( azimuth / 2 / Math.PI + 0.5, uv.y );\r\n\t\treturn uv.clone();\r\n\r\n\t}\r\n\r\n\r\n};\r\n\r\nTHREE.PolyhedronGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.PolyhedronGeometry.prototype.constructor = THREE.PolyhedronGeometry;\r\n\r\n// File:src/extras/geometries/DodecahedronGeometry.js\r\n\r\n/**\r\n * @author Abe Pazos / https://hamoid.com\r\n */\r\n\r\nTHREE.DodecahedronGeometry = function ( radius, detail ) {\r\n\r\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n\tvar r = 1 / t;\r\n\r\n\tvar vertices = [\r\n\r\n\t\t// (±1, ±1, ±1)\r\n\t\t- 1, - 1, - 1,    - 1, - 1,  1,\r\n\t\t- 1,  1, - 1,    - 1,  1,  1,\r\n\t\t 1, - 1, - 1,     1, - 1,  1,\r\n\t\t 1,  1, - 1,     1,  1,  1,\r\n\r\n\t\t// (0, ±1/φ, ±φ)\r\n\t\t 0, - r, - t,     0, - r,  t,\r\n\t\t 0,  r, - t,     0,  r,  t,\r\n\r\n\t\t// (±1/φ, ±φ, 0)\r\n\t\t- r, - t,  0,    - r,  t,  0,\r\n\t\t r, - t,  0,     r,  t,  0,\r\n\r\n\t\t// (±φ, 0, ±1/φ)\r\n\t\t- t,  0, - r,     t,  0, - r,\r\n\t\t- t,  0,  r,     t,  0,  r\r\n\t];\r\n\r\n\tvar indices = [\r\n\t\t 3, 11,  7,      3,  7, 15,      3, 15, 13,\r\n\t\t 7, 19, 17,      7, 17,  6,      7,  6, 15,\r\n\t\t17,  4,  8,     17,  8, 10,     17, 10,  6,\r\n\t\t 8,  0, 16,      8, 16,  2,      8,  2, 10,\r\n\t\t 0, 12,  1,      0,  1, 18,      0, 18, 16,\r\n\t\t 6, 10,  2,      6,  2, 13,      6, 13, 15,\r\n\t\t 2, 16, 18,      2, 18,  3,      2,  3, 13,\r\n\t\t18,  1,  9,     18,  9, 11,     18, 11,  3,\r\n\t\t 4, 14, 12,      4, 12,  0,      4,  0,  8,\r\n\t\t11,  9,  5,     11,  5, 19,     11, 19,  7,\r\n\t\t19,  5, 14,     19, 14,  4,     19,  4, 17,\r\n\t\t 1, 12, 14,      1, 14,  5,      1,  5,  9\r\n\t];\r\n\r\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n\tthis.type = 'DodecahedronGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n};\r\n\r\nTHREE.DodecahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\nTHREE.DodecahedronGeometry.prototype.constructor = THREE.DodecahedronGeometry;\r\n\r\n// File:src/extras/geometries/IcosahedronGeometry.js\r\n\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.IcosahedronGeometry = function ( radius, detail ) {\r\n\r\n\tvar t = ( 1 + Math.sqrt( 5 ) ) / 2;\r\n\r\n\tvar vertices = [\r\n\t\t- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,\r\n\t\t 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,\r\n\t\t t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1\r\n\t];\r\n\r\n\tvar indices = [\r\n\t\t 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,\r\n\t\t 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,\r\n\t\t 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,\r\n\t\t 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1\r\n\t];\r\n\r\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n\tthis.type = 'IcosahedronGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n};\r\n\r\nTHREE.IcosahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\nTHREE.IcosahedronGeometry.prototype.constructor = THREE.IcosahedronGeometry;\r\n\r\n// File:src/extras/geometries/OctahedronGeometry.js\r\n\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.OctahedronGeometry = function ( radius, detail ) {\r\n\r\n\tvar vertices = [\r\n\t\t1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1\r\n\t];\r\n\r\n\tvar indices = [\r\n\t\t0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2\r\n\t];\r\n\r\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n\tthis.type = 'OctahedronGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n};\r\n\r\nTHREE.OctahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\nTHREE.OctahedronGeometry.prototype.constructor = THREE.OctahedronGeometry;\r\n\r\n// File:src/extras/geometries/TetrahedronGeometry.js\r\n\r\n/**\r\n * @author timothypratley / https://github.com/timothypratley\r\n */\r\n\r\nTHREE.TetrahedronGeometry = function ( radius, detail ) {\r\n\r\n\tvar vertices = [\r\n\t\t 1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1\r\n\t];\r\n\r\n\tvar indices = [\r\n\t\t 2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1\r\n\t];\r\n\r\n\tTHREE.PolyhedronGeometry.call( this, vertices, indices, radius, detail );\r\n\r\n\tthis.type = 'TetrahedronGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tradius: radius,\r\n\t\tdetail: detail\r\n\t};\r\n\r\n};\r\n\r\nTHREE.TetrahedronGeometry.prototype = Object.create( THREE.PolyhedronGeometry.prototype );\r\nTHREE.TetrahedronGeometry.prototype.constructor = THREE.TetrahedronGeometry;\r\n\r\n// File:src/extras/geometries/ParametricGeometry.js\r\n\r\n/**\r\n * @author zz85 / https://github.com/zz85\r\n * Parametric Surfaces Geometry\r\n * based on the brilliant article by @prideout http://prideout.net/blog/?p=44\r\n *\r\n * new THREE.ParametricGeometry( parametricFunction, uSegments, ySegements );\r\n *\r\n */\r\n\r\nTHREE.ParametricGeometry = function ( func, slices, stacks ) {\r\n\r\n\tTHREE.Geometry.call( this );\r\n\r\n\tthis.type = 'ParametricGeometry';\r\n\r\n\tthis.parameters = {\r\n\t\tfunc: func,\r\n\t\tslices: slices,\r\n\t\tstacks: stacks\r\n\t};\r\n\r\n\tvar verts = this.vertices;\r\n\tvar faces = this.faces;\r\n\tvar uvs = this.faceVertexUvs[ 0 ];\r\n\r\n\tvar i, j, p;\r\n\tvar u, v;\r\n\r\n\tvar sliceCount = slices + 1;\r\n\r\n\tfor ( i = 0; i <= stacks; i ++ ) {\r\n\r\n\t\tv = i / stacks;\r\n\r\n\t\tfor ( j = 0; j <= slices; j ++ ) {\r\n\r\n\t\t\tu = j / slices;\r\n\r\n\t\t\tp = func( u, v );\r\n\t\t\tverts.push( p );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tvar a, b, c, d;\r\n\tvar uva, uvb, uvc, uvd;\r\n\r\n\tfor ( i = 0; i < stacks; i ++ ) {\r\n\r\n\t\tfor ( j = 0; j < slices; j ++ ) {\r\n\r\n\t\t\ta = i * sliceCount + j;\r\n\t\t\tb = i * sliceCount + j + 1;\r\n\t\t\tc = ( i + 1 ) * sliceCount + j + 1;\r\n\t\t\td = ( i + 1 ) * sliceCount + j;\r\n\r\n\t\t\tuva = new THREE.Vector2( j / slices, i / stacks );\r\n\t\t\tuvb = new THREE.Vector2( ( j + 1 ) / slices, i / stacks );\r\n\t\t\tuvc = new THREE.Vector2( ( j + 1 ) / slices, ( i + 1 ) / stacks );\r\n\t\t\tuvd = new THREE.Vector2( j / slices, ( i + 1 ) / stacks );\r\n\r\n\t\t\tfaces.push( new THREE.Face3( a, b, d ) );\r\n\t\t\tuvs.push( [ uva, uvb, uvd ] );\r\n\r\n\t\t\tfaces.push( new THREE.Face3( b, c, d ) );\r\n\t\t\tuvs.push( [ uvb.clone(), uvc, uvd.clone() ] );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t// console.log(this);\r\n\r\n\t// magic bullet\r\n\t// var diff = this.mergeVertices();\r\n\t// console.log('removed ', diff, ' vertices by merging');\r\n\r\n\tthis.computeFaceNormals();\r\n\tthis.computeVertexNormals();\r\n\r\n};\r\n\r\nTHREE.ParametricGeometry.prototype = Object.create( THREE.Geometry.prototype );\r\nTHREE.ParametricGeometry.prototype.constructor = THREE.ParametricGeometry;\r\n\r\n// File:src/extras/geometries/WireframeGeometry.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.WireframeGeometry = function ( geometry ) {\r\n\r\n\tTHREE.BufferGeometry.call( this );\r\n\r\n\tvar edge = [ 0, 0 ], hash = {};\r\n\r\n\tfunction sortFunction( a, b ) {\r\n\r\n\t\treturn a - b;\r\n\r\n\t}\r\n\r\n\tvar keys = [ 'a', 'b', 'c' ];\r\n\r\n\tif ( geometry instanceof THREE.Geometry ) {\r\n\r\n\t\tvar vertices = geometry.vertices;\r\n\t\tvar faces = geometry.faces;\r\n\t\tvar numEdges = 0;\r\n\r\n\t\t// allocate maximal size\r\n\t\tvar edges = new Uint32Array( 6 * faces.length );\r\n\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\tedge[ 0 ] = face[ keys[ j ] ];\r\n\t\t\t\tedge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];\r\n\t\t\t\tedge.sort( sortFunction );\r\n\r\n\t\t\t\tvar key = edge.toString();\r\n\r\n\t\t\t\tif ( hash[ key ] === undefined ) {\r\n\r\n\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\r\n\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\r\n\t\t\t\t\thash[ key ] = true;\r\n\t\t\t\t\tnumEdges ++;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\r\n\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\r\n\r\n\t\t\tfor ( var j = 0; j < 2; j ++ ) {\r\n\r\n\t\t\t\tvar vertex = vertices[ edges [ 2 * i + j ] ];\r\n\r\n\t\t\t\tvar index = 6 * i + 3 * j;\r\n\t\t\t\tcoords[ index + 0 ] = vertex.x;\r\n\t\t\t\tcoords[ index + 1 ] = vertex.y;\r\n\t\t\t\tcoords[ index + 2 ] = vertex.z;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\r\n\t} else if ( geometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\tif ( geometry.index !== null ) {\r\n\r\n\t\t\t// Indexed BufferGeometry\r\n\r\n\t\t\tvar indices = geometry.index.array;\r\n\t\t\tvar vertices = geometry.attributes.position;\r\n\t\t\tvar groups = geometry.groups;\r\n\t\t\tvar numEdges = 0;\r\n\r\n\t\t\tif ( groups.length === 0 ) {\r\n\r\n\t\t\t\tgeometry.addGroup( 0, indices.length );\r\n\r\n\t\t\t}\r\n\r\n\t\t\t// allocate maximal size\r\n\t\t\tvar edges = new Uint32Array( 2 * indices.length );\r\n\r\n\t\t\tfor ( var o = 0, ol = groups.length; o < ol; ++ o ) {\r\n\r\n\t\t\t\tvar group = groups[ o ];\r\n\r\n\t\t\t\tvar start = group.start;\r\n\t\t\t\tvar count = group.count;\r\n\r\n\t\t\t\tfor ( var i = start, il = start + count; i < il; i += 3 ) {\r\n\r\n\t\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\t\tedge[ 0 ] = indices[ i + j ];\r\n\t\t\t\t\t\tedge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];\r\n\t\t\t\t\t\tedge.sort( sortFunction );\r\n\r\n\t\t\t\t\t\tvar key = edge.toString();\r\n\r\n\t\t\t\t\t\tif ( hash[ key ] === undefined ) {\r\n\r\n\t\t\t\t\t\t\tedges[ 2 * numEdges ] = edge[ 0 ];\r\n\t\t\t\t\t\t\tedges[ 2 * numEdges + 1 ] = edge[ 1 ];\r\n\t\t\t\t\t\t\thash[ key ] = true;\r\n\t\t\t\t\t\t\tnumEdges ++;\r\n\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\r\n\t\t\tfor ( var i = 0, l = numEdges; i < l; i ++ ) {\r\n\r\n\t\t\t\tfor ( var j = 0; j < 2; j ++ ) {\r\n\r\n\t\t\t\t\tvar index = 6 * i + 3 * j;\r\n\t\t\t\t\tvar index2 = edges[ 2 * i + j ];\r\n\r\n\t\t\t\t\tcoords[ index + 0 ] = vertices.getX( index2 );\r\n\t\t\t\t\tcoords[ index + 1 ] = vertices.getY( index2 );\r\n\t\t\t\t\tcoords[ index + 2 ] = vertices.getZ( index2 );\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\r\n\t\t} else {\r\n\r\n\t\t\t// non-indexed BufferGeometry\r\n\r\n\t\t\tvar vertices = geometry.attributes.position.array;\r\n\t\t\tvar numEdges = vertices.length / 3;\r\n\t\t\tvar numTris = numEdges / 3;\r\n\r\n\t\t\tvar coords = new Float32Array( numEdges * 2 * 3 );\r\n\r\n\t\t\tfor ( var i = 0, l = numTris; i < l; i ++ ) {\r\n\r\n\t\t\t\tfor ( var j = 0; j < 3; j ++ ) {\r\n\r\n\t\t\t\t\tvar index = 18 * i + 6 * j;\r\n\r\n\t\t\t\t\tvar index1 = 9 * i + 3 * j;\r\n\t\t\t\t\tcoords[ index + 0 ] = vertices[ index1 ];\r\n\t\t\t\t\tcoords[ index + 1 ] = vertices[ index1 + 1 ];\r\n\t\t\t\t\tcoords[ index + 2 ] = vertices[ index1 + 2 ];\r\n\r\n\t\t\t\t\tvar index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );\r\n\t\t\t\t\tcoords[ index + 3 ] = vertices[ index2 ];\r\n\t\t\t\t\tcoords[ index + 4 ] = vertices[ index2 + 1 ];\r\n\t\t\t\t\tcoords[ index + 5 ] = vertices[ index2 + 2 ];\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t\tthis.addAttribute( 'position', new THREE.BufferAttribute( coords, 3 ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.WireframeGeometry.prototype = Object.create( THREE.BufferGeometry.prototype );\r\nTHREE.WireframeGeometry.prototype.constructor = THREE.WireframeGeometry;\r\n\r\n// File:src/extras/helpers/AxisHelper.js\r\n\r\n/**\r\n * @author sroucheray / http://sroucheray.org/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.AxisHelper = function ( size ) {\r\n\r\n\tsize = size || 1;\r\n\r\n\tvar vertices = new Float32Array( [\r\n\t\t0, 0, 0,  size, 0, 0,\r\n\t\t0, 0, 0,  0, size, 0,\r\n\t\t0, 0, 0,  0, 0, size\r\n\t] );\r\n\r\n\tvar colors = new Float32Array( [\r\n\t\t1, 0, 0,  1, 0.6, 0,\r\n\t\t0, 1, 0,  0.6, 1, 0,\r\n\t\t0, 0, 1,  0, 0.6, 1\r\n\t] );\r\n\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( vertices, 3 ) );\r\n\tgeometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3 ) );\r\n\r\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\r\n\r\n\tTHREE.LineSegments.call( this, geometry, material );\r\n\r\n};\r\n\r\nTHREE.AxisHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.AxisHelper.prototype.constructor = THREE.AxisHelper;\r\n\r\n// File:src/extras/helpers/ArrowHelper.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @author zz85 / http://github.com/zz85\r\n * @author bhouston / http://clara.io\r\n *\r\n * Creates an arrow for visualizing directions\r\n *\r\n * Parameters:\r\n *  dir - Vector3\r\n *  origin - Vector3\r\n *  length - Number\r\n *  color - color in hex value\r\n *  headLength - Number\r\n *  headWidth - Number\r\n */\r\n\r\nTHREE.ArrowHelper = ( function () {\r\n\r\n\tvar lineGeometry = new THREE.BufferGeometry();\r\n\tlineGeometry.addAttribute( 'position', new THREE.Float32Attribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );\r\n\r\n\tvar coneGeometry = new THREE.CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );\r\n\tconeGeometry.translate( 0, - 0.5, 0 );\r\n\r\n\treturn function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {\r\n\r\n\t\t// dir is assumed to be normalized\r\n\r\n\t\tTHREE.Object3D.call( this );\r\n\r\n\t\tif ( color === undefined ) color = 0xffff00;\r\n\t\tif ( length === undefined ) length = 1;\r\n\t\tif ( headLength === undefined ) headLength = 0.2 * length;\r\n\t\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\r\n\r\n\t\tthis.position.copy( origin );\r\n\r\n\t\tthis.line = new THREE.Line( lineGeometry, new THREE.LineBasicMaterial( { color: color } ) );\r\n\t\tthis.line.matrixAutoUpdate = false;\r\n\t\tthis.add( this.line );\r\n\r\n\t\tthis.cone = new THREE.Mesh( coneGeometry, new THREE.MeshBasicMaterial( { color: color } ) );\r\n\t\tthis.cone.matrixAutoUpdate = false;\r\n\t\tthis.add( this.cone );\r\n\r\n\t\tthis.setDirection( dir );\r\n\t\tthis.setLength( length, headLength, headWidth );\r\n\r\n\t};\r\n\r\n}() );\r\n\r\nTHREE.ArrowHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.ArrowHelper.prototype.constructor = THREE.ArrowHelper;\r\n\r\nTHREE.ArrowHelper.prototype.setDirection = ( function () {\r\n\r\n\tvar axis = new THREE.Vector3();\r\n\tvar radians;\r\n\r\n\treturn function setDirection( dir ) {\r\n\r\n\t\t// dir is assumed to be normalized\r\n\r\n\t\tif ( dir.y > 0.99999 ) {\r\n\r\n\t\t\tthis.quaternion.set( 0, 0, 0, 1 );\r\n\r\n\t\t} else if ( dir.y < - 0.99999 ) {\r\n\r\n\t\t\tthis.quaternion.set( 1, 0, 0, 0 );\r\n\r\n\t\t} else {\r\n\r\n\t\t\taxis.set( dir.z, 0, - dir.x ).normalize();\r\n\r\n\t\t\tradians = Math.acos( dir.y );\r\n\r\n\t\t\tthis.quaternion.setFromAxisAngle( axis, radians );\r\n\r\n\t\t}\r\n\r\n\t};\r\n\r\n}() );\r\n\r\nTHREE.ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {\r\n\r\n\tif ( headLength === undefined ) headLength = 0.2 * length;\r\n\tif ( headWidth === undefined ) headWidth = 0.2 * headLength;\r\n\r\n\tthis.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );\r\n\tthis.line.updateMatrix();\r\n\r\n\tthis.cone.scale.set( headWidth, headLength, headWidth );\r\n\tthis.cone.position.y = length;\r\n\tthis.cone.updateMatrix();\r\n\r\n};\r\n\r\nTHREE.ArrowHelper.prototype.setColor = function ( color ) {\r\n\r\n\tthis.line.material.color.copy( color );\r\n\tthis.cone.material.color.copy( color );\r\n\r\n};\r\n\r\n// File:src/extras/helpers/BoxHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.BoxHelper = function ( object ) {\r\n\r\n\tvar indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );\r\n\tvar positions = new Float32Array( 8 * 3 );\r\n\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\tgeometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );\r\n\tgeometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );\r\n\r\n\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: 0xffff00 } ) );\r\n\r\n\tif ( object !== undefined ) {\r\n\r\n\t\tthis.update( object );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.BoxHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.BoxHelper.prototype.constructor = THREE.BoxHelper;\r\n\r\nTHREE.BoxHelper.prototype.update = ( function () {\r\n\r\n\tvar box = new THREE.Box3();\r\n\r\n\treturn function ( object ) {\r\n\r\n\t\tif ( object instanceof THREE.Box3 ) {\r\n\r\n\t\t\tbox.copy( object );\r\n\r\n\t\t} else {\r\n\r\n\t\t\tbox.setFromObject( object );\r\n\r\n\t\t}\r\n\r\n\t\tif ( box.isEmpty() ) return;\r\n\r\n\t\tvar min = box.min;\r\n\t\tvar max = box.max;\r\n\r\n\t\t/*\r\n\t\t  5____4\r\n\t\t1/___0/|\r\n\t\t| 6__|_7\r\n\t\t2/___3/\r\n\r\n\t\t0: max.x, max.y, max.z\r\n\t\t1: min.x, max.y, max.z\r\n\t\t2: min.x, min.y, max.z\r\n\t\t3: max.x, min.y, max.z\r\n\t\t4: max.x, max.y, min.z\r\n\t\t5: min.x, max.y, min.z\r\n\t\t6: min.x, min.y, min.z\r\n\t\t7: max.x, min.y, min.z\r\n\t\t*/\r\n\r\n\t\tvar position = this.geometry.attributes.position;\r\n\t\tvar array = position.array;\r\n\r\n\t\tarray[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;\r\n\t\tarray[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;\r\n\t\tarray[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;\r\n\t\tarray[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;\r\n\t\tarray[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;\r\n\t\tarray[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;\r\n\t\tarray[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;\r\n\t\tarray[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;\r\n\r\n\t\tposition.needsUpdate = true;\r\n\r\n\t\tthis.geometry.computeBoundingSphere();\r\n\r\n\t};\r\n\r\n} )();\r\n\r\n// File:src/extras/helpers/BoundingBoxHelper.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\n// a helper to show the world-axis-aligned bounding box for an object\r\n\r\nTHREE.BoundingBoxHelper = function ( object, hex ) {\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0x888888;\r\n\r\n\tthis.object = object;\r\n\r\n\tthis.box = new THREE.Box3();\r\n\r\n\tTHREE.Mesh.call( this, new THREE.BoxGeometry( 1, 1, 1 ), new THREE.MeshBasicMaterial( { color: color, wireframe: true } ) );\r\n\r\n};\r\n\r\nTHREE.BoundingBoxHelper.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.BoundingBoxHelper.prototype.constructor = THREE.BoundingBoxHelper;\r\n\r\nTHREE.BoundingBoxHelper.prototype.update = function () {\r\n\r\n\tthis.box.setFromObject( this.object );\r\n\r\n\tthis.box.size( this.scale );\r\n\r\n\tthis.box.center( this.position );\r\n\r\n};\r\n\r\n// File:src/extras/helpers/CameraHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n *\r\n *\t- shows frustum, line of sight and up of the camera\r\n *\t- suitable for fast updates\r\n * \t- based on frustum visualization in lightgl.js shadowmap example\r\n *\t\thttp://evanw.github.com/lightgl.js/tests/shadowmap.html\r\n */\r\n\r\nTHREE.CameraHelper = function ( camera ) {\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\tvar material = new THREE.LineBasicMaterial( { color: 0xffffff, vertexColors: THREE.FaceColors } );\r\n\r\n\tvar pointMap = {};\r\n\r\n\t// colors\r\n\r\n\tvar hexFrustum = 0xffaa00;\r\n\tvar hexCone = 0xff0000;\r\n\tvar hexUp = 0x00aaff;\r\n\tvar hexTarget = 0xffffff;\r\n\tvar hexCross = 0x333333;\r\n\r\n\t// near\r\n\r\n\taddLine( \"n1\", \"n2\", hexFrustum );\r\n\taddLine( \"n2\", \"n4\", hexFrustum );\r\n\taddLine( \"n4\", \"n3\", hexFrustum );\r\n\taddLine( \"n3\", \"n1\", hexFrustum );\r\n\r\n\t// far\r\n\r\n\taddLine( \"f1\", \"f2\", hexFrustum );\r\n\taddLine( \"f2\", \"f4\", hexFrustum );\r\n\taddLine( \"f4\", \"f3\", hexFrustum );\r\n\taddLine( \"f3\", \"f1\", hexFrustum );\r\n\r\n\t// sides\r\n\r\n\taddLine( \"n1\", \"f1\", hexFrustum );\r\n\taddLine( \"n2\", \"f2\", hexFrustum );\r\n\taddLine( \"n3\", \"f3\", hexFrustum );\r\n\taddLine( \"n4\", \"f4\", hexFrustum );\r\n\r\n\t// cone\r\n\r\n\taddLine( \"p\", \"n1\", hexCone );\r\n\taddLine( \"p\", \"n2\", hexCone );\r\n\taddLine( \"p\", \"n3\", hexCone );\r\n\taddLine( \"p\", \"n4\", hexCone );\r\n\r\n\t// up\r\n\r\n\taddLine( \"u1\", \"u2\", hexUp );\r\n\taddLine( \"u2\", \"u3\", hexUp );\r\n\taddLine( \"u3\", \"u1\", hexUp );\r\n\r\n\t// target\r\n\r\n\taddLine( \"c\", \"t\", hexTarget );\r\n\taddLine( \"p\", \"c\", hexCross );\r\n\r\n\t// cross\r\n\r\n\taddLine( \"cn1\", \"cn2\", hexCross );\r\n\taddLine( \"cn3\", \"cn4\", hexCross );\r\n\r\n\taddLine( \"cf1\", \"cf2\", hexCross );\r\n\taddLine( \"cf3\", \"cf4\", hexCross );\r\n\r\n\tfunction addLine( a, b, hex ) {\r\n\r\n\t\taddPoint( a, hex );\r\n\t\taddPoint( b, hex );\r\n\r\n\t}\r\n\r\n\tfunction addPoint( id, hex ) {\r\n\r\n\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\tgeometry.colors.push( new THREE.Color( hex ) );\r\n\r\n\t\tif ( pointMap[ id ] === undefined ) {\r\n\r\n\t\t\tpointMap[ id ] = [];\r\n\r\n\t\t}\r\n\r\n\t\tpointMap[ id ].push( geometry.vertices.length - 1 );\r\n\r\n\t}\r\n\r\n\tTHREE.LineSegments.call( this, geometry, material );\r\n\r\n\tthis.camera = camera;\r\n\tthis.camera.updateProjectionMatrix();\r\n\r\n\tthis.matrix = camera.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.pointMap = pointMap;\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.CameraHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.CameraHelper.prototype.constructor = THREE.CameraHelper;\r\n\r\nTHREE.CameraHelper.prototype.update = function () {\r\n\r\n\tvar geometry, pointMap;\r\n\r\n\tvar vector = new THREE.Vector3();\r\n\tvar camera = new THREE.Camera();\r\n\r\n\tfunction setPoint( point, x, y, z ) {\r\n\r\n\t\tvector.set( x, y, z ).unproject( camera );\r\n\r\n\t\tvar points = pointMap[ point ];\r\n\r\n\t\tif ( points !== undefined ) {\r\n\r\n\t\t\tfor ( var i = 0, il = points.length; i < il; i ++ ) {\r\n\r\n\t\t\t\tgeometry.vertices[ points[ i ] ].copy( vector );\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn function () {\r\n\r\n\t\tgeometry = this.geometry;\r\n\t\tpointMap = this.pointMap;\r\n\r\n\t\tvar w = 1, h = 1;\r\n\r\n\t\t// we need just camera projection matrix\r\n\t\t// world matrix must be identity\r\n\r\n\t\tcamera.projectionMatrix.copy( this.camera.projectionMatrix );\r\n\r\n\t\t// center / target\r\n\r\n\t\tsetPoint( \"c\", 0, 0, - 1 );\r\n\t\tsetPoint( \"t\", 0, 0,  1 );\r\n\r\n\t\t// near\r\n\r\n\t\tsetPoint( \"n1\", - w, - h, - 1 );\r\n\t\tsetPoint( \"n2\",   w, - h, - 1 );\r\n\t\tsetPoint( \"n3\", - w,   h, - 1 );\r\n\t\tsetPoint( \"n4\",   w,   h, - 1 );\r\n\r\n\t\t// far\r\n\r\n\t\tsetPoint( \"f1\", - w, - h, 1 );\r\n\t\tsetPoint( \"f2\",   w, - h, 1 );\r\n\t\tsetPoint( \"f3\", - w,   h, 1 );\r\n\t\tsetPoint( \"f4\",   w,   h, 1 );\r\n\r\n\t\t// up\r\n\r\n\t\tsetPoint( \"u1\",   w * 0.7, h * 1.1, - 1 );\r\n\t\tsetPoint( \"u2\", - w * 0.7, h * 1.1, - 1 );\r\n\t\tsetPoint( \"u3\",         0, h * 2,   - 1 );\r\n\r\n\t\t// cross\r\n\r\n\t\tsetPoint( \"cf1\", - w,   0, 1 );\r\n\t\tsetPoint( \"cf2\",   w,   0, 1 );\r\n\t\tsetPoint( \"cf3\",   0, - h, 1 );\r\n\t\tsetPoint( \"cf4\",   0,   h, 1 );\r\n\r\n\t\tsetPoint( \"cn1\", - w,   0, - 1 );\r\n\t\tsetPoint( \"cn2\",   w,   0, - 1 );\r\n\t\tsetPoint( \"cn3\",   0, - h, - 1 );\r\n\t\tsetPoint( \"cn4\",   0,   h, - 1 );\r\n\r\n\t\tgeometry.verticesNeedUpdate = true;\r\n\r\n\t};\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/DirectionalLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n */\r\n\r\nTHREE.DirectionalLightHelper = function ( light, size ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.light = light;\r\n\tthis.light.updateMatrixWorld();\r\n\r\n\tthis.matrix = light.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tif ( size === undefined ) size = 1;\r\n\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( [\r\n\t\t- size,   size, 0,\r\n\t\t  size,   size, 0,\r\n\t\t  size, - size, 0,\r\n\t\t- size, - size, 0,\r\n\t\t- size,   size, 0\r\n\t], 3 ) );\r\n\r\n\tvar material = new THREE.LineBasicMaterial( { fog: false } );\r\n\r\n\tthis.add( new THREE.Line( geometry, material ) );\r\n\r\n\tgeometry = new THREE.BufferGeometry();\r\n\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );\r\n\r\n\tthis.add( new THREE.Line( geometry, material ));\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.DirectionalLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.DirectionalLightHelper.prototype.constructor = THREE.DirectionalLightHelper;\r\n\r\nTHREE.DirectionalLightHelper.prototype.dispose = function () {\r\n\r\n\tvar lightPlane = this.children[ 0 ];\r\n\tvar targetLine = this.children[ 1 ];\r\n\r\n\tlightPlane.geometry.dispose();\r\n\tlightPlane.material.dispose();\r\n\ttargetLine.geometry.dispose();\r\n\ttargetLine.material.dispose();\r\n\r\n};\r\n\r\nTHREE.DirectionalLightHelper.prototype.update = function () {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\tvar v2 = new THREE.Vector3();\r\n\tvar v3 = new THREE.Vector3();\r\n\r\n\treturn function () {\r\n\r\n\t\tv1.setFromMatrixPosition( this.light.matrixWorld );\r\n\t\tv2.setFromMatrixPosition( this.light.target.matrixWorld );\r\n\t\tv3.subVectors( v2, v1 );\r\n\r\n\t\tvar lightPlane = this.children[ 0 ];\r\n\t\tvar targetLine = this.children[ 1 ];\r\n\r\n\t\tlightPlane.lookAt( v3 );\r\n\t\tlightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\t\ttargetLine.lookAt( v3 );\r\n\t\ttargetLine.scale.z = v3.length();\r\n\r\n\t};\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/EdgesHelper.js\r\n\r\n/**\r\n * @author WestLangley / http://github.com/WestLangley\r\n * @param object THREE.Mesh whose geometry will be used\r\n * @param hex line color\r\n * @param thresholdAngle the minimum angle (in degrees),\r\n * between the face normals of adjacent faces,\r\n * that is required to render an edge. A value of 10 means\r\n * an edge is only rendered if the angle is at least 10 degrees.\r\n */\r\n\r\nTHREE.EdgesHelper = function ( object, hex, thresholdAngle ) {\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\r\n\r\n\tTHREE.LineSegments.call( this, new THREE.EdgesGeometry( object.geometry, thresholdAngle ), new THREE.LineBasicMaterial( { color: color } ) );\r\n\r\n\tthis.matrix = object.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.EdgesHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.EdgesHelper.prototype.constructor = THREE.EdgesHelper;\r\n\r\n// File:src/extras/helpers/FaceNormalsHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.FaceNormalsHelper = function ( object, size, hex, linewidth ) {\r\n\r\n\t// FaceNormalsHelper only supports THREE.Geometry\r\n\r\n\tthis.object = object;\r\n\r\n\tthis.size = ( size !== undefined ) ? size : 1;\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0xffff00;\r\n\r\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\r\n\t//\r\n\r\n\tvar nNormals = 0;\r\n\r\n\tvar objGeometry = this.object.geometry;\r\n\r\n\tif ( objGeometry instanceof THREE.Geometry ) {\r\n\r\n\t\tnNormals = objGeometry.faces.length;\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\r\n\tvar positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\r\n\r\n\tgeometry.addAttribute( 'position', positions );\r\n\r\n\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\r\n\r\n\t//\r\n\r\n\tthis.matrixAutoUpdate = false;\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.FaceNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.FaceNormalsHelper.prototype.constructor = THREE.FaceNormalsHelper;\r\n\r\nTHREE.FaceNormalsHelper.prototype.update = ( function () {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\tvar v2 = new THREE.Vector3();\r\n\tvar normalMatrix = new THREE.Matrix3();\r\n\r\n\treturn function update() {\r\n\r\n\t\tthis.object.updateMatrixWorld( true );\r\n\r\n\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\r\n\r\n\t\tvar matrixWorld = this.object.matrixWorld;\r\n\r\n\t\tvar position = this.geometry.attributes.position;\r\n\r\n\t\t//\r\n\r\n\t\tvar objGeometry = this.object.geometry;\r\n\r\n\t\tvar vertices = objGeometry.vertices;\r\n\r\n\t\tvar faces = objGeometry.faces;\r\n\r\n\t\tvar idx = 0;\r\n\r\n\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\tvar normal = face.normal;\r\n\r\n\t\t\tv1.copy( vertices[ face.a ] )\r\n\t\t\t\t.add( vertices[ face.b ] )\r\n\t\t\t\t.add( vertices[ face.c ] )\r\n\t\t\t\t.divideScalar( 3 )\r\n\t\t\t\t.applyMatrix4( matrixWorld );\r\n\r\n\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\r\n\r\n\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\r\n\r\n\t\t\tidx = idx + 1;\r\n\r\n\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\r\n\r\n\t\t\tidx = idx + 1;\r\n\r\n\t\t}\r\n\r\n\t\tposition.needsUpdate = true;\r\n\r\n\t\treturn this;\r\n\r\n\t};\r\n\r\n}() );\r\n\r\n// File:src/extras/helpers/GridHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.GridHelper = function ( size, step, color1, color2 ) {\r\n\r\n\tcolor1 = new THREE.Color( color1 !== undefined ? color1 : 0x444444 );\r\n\tcolor2 = new THREE.Color( color2 !== undefined ? color2 : 0x888888 );\r\n\r\n\tvar vertices = [];\r\n\tvar colors = [];\r\n\r\n\tfor ( var i = - size, j = 0; i <= size; i += step ) {\r\n\r\n\t\tvertices.push( - size, 0, i, size, 0, i );\r\n\t\tvertices.push( i, 0, - size, i, 0, size );\r\n\r\n\t\tvar color = i === 0 ? color1 : color2;\r\n\r\n\t\tcolor.toArray( colors, j ); j += 3;\r\n\t\tcolor.toArray( colors, j ); j += 3;\r\n\t\tcolor.toArray( colors, j ); j += 3;\r\n\t\tcolor.toArray( colors, j ); j += 3;\r\n\r\n\t}\r\n\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( vertices, 3 ) );\r\n\tgeometry.addAttribute( 'color', new THREE.Float32Attribute( colors, 3 ) );\r\n\r\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );\r\n\r\n\tTHREE.LineSegments.call( this, geometry, material );\r\n\r\n};\r\n\r\nTHREE.GridHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.GridHelper.prototype.constructor = THREE.GridHelper;\r\n\r\nTHREE.GridHelper.prototype.setColors = function () {\r\n\r\n\tconsole.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );\r\n\r\n};\r\n\r\n// File:src/extras/helpers/HemisphereLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.HemisphereLightHelper = function ( light, sphereSize ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.light = light;\r\n\tthis.light.updateMatrixWorld();\r\n\r\n\tthis.matrix = light.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.colors = [ new THREE.Color(), new THREE.Color() ];\r\n\r\n\tvar geometry = new THREE.SphereGeometry( sphereSize, 4, 2 );\r\n\tgeometry.rotateX( - Math.PI / 2 );\r\n\r\n\tfor ( var i = 0, il = 8; i < il; i ++ ) {\r\n\r\n\t\tgeometry.faces[ i ].color = this.colors[ i < 4 ? 0 : 1 ];\r\n\r\n\t}\r\n\r\n\tvar material = new THREE.MeshBasicMaterial( { vertexColors: THREE.FaceColors, wireframe: true } );\r\n\r\n\tthis.lightSphere = new THREE.Mesh( geometry, material );\r\n\tthis.add( this.lightSphere );\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.HemisphereLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.HemisphereLightHelper.prototype.constructor = THREE.HemisphereLightHelper;\r\n\r\nTHREE.HemisphereLightHelper.prototype.dispose = function () {\r\n\r\n\tthis.lightSphere.geometry.dispose();\r\n\tthis.lightSphere.material.dispose();\r\n\r\n};\r\n\r\nTHREE.HemisphereLightHelper.prototype.update = function () {\r\n\r\n\tvar vector = new THREE.Vector3();\r\n\r\n\treturn function () {\r\n\r\n\t\tthis.colors[ 0 ].copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\t\tthis.colors[ 1 ].copy( this.light.groundColor ).multiplyScalar( this.light.intensity );\r\n\r\n\t\tthis.lightSphere.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );\r\n\t\tthis.lightSphere.geometry.colorsNeedUpdate = true;\r\n\r\n\t};\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/PointLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.PointLightHelper = function ( light, sphereSize ) {\r\n\r\n\tthis.light = light;\r\n\tthis.light.updateMatrixWorld();\r\n\r\n\tvar geometry = new THREE.SphereBufferGeometry( sphereSize, 4, 2 );\r\n\tvar material = new THREE.MeshBasicMaterial( { wireframe: true, fog: false } );\r\n\tmaterial.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\tTHREE.Mesh.call( this, geometry, material );\r\n\r\n\tthis.matrix = this.light.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\t/*\r\n\tvar distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );\r\n\tvar distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );\r\n\r\n\tthis.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );\r\n\tthis.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );\r\n\r\n\tvar d = light.distance;\r\n\r\n\tif ( d === 0.0 ) {\r\n\r\n\t\tthis.lightDistance.visible = false;\r\n\r\n\t} else {\r\n\r\n\t\tthis.lightDistance.scale.set( d, d, d );\r\n\r\n\t}\r\n\r\n\tthis.add( this.lightDistance );\r\n\t*/\r\n\r\n};\r\n\r\nTHREE.PointLightHelper.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.PointLightHelper.prototype.constructor = THREE.PointLightHelper;\r\n\r\nTHREE.PointLightHelper.prototype.dispose = function () {\r\n\r\n\tthis.geometry.dispose();\r\n\tthis.material.dispose();\r\n\r\n};\r\n\r\nTHREE.PointLightHelper.prototype.update = function () {\r\n\r\n\tthis.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\t/*\r\n\tvar d = this.light.distance;\r\n\r\n\tif ( d === 0.0 ) {\r\n\r\n\t\tthis.lightDistance.visible = false;\r\n\r\n\t} else {\r\n\r\n\t\tthis.lightDistance.visible = true;\r\n\t\tthis.lightDistance.scale.set( d, d, d );\r\n\r\n\t}\r\n\t*/\r\n\r\n};\r\n\r\n// File:src/extras/helpers/SkeletonHelper.js\r\n\r\n/**\r\n * @author Sean Griffin / http://twitter.com/sgrif\r\n * @author Michael Guerrero / http://realitymeltdown.com\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author ikerr / http://verold.com\r\n */\r\n\r\nTHREE.SkeletonHelper = function ( object ) {\r\n\r\n\tthis.bones = this.getBoneList( object );\r\n\r\n\tvar geometry = new THREE.Geometry();\r\n\r\n\tfor ( var i = 0; i < this.bones.length; i ++ ) {\r\n\r\n\t\tvar bone = this.bones[ i ];\r\n\r\n\t\tif ( bone.parent instanceof THREE.Bone ) {\r\n\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\tgeometry.vertices.push( new THREE.Vector3() );\r\n\t\t\tgeometry.colors.push( new THREE.Color( 0, 0, 1 ) );\r\n\t\t\tgeometry.colors.push( new THREE.Color( 0, 1, 0 ) );\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgeometry.dynamic = true;\r\n\r\n\tvar material = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors, depthTest: false, depthWrite: false, transparent: true } );\r\n\r\n\tTHREE.LineSegments.call( this, geometry, material );\r\n\r\n\tthis.root = object;\r\n\r\n\tthis.matrix = object.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\n\r\nTHREE.SkeletonHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.SkeletonHelper.prototype.constructor = THREE.SkeletonHelper;\r\n\r\nTHREE.SkeletonHelper.prototype.getBoneList = function( object ) {\r\n\r\n\tvar boneList = [];\r\n\r\n\tif ( object instanceof THREE.Bone ) {\r\n\r\n\t\tboneList.push( object );\r\n\r\n\t}\r\n\r\n\tfor ( var i = 0; i < object.children.length; i ++ ) {\r\n\r\n\t\tboneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );\r\n\r\n\t}\r\n\r\n\treturn boneList;\r\n\r\n};\r\n\r\nTHREE.SkeletonHelper.prototype.update = function () {\r\n\r\n\tvar geometry = this.geometry;\r\n\r\n\tvar matrixWorldInv = new THREE.Matrix4().getInverse( this.root.matrixWorld );\r\n\r\n\tvar boneMatrix = new THREE.Matrix4();\r\n\r\n\tvar j = 0;\r\n\r\n\tfor ( var i = 0; i < this.bones.length; i ++ ) {\r\n\r\n\t\tvar bone = this.bones[ i ];\r\n\r\n\t\tif ( bone.parent instanceof THREE.Bone ) {\r\n\r\n\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );\r\n\t\t\tgeometry.vertices[ j ].setFromMatrixPosition( boneMatrix );\r\n\r\n\t\t\tboneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );\r\n\t\t\tgeometry.vertices[ j + 1 ].setFromMatrixPosition( boneMatrix );\r\n\r\n\t\t\tj += 2;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tgeometry.verticesNeedUpdate = true;\r\n\r\n\tgeometry.computeBoundingSphere();\r\n\r\n};\r\n\r\n// File:src/extras/helpers/SpotLightHelper.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.SpotLightHelper = function ( light ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.light = light;\r\n\tthis.light.updateMatrixWorld();\r\n\r\n\tthis.matrix = light.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\r\n\tvar positions = [\r\n\t\t0, 0, 0,   0,   0,   1,\r\n\t\t0, 0, 0,   1,   0,   1,\r\n\t\t0, 0, 0, - 1,   0,   1,\r\n\t\t0, 0, 0,   0,   1,   1,\r\n\t\t0, 0, 0,   0, - 1,   1\r\n\t];\r\n\r\n\tfor ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {\r\n\r\n\t\tvar p1 = ( i / l ) * Math.PI * 2;\r\n\t\tvar p2 = ( j / l ) * Math.PI * 2;\r\n\r\n\t\tpositions.push(\r\n\t\t\tMath.cos( p1 ), Math.sin( p1 ), 1,\r\n\t\t\tMath.cos( p2 ), Math.sin( p2 ), 1\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tgeometry.addAttribute( 'position', new THREE.Float32Attribute( positions, 3 ) );\r\n\r\n\tvar material = new THREE.LineBasicMaterial( { fog: false } );\r\n\r\n\tthis.cone = new THREE.LineSegments( geometry, material );\r\n\tthis.add( this.cone );\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.SpotLightHelper.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.SpotLightHelper.prototype.constructor = THREE.SpotLightHelper;\r\n\r\nTHREE.SpotLightHelper.prototype.dispose = function () {\r\n\r\n\tthis.cone.geometry.dispose();\r\n\tthis.cone.material.dispose();\r\n\r\n};\r\n\r\nTHREE.SpotLightHelper.prototype.update = function () {\r\n\r\n\tvar vector = new THREE.Vector3();\r\n\tvar vector2 = new THREE.Vector3();\r\n\r\n\treturn function () {\r\n\r\n\t\tvar coneLength = this.light.distance ? this.light.distance : 1000;\r\n\t\tvar coneWidth = coneLength * Math.tan( this.light.angle );\r\n\r\n\t\tthis.cone.scale.set( coneWidth, coneWidth, coneLength );\r\n\r\n\t\tvector.setFromMatrixPosition( this.light.matrixWorld );\r\n\t\tvector2.setFromMatrixPosition( this.light.target.matrixWorld );\r\n\r\n\t\tthis.cone.lookAt( vector2.sub( vector ) );\r\n\r\n\t\tthis.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );\r\n\r\n\t};\r\n\r\n}();\r\n\r\n// File:src/extras/helpers/VertexNormalsHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n * @author WestLangley / http://github.com/WestLangley\r\n*/\r\n\r\nTHREE.VertexNormalsHelper = function ( object, size, hex, linewidth ) {\r\n\r\n\tthis.object = object;\r\n\r\n\tthis.size = ( size !== undefined ) ? size : 1;\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0xff0000;\r\n\r\n\tvar width = ( linewidth !== undefined ) ? linewidth : 1;\r\n\r\n\t//\r\n\r\n\tvar nNormals = 0;\r\n\r\n\tvar objGeometry = this.object.geometry;\r\n\r\n\tif ( objGeometry instanceof THREE.Geometry ) {\r\n\r\n\t\tnNormals = objGeometry.faces.length * 3;\r\n\r\n\t} else if ( objGeometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\tnNormals = objGeometry.attributes.normal.count;\r\n\r\n\t}\r\n\r\n\t//\r\n\r\n\tvar geometry = new THREE.BufferGeometry();\r\n\r\n\tvar positions = new THREE.Float32Attribute( nNormals * 2 * 3, 3 );\r\n\r\n\tgeometry.addAttribute( 'position', positions );\r\n\r\n\tTHREE.LineSegments.call( this, geometry, new THREE.LineBasicMaterial( { color: color, linewidth: width } ) );\r\n\r\n\t//\r\n\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n\tthis.update();\r\n\r\n};\r\n\r\nTHREE.VertexNormalsHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.VertexNormalsHelper.prototype.constructor = THREE.VertexNormalsHelper;\r\n\r\nTHREE.VertexNormalsHelper.prototype.update = ( function () {\r\n\r\n\tvar v1 = new THREE.Vector3();\r\n\tvar v2 = new THREE.Vector3();\r\n\tvar normalMatrix = new THREE.Matrix3();\r\n\r\n\treturn function update() {\r\n\r\n\t\tvar keys = [ 'a', 'b', 'c' ];\r\n\r\n\t\tthis.object.updateMatrixWorld( true );\r\n\r\n\t\tnormalMatrix.getNormalMatrix( this.object.matrixWorld );\r\n\r\n\t\tvar matrixWorld = this.object.matrixWorld;\r\n\r\n\t\tvar position = this.geometry.attributes.position;\r\n\r\n\t\t//\r\n\r\n\t\tvar objGeometry = this.object.geometry;\r\n\r\n\t\tif ( objGeometry instanceof THREE.Geometry ) {\r\n\r\n\t\t\tvar vertices = objGeometry.vertices;\r\n\r\n\t\t\tvar faces = objGeometry.faces;\r\n\r\n\t\t\tvar idx = 0;\r\n\r\n\t\t\tfor ( var i = 0, l = faces.length; i < l; i ++ ) {\r\n\r\n\t\t\t\tvar face = faces[ i ];\r\n\r\n\t\t\t\tfor ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {\r\n\r\n\t\t\t\t\tvar vertex = vertices[ face[ keys[ j ] ] ];\r\n\r\n\t\t\t\t\tvar normal = face.vertexNormals[ j ];\r\n\r\n\t\t\t\t\tv1.copy( vertex ).applyMatrix4( matrixWorld );\r\n\r\n\t\t\t\t\tv2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\r\n\r\n\t\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\r\n\r\n\t\t\t\t\tidx = idx + 1;\r\n\r\n\t\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\r\n\r\n\t\t\t\t\tidx = idx + 1;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else if ( objGeometry instanceof THREE.BufferGeometry ) {\r\n\r\n\t\t\tvar objPos = objGeometry.attributes.position;\r\n\r\n\t\t\tvar objNorm = objGeometry.attributes.normal;\r\n\r\n\t\t\tvar idx = 0;\r\n\r\n\t\t\t// for simplicity, ignore index and drawcalls, and render every normal\r\n\r\n\t\t\tfor ( var j = 0, jl = objPos.count; j < jl; j ++ ) {\r\n\r\n\t\t\t\tv1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );\r\n\r\n\t\t\t\tv2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );\r\n\r\n\t\t\t\tv2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );\r\n\r\n\t\t\t\tposition.setXYZ( idx, v1.x, v1.y, v1.z );\r\n\r\n\t\t\t\tidx = idx + 1;\r\n\r\n\t\t\t\tposition.setXYZ( idx, v2.x, v2.y, v2.z );\r\n\r\n\t\t\t\tidx = idx + 1;\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\tposition.needsUpdate = true;\r\n\r\n\t\treturn this;\r\n\r\n\t};\r\n\r\n}() );\r\n\r\n// File:src/extras/helpers/WireframeHelper.js\r\n\r\n/**\r\n * @author mrdoob / http://mrdoob.com/\r\n */\r\n\r\nTHREE.WireframeHelper = function ( object, hex ) {\r\n\r\n\tvar color = ( hex !== undefined ) ? hex : 0xffffff;\r\n\r\n\tTHREE.LineSegments.call( this, new THREE.WireframeGeometry( object.geometry ), new THREE.LineBasicMaterial( { color: color } ) );\r\n\r\n\tthis.matrix = object.matrixWorld;\r\n\tthis.matrixAutoUpdate = false;\r\n\r\n};\r\n\r\nTHREE.WireframeHelper.prototype = Object.create( THREE.LineSegments.prototype );\r\nTHREE.WireframeHelper.prototype.constructor = THREE.WireframeHelper;\r\n\r\n// File:src/extras/objects/ImmediateRenderObject.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.ImmediateRenderObject = function ( material ) {\r\n\r\n\tTHREE.Object3D.call( this );\r\n\r\n\tthis.material = material;\r\n\tthis.render = function ( renderCallback ) {};\r\n\r\n};\r\n\r\nTHREE.ImmediateRenderObject.prototype = Object.create( THREE.Object3D.prototype );\r\nTHREE.ImmediateRenderObject.prototype.constructor = THREE.ImmediateRenderObject;\r\n\r\n// File:src/extras/objects/MorphBlendMesh.js\r\n\r\n/**\r\n * @author alteredq / http://alteredqualia.com/\r\n */\r\n\r\nTHREE.MorphBlendMesh = function( geometry, material ) {\r\n\r\n\tTHREE.Mesh.call( this, geometry, material );\r\n\r\n\tthis.animationsMap = {};\r\n\tthis.animationsList = [];\r\n\r\n\t// prepare default animation\r\n\t// (all frames played together in 1 second)\r\n\r\n\tvar numFrames = this.geometry.morphTargets.length;\r\n\r\n\tvar name = \"__default\";\r\n\r\n\tvar startFrame = 0;\r\n\tvar endFrame = numFrames - 1;\r\n\r\n\tvar fps = numFrames / 1;\r\n\r\n\tthis.createAnimation( name, startFrame, endFrame, fps );\r\n\tthis.setAnimationWeight( name, 1 );\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype = Object.create( THREE.Mesh.prototype );\r\nTHREE.MorphBlendMesh.prototype.constructor = THREE.MorphBlendMesh;\r\n\r\nTHREE.MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {\r\n\r\n\tvar animation = {\r\n\r\n\t\tstart: start,\r\n\t\tend: end,\r\n\r\n\t\tlength: end - start + 1,\r\n\r\n\t\tfps: fps,\r\n\t\tduration: ( end - start ) / fps,\r\n\r\n\t\tlastFrame: 0,\r\n\t\tcurrentFrame: 0,\r\n\r\n\t\tactive: false,\r\n\r\n\t\ttime: 0,\r\n\t\tdirection: 1,\r\n\t\tweight: 1,\r\n\r\n\t\tdirectionBackwards: false,\r\n\t\tmirroredLoop: false\r\n\r\n\t};\r\n\r\n\tthis.animationsMap[ name ] = animation;\r\n\tthis.animationsList.push( animation );\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {\r\n\r\n\tvar pattern = /([a-z]+)_?(\\d+)/i;\r\n\r\n\tvar firstAnimation, frameRanges = {};\r\n\r\n\tvar geometry = this.geometry;\r\n\r\n\tfor ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {\r\n\r\n\t\tvar morph = geometry.morphTargets[ i ];\r\n\t\tvar chunks = morph.name.match( pattern );\r\n\r\n\t\tif ( chunks && chunks.length > 1 ) {\r\n\r\n\t\t\tvar name = chunks[ 1 ];\r\n\r\n\t\t\tif ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };\r\n\r\n\t\t\tvar range = frameRanges[ name ];\r\n\r\n\t\t\tif ( i < range.start ) range.start = i;\r\n\t\t\tif ( i > range.end ) range.end = i;\r\n\r\n\t\t\tif ( ! firstAnimation ) firstAnimation = name;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\tfor ( var name in frameRanges ) {\r\n\r\n\t\tvar range = frameRanges[ name ];\r\n\t\tthis.createAnimation( name, range.start, range.end, fps );\r\n\r\n\t}\r\n\r\n\tthis.firstAnimation = firstAnimation;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.direction = 1;\r\n\t\tanimation.directionBackwards = false;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.direction = - 1;\r\n\t\tanimation.directionBackwards = true;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.fps = fps;\r\n\t\tanimation.duration = ( animation.end - animation.start ) / animation.fps;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.duration = duration;\r\n\t\tanimation.fps = ( animation.end - animation.start ) / animation.duration;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.weight = weight;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.time = time;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.getAnimationTime = function ( name ) {\r\n\r\n\tvar time = 0;\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\ttime = animation.time;\r\n\r\n\t}\r\n\r\n\treturn time;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {\r\n\r\n\tvar duration = - 1;\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tduration = animation.duration;\r\n\r\n\t}\r\n\r\n\treturn duration;\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.playAnimation = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.time = 0;\r\n\t\tanimation.active = true;\r\n\r\n\t} else {\r\n\r\n\t\tconsole.warn( \"THREE.MorphBlendMesh: animation[\" + name + \"] undefined in .playAnimation()\" );\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.stopAnimation = function ( name ) {\r\n\r\n\tvar animation = this.animationsMap[ name ];\r\n\r\n\tif ( animation ) {\r\n\r\n\t\tanimation.active = false;\r\n\r\n\t}\r\n\r\n};\r\n\r\nTHREE.MorphBlendMesh.prototype.update = function ( delta ) {\r\n\r\n\tfor ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {\r\n\r\n\t\tvar animation = this.animationsList[ i ];\r\n\r\n\t\tif ( ! animation.active ) continue;\r\n\r\n\t\tvar frameTime = animation.duration / animation.length;\r\n\r\n\t\tanimation.time += animation.direction * delta;\r\n\r\n\t\tif ( animation.mirroredLoop ) {\r\n\r\n\t\t\tif ( animation.time > animation.duration || animation.time < 0 ) {\r\n\r\n\t\t\t\tanimation.direction *= - 1;\r\n\r\n\t\t\t\tif ( animation.time > animation.duration ) {\r\n\r\n\t\t\t\t\tanimation.time = animation.duration;\r\n\t\t\t\t\tanimation.directionBackwards = true;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif ( animation.time < 0 ) {\r\n\r\n\t\t\t\t\tanimation.time = 0;\r\n\t\t\t\t\tanimation.directionBackwards = false;\r\n\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\r\n\t\t} else {\r\n\r\n\t\t\tanimation.time = animation.time % animation.duration;\r\n\r\n\t\t\tif ( animation.time < 0 ) animation.time += animation.duration;\r\n\r\n\t\t}\r\n\r\n\t\tvar keyframe = animation.start + THREE.Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );\r\n\t\tvar weight = animation.weight;\r\n\r\n\t\tif ( keyframe !== animation.currentFrame ) {\r\n\r\n\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = 0;\r\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;\r\n\r\n\t\t\tthis.morphTargetInfluences[ keyframe ] = 0;\r\n\r\n\t\t\tanimation.lastFrame = animation.currentFrame;\r\n\t\t\tanimation.currentFrame = keyframe;\r\n\r\n\t\t}\r\n\r\n\t\tvar mix = ( animation.time % frameTime ) / frameTime;\r\n\r\n\t\tif ( animation.directionBackwards ) mix = 1 - mix;\r\n\r\n\t\tif ( animation.currentFrame !== animation.lastFrame ) {\r\n\r\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = mix * weight;\r\n\t\t\tthis.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tthis.morphTargetInfluences[ animation.currentFrame ] = weight;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n};\r\n\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/three/build/three.js\n ** module id = 1\n ** module chunks = 0\n **/"],"sourceRoot":""}